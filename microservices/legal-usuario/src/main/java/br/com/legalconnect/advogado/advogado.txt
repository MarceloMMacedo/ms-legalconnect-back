```java
```java
```java
package br.com.legalconnect.advogado.application.dto.enums;

public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}

```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AtualizacaoPerfilRequest {
    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId;

    private UUID planoId;

    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @PastOrPresent(message = "A data de nascimento da pessoa não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<@NotBlank(message = "O número de telefone não pode ser vazio.") @Size(max = 20, message = "O número de telefone deve ter no máximo 20 caracteres.") String> telefonesPessoa;

    private List<@NotNull(message = "O ID do local de atuação não pode ser nulo.") UUID> locaisAtuacaoIds;

    private List<@NotNull(message = "O ID da área de atuação não pode ser nulo.") UUID> areaAtuacaoIds;

    private List<@NotNull(message = "O ID do idioma não pode ser nulo.") UUID> idiomaIds;

    private List<@NotNull(message = "O ID do tipo de atendimento não pode ser nulo.") UUID> tipoAtendimentoIds;

    @Valid
    private List<CertificacaoRequestDTO> certificacoes;

    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;

    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoRequestDTO {
    private UUID id;
    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;
    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;
    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    @NotBlank(message = "O tipo do documento é obrigatório.")
    @Size(max = 100, message = "O tipo do documento deve ter no máximo 100 caracteres.")
    private String tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id;
    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;
    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;
    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;
    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {
    private UUID id;
    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;
    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;
    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalCreateRequest {
    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String emailUsuario;

    @NotBlank(message = "A senha do usuário é obrigatória.")
    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    private String senhaUsuario;

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpfPessoa;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalDetalhadoResponse {
    private UUID id;
    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private UUID pessoaId;
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    private String nomeCompletoPessoa;
    private String cpfPessoa;
    private LocalDate dataNascimentoPessoa;
    private List<String> telefonesPessoa;

    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;
    private List<UUID> roleProfissionalIds;
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

@Mapper(componentModel = "spring")
public interface CertificacaoMapper {

    // Mapeia CertificacaoRequestDTO para o modelo de domínio Certificacao

    CertificacaoEntity toDomainModel(CertificacaoRequestDTO dto);

    // Atualiza um modelo de domínio Certificacao a partir de CertificacaoRequestDTO
    @Mapping(target = "id", ignore = true) // ID não é atualizável via update
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(CertificacaoRequestDTO dto, @MappingTarget CertificacaoEntity certificacao);

    // Mapeia o modelo de domínio Certificacao para CertificacaoResponseDTO
    CertificacaoResponseDTO toResponseDTO(CertificacaoEntity certificacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

import br.com.legalconnect.advogado.application.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.application.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.application.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

@Mapper(componentModel = "spring")
public interface DocumentoMapper {

    // Mapeia DocumentoUploadRequest para o modelo de domínio Documento
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapStringToDocumentoTipo")
    DocumentoEntity toDomainModel(DocumentoUploadRequest request);

    // Mapeia o modelo de domínio Documento para DocumentoResponseDTO
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    DocumentoResponseDTO toResponseDTO(DocumentoEntity documento);

    @Named("mapStringToDocumentoTipo")
    default DocumentoTipo mapStringToDocumentoTipo(String tipoDocumento) {
        if (tipoDocumento == null) {
            return null;
        }
        try {
            return DocumentoTipo.valueOf(tipoDocumento.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Tratar caso de tipo de documento inválido, talvez lançar uma exceção de
            // validação
            return DocumentoTipo.OUTRO; // Ou outro tratamento de erro
        }
    }

    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipoDocumento) {
        return tipoDocumento != null ? tipoDocumento.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

@Mapper(componentModel = "spring")
public interface ExperienciaMapper {

    // Mapeia ExperienciaProfissionalRequestDTO para o modelo de domínio
    // ExperienciaProfissional
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    ExperienciaProfissionalEntity toDomainModel(ExperienciaProfissionalRequestDTO dto);

    // Atualiza um modelo de domínio ExperienciaProfissional a partir de
    // ExperienciaProfissionalRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(ExperienciaProfissionalRequestDTO dto,
            @MappingTarget ExperienciaProfissionalEntity experiencia);

    // Mapeia o modelo de domínio ExperienciaProfissional para
    // ExperienciaProfissionalResponseDTO
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissionalEntity experiencia);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

@Mapper(componentModel = "spring")
public interface FormacaoMapper {

    // Mapeia FormacaoAcademicaRequestDTO para o modelo de domínio FormacaoAcademica
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    FormacaoAcademicaEntity toDomainModel(FormacaoAcademicaRequestDTO dto);

    // Atualiza um modelo de domínio FormacaoAcademica a partir de
    // FormacaoAcademicaRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademicaEntity formacao);

    // Mapeia o modelo de domínio FormacaoAcademica para
    // FormacaoAcademicaResponseDTO
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademicaEntity formacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import java.util.List;
import java.util.Set;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.AtualizacaoPerfilRequest;
import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ProfissionalDetalhadoResponse;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;
import br.com.legalconnect.entity.Profissional;

@Mapper(componentModel = "spring", uses = { CertificacaoMapper.class, ExperienciaMapper.class, FormacaoMapper.class })
public interface ProfissionalMapper {

    // Mapeia ProfissionalCreateRequest para o modelo de domínio Profissional
    @Mapping(target = "id", ignore = true) // ID será gerado no domínio/persistência
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", constant = "EM_ANALISE") // Status inicial padrão
    @Mapping(target = "usaMarketplace", constant = "false")
    @Mapping(target = "fazParteDePlano", constant = "false")
    // @Mapping(target = "certificacoes", ignore = true) // Coleções serão tratadas
    // separadamente ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "locaisAtuacaoIds", ignore = true)
    // @Mapping(target = "areaAtuacaoIds", ignore = true)
    // @Mapping(target = "idiomaIds", ignore = true)
    // @Mapping(target = "tipoAtendimentoIds", ignore = true)
    // @Mapping(target = "roleProfissionalIds", ignore = true)
    // @Mapping(source = "planoId", target = "planoId")
    // @Mapping(source = "tenantId", target = "tenantId")
    // Note: pessoaId e empresaId não são mapeados diretamente aqui, pois virão de
    // outros serviços
    Profissional toDomainModel(ProfissionalCreateRequest request);

    // Atualiza um modelo de domínio Profissional a partir de
    // AtualizacaoPerfilRequest
    @Mapping(target = "id", ignore = true) // ID não é atualizável
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", ignore = true) // Status é atualizado por métodos de negócio
    @Mapping(target = "numeroOab", ignore = true) // OAB geralmente não é atualizável após o cadastro
    // @Mapping(target = "certificacoes", ignore = true) // Coleções tratadas por
    // mappers específicos ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "pessoaId", ignore = true)
    // @Mapping(target = "tenantId", ignore = true)
    // // Mapeamento de coleções de UUIDs
    // @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds")
    // @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds")
    // @Mapping(source = "idiomaIds", target = "idiomaIds")
    // @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds")
    void updateDomainModelFromRequest(AtualizacaoPerfilRequest request, @MappingTarget Profissional profissional);

    // Mapeia o modelo de domínio Profissional para ProfissionalDetalhadoResponse
    @Mapping(source = "statusProfissional", target = "statusProfissional") // Mapeia o enum para String
    // @Mapping(source = "certificacoes", target = "certificacoes")
    // @Mapping(source = "documentos", target = "documentos")
    // @Mapping(source = "experiencias", target = "experiencias")
    // @Mapping(source = "formacoes", target = "formacoes")
    ProfissionalDetalhadoResponse toDetalhadoResponse(Profissional profissional);

    // Mapeamento de coleções aninhadas
    Set<CertificacaoEntity> mapCertificacaoRequestDTOsToCertificacoes(List<CertificacaoRequestDTO> dtos);

    Set<ExperienciaProfissionalEntity> mapExperienciaRequestDTOsToExperiencias(
            List<ExperienciaProfissionalRequestDTO> dtos);

    Set<FormacaoAcademicaEntity> mapFormacaoRequestDTOsToFormacoes(List<FormacaoAcademicaRequestDTO> dtos);

    List<CertificacaoResponseDTO> mapCertificacoesToCertificacaoResponseDTOs(Set<CertificacaoEntity> certificacoes);

    List<ExperienciaProfissionalResponseDTO> mapExperienciasToExperienciaResponseDTOs(
            Set<ExperienciaProfissionalEntity> experiencias);

    List<FormacaoAcademicaResponseDTO> mapFormacoesToFormacaoResponseDTOs(Set<FormacaoAcademicaEntity> formacoes);
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class CertificacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class DocumentoEntity extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class EnderecoEntity extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro;

    @Column(name = "numero", length = 20)
    private String numero;

    @Column(name = "complemento", length = 100)
    private String complemento;

    @Column(name = "bairro", length = 100)
    private String bairro;

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade;

    @Column(name = "estado", nullable = false, length = 2)
    private String estado;

    @Column(name = "cep", nullable = false, length = 10)
    private String cep;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id", nullable = false)
    private PessoaEntity pessoa; // Pessoa está no mesmo serviço (Person Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant
}

// --- Serviço de Profissional (br.com.legalconnect.profissional) - Entidades de
// Infraestrutura ---
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissionalEntity extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademicaEntity extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class IdiomaEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED) // Estratégia de herança para subclasses
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaEntity extends BaseEntity {

    @Column(name = "user_id", nullable = false, unique = true)
    private UUID userId; // Referência ao ID do usuário do Auth Service

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto;

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf;

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento;

    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<EnderecoEntity> enderecos = new HashSet<>();

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalEntity extends BaseEntity {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId; // Referência ao ID da Pessoa (do Person Service)

    @Column(name = "empresa_id")
    private UUID empresaId; // Referência ao ID da Empresa (do Company Service)

    @Column(name = "plano_id", nullable = false)
    private UUID planoId; // Referência ao ID do Plano (do Subscription Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant

    // Relacionamentos com entidades que residem no mesmo Professional Service
    // (infraestrutura)
    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<CertificacaoEntity> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<DocumentoEntity> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissionalEntity> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademicaEntity> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissionalEntity> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissionalEntity extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

// --- Entidades de Dados Mestres (se gerenciadas localmente no Professional
// Service) ---
// NOTA: Se estas entidades residirem em um "Master Data Service" separado e o
// Professional Service
// apenas referenciar seus IDs, então estas classes de entidade não estariam
// aqui.
// Elas são incluídas assumindo que o Professional Service pode ter uma cópia
// local ou gerenciar
// essas entidades para seu próprio contexto.
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimentoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacaoEntity;

public interface AreaAtuacaoRepository {

    // Salva ou atualiza uma Área de Atuação.
    AreaAtuacaoEntity save(AreaAtuacaoEntity areaAtuacao);

    // Busca uma Área de Atuação pelo seu ID.
    Optional<AreaAtuacaoEntity> findById(UUID id);

    // Busca uma Área de Atuação pelo nome.
    Optional<AreaAtuacaoEntity> findByNome(String nome);

    // Busca todas as Áreas de Atuação.
    List<AreaAtuacaoEntity> findAll();

    // Deleta uma Área de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

public interface CertificacaoRepository {

    // Salva ou atualiza uma Certificação para um Profissional.
    CertificacaoEntity save(CertificacaoEntity certificacao, UUID profissionalId);

    // Busca uma Certificação pelo seu ID e pelo ID do Profissional.
    Optional<CertificacaoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Certificações de um Profissional.
    List<CertificacaoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

public interface DocumentoRepository {

    // Salva ou atualiza um Documento para um Profissional.
    DocumentoEntity save(DocumentoEntity documento, UUID profissionalId);

    // Busca um Documento pelo seu ID e pelo ID do Profissional.
    Optional<DocumentoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todos os Documentos de um Profissional.
    List<DocumentoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta um Documento pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

public interface ExperienciaRepository {

    // Salva ou atualiza uma Experiência Profissional para um Profissional.
    ExperienciaProfissionalEntity save(ExperienciaProfissionalEntity experiencia, UUID profissionalId);

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissionalEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissionalEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

public interface FormacaoRepository {

    // Salva ou atualiza uma Formação Acadêmica para um Profissional.
    FormacaoAcademicaEntity save(FormacaoAcademicaEntity formacao, UUID profissionalId);

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademicaEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademicaEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.IdiomaEntity;

public interface IdiomaRepository {

    // Salva ou atualiza um Idioma.
    IdiomaEntity save(IdiomaEntity idioma);

    // Busca um Idioma pelo seu ID.
    Optional<IdiomaEntity> findById(UUID id);

    // Busca um Idioma pelo nome.
    Optional<IdiomaEntity> findByNome(String nome);

    // Busca todos os Idiomas.
    List<IdiomaEntity> findAll();

    // Deleta um Idioma pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacaoEntity;

public interface LocalAtuacaoRepository {

    // Salva ou atualiza um Local de Atuação.
    LocalAtuacaoEntity save(LocalAtuacaoEntity localAtuacao);

    // Busca um Local de Atuação pelo seu ID.
    Optional<LocalAtuacaoEntity> findById(UUID id);

    // Busca um Local de Atuação pelo nome.
    Optional<LocalAtuacaoEntity> findByNome(String nome);

    // Busca todos os Locais de Atuação.
    List<LocalAtuacaoEntity> findAll();

    // Deleta um Local de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ProfissionalEntity;

public interface ProfissionalRepository {

    // Salva ou atualiza um Profissional no repositório.
    ProfissionalEntity save(ProfissionalEntity profissional);

    // Busca um Profissional pelo seu ID.
    Optional<ProfissionalEntity> findById(UUID id);

    // Busca um Profissional pelo número da OAB.
    Optional<ProfissionalEntity> findByNumeroOab(String numeroOab);

    // Busca todos os Profissionais associados a um determinado tenant.
    List<ProfissionalEntity> findAllByTenantId(UUID tenantId);

    // Deleta um Profissional pelo seu ID.
    void deleteById(UUID id);

    // Verifica se um Profissional existe pelo número da OAB.
    boolean existsByNumeroOab(String numeroOab);

    // Verifica se um Profissional existe pelo ID da pessoa associada.
    boolean existsByPessoaId(UUID pessoaId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimentoEntity;

public interface TipoAtendimentoRepository {

    // Salva ou atualiza um Tipo de Atendimento.
    TipoAtendimentoEntity save(TipoAtendimentoEntity tipoAtendimento);

    // Busca um Tipo de Atendimento pelo seu ID.
    Optional<TipoAtendimentoEntity> findById(UUID id);

    // Busca um Tipo de Atendimento pelo nome.
    Optional<TipoAtendimentoEntity> findByNome(String nome);

    // Busca todos os Tipos de Atendimento.
    List<TipoAtendimentoEntity> findAll();

    // Deleta um Tipo de Atendimento pelo seu ID.
    void deleteById(UUID id);
}
```
```
```java
package br.com.legalconnect.advogado.application.dto.enums;

public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}

```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AtualizacaoPerfilRequest {
    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId;

    private UUID planoId;

    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @PastOrPresent(message = "A data de nascimento da pessoa não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @NotBlank(message = "O número de telefone não pode ser vazio.")
    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefonesPessoa;

    @NotNull(message = "O ID do local de atuação não pode ser nulo.")
    private List<UUID> locaisAtuacaoIds;

    @NotNull(message = "O ID da área de atuação não pode ser nulo.")
    private List<UUID> areaAtuacaoIds;

    @NotNull(message = "O ID do idioma não pode ser nulo.")
    private List<UUID> idiomaIds;

    @NotNull(message = "O ID do tipo de atendimento não pode ser nulo.")
    private List<UUID> tipoAtendimentoIds;

    @Valid
    private List<CertificacaoRequestDTO> certificacoes;

    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;

    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoRequestDTO {
    private UUID id;
    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;
    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;
    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    @NotBlank(message = "O tipo do documento é obrigatório.")
    @Size(max = 100, message = "O tipo do documento deve ter no máximo 100 caracteres.")
    private String tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id;
    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;
    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;
    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;
    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {
    private UUID id;
    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;
    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;
    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalCreateRequest {
    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String emailUsuario;

    @NotBlank(message = "A senha do usuário é obrigatória.")
    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    private String senhaUsuario;

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpfPessoa;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalDetalhadoResponse {
    private UUID id;
    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private UUID pessoaId;
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    private String nomeCompletoPessoa;
    private String cpfPessoa;
    private LocalDate dataNascimentoPessoa;
    private List<String> telefonesPessoa;

    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;
    private List<UUID> roleProfissionalIds;
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

@Mapper(componentModel = "spring")
public interface CertificacaoMapper {

    // Mapeia CertificacaoRequestDTO para o modelo de domínio Certificacao

    CertificacaoEntity toDomainModel(CertificacaoRequestDTO dto);

    // Atualiza um modelo de domínio Certificacao a partir de CertificacaoRequestDTO
    @Mapping(target = "id", ignore = true) // ID não é atualizável via update
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(CertificacaoRequestDTO dto, @MappingTarget CertificacaoEntity certificacao);

    // Mapeia o modelo de domínio Certificacao para CertificacaoResponseDTO
    CertificacaoResponseDTO toResponseDTO(CertificacaoEntity certificacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

import br.com.legalconnect.advogado.application.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.application.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.application.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

@Mapper(componentModel = "spring")
public interface DocumentoMapper {

    // Mapeia DocumentoUploadRequest para o modelo de domínio Documento
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapStringToDocumentoTipo")
    DocumentoEntity toDomainModel(DocumentoUploadRequest request);

    // Mapeia o modelo de domínio Documento para DocumentoResponseDTO
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    DocumentoResponseDTO toResponseDTO(DocumentoEntity documento);

    @Named("mapStringToDocumentoTipo")
    default DocumentoTipo mapStringToDocumentoTipo(String tipoDocumento) {
        if (tipoDocumento == null) {
            return null;
        }
        try {
            return DocumentoTipo.valueOf(tipoDocumento.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Tratar caso de tipo de documento inválido, talvez lançar uma exceção de
            // validação
            return DocumentoTipo.OUTRO; // Ou outro tratamento de erro
        }
    }

    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipoDocumento) {
        return tipoDocumento != null ? tipoDocumento.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

@Mapper(componentModel = "spring")
public interface ExperienciaMapper {

    // Mapeia ExperienciaProfissionalRequestDTO para o modelo de domínio
    // ExperienciaProfissional
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    ExperienciaProfissionalEntity toDomainModel(ExperienciaProfissionalRequestDTO dto);

    // Atualiza um modelo de domínio ExperienciaProfissional a partir de
    // ExperienciaProfissionalRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(ExperienciaProfissionalRequestDTO dto,
            @MappingTarget ExperienciaProfissionalEntity experiencia);

    // Mapeia o modelo de domínio ExperienciaProfissional para
    // ExperienciaProfissionalResponseDTO
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissionalEntity experiencia);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

@Mapper(componentModel = "spring")
public interface FormacaoMapper {

    // Mapeia FormacaoAcademicaRequestDTO para o modelo de domínio FormacaoAcademica
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    FormacaoAcademicaEntity toDomainModel(FormacaoAcademicaRequestDTO dto);

    // Atualiza um modelo de domínio FormacaoAcademica a partir de
    // FormacaoAcademicaRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademicaEntity formacao);

    // Mapeia o modelo de domínio FormacaoAcademica para
    // FormacaoAcademicaResponseDTO
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademicaEntity formacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import java.util.List;
import java.util.Set;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.AtualizacaoPerfilRequest;
import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ProfissionalDetalhadoResponse;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;
import br.com.legalconnect.entity.Profissional;

@Mapper(componentModel = "spring", uses = { CertificacaoMapper.class, ExperienciaMapper.class, FormacaoMapper.class })
public interface ProfissionalMapper {

    // Mapeia ProfissionalCreateRequest para o modelo de domínio Profissional
    @Mapping(target = "id", ignore = true) // ID será gerado no domínio/persistência
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", constant = "EM_ANALISE") // Status inicial padrão
    @Mapping(target = "usaMarketplace", constant = "false")
    @Mapping(target = "fazParteDePlano", constant = "false")
    // @Mapping(target = "certificacoes", ignore = true) // Coleções serão tratadas
    // separadamente ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "locaisAtuacaoIds", ignore = true)
    // @Mapping(target = "areaAtuacaoIds", ignore = true)
    // @Mapping(target = "idiomaIds", ignore = true)
    // @Mapping(target = "tipoAtendimentoIds", ignore = true)
    // @Mapping(target = "roleProfissionalIds", ignore = true)
    // @Mapping(source = "planoId", target = "planoId")
    // @Mapping(source = "tenantId", target = "tenantId")
    // Note: pessoaId e empresaId não são mapeados diretamente aqui, pois virão de
    // outros serviços
    Profissional toDomainModel(ProfissionalCreateRequest request);

    // Atualiza um modelo de domínio Profissional a partir de
    // AtualizacaoPerfilRequest
    @Mapping(target = "id", ignore = true) // ID não é atualizável
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", ignore = true) // Status é atualizado por métodos de negócio
    @Mapping(target = "numeroOab", ignore = true) // OAB geralmente não é atualizável após o cadastro
    // @Mapping(target = "certificacoes", ignore = true) // Coleções tratadas por
    // mappers específicos ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "pessoaId", ignore = true)
    // @Mapping(target = "tenantId", ignore = true)
    // // Mapeamento de coleções de UUIDs
    // @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds")
    // @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds")
    // @Mapping(source = "idiomaIds", target = "idiomaIds")
    // @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds")
    void updateDomainModelFromRequest(AtualizacaoPerfilRequest request, @MappingTarget Profissional profissional);

    // Mapeia o modelo de domínio Profissional para ProfissionalDetalhadoResponse
    @Mapping(source = "statusProfissional", target = "statusProfissional") // Mapeia o enum para String
    // @Mapping(source = "certificacoes", target = "certificacoes")
    // @Mapping(source = "documentos", target = "documentos")
    // @Mapping(source = "experiencias", target = "experiencias")
    // @Mapping(source = "formacoes", target = "formacoes")
    ProfissionalDetalhadoResponse toDetalhadoResponse(Profissional profissional);

    // Mapeamento de coleções aninhadas
    Set<CertificacaoEntity> mapCertificacaoRequestDTOsToCertificacoes(List<CertificacaoRequestDTO> dtos);

    Set<ExperienciaProfissionalEntity> mapExperienciaRequestDTOsToExperiencias(
            List<ExperienciaProfissionalRequestDTO> dtos);

    Set<FormacaoAcademicaEntity> mapFormacaoRequestDTOsToFormacoes(List<FormacaoAcademicaRequestDTO> dtos);

    List<CertificacaoResponseDTO> mapCertificacoesToCertificacaoResponseDTOs(Set<CertificacaoEntity> certificacoes);

    List<ExperienciaProfissionalResponseDTO> mapExperienciasToExperienciaResponseDTOs(
            Set<ExperienciaProfissionalEntity> experiencias);

    List<FormacaoAcademicaResponseDTO> mapFormacoesToFormacaoResponseDTOs(Set<FormacaoAcademicaEntity> formacoes);
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class CertificacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class DocumentoEntity extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class EnderecoEntity extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro;

    @Column(name = "numero", length = 20)
    private String numero;

    @Column(name = "complemento", length = 100)
    private String complemento;

    @Column(name = "bairro", length = 100)
    private String bairro;

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade;

    @Column(name = "estado", nullable = false, length = 2)
    private String estado;

    @Column(name = "cep", nullable = false, length = 10)
    private String cep;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id", nullable = false)
    private PessoaEntity pessoa; // Pessoa está no mesmo serviço (Person Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant
}

// --- Serviço de Profissional (br.com.legalconnect.profissional) - Entidades de
// Infraestrutura ---
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissionalEntity extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademicaEntity extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class IdiomaEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED) // Estratégia de herança para subclasses
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaEntity extends BaseEntity {

    @Column(name = "user_id", nullable = false, unique = true)
    private UUID userId; // Referência ao ID do usuário do Auth Service

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto;

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf;

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento;

    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<EnderecoEntity> enderecos = new HashSet<>();

    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalEntity extends BaseEntity {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId; // Referência ao ID da Pessoa (do Person Service)

    @Column(name = "empresa_id")
    private UUID empresaId; // Referência ao ID da Empresa (do Company Service)

    @Column(name = "plano_id", nullable = false)
    private UUID planoId; // Referência ao ID do Plano (do Subscription Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant

    // Relacionamentos com entidades que residem no mesmo Professional Service
    // (infraestrutura)
    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<CertificacaoEntity> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<DocumentoEntity> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissionalEntity> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademicaEntity> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissionalEntity> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissionalEntity extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

// --- Entidades de Dados Mestres (se gerenciadas localmente no Professional
// Service) ---
// NOTA: Se estas entidades residirem em um "Master Data Service" separado e o
// Professional Service
// apenas referenciar seus IDs, então estas classes de entidade não estariam
// aqui.
// Elas são incluídas assumindo que o Professional Service pode ter uma cópia
// local ou gerenciar
// essas entidades para seu próprio contexto.
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimentoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacaoEntity;

public interface AreaAtuacaoRepository {

    // Salva ou atualiza uma Área de Atuação.
    AreaAtuacaoEntity save(AreaAtuacaoEntity areaAtuacao);

    // Busca uma Área de Atuação pelo seu ID.
    Optional<AreaAtuacaoEntity> findById(UUID id);

    // Busca uma Área de Atuação pelo nome.
    Optional<AreaAtuacaoEntity> findByNome(String nome);

    // Busca todas as Áreas de Atuação.
    List<AreaAtuacaoEntity> findAll();

    // Deleta uma Área de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

public interface CertificacaoRepository {

    // Salva ou atualiza uma Certificação para um Profissional.
    CertificacaoEntity save(CertificacaoEntity certificacao, UUID profissionalId);

    // Busca uma Certificação pelo seu ID e pelo ID do Profissional.
    Optional<CertificacaoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Certificações de um Profissional.
    List<CertificacaoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

public interface DocumentoRepository {

    // Salva ou atualiza um Documento para um Profissional.
    DocumentoEntity save(DocumentoEntity documento, UUID profissionalId);

    // Busca um Documento pelo seu ID e pelo ID do Profissional.
    Optional<DocumentoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todos os Documentos de um Profissional.
    List<DocumentoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta um Documento pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

public interface ExperienciaRepository {

    // Salva ou atualiza uma Experiência Profissional para um Profissional.
    ExperienciaProfissionalEntity save(ExperienciaProfissionalEntity experiencia, UUID profissionalId);

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissionalEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissionalEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

public interface FormacaoRepository {

    // Salva ou atualiza uma Formação Acadêmica para um Profissional.
    FormacaoAcademicaEntity save(FormacaoAcademicaEntity formacao, UUID profissionalId);

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademicaEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademicaEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.IdiomaEntity;

public interface IdiomaRepository {

    // Salva ou atualiza um Idioma.
    IdiomaEntity save(IdiomaEntity idioma);

    // Busca um Idioma pelo seu ID.
    Optional<IdiomaEntity> findById(UUID id);

    // Busca um Idioma pelo nome.
    Optional<IdiomaEntity> findByNome(String nome);

    // Busca todos os Idiomas.
    List<IdiomaEntity> findAll();

    // Deleta um Idioma pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacaoEntity;

public interface LocalAtuacaoRepository {

    // Salva ou atualiza um Local de Atuação.
    LocalAtuacaoEntity save(LocalAtuacaoEntity localAtuacao);

    // Busca um Local de Atuação pelo seu ID.
    Optional<LocalAtuacaoEntity> findById(UUID id);

    // Busca um Local de Atuação pelo nome.
    Optional<LocalAtuacaoEntity> findByNome(String nome);

    // Busca todos os Locais de Atuação.
    List<LocalAtuacaoEntity> findAll();

    // Deleta um Local de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ProfissionalEntity;

public interface ProfissionalRepository {

    // Salva ou atualiza um Profissional no repositório.
    ProfissionalEntity save(ProfissionalEntity profissional);

    // Busca um Profissional pelo seu ID.
    Optional<ProfissionalEntity> findById(UUID id);

    // Busca um Profissional pelo número da OAB.
    Optional<ProfissionalEntity> findByNumeroOab(String numeroOab);

    // Busca todos os Profissionais associados a um determinado tenant.
    List<ProfissionalEntity> findAllByTenantId(UUID tenantId);

    // Deleta um Profissional pelo seu ID.
    void deleteById(UUID id);

    // Verifica se um Profissional existe pelo número da OAB.
    boolean existsByNumeroOab(String numeroOab);

    // Verifica se um Profissional existe pelo ID da pessoa associada.
    boolean existsByPessoaId(UUID pessoaId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimentoEntity;

public interface TipoAtendimentoRepository {

    // Salva ou atualiza um Tipo de Atendimento.
    TipoAtendimentoEntity save(TipoAtendimentoEntity tipoAtendimento);

    // Busca um Tipo de Atendimento pelo seu ID.
    Optional<TipoAtendimentoEntity> findById(UUID id);

    // Busca um Tipo de Atendimento pelo nome.
    Optional<TipoAtendimentoEntity> findByNome(String nome);

    // Busca todos os Tipos de Atendimento.
    List<TipoAtendimentoEntity> findAll();

    // Deleta um Tipo de Atendimento pelo seu ID.
    void deleteById(UUID id);
}
```
```
```java
package br.com.legalconnect.advogado.application.dto.enums;

public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}

```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AtualizacaoPerfilRequest {
    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId;

    private UUID planoId;

    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @PastOrPresent(message = "A data de nascimento da pessoa não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @NotBlank(message = "O número de telefone não pode ser vazio.")
    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefonesPessoa;

    @NotNull(message = "O ID do local de atuação não pode ser nulo.")
    private List<UUID> locaisAtuacaoIds;

    @NotNull(message = "O ID da área de atuação não pode ser nulo.")
    private List<UUID> areaAtuacaoIds;

    @NotNull(message = "O ID do idioma não pode ser nulo.")
    private List<UUID> idiomaIds;

    @NotNull(message = "O ID do tipo de atendimento não pode ser nulo.")
    private List<UUID> tipoAtendimentoIds;

    @Valid
    private List<CertificacaoRequestDTO> certificacoes;

    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;

    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoRequestDTO {

    private UUID id;

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    @NotBlank(message = "O tipo do documento é obrigatório.")
    @Size(max = 100, message = "O tipo do documento deve ter no máximo 100 caracteres.")
    private String tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id;

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim;

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id;

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalCreateRequest {
    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String emailUsuario;

    @NotBlank(message = "A senha do usuário é obrigatória.")
    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    private String senhaUsuario;

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompletoPessoa;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpfPessoa;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimentoPessoa;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;

    private String nome;

    private String instituicao;

    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;

    private String nomeArquivo;

    private String urlS3;

    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;

    private String cargo;

    private String empresa;

    private LocalDate dataInicio;

    private LocalDate dataFim;

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;

    private String curso;

    private String instituicao;

    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalDetalhadoResponse {
    private UUID id;

    private String numeroOab;

    private String statusProfissional;

    private Boolean usaMarketplace;

    private Boolean fazParteDePlano;

    private UUID pessoaId;

    private UUID empresaId;

    private UUID planoId;

    private UUID tenantId;

    private String nomeCompletoPessoa;

    private String cpfPessoa;

    private LocalDate dataNascimentoPessoa;

    private List<String> telefonesPessoa;

    private List<CertificacaoResponseDTO> certificacoes;

    private List<DocumentoResponseDTO> documentos;

    private List<ExperienciaProfissionalResponseDTO> experiencias;

    private List<FormacaoAcademicaResponseDTO> formacoes;

    private List<UUID> locaisAtuacaoIds;

    private List<UUID> areaAtuacaoIds;

    private List<UUID> idiomaIds;

    private List<UUID> tipoAtendimentoIds;

    private List<UUID> roleProfissionalIds;
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

@Mapper(componentModel = "spring")
public interface CertificacaoMapper {

    // Mapeia CertificacaoRequestDTO para o modelo de domínio Certificacao

    CertificacaoEntity toDomainModel(CertificacaoRequestDTO dto);

    // Atualiza um modelo de domínio Certificacao a partir de CertificacaoRequestDTO
    @Mapping(target = "id", ignore = true) // ID não é atualizável via update
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(CertificacaoRequestDTO dto, @MappingTarget CertificacaoEntity certificacao);

    // Mapeia o modelo de domínio Certificacao para CertificacaoResponseDTO
    CertificacaoResponseDTO toResponseDTO(CertificacaoEntity certificacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;

import br.com.legalconnect.advogado.application.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.application.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.application.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

@Mapper(componentModel = "spring")
public interface DocumentoMapper {

    // Mapeia DocumentoUploadRequest para o modelo de domínio Documento
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapStringToDocumentoTipo")
    DocumentoEntity toDomainModel(DocumentoUploadRequest request);

    // Mapeia o modelo de domínio Documento para DocumentoResponseDTO
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    DocumentoResponseDTO toResponseDTO(DocumentoEntity documento);

    @Named("mapStringToDocumentoTipo")
    default DocumentoTipo mapStringToDocumentoTipo(String tipoDocumento) {
        if (tipoDocumento == null) {
            return null;
        }
        try {
            return DocumentoTipo.valueOf(tipoDocumento.toUpperCase());
        } catch (IllegalArgumentException e) {
            // Tratar caso de tipo de documento inválido, talvez lançar uma exceção de
            // validação
            return DocumentoTipo.OUTRO; // Ou outro tratamento de erro
        }
    }

    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipoDocumento) {
        return tipoDocumento != null ? tipoDocumento.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

@Mapper(componentModel = "spring")
public interface ExperienciaMapper {

    // Mapeia ExperienciaProfissionalRequestDTO para o modelo de domínio
    // ExperienciaProfissional
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    ExperienciaProfissionalEntity toDomainModel(ExperienciaProfissionalRequestDTO dto);

    // Atualiza um modelo de domínio ExperienciaProfissional a partir de
    // ExperienciaProfissionalRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(ExperienciaProfissionalRequestDTO dto,
            @MappingTarget ExperienciaProfissionalEntity experiencia);

    // Mapeia o modelo de domínio ExperienciaProfissional para
    // ExperienciaProfissionalResponseDTO
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissionalEntity experiencia);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

@Mapper(componentModel = "spring")
public interface FormacaoMapper {

    // Mapeia FormacaoAcademicaRequestDTO para o modelo de domínio FormacaoAcademica
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    FormacaoAcademicaEntity toDomainModel(FormacaoAcademicaRequestDTO dto);

    // Atualiza um modelo de domínio FormacaoAcademica a partir de
    // FormacaoAcademicaRequestDTO
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    void updateDomainModelFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademicaEntity formacao);

    // Mapeia o modelo de domínio FormacaoAcademica para
    // FormacaoAcademicaResponseDTO
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademicaEntity formacao);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import java.util.List;
import java.util.Set;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;

import br.com.legalconnect.advogado.application.dto.request.AtualizacaoPerfilRequest;
import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.application.dto.response.ProfissionalDetalhadoResponse;
import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;
import br.com.legalconnect.entity.Profissional;

@Mapper(componentModel = "spring", uses = { CertificacaoMapper.class, ExperienciaMapper.class, FormacaoMapper.class })
public interface ProfissionalMapper {

    // Mapeia ProfissionalCreateRequest para o modelo de domínio Profissional
    @Mapping(target = "id", ignore = true) // ID será gerado no domínio/persistência
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", constant = "EM_ANALISE") // Status inicial padrão
    @Mapping(target = "usaMarketplace", constant = "false")
    @Mapping(target = "fazParteDePlano", constant = "false")
    // @Mapping(target = "certificacoes", ignore = true) // Coleções serão tratadas
    // separadamente ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "locaisAtuacaoIds", ignore = true)
    // @Mapping(target = "areaAtuacaoIds", ignore = true)
    // @Mapping(target = "idiomaIds", ignore = true)
    // @Mapping(target = "tipoAtendimentoIds", ignore = true)
    // @Mapping(target = "roleProfissionalIds", ignore = true)
    // @Mapping(source = "planoId", target = "planoId")
    // @Mapping(source = "tenantId", target = "tenantId")
    // Note: pessoaId e empresaId não são mapeados diretamente aqui, pois virão de
    // outros serviços
    Profissional toDomainModel(ProfissionalCreateRequest request);

    // Atualiza um modelo de domínio Profissional a partir de
    // AtualizacaoPerfilRequest
    @Mapping(target = "id", ignore = true) // ID não é atualizável
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "statusProfissional", ignore = true) // Status é atualizado por métodos de negócio
    @Mapping(target = "numeroOab", ignore = true) // OAB geralmente não é atualizável após o cadastro
    // @Mapping(target = "certificacoes", ignore = true) // Coleções tratadas por
    // mappers específicos ou no serviço
    // @Mapping(target = "documentos", ignore = true)
    // @Mapping(target = "experiencias", ignore = true)
    // @Mapping(target = "formacoes", ignore = true)
    // @Mapping(target = "pessoaId", ignore = true)
    // @Mapping(target = "tenantId", ignore = true)
    // // Mapeamento de coleções de UUIDs
    // @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds")
    // @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds")
    // @Mapping(source = "idiomaIds", target = "idiomaIds")
    // @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds")
    void updateDomainModelFromRequest(AtualizacaoPerfilRequest request, @MappingTarget Profissional profissional);

    // Mapeia o modelo de domínio Profissional para ProfissionalDetalhadoResponse
    @Mapping(source = "statusProfissional", target = "statusProfissional") // Mapeia o enum para String
    // @Mapping(source = "certificacoes", target = "certificacoes")
    // @Mapping(source = "documentos", target = "documentos")
    // @Mapping(source = "experiencias", target = "experiencias")
    // @Mapping(source = "formacoes", target = "formacoes")
    ProfissionalDetalhadoResponse toDetalhadoResponse(Profissional profissional);

    // Mapeamento de coleções aninhadas
    Set<CertificacaoEntity> mapCertificacaoRequestDTOsToCertificacoes(List<CertificacaoRequestDTO> dtos);

    Set<ExperienciaProfissionalEntity> mapExperienciaRequestDTOsToExperiencias(
            List<ExperienciaProfissionalRequestDTO> dtos);

    Set<FormacaoAcademicaEntity> mapFormacaoRequestDTOsToFormacoes(List<FormacaoAcademicaRequestDTO> dtos);

    List<CertificacaoResponseDTO> mapCertificacoesToCertificacaoResponseDTOs(Set<CertificacaoEntity> certificacoes);

    List<ExperienciaProfissionalResponseDTO> mapExperienciasToExperienciaResponseDTOs(
            Set<ExperienciaProfissionalEntity> experiencias);

    List<FormacaoAcademicaResponseDTO> mapFormacoesToFormacaoResponseDTOs(Set<FormacaoAcademicaEntity> formacoes);
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class CertificacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class DocumentoEntity extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class EnderecoEntity extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro;

    @Column(name = "numero", length = 20)
    private String numero;

    @Column(name = "complemento", length = 100)
    private String complemento;

    @Column(name = "bairro", length = 100)
    private String bairro;

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade;

    @Column(name = "estado", nullable = false, length = 2)
    private String estado;

    @Column(name = "cep", nullable = false, length = 10)
    private String cep;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id", nullable = false)
    private PessoaEntity pessoa; // Pessoa está no mesmo serviço (Person Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant
}

// --- Serviço de Profissional (br.com.legalconnect.profissional) - Entidades de
// Infraestrutura ---
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissionalEntity extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademicaEntity extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private ProfissionalEntity profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class IdiomaEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacaoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaEntity extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalEntity extends BaseEntity {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId; // Referência ao ID da Pessoa (do Person Service)

    @Column(name = "empresa_id")
    private UUID empresaId; // Referência ao ID da Empresa (do Company Service)

    @Column(name = "plano_id", nullable = false)
    private UUID planoId; // Referência ao ID do Plano (do Subscription Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant

    // Relacionamentos com entidades que residem no mesmo Professional Service
    // (infraestrutura)
    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<CertificacaoEntity> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<DocumentoEntity> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissionalEntity> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademicaEntity> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissionalEntity> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissionalEntity extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

// --- Entidades de Dados Mestres (se gerenciadas localmente no Professional
// Service) ---
// NOTA: Se estas entidades residirem em um "Master Data Service" separado e o
// Professional Service
// apenas referenciar seus IDs, então estas classes de entidade não estariam
// aqui.
// Elas são incluídas assumindo que o Professional Service pode ter uma cópia
// local ou gerenciar
// essas entidades para seu próprio contexto.
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimentoEntity extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacaoEntity;

public interface AreaAtuacaoRepository {

    // Salva ou atualiza uma Área de Atuação.
    AreaAtuacaoEntity save(AreaAtuacaoEntity areaAtuacao);

    // Busca uma Área de Atuação pelo seu ID.
    Optional<AreaAtuacaoEntity> findById(UUID id);

    // Busca uma Área de Atuação pelo nome.
    Optional<AreaAtuacaoEntity> findByNome(String nome);

    // Busca todas as Áreas de Atuação.
    List<AreaAtuacaoEntity> findAll();

    // Deleta uma Área de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.CertificacaoEntity;

public interface CertificacaoRepository {

    // Salva ou atualiza uma Certificação para um Profissional.
    CertificacaoEntity save(CertificacaoEntity certificacao, UUID profissionalId);

    // Busca uma Certificação pelo seu ID e pelo ID do Profissional.
    Optional<CertificacaoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Certificações de um Profissional.
    List<CertificacaoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.DocumentoEntity;

public interface DocumentoRepository {

    // Salva ou atualiza um Documento para um Profissional.
    DocumentoEntity save(DocumentoEntity documento, UUID profissionalId);

    // Busca um Documento pelo seu ID e pelo ID do Profissional.
    Optional<DocumentoEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todos os Documentos de um Profissional.
    List<DocumentoEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta um Documento pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissionalEntity;

public interface ExperienciaRepository {

    // Salva ou atualiza uma Experiência Profissional para um Profissional.
    ExperienciaProfissionalEntity save(ExperienciaProfissionalEntity experiencia, UUID profissionalId);

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissionalEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissionalEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademicaEntity;

public interface FormacaoRepository {

    // Salva ou atualiza uma Formação Acadêmica para um Profissional.
    FormacaoAcademicaEntity save(FormacaoAcademicaEntity formacao, UUID profissionalId);

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademicaEntity> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademicaEntity> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.IdiomaEntity;

public interface IdiomaRepository {

    // Salva ou atualiza um Idioma.
    IdiomaEntity save(IdiomaEntity idioma);

    // Busca um Idioma pelo seu ID.
    Optional<IdiomaEntity> findById(UUID id);

    // Busca um Idioma pelo nome.
    Optional<IdiomaEntity> findByNome(String nome);

    // Busca todos os Idiomas.
    List<IdiomaEntity> findAll();

    // Deleta um Idioma pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacaoEntity;

public interface LocalAtuacaoRepository {

    // Salva ou atualiza um Local de Atuação.
    LocalAtuacaoEntity save(LocalAtuacaoEntity localAtuacao);

    // Busca um Local de Atuação pelo seu ID.
    Optional<LocalAtuacaoEntity> findById(UUID id);

    // Busca um Local de Atuação pelo nome.
    Optional<LocalAtuacaoEntity> findByNome(String nome);

    // Busca todos os Locais de Atuação.
    List<LocalAtuacaoEntity> findAll();

    // Deleta um Local de Atuação pelo seu ID.
    void deleteById(UUID id);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.ProfissionalEntity;

public interface ProfissionalRepository {

    // Salva ou atualiza um Profissional no repositório.
    ProfissionalEntity save(ProfissionalEntity profissional);

    // Busca um Profissional pelo seu ID.
    Optional<ProfissionalEntity> findById(UUID id);

    // Busca um Profissional pelo número da OAB.
    Optional<ProfissionalEntity> findByNumeroOab(String numeroOab);

    // Busca todos os Profissionais associados a um determinado tenant.
    List<ProfissionalEntity> findAllByTenantId(UUID tenantId);

    // Deleta um Profissional pelo seu ID.
    void deleteById(UUID id);

    // Verifica se um Profissional existe pelo número da OAB.
    boolean existsByNumeroOab(String numeroOab);

    // Verifica se um Profissional existe pelo ID da pessoa associada.
    boolean existsByPessoaId(UUID pessoaId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimentoEntity;

public interface TipoAtendimentoRepository {

    // Salva ou atualiza um Tipo de Atendimento.
    TipoAtendimentoEntity save(TipoAtendimentoEntity tipoAtendimento);

    // Busca um Tipo de Atendimento pelo seu ID.
    Optional<TipoAtendimentoEntity> findById(UUID id);

    // Busca um Tipo de Atendimento pelo nome.
    Optional<TipoAtendimentoEntity> findByNome(String nome);

    // Busca todos os Tipos de Atendimento.
    List<TipoAtendimentoEntity> findAll();

    // Deleta um Tipo de Atendimento pelo seu ID.
    void deleteById(UUID id);
}
```