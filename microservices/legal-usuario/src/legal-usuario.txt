```java
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication(exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui também, se já está no
                                                                // pacote raiz
@EntityScan(basePackages = {
        // "br.com.legalconnect.entity",
        "br.com.legalconnect.entity"
})
// @EnableJpaRepositories(basePackages = {
// "br.com.legalconnect.user.repository",
// "br.com.legalconnect.auth.repository"
// })
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class LegalUsuarioApplication {

    private static final Logger log = LoggerFactory.getLogger(LegalUsuarioApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(LegalUsuarioApplication.class, args);
        log.info("LegalUsuarioApplication iniciada com sucesso!");
    }
}
```
```java
package br.com.legalconnect.config; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.multitenancy.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String tenantIdHeader = request.getHeader(TENANT_HEADER);
            String tenantId = "public";

            if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
                try {
                    tenantId = (tenantIdHeader);
                } catch (IllegalArgumentException e) {
                    // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                    System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                    return;
                }
            } else {
                // Usar o tenant padrão se o cabeçalho não for fornecido
                try {
                    tenantId = (defaultTenantId);
                } catch (IllegalArgumentException e) {
                    System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                            "Configuração de Tenant padrão inválida.");
                    return;
                }
            }

            TenantContext.setCurrentTenant(tenantId);
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear(); // Limpar o TenantContext após a requisição
        }
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.AdministradorRequestDTO;
import dto.AdministradorResponseDTO;
import service.ServicoAdministrador;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorAdministradorPlataforma
 * @brief Controlador REST para gerenciar operações relacionadas a Administradores da Plataforma.
 * Expõe endpoints para CRUD de Administradores.
 */
@RestController
@RequestMapping("/api/v1/administradores-plataforma")
public class ControladorAdministradorPlataforma {

    private final ServicoAdministrador servicoAdministrador;

    @Autowired
    public ControladorAdministradorPlataforma(ServicoAdministrador servicoAdministrador) {
        this.servicoAdministrador = servicoAdministrador;
    }

    /**
     * @brief Cadastra um novo Administrador da Plataforma.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return ResponseEntity com o DTO do Administrador cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> cadastrarAdministrador(@Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.cadastrarAdministrador(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Administrador da Plataforma por ID.
     * @param id ID do Administrador a ser buscado.
     * @return ResponseEntity com o DTO do Administrador encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> buscarAdministradorPorId(@PathVariable UUID id) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.buscarAdministradorPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Administradores da Plataforma com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Administradores e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<AdministradorResponseDTO>>> listarAdministradores(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<AdministradorResponseDTO> responsePage = servicoAdministrador.listarAdministradores(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de administradores recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Administrador da Plataforma existente.
     * @param id ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return ResponseEntity com o DTO do Administrador atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> atualizarAdministrador(
            @PathVariable UUID id,
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.atualizarAdministrador(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Administrador da Plataforma pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirAdministrador(@PathVariable UUID id) {
        servicoAdministrador.excluirAdministrador(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.ClienteRequestDTO;
import dto.ClienteResponseDTO;
import service.ServicoCliente;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorCliente
 * @brief Controlador REST para gerenciar operações relacionadas a Clientes.
 * Expõe endpoints para CRUD de Clientes.
 */
@RestController
@RequestMapping("/api/v1/clientes")
public class ControladorCliente {

    private final ServicoCliente servicoCliente;

    @Autowired
    public ControladorCliente(ServicoCliente servicoCliente) {
        this.servicoCliente = servicoCliente;
    }

    /**
     * @brief Cadastra um novo Cliente.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return ResponseEntity com o DTO do Cliente cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> cadastrarCliente(@Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.cadastrarCliente(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Cliente por ID.
     * @param id ID do Cliente a ser buscado.
     * @return ResponseEntity com o DTO do Cliente encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> buscarClientePorId(@PathVariable UUID id) {
        ClienteResponseDTO responseDTO = servicoCliente.buscarClientePorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Clientes e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ClienteResponseDTO>>> listarClientes(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ClienteResponseDTO> responsePage = servicoCliente.listarClientes(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de clientes recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return ResponseEntity com o DTO do Cliente atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> atualizarCliente(
            @PathVariable UUID id,
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.atualizarCliente(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirCliente(@PathVariable UUID id) {
        servicoCliente.excluirCliente(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.EmpresaRequestDTO;
import dto.EmpresaResponseDTO;
import service.ServicoEmpresa;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorEmpresa
 * @brief Controlador REST para gerenciar operações relacionadas a Empresas.
 * Expõe endpoints para CRUD de Empresas.
 */
@RestController
@RequestMapping("/api/v1/empresas")
public class ControladorEmpresa {

    private final ServicoEmpresa servicoEmpresa;

    @Autowired
    public ControladorEmpresa(ServicoEmpresa servicoEmpresa) {
        this.servicoEmpresa = servicoEmpresa;
    }

    /**
     * @brief Cadastra uma nova Empresa.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return ResponseEntity com o DTO da Empresa cadastrada e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> cadastrarEmpresa(@Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.cadastrarEmpresa(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa cadastrada com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca uma Empresa por ID.
     * @param id ID da Empresa a ser buscada.
     * @return ResponseEntity com o DTO da Empresa encontrada e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> buscarEmpresaPorId(@PathVariable UUID id) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.buscarEmpresaPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa encontrada.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeFantasia,asc).
     * @return ResponseEntity com uma página de DTOs de Empresas e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<EmpresaResponseDTO>>> listarEmpresas(
            @PageableDefault(size = 10, page = 0, sort = "nomeFantasia") Pageable pageable) {
        Page<EmpresaResponseDTO> responsePage = servicoEmpresa.listarEmpresas(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de empresas recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return ResponseEntity com o DTO da Empresa atualizada e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> atualizarEmpresa(
            @PathVariable UUID id,
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.atualizarEmpresa(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa atualizada com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirEmpresa(@PathVariable UUID id) {
        servicoEmpresa.excluirEmpresa(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa excluída com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.ProfissionalRequestDTO;
import dto.ProfissionalResponseDTO;
import service.ServicoProfissional;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorProfissional
 * @brief Controlador REST para gerenciar operações relacionadas a Profissionais.
 * Expõe endpoints para CRUD de Profissionais.
 */
@RestController
@RequestMapping("/api/v1/profissionais")
public class ControladorProfissional {

    private final ServicoProfissional servicoProfissional;

    @Autowired
    public ControladorProfissional(ServicoProfissional servicoProfissional) {
        this.servicoProfissional = servicoProfissional;
    }

    /**
     * @brief Cadastra um novo Profissional.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return ResponseEntity com o DTO do Profissional cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> cadastrarProfissional(@Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.cadastrarProfissional(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Profissional por ID.
     * @param id ID do Profissional a ser buscado.
     * @return ResponseEntity com o DTO do Profissional encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> buscarProfissionalPorId(@PathVariable UUID id) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.buscarProfissionalPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Profissionais e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> listarProfissionais(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ProfissionalResponseDTO> responsePage = servicoProfissional.listarProfissionais(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de profissionais recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return ResponseEntity com o DTO do Profissional atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> atualizarProfissional(
            @PathVariable UUID id,
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.atualizarProfissional(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirProfissional(@PathVariable UUID id) {
        servicoProfissional.excluirProfissional(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorRequestDTO
 * @brief DTO para requisições de criação ou atualização de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorResponseDTO
 * @brief DTO para respostas de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorResponseDTO extends PessoaResponseDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteRequestDTO
 * @brief DTO para requisições de criação ou atualização de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteResponseDTO
 * @brief DTO para respostas de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteResponseDTO extends PessoaResponseDTO {
    private String status;
    private String tipo;
}
```
```java
package br.com.legalconnect.dto;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaRequestDTO
 * @brief DTO para requisições de criação ou atualização de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O nome fantasia não pode estar em branco.")
    @Size(max = 255, message = "O nome fantasia deve ter no máximo 255 caracteres.")
    private String nomeFantasia;

    @NotBlank(message = "A razão social não pode estar em branco.")
    @Size(max = 255, message = "A razão social deve ter no máximo 255 caracteres.")
    private String razaoSocial;

    @NotBlank(message = "O CNPJ não pode estar em branco.")
    @Pattern(regexp = "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}", message = "Formato de CNPJ inválido. Use XX.XXX.XXX/XXXX-XX.")
    private String cnpj;

    @Email(message = "Formato de email de contato inválido.")
    @Size(max = 255, message = "O email de contato deve ter no máximo 255 caracteres.")
    private String emailContato;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos;

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaResponseDTO
 * @brief DTO para respostas de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaResponseDTO {
    private UUID id;
    private String nomeFantasia;
    private String razaoSocial;
    private String cnpj;
    private String emailContato;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoRequestDTO
 * @brief DTO para requisições de criação ou atualização de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número não pode estar em branco.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade não pode estar em branco.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado não pode estar em branco.")
    @Size(min = 2, max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "\\d{5}-\\d{3}", message = "Formato de CEP inválido. Use XXXXX-XXX.")
    private String cep;

    @NotBlank(message = "O país não pode estar em branco.")
    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais;

    @NotNull(message = "O tipo de endereço não pode ser nulo.")
    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoResponseDTO
 * @brief DTO para respostas de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;
    private String logradouro;
    private String numero;
    private String complemento;
    private String bairro;
    private String cidade;
    private String estado;
    private String cep;
    private String pais;
    private TipoEndereco tipoEndereco;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.util.List; // Usar List para Enderecos para manter a ordem se necessário
import java.util.Set;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaRequestDTO
 * @brief DTO base para requisições de criação ou atualização de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // Não incluir o ID aqui, pois ele será definido pela entidade base (BaseEntity)
    // e retornado no ResponseDTO.

    @NotNull(message = "Os dados do usuário não podem ser nulos.")
    @Valid // Valida o DTO aninhado
    private UserRequestDTO usuario;

    @NotBlank(message = "O nome completo não pode estar em branco.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Pattern(regexp = "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}", message = "Formato de CPF inválido. Use XXX.XXX.XXX-XX.")
    private String cpf;

    @PastOrPresent(message = "A data de nascimento não pode ser futura.")
    private LocalDate dataNascimento;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos; // Usar List para manter a ordem se necessário

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaResponseDTO
 * @brief DTO base para respostas de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaResponseDTO {
    private UUID id;
    private UserResponseDTO usuario;
    private String nomeCompleto;
    private String cpf;
    private LocalDate dataNascimento;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Plano.VisibilidadeDestaque;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class PlanoResponseDTO
 * @brief DTO para respostas de Plano.
 *        Esta classe é um DTO simplificado para ser usado em outros
 *        microsserviços.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PlanoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
    private BigDecimal precoMensal;
    private BigDecimal precoAnual;
    private Integer limiteServicosAgendaveis;
    private VisibilidadeDestaque visibilidadeDestaque;
    private Boolean acessoRelatoriosAvancados;
    private Boolean permitePedidosOrcamento;
    private Integer periodoTesteDias;
    private Boolean isDefault;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalRequestDTO
 * @brief DTO para requisições de criação ou atualização de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalRequestDTO extends PessoaRequestDTO {
    @NotBlank(message = "O número da OAB não pode estar em branco.")
    @Size(max = 50, message = "O número da OAB deve ter no máximo 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "O status profissional não pode ser nulo.")
    private StatusProfissional statusProfissional;

    @NotNull(message = "A indicação de uso do marketplace não pode ser nula.")
    private Boolean usaMarketplace;

    @NotNull(message = "A indicação de participação em plano não pode ser nula.")
    private Boolean fazParteDePlano;

    private UUID empresaId; // ID da empresa associada (opcional)

    @NotNull(message = "O ID do plano não pode ser nulo.")
    private UUID planoId; // ID do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalResponseDTO
 * @brief DTO para respostas de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalResponseDTO extends PessoaResponseDTO {
    private String numeroOab;
    private StatusProfissional statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private EmpresaResponseDTO empresa; // DTO da empresa associada (simplificado)
    private PlanoResponseDTO plano; // DTO do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserRequestDTO
 * @brief DTO para requisições de criação ou atualização de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    private UUID id;
    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    private String email;

    // @NotBlank(message = "A senha não pode estar em branco.")
    // @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // private String password;

    // O papel (Role) pode ser definido aqui ou inferido pelo serviço de
    // autenticação/usuário
    // dependendo da lógica de negócio. Para simplificar, pode ser incluído se for
    // um input direto.
    // private String role;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserResponseDTO
 * @brief DTO para respostas de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // private String role; // Incluir se o papel for relevante na resposta
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Administrador
 * @brief Entidade que representa um administrador da plataforma.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_administrador' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_administrador")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Administrador extends Pessoa {
    private String status;

    // Atualmente, não há campos adicionais específicos para Administrador além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, nível de acesso
    // administrativo, etc.
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Cliente
 * @brief Entidade que representa um cliente.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_cliente' que se junta a 'tb_pessoa' pela
 *        chave primária.
 */
@Entity
@Table(name = "tb_cliente")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Cliente extends Pessoa {
    private String status;
    private String tipo;

    // Atualmente, não há campos adicionais específicos para Cliente além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, histórico de preferências,
    // etc.
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Empresa
 * @brief Entidade que representa uma empresa que pode contratar planos na
 *        plataforma.
 *        Esta entidade não estende Pessoa, pois representa uma pessoa jurídica.
 *        Mapeada para a tabela 'tb_empresa'.
 */
@Entity
@Table(name = "tb_empresa")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Empresa extends BaseEntity {

    @Column(name = "nome_fantasia", nullable = false, length = 255)
    private String nomeFantasia; // Nome fantasia da empresa

    @Column(name = "razao_social", nullable = false, length = 255)
    private String razaoSocial; // Razão social da empresa

    @Column(name = "cnpj", nullable = false, unique = true, length = 18) // CNPJ com máscara
    private String cnpj; // Número do Cadastro Nacional de Pessoas Jurídicas (CNPJ), único por empresa

    @Column(name = "email_contato", length = 255)
    private String emailContato; // E-mail de contato da empresa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma empresa pode ter múltiplos endereços (sede, filiais, etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Empresa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'empresa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da empresa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_empresa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_empresa_telefones", joinColumns = @JoinColumn(name = "empresa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da empresa

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionais = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id")
    private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set; // Usaremos Set para evitar duplicatas e garantir unicidade

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public abstract class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da pessoa
}
```
```java
package br.com.legalconnect.entity;

import java.math.BigDecimal;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 *        plataforma.
 *        Esta classe é um placeholder e deve ser definida em seu próprio
 *        microsserviço (marketplace).
 *        Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault; // Indica se é o plano padrão para novos cadastros

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     *        plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        PREMIUM,
        DESTAQUE_MAXIMO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Profissional
 * @brief Entidade que representa um profissional do direito.
 *        Estende a entidade Pessoa e adiciona campos específicos de um
 *        profissional.
 *        Mapeado para a tabela 'tb_profissional' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_profissional")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab; // Número de registro na OAB, único por profissional

    @Enumerated(EnumType.STRING)
    @Column(name = "status_profissional", nullable = false, length = 50)
    private StatusProfissional statusProfissional; // Status específico do profissional (ex: ATIVO, LICENCIADO)

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false; // Indica se o profissional deseja aparecer no marketplace

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false; // Indica se o profissional está associado a um plano pago

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um profissional pode pertencer a uma empresa.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id") // Coluna de chave estrangeira para a empresa
    private Empresa empresa; // A empresa à qual o profissional está associado (se houver)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Plano.
     *        Um profissional está associado a um plano de assinatura.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira para o plano
    private Plano plano; // O plano de assinatura do advogado
    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_profissionals_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "profissional_profissionals_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<RoleProfissional> roleProfissionals = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum StatusProfissional
     * @brief Enumeração para representar o status específico de um Profissional.
     */
    public enum StatusProfissional {
        ATIVO, // Profissional ativo e em dia
        LICENCIADO, // Profissional com licença temporariamente suspensa
        SUSPENSO, // Profissional suspenso (ex: por infração)
        EM_ANALISE // Profissional aguardando aprovação/verificação
    }
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 *        Esta tabela de roles agora reside nos schemas de tenant, o que
 *        significa
 *        que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 *        IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RoleProfissional extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface AdministradorMapper
 * @brief Mapper MapStruct para conversão entre Administrador e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface AdministradorMapper extends PessoaMapper {

    AdministradorMapper INSTANCE = Mappers.getMapper(AdministradorMapper.class);

    /**
     * @brief Mapeia um AdministradorRequestDTO para uma entidade Administrador.
     * @param dto O DTO de requisição do administrador.
     * @return A entidade Administrador.
     */
    Administrador toEntity(AdministradorRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Administrador para um AdministradorResponseDTO.
     * @param entity A entidade Administrador.
     * @return O DTO de resposta do administrador.
     */
    @Mapping(source = "status", target = "status")
    AdministradorResponseDTO toResponseDTO(Administrador entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ClienteMapper
 * @brief Mapper MapStruct para conversão entre Cliente e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface ClienteMapper extends PessoaMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    /**
     * @brief Mapeia um ClienteRequestDTO para uma entidade Cliente.
     * @param dto O DTO de requisição do cliente.
     * @return A entidade Cliente.
     */
    Cliente toEntity(ClienteRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Cliente para um ClienteResponseDTO.
     * @param entity A entidade Cliente.
     * @return O DTO de resposta do cliente.
     */
    @Mapping(source = "status", target = "status")
    @Mapping(target = "tipo", ignore = true) // O campo 'tipo' não existe na entidade Cliente, apenas no DTO de resposta
    ClienteResponseDTO toResponseDTO(Cliente entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EmpresaMapper
 * @brief Mapper MapStruct para conversão entre Empresa e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class})
public interface EmpresaMapper {

    EmpresaMapper INSTANCE = Mappers.getMapper(EmpresaMapper.class);

    /**
     * @brief Converte um EmpresaRequestDTO para uma entidade Empresa.
     * @param dto O DTO de requisição da empresa.
     * @return A entidade Empresa.
     */
    @Mapping(target = "id", ignore = true) // ID é gerado, não vem do DTO de requisição
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    Empresa toEntity(EmpresaRequestDTO dto);

    /**
     * @brief Converte uma entidade Empresa para um EmpresaResponseDTO.
     * @param entity A entidade Empresa.
     * @return O DTO de resposta da empresa.
     */
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    EmpresaResponseDTO toResponseDTO(Empresa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Endereco.TipoEndereco; // Importa o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EnderecoMapper
 * @brief Mapper MapStruct para conversão entre Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * @brief Converte um EnderecoRequestDTO para uma entidade Endereco.
     * @param dto O DTO de requisição do endereço.
     * @return A entidade Endereco.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "pessoa", ignore = true) // Será setado no serviço
    @Mapping(target = "empresa", ignore = true) // Será setado no serviço
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * @brief Converte uma entidade Endereco para um EnderecoResponseDTO.
     * @param entity A entidade Endereco.
     * @return O DTO de resposta do endereço.
     */
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * @brief Converte uma lista de EnderecoRequestDTOs para um Set de entidades Endereco.
     * @param dtoList A lista de DTOs de requisição de endereços.
     * @return Um Set de entidades Endereco.
     */
    Set<Endereco> toEntitySet(List<EnderecoRequestDTO> dtoList);

    /**
     * @brief Converte um Set de entidades Endereco para uma lista de EnderecoResponseDTOs.
     * @param entitySet Um Set de entidades Endereco.
     * @return Uma lista de DTOs de resposta de endereços.
     */
    List<EnderecoResponseDTO> toResponseDTOList(Set<Endereco> entitySet);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.InheritInverseConfiguration; // Importar se for usar @InheritInverseConfiguration
import org.mapstruct.factory.Mappers;

/**
 * @interface PessoaMapper
 * @brief Mapper MapStruct para conversão entre Pessoa e seus DTOs.
 * Esta é uma interface base para ser estendida por mappers de subclasses de Pessoa.
 */
@Mapper(componentModel = "spring", uses = {UserMapper.class, EnderecoMapper.class})
public interface PessoaMapper {

    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * @brief Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta da pessoa.
     */
    @Mapping(source = "usuario", target = "usuario")
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    PessoaResponseDTO toResponseDTO(Pessoa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano; // Importar Plano da entidade
import br.com.legalconnect.dto.EmpresaResponseDTO; // Importar EmpresaResponseDTO
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa; // Importar Empresa da entidade
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.Profissional.StatusProfissional; // Importar o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ProfissionalMapper
 * @brief Mapper MapStruct para conversão entre Profissional e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class, EmpresaMapper.class})
public interface ProfissionalMapper extends PessoaMapper {

    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * @brief Mapeia um ProfissionalRequestDTO para uma entidade Profissional.
     * @param dto O DTO de requisição do profissional.
     * @return A entidade Profissional.
     */
    @Mapping(target = "empresa", ignore = true) // Empresa será setada no serviço
    @Mapping(target = "plano", ignore = true)   // Plano será setado no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Não presente no DTO
    Profissional toEntity(ProfissionalRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * @param entity A entidade Profissional.
     * @return O DTO de resposta do profissional.
     */
    @Mapping(source = "empresa", target = "empresa")
    @Mapping(source = "plano", target = "plano")
    ProfissionalResponseDTO toResponseDTO(Profissional entity);

    /**
     * @brief Mapeia uma entidade Plano para um PlanoResponseDTO.
     * @param plano A entidade Plano.
     * @return O DTO de resposta do Plano.
     */
    PlanoResponseDTO toPlanoResponseDTO(Plano plano);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper MapStruct para conversão entre User e seus DTOs.
 */
@Mapper(componentModel = "spring") // Integração com Spring para injeção de dependência
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * @brief Converte um UserRequestDTO para uma entidade User.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserRequestDTO.
     * @param dto O DTO de requisição do usuário.
     * @return A entidade User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "nomeCompleto", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "cpf", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "telefone", ignore = true) // Não presente no DTO de requisição
    // @Mapping(target = "senhaHash", source = "password") // Mapeia password do DTO
    // para senhaHash da entidade
    @Mapping(target = "fotoUrl", ignore = true) // Não presente no DTO de requisição
    User toEntity(UserRequestDTO dto);

    /**
     * @brief Converte uma entidade User para um UserResponseDTO.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserResponseDTO.
     * @param entity A entidade User.
     * @return O DTO de resposta do usuário.
     */
    @Mapping(target = "email", source = "email")
    UserResponseDTO toResponseDTO(User entity);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Administrador;

/**
 * @interface RepositorioAdministrador
 * @brief Repositório Spring Data JPA para a entidade Administrador.
 *        Fornece métodos CRUD e de busca personalizados para Administrador.
 */
@Repository
public interface RepositorioAdministrador extends JpaRepository<Administrador, UUID> {

    /**
     * @brief Busca um Administrador pelo CPF.
     * @param cpf O CPF do administrador.
     * @return Um Optional contendo o Administrador, se encontrado.
     */
    Optional<Administrador> findByCpf(String cpf);

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Administradores.
     */
    Page<Administrador> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Cliente;

/**
 * @interface RepositorioCliente
 * @brief Repositório Spring Data JPA para a entidade Cliente.
 *        Fornece métodos CRUD e de busca personalizados para Cliente.
 */
@Repository
public interface RepositorioCliente extends JpaRepository<Cliente, UUID> {

    /**
     * @brief Busca um Cliente pelo CPF.
     * @param cpf O CPF do cliente.
     * @return Um Optional contendo o Cliente, se encontrado.
     */
    Optional<Cliente> findByCpf(String cpf);

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Clientes.
     */
    Page<Cliente> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Empresa;

/**
 * @interface RepositorioEmpresa
 * @brief Repositório Spring Data JPA para a entidade Empresa.
 *        Fornece métodos CRUD e de busca personalizados para Empresa.
 */
@Repository
public interface RepositorioEmpresa extends JpaRepository<Empresa, UUID> {

    /**
     * @brief Busca uma Empresa pelo CNPJ.
     * @param cnpj O CNPJ da empresa.
     * @return Um Optional contendo a Empresa, se encontrada.
     */
    Optional<Empresa> findByCnpj(String cnpj);

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Empresas.
     */
    Page<Empresa> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Endereco;

/**
 * @interface RepositorioEndereco
 * @brief Repositório Spring Data JPA para a entidade Endereco.
 *        Fornece métodos CRUD básicos para Endereco.
 */
@Repository
public interface RepositorioEndereco extends JpaRepository<Endereco, UUID> {
    // Métodos de busca adicionais podem ser definidos aqui se necessário,
    // como findByPessoaId(UUID pessoaId) ou findByEmpresaId(UUID empresaId)
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Pessoa;

/**
 * @interface RepositorioPessoa
 * @brief Repositório Spring Data JPA para a entidade Pessoa (base).
 *        Fornece métodos CRUD básicos para Pessoa e busca por CPF.
 *        Como Pessoa é uma entidade base abstrata com estratégia JOINED, este
 *        repositório
 *        pode ser usado para operações polimórficas se necessário, mas
 *        geralmente
 *        repositórios específicos para subclasses (Profissional, Cliente,
 *        Administrador)
 *        são mais comuns para operações de negócio.
 */
@Repository
public interface RepositorioPessoa extends JpaRepository<Pessoa, UUID> {

    /**
     * @brief Busca uma Pessoa pelo CPF.
     * @param cpf O CPF da pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Plano;

/**
 * @interface RepositorioPlano
 * @brief Repositório Spring Data JPA para a entidade Plano.
 *        Fornece métodos CRUD e de busca personalizados para Plano.
 *        **Nota:** Em uma arquitetura de microsserviços ideal, esta entidade e
 *        seu
 *        repositório poderiam residir em um serviço de 'marketplace' ou
 *        'assinatura'.
 *        Aqui, é mantido para fins de completude do modelo de dados do
 *        user-service,
 *        mas a gestão real dos planos pode ser externa.
 */
@Repository
public interface RepositorioPlano extends JpaRepository<Plano, UUID> {

    /**
     * @brief Busca um Plano pelo nome.
     * @param nome O nome do plano.
     * @return Um Optional contendo o Plano, se encontrado.
     */
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Profissional;

/**
 * @interface RepositorioProfissional
 * @brief Repositório Spring Data JPA para a entidade Profissional.
 *        Fornece métodos CRUD e de busca personalizados para Profissional.
 */
@Repository
public interface RepositorioProfissional extends JpaRepository<Profissional, UUID> {

    /**
     * @brief Busca um Profissional pelo CPF.
     * @param cpf O CPF do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByCpf(String cpf);

    /**
     * @brief Busca um Profissional pelo número da OAB.
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Profissionais.
     */
    Page<Profissional> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.RoleProfissional;

/**
 * @interface RepositorioRoleProfissional
 * @brief Repositório Spring Data JPA para a entidade RoleProfissional.
 *        Fornece métodos CRUD e de busca personalizados para RoleProfissional.
 *        **Nota:** Em um ambiente multi-tenant, os papéis podem ser globais ou
 *        por tenant.
 *        Este repositório assume que a entidade RoleProfissional está no schema
 *        do tenant.
 */
@Repository
public interface RepositorioRoleProfissional extends JpaRepository<RoleProfissional, UUID> {

    /**
     * @brief Busca um RoleProfissional pelo nome.
     * @param nome O nome do papel.
     * @return Um Optional contendo o RoleProfissional, se encontrado.
     */
    Optional<RoleProfissional> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.User;

/**
 * @interface RepositorioUser
 * @brief Repositório Spring Data JPA para a entidade User.
 *        Fornece métodos CRUD e de busca personalizados para User.
 *        **Nota:** Este repositório é crucial para o pré-requisito de
 *        associação de Pessoa a um User existente.
 *        As operações de criação/atualização de User em si são de
 *        responsabilidade de outro microsserviço (ex: auth-service).
 */
@Repository
public interface RepositorioUser extends JpaRepository<User, UUID> {

    /**
     * @brief Busca um User pelo email.
     * @param email O email do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.AdministradorMapper;
import br.com.legalconnect.repository.RepositorioAdministrador;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoAdministrador
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Administradores.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Administradores.
 */
@Service
public class ServicoAdministrador {

    private final RepositorioAdministrador repositorioAdministrador;
    private final RepositorioUser repositorioUser;
    private final AdministradorMapper administradorMapper;

    @Autowired
    public ServicoAdministrador(RepositorioAdministrador repositorioAdministrador, RepositorioUser repositorioUser,
            AdministradorMapper administradorMapper) {
        this.repositorioAdministrador = repositorioAdministrador;
        this.repositorioUser = repositorioUser;
        this.administradorMapper = administradorMapper;
    }

    /**
     * @brief Cadastra um novo Administrador no sistema.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return DTO com os dados do Administrador cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public AdministradorResponseDTO cadastrarAdministrador(AdministradorRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro administrador.");
        }

        // 3. Mapear DTO para entidade
        Administrador administrador = administradorMapper.toEntity(requestDTO);
        administrador.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Administrador)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = administradorMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(administrador); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        administrador.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Administrador savedAdministrador = repositorioAdministrador.save(administrador);

        // 6. Mapear entidade salva para DTO de resposta
        return administradorMapper.toResponseDTO(savedAdministrador);
    }

    /**
     * @brief Busca um Administrador pelo ID.
     * @param id ID do Administrador a ser buscado.
     * @return DTO com os dados do Administrador encontrado.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional(readOnly = true)
    public AdministradorResponseDTO buscarAdministradorPorId(UUID id) {
        Administrador administrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado."));
        return administradorMapper.toResponseDTO(administrador);
    }

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Administradores.
     */
    @Transactional(readOnly = true)
    public Page<AdministradorResponseDTO> listarAdministradores(Pageable pageable) {
        return repositorioAdministrador.findAll(pageable)
                .map(administradorMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Administrador existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return DTO com os dados do Administrador atualizado.
     * @throws BusinessException Se o Administrador não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public AdministradorResponseDTO atualizarAdministrador(UUID id, AdministradorRequestDTO requestDTO) {
        Administrador existingAdministrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingAdministrador.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro administrador.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Administrador
        // O mapper precisa de um método de atualização, ou fazer manualmente
        existingAdministrador.setNomeCompleto(requestDTO.getNomeCompleto());
        existingAdministrador.setCpf(requestDTO.getCpf());
        existingAdministrador.setDataNascimento(requestDTO.getDataNascimento());
        existingAdministrador.setStatus(requestDTO.getStatus()); // Campo específico de Administrador

        // 3. Atualizar endereços (lógica de sincronização)
        existingAdministrador.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            // Reutiliza o mapper para converter DTO para Endereco
            Endereco newEndereco = administradorMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingAdministrador); // Garante a associação bidirecional
            existingAdministrador.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingAdministrador.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingAdministrador.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Administrador updatedAdministrador = repositorioAdministrador.save(existingAdministrador);

        return administradorMapper.toResponseDTO(updatedAdministrador);
    }

    /**
     * @brief Exclui um Administrador pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional
    public void excluirAdministrador(UUID id) {
        if (!repositorioAdministrador.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Administrador com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioAdministrador.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ClienteMapper;
import br.com.legalconnect.repository.RepositorioCliente;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoCliente
 * @brief Serviço de domínio para gerenciar operações relacionadas a Clientes.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Clientes.
 */
@Service
public class ServicoCliente {

    private final RepositorioCliente repositorioCliente;
    private final RepositorioUser repositorioUser;
    private final ClienteMapper clienteMapper;

    @Autowired
    public ServicoCliente(RepositorioCliente repositorioCliente, RepositorioUser repositorioUser,
            ClienteMapper clienteMapper) {
        this.repositorioCliente = repositorioCliente;
        this.repositorioUser = repositorioUser;
        this.clienteMapper = clienteMapper;
    }

    /**
     * @brief Cadastra um novo Cliente no sistema.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return DTO com os dados do Cliente cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public ClienteResponseDTO cadastrarCliente(ClienteRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro cliente.");
        }

        // 3. Mapear DTO para entidade
        Cliente cliente = clienteMapper.toEntity(requestDTO);
        cliente.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Cliente)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = clienteMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(cliente); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        cliente.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Cliente savedCliente = repositorioCliente.save(cliente);

        // 6. Mapear entidade salva para DTO de resposta
        return clienteMapper.toResponseDTO(savedCliente);
    }

    /**
     * @brief Busca um Cliente pelo ID.
     * @param id ID do Cliente a ser buscado.
     * @return DTO com os dados do Cliente encontrado.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional(readOnly = true)
    public ClienteResponseDTO buscarClientePorId(UUID id) {
        Cliente cliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado."));
        return clienteMapper.toResponseDTO(cliente);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Clientes.
     */
    @Transactional(readOnly = true)
    public Page<ClienteResponseDTO> listarClientes(Pageable pageable) {
        return repositorioCliente.findAll(pageable)
                .map(clienteMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return DTO com os dados do Cliente atualizado.
     * @throws BusinessException Se o Cliente não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public ClienteResponseDTO atualizarCliente(UUID id, ClienteRequestDTO requestDTO) {
        Cliente existingCliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingCliente.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro cliente.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Cliente
        existingCliente.setNomeCompleto(requestDTO.getNomeCompleto());
        existingCliente.setCpf(requestDTO.getCpf());
        existingCliente.setDataNascimento(requestDTO.getDataNascimento());
        existingCliente.setStatus(requestDTO.getStatus()); // Campo específico de Cliente
        existingCliente.setTipo(requestDTO.getTipo()); // Campo específico de Cliente

        // 3. Atualizar endereços (lógica de sincronização)
        existingCliente.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = clienteMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingCliente);
            existingCliente.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingCliente.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingCliente.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Cliente updatedCliente = repositorioCliente.save(existingCliente);

        return clienteMapper.toResponseDTO(updatedCliente);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional
    public void excluirCliente(UUID id) {
        if (!repositorioCliente.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Cliente com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioCliente.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.EmpresaRequestDTO;
import dto.EmpresaResponseDTO;
import entity.Empresa;
import entity.Endereco;
import common.exception.BusinessException; // Importa da common-lib
import mapper.EmpresaMapper;
import repository.RepositorioEmpresa;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoEmpresa
 * @brief Serviço de domínio para gerenciar operações relacionadas a Empresas.
 * Contém a lógica de negócio para criação, busca, atualização e exclusão de Empresas.
 */
@Service
public class ServicoEmpresa {

    private final RepositorioEmpresa repositorioEmpresa;
    private final EmpresaMapper empresaMapper;

    @Autowired
    public ServicoEmpresa(RepositorioEmpresa repositorioEmpresa, EmpresaMapper empresaMapper) {
        this.repositorioEmpresa = repositorioEmpresa;
        this.empresaMapper = empresaMapper;
    }

    /**
     * @brief Cadastra uma nova Empresa no sistema.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return DTO com os dados da Empresa cadastrada.
     * @throws BusinessException Se o CNPJ já estiver cadastrado.
     */
    @Transactional
    public EmpresaResponseDTO cadastrarEmpresa(EmpresaRequestDTO requestDTO) {
        // 1. Validação de duplicidade de CNPJ
        if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CNPJ, "CNPJ já cadastrado para outra empresa.");
        }

        // 2. Mapear DTO para entidade
        Empresa empresa = empresaMapper.toEntity(requestDTO);

        // 3. Associar endereços à empresa
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = empresaMapper.toEntity(enderecoDTO);
                    endereco.setEmpresa(empresa); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        empresa.setEnderecos(enderecos);

        // 4. Salvar a entidade
        Empresa savedEmpresa = repositorioEmpresa.save(empresa);

        // 5. Mapear entidade salva para DTO de resposta
        return empresaMapper.toResponseDTO(savedEmpresa);
    }

    /**
     * @brief Busca uma Empresa pelo ID.
     * @param id ID da Empresa a ser buscada.
     * @return DTO com os dados da Empresa encontrada.
     * @throws BusinessException Se a Empresa não for encontrada.
     */
    @Transactional(readOnly = true)
    public EmpresaResponseDTO buscarEmpresaPorId(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada."));
        return empresaMapper.toResponseDTO(empresa);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Empresas.
     */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDTO> listarEmpresas(Pageable pageable) {
        return repositorioEmpresa.findAll(pageable)
                .map(empresaMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return DTO com os dados da Empresa atualizada.
     * @throws BusinessException Se a Empresa não for encontrada ou se houver duplicidade de CNPJ.
     */
    @Transactional
    public EmpresaResponseDTO atualizarEmpresa(UUID id, EmpresaRequestDTO requestDTO) {
        Empresa existingEmpresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada para atualização."));

        // 1. Validação de duplicidade de CNPJ (se o CNPJ foi alterado)
        if (!existingEmpresa.getCnpj().equals(requestDTO.getCnpj())) {
            if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CNPJ, "Novo CNPJ já cadastrado para outra empresa.");
            }
        }

        // 2. Atualizar campos básicos da Empresa
        existingEmpresa.setNomeFantasia(requestDTO.getNomeFantasia());
        existingEmpresa.setRazaoSocial(requestDTO.getRazaoSocial());
        existingEmpresa.setCnpj(requestDTO.getCnpj());
        existingEmpresa.setEmailContato(requestDTO.getEmailContato());

        // 3. Atualizar endereços (lógica de sincronização)
        existingEmpresa.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = empresaMapper.toEntity(enderecoDTO);
            newEndereco.setEmpresa(existingEmpresa);
            existingEmpresa.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingEmpresa.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingEmpresa.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Empresa updatedEmpresa = repositorioEmpresa.save(existingEmpresa);

        return empresaMapper.toResponseDTO(updatedEmpresa);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @throws BusinessException Se a Empresa não for encontrada ou se possuir profissionais associados.
     */
    @Transactional
    public void excluirEmpresa(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada para exclusão."));

        // Verificar se existem profissionais associados antes de excluir
        if (!empresa.getProfissionais().isEmpty()) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa não pode ser excluída pois possui profissionais associados.");
        }

        // A exclusão em cascata do Endereco será tratada pelo JPA
        repositorioEmpresa.delete(empresa);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.EnderecoRequestDTO;
import dto.EnderecoResponseDTO;
import entity.Endereco;
import common.exception.BusinessException; // Importa da common-lib
import mapper.EnderecoMapper;
import repository.RepositorioEndereco;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoEndereco
 * @brief Serviço de domínio para gerenciar operações relacionadas a Endereços.
 * Este serviço pode ser usado para operações diretas em Endereços,
 * embora na maioria dos casos eles sejam gerenciados em cascata por Pessoa ou Empresa.
 */
@Service
public class ServicoEndereco {

    private final RepositorioEndereco repositorioEndereco;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public ServicoEndereco(RepositorioEndereco repositorioEndereco, EnderecoMapper enderecoMapper) {
        this.repositorioEndereco = repositorioEndereco;
        this.enderecoMapper = enderecoMapper;
    }

    /**
     * @brief Cadastra um novo Endereco.
     * @param requestDTO DTO com os dados do Endereco a ser cadastrado.
     * @return DTO com os dados do Endereco cadastrado.
     */
    @Transactional
    public EnderecoResponseDTO cadastrarEndereco(EnderecoRequestDTO requestDTO) {
        Endereco endereco = enderecoMapper.toEntity(requestDTO);
        Endereco savedEndereco = repositorioEndereco.save(endereco);
        return enderecoMapper.toResponseDTO(savedEndereco);
    }

    /**
     * @brief Busca um Endereco pelo ID.
     * @param id ID do Endereco a ser buscado.
     * @return DTO com os dados do Endereco encontrado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional(readOnly = true)
    public EnderecoResponseDTO buscarEnderecoPorId(UUID id) {
        Endereco endereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado."));
        return enderecoMapper.toResponseDTO(endereco);
    }

    /**
     * @brief Lista todos os Enderecos.
     * @return Lista de DTOs de Enderecos.
     */
    @Transactional(readOnly = true)
    public List<EnderecoResponseDTO> listarEnderecos() {
        return repositorioEndereco.findAll().stream()
                .map(enderecoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Atualiza os dados de um Endereco existente.
     * @param id ID do Endereco a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Endereco.
     * @return DTO com os dados do Endereco atualizado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public EnderecoResponseDTO atualizarEndereco(UUID id, EnderecoRequestDTO requestDTO) {
        Endereco existingEndereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado para atualização."));

        // Atualizar campos básicos do Endereco
        existingEndereco.setLogradouro(requestDTO.getLogradouro());
        existingEndereco.setNumero(requestDTO.getNumero());
        existingEndereco.setComplemento(requestDTO.getComplemento());
        existingEndereco.setBairro(requestDTO.getBairro());
        existingEndereco.setCidade(requestDTO.getCidade());
        existingEndereco.setEstado(requestDTO.getEstado());
        existingEndereco.setCep(requestDTO.getCep());
        existingEndereco.setPais(requestDTO.getPais());
        existingEndereco.setTipoEndereco(requestDTO.getTipoEndereco());

        Endereco updatedEndereco = repositorioEndereco.save(existingEndereco);
        return enderecoMapper.toResponseDTO(updatedEndereco);
    }

    /**
     * @brief Exclui um Endereco pelo ID.
     * @param id ID do Endereco a ser excluído.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public void excluirEndereco(UUID id) {
        if (!repositorioEndereco.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado para exclusão.");
        }
        repositorioEndereco.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.PessoaResponseDTO;
import entity.Pessoa;
import common.exception.BusinessException; // Importa da common-lib
import mapper.PessoaMapper;
import repository.RepositorioPessoa;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoPessoa
 * @brief Serviço de domínio para operações genéricas relacionadas a Pessoas.
 * Como Pessoa é uma entidade base abstrata, este serviço lida com operações
 * que podem ser comuns a todas as subclasses (Profissional, Cliente, Administrador).
 * Operações de criação/atualização específicas devem ser tratadas nos serviços das subclasses.
 */
@Service
public class ServicoPessoa {

    private final RepositorioPessoa repositorioPessoa;
    private final PessoaMapper pessoaMapper;

    @Autowired
    public ServicoPessoa(RepositorioPessoa repositorioPessoa, PessoaMapper pessoaMapper) {
        this.repositorioPessoa = repositorioPessoa;
        this.pessoaMapper = pessoaMapper;
    }

    /**
     * @brief Busca uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser buscada.
     * @return DTO com os dados da Pessoa encontrada.
     * @throws BusinessException Se a Pessoa não for encontrada.
     */
    @Transactional(readOnly = true)
    public PessoaResponseDTO buscarPessoaPorId(UUID id) {
        Pessoa pessoa = repositorioPessoa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Pessoa com ID " + id + " não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * @brief Lista todas as Pessoas.
     * @return Lista de DTOs de Pessoas.
     */
    @Transactional(readOnly = true)
    public List<PessoaResponseDTO> listarTodasPessoas() {
        return repositorioPessoa.findAll().stream()
                .map(pessoaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Exclui uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser excluída.
     * @throws BusinessException Se a Pessoa não for encontrada.
     * **Nota:** A exclusão de Pessoa deve ser feita com cautela, pois pode
     * impactar subclasses (Profissional, Cliente, Administrador) e o User associado.
     * Idealmente, a exclusão de subclasses deveria ser o ponto de entrada.
     */
    @Transactional
    public void excluirPessoa(UUID id) {
        if (!repositorioPessoa.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Pessoa com ID " + id + " não encontrada para exclusão.");
        }
        repositorioPessoa.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.PlanoResponseDTO;
import entity.Plano;
import common.exception.BusinessException; // Importa da common-lib
import mapper.ProfissionalMapper; // Reutilizando mapper de profissional para plano
import repository.RepositorioPlano;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoPlano
 * @brief Serviço de domínio para gerenciar operações relacionadas a Planos.
 * **Nota:** Este serviço é um placeholder. Em uma arquitetura de microsserviços real,
 * a gestão de planos seria feita em um microsserviço dedicado (ex: marketplace ou assinatura).
 * Aqui, ele apenas fornece métodos de busca para que outros serviços possam referenciar planos.
 */
@Service
public class ServicoPlano {

    private final RepositorioPlano repositorioPlano;
    private final ProfissionalMapper profissionalMapper; // Usando o mapper de Profissional que já tem o toPlanoResponseDTO

    @Autowired
    public ServicoPlano(RepositorioPlano repositorioPlano, ProfissionalMapper profissionalMapper) {
        this.repositorioPlano = repositorioPlano;
        this.profissionalMapper = profissionalMapper;
    }

    /**
     * @brief Busca um Plano pelo ID.
     * @param id ID do Plano a ser buscado.
     * @return DTO com os dados do Plano encontrado.
     * @throws BusinessException Se o Plano não for encontrado.
     */
    @Transactional(readOnly = true)
    public PlanoResponseDTO buscarPlanoPorId(UUID id) {
        Plano plano = repositorioPlano.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Plano com ID " + id + " não encontrado."));
        return profissionalMapper.toPlanoResponseDTO(plano);
    }

    /**
     * @brief Lista todos os Planos disponíveis.
     * @return Lista de DTOs de Planos.
     */
    @Transactional(readOnly = true)
    public List<PlanoResponseDTO> listarTodosPlanos() {
        return repositorioPlano.findAll().stream()
                .map(profissionalMapper::toPlanoResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para cadastrar, atualizar e excluir planos não são implementados aqui,
    // pois seriam responsabilidade do microsserviço de marketplace/assinatura.
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ProfissionalMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import br.com.legalconnect.repository.RepositorioPlano;
import br.com.legalconnect.repository.RepositorioProfissional;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoProfissional
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Profissionais.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Profissionais.
 */
@Service
public class ServicoProfissional {

    private final RepositorioProfissional repositorioProfissional;
    private final RepositorioUser repositorioUser;
    private final RepositorioPlano repositorioPlano;
    private final RepositorioEmpresa repositorioEmpresa;
    private final ProfissionalMapper profissionalMapper;

    @Autowired
    public ServicoProfissional(RepositorioProfissional repositorioProfissional,
            RepositorioUser repositorioUser,
            RepositorioPlano repositorioPlano,
            RepositorioEmpresa repositorioEmpresa,
            ProfissionalMapper profissionalMapper) {
        this.repositorioProfissional = repositorioProfissional;
        this.repositorioUser = repositorioUser;
        this.repositorioPlano = repositorioPlano;
        this.repositorioEmpresa = repositorioEmpresa;
        this.profissionalMapper = profissionalMapper;
    }

    /**
     * @brief Cadastra um novo Profissional no sistema.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return DTO com os dados do Profissional cadastrado.
     * @throws BusinessException Se o CPF ou OAB já estiverem cadastrados, ou se o
     *                           User/Plano/Empresa associado não for encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO cadastrarProfissional(ProfissionalRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF e OAB
        if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro profissional.");
        }
        if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_INPUT,
                    "Número da OAB já cadastrado para outro profissional.");
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Mapear DTO para entidade
        Profissional profissional = profissionalMapper.toEntity(requestDTO);
        profissional.setUsuario(user); // Associar o User encontrado
        profissional.setPlano(plano); // Associar o Plano encontrado
        profissional.setEmpresa(empresa); // Associar a Empresa (pode ser null)

        // 5. Associar endereços à pessoa (Profissional)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = profissionalMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(profissional); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        profissional.setEnderecos(enderecos);

        // 6. Salvar a entidade
        Profissional savedProfissional = repositorioProfissional.save(profissional);

        // 7. Mapear entidade salva para DTO de resposta
        return profissionalMapper.toResponseDTO(savedProfissional);
    }

    /**
     * @brief Busca um Profissional pelo ID.
     * @param id ID do Profissional a ser buscado.
     * @return DTO com os dados do Profissional encontrado.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional(readOnly = true)
    public ProfissionalResponseDTO buscarProfissionalPorId(UUID id) {
        Profissional profissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado."));
        return profissionalMapper.toResponseDTO(profissional);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Profissionais.
     */
    @Transactional(readOnly = true)
    public Page<ProfissionalResponseDTO> listarProfissionais(Pageable pageable) {
        return repositorioProfissional.findAll(pageable)
                .map(profissionalMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return DTO com os dados do Profissional atualizado.
     * @throws BusinessException Se o Profissional não for encontrado, ou se houver
     *                           duplicidade de CPF/OAB, ou se Plano/Empresa não for
     *                           encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO atualizarProfissional(UUID id, ProfissionalRequestDTO requestDTO) {
        Profissional existingProfissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingProfissional.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro profissional.");
            }
        }
        // 2. Validação de duplicidade de OAB (se a OAB foi alterada)
        if (!existingProfissional.getNumeroOab().equals(requestDTO.getNumeroOab())) {
            if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_INPUT,
                        "Novo número da OAB já cadastrado para outro profissional.");
            }
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Atualizar campos básicos da Pessoa e Profissional
        existingProfissional.setNomeCompleto(requestDTO.getNomeCompleto());
        existingProfissional.setCpf(requestDTO.getCpf());
        existingProfissional.setDataNascimento(requestDTO.getDataNascimento());
        existingProfissional.setNumeroOab(requestDTO.getNumeroOab());
        existingProfissional.setStatusProfissional(requestDTO.getStatusProfissional());
        existingProfissional.setUsaMarketplace(requestDTO.getUsaMarketplace());
        existingProfissional.setFazParteDePlano(requestDTO.getFazParteDePlano());
        existingProfissional.setPlano(plano);
        existingProfissional.setEmpresa(empresa);

        // 5. Atualizar endereços (lógica de sincronização)
        existingProfissional.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = profissionalMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingProfissional);
            existingProfissional.getEnderecos().add(newEndereco);
        });

        // 6. Atualizar telefones
        existingProfissional.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingProfissional.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 7. Salvar a entidade atualizada
        Profissional updatedProfissional = repositorioProfissional.save(existingProfissional);

        return profissionalMapper.toResponseDTO(updatedProfissional);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional
    public void excluirProfissional(UUID id) {
        if (!repositorioProfissional.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Profissional com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioProfissional.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.UserResponseDTO;
import entity.User;
import common.exception.BusinessException; // Importa da common-lib
import mapper.UserMapper;
import repository.RepositorioUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoUser
 * @brief Serviço de domínio para gerenciar operações relacionadas a Users.
 * **Nota:** Este serviço é primariamente para busca e validação de Users existentes
 * para associação com entidades Pessoa (Profissional, Cliente, Administrador).
 * A criação e gestão principal de Users é responsabilidade de outro microsserviço (ex: auth-service).
 */
@Service
public class ServicoUser {

    private final RepositorioUser repositorioUser;
    private final UserMapper userMapper;

    @Autowired
    public ServicoUser(RepositorioUser repositorioUser, UserMapper userMapper) {
        this.repositorioUser = repositorioUser;
        this.userMapper = userMapper;
    }

    /**
     * @brief Busca um User pelo ID.
     * @param id ID do User a ser buscado.
     * @return DTO com os dados do User encontrado.
     * @throws BusinessException Se o User não for encontrado.
     */
    @Transactional(readOnly = true)
    public UserResponseDTO buscarUserPorId(UUID id) {
        User user = repositorioUser.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND, "Usuário com ID " + id + " não encontrado."));
        return userMapper.toResponseDTO(user);
    }

    /**
     * @brief Lista todos os Users.
     * @return Lista de DTOs de Users.
     */
    @Transactional(readOnly = true)
    public List<UserResponseDTO> listarTodosUsers() {
        return repositorioUser.findAll().stream()
                .map(userMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Verifica se um User existe pelo ID.
     * @param id ID do User a ser verificado.
     * @return true se o User existe, false caso contrário.
     */
    @Transactional(readOnly = true)
    public boolean userExiste(UUID id) {
        return repositorioUser.existsById(id);
    }

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o DTO do User, se encontrado.
     */
    @Transactional(readOnly = true)
    public Optional<UserResponseDTO> buscarUserPorCpf(String cpf) {
        return repositorioUser.findByCpf(cpf)
                .map(userMapper::toResponseDTO);
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada
server.port=8084
# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

# Habilita o Eureka Client
eureka.client.enabled=true
# URL do servidor Eureka onde o auth-service irá se registrar
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância para garantir identificação única no Eureka
eureka.instance.hostname=localhost
eureka.instance.instance-id=${spring.application.name}:${instanceId:${random.value}}
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=00000000-0000-0000-0000-000000000001

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication(exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui também, se já está no
                                                                // pacote raiz
@EntityScan(basePackages = {
        // "br.com.legalconnect.entity",
        "br.com.legalconnect.entity"
})
// @EnableJpaRepositories(basePackages = {
// "br.com.legalconnect.user.repository",
// "br.com.legalconnect.auth.repository"
// })
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class LegalUsuarioApplication {

    private static final Logger log = LoggerFactory.getLogger(LegalUsuarioApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(LegalUsuarioApplication.class, args);
        log.info("LegalUsuarioApplication iniciada com sucesso!");
    }
}
```
```java
package br.com.legalconnect.config; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.multitenancy.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String tenantIdHeader = request.getHeader(TENANT_HEADER);
            String tenantId = "public";

            if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
                try {
                    tenantId = (tenantIdHeader);
                } catch (IllegalArgumentException e) {
                    // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                    System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                    return;
                }
            } else {
                // Usar o tenant padrão se o cabeçalho não for fornecido
                try {
                    tenantId = (defaultTenantId);
                } catch (IllegalArgumentException e) {
                    System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                            "Configuração de Tenant padrão inválida.");
                    return;
                }
            }

            TenantContext.setCurrentTenant(tenantId);
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear(); // Limpar o TenantContext após a requisição
        }
    }
}
```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoAdministrador;
import jakarta.validation.Valid;

/**
 * @class ControladorAdministradorPlataforma
 * @brief Controlador REST para gerenciar operações relacionadas a
 *        Administradores da Plataforma.
 *        Expõe endpoints para CRUD de Administradores.
 */
@RestController
@RequestMapping("/api/v1/administradores-plataforma")
public class ControladorAdministradorPlataforma {

    private final ServicoAdministrador servicoAdministrador;

    @Autowired
    public ControladorAdministradorPlataforma(ServicoAdministrador servicoAdministrador) {
        this.servicoAdministrador = servicoAdministrador;
    }

    /**
     * @brief Cadastra um novo Administrador da Plataforma.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return ResponseEntity com o DTO do Administrador cadastrado e status 201
     *         Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> cadastrarAdministrador(
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.cadastrarAdministrador(requestDTO); // Usar o método
                                                                                                        // 'cadastrar'
        // da classe base
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Administrador da Plataforma por ID.
     * @param id ID do Administrador a ser buscado.
     * @return ResponseEntity com o DTO do Administrador encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> buscarAdministradorPorId(@PathVariable UUID id) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.buscarAdministradorPorId(id); // Usar o método
                                                                                                  // 'buscarPorId' da
        // classe base
        return ResponseEntity.ok(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Administradores da Plataforma com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Administradores e status 200
     *         OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<AdministradorResponseDTO>>> listarAdministradores(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<AdministradorResponseDTO> responsePage = servicoAdministrador.listarAdministradores(pageable); // Usar o
                                                                                                            // método
                                                                                                            // 'listar'
        // da classe base
        return ResponseEntity.ok(
                BaseResponse.<Page<AdministradorResponseDTO>>builder()
                        .message("Lista de administradores recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Administrador da Plataforma existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return ResponseEntity com o DTO do Administrador atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> atualizarAdministrador(
            @PathVariable UUID id,
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.atualizarAdministrador(id, requestDTO); // Usar o
                                                                                                            // método
        // 'atualizar' da classe
        // base
        return ResponseEntity.ok(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Administrador da Plataforma pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirAdministrador(@PathVariable UUID id) {
        servicoAdministrador.excluirAdministrador(id); // Usar o método 'excluir' da classe base
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body( // Retorna 204 No Content com um corpo de sucesso
                BaseResponse.<Void>builder()
                        .message("Administrador excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoCliente;
import jakarta.validation.Valid;

/**
 * @class ControladorCliente
 * @brief Controlador REST para gerenciar operações relacionadas a Clientes.
 *        Expõe endpoints para CRUD de Clientes.
 */
@RestController
@RequestMapping("/api/v1/clientes")
public class ControladorCliente {

    private final ServicoCliente servicoCliente;

    @Autowired
    public ControladorCliente(ServicoCliente servicoCliente) {
        this.servicoCliente = servicoCliente;
    }

    /**
     * @brief Cadastra um novo Cliente.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return ResponseEntity com o DTO do Cliente cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> cadastrarCliente(
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.cadastrarCliente(requestDTO); // Chamando o método original do
                                                                                      // serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Cliente por ID.
     * @param id ID do Cliente a ser buscado.
     * @return ResponseEntity com o DTO do Cliente encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> buscarClientePorId(@PathVariable UUID id) {
        ClienteResponseDTO responseDTO = servicoCliente.buscarClientePorId(id); // Chamando o método original do serviço
        return ResponseEntity.ok(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Clientes e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ClienteResponseDTO>>> listarClientes(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ClienteResponseDTO> responsePage = servicoCliente.listarClientes(pageable); // Chamando o método original
                                                                                         // do serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<ClienteResponseDTO>>builder()
                        .message("Lista de clientes recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return ResponseEntity com o DTO do Cliente atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> atualizarCliente(
            @PathVariable UUID id,
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.atualizarCliente(id, requestDTO); // Chamando o método original
                                                                                          // do serviço
        return ResponseEntity.ok(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirCliente(@PathVariable UUID id) {
        servicoCliente.excluirCliente(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Cliente excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoEmpresa;
import jakarta.validation.Valid;

/**
 * @class ControladorEmpresa
 * @brief Controlador REST para gerenciar operações relacionadas a Empresas.
 *        Expõe endpoints para CRUD de Empresas.
 */
@RestController
@RequestMapping("/api/v1/empresas")
public class ControladorEmpresa {

    private final ServicoEmpresa servicoEmpresa;

    @Autowired
    public ControladorEmpresa(ServicoEmpresa servicoEmpresa) {
        this.servicoEmpresa = servicoEmpresa;
    }

    /**
     * @brief Cadastra uma nova Empresa.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return ResponseEntity com o DTO da Empresa cadastrada e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> cadastrarEmpresa(
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.cadastrarEmpresa(requestDTO); // Chamando o método original do
                                                                                      // serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa cadastrada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca uma Empresa por ID.
     * @param id ID da Empresa a ser buscada.
     * @return ResponseEntity com o DTO da Empresa encontrada e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> buscarEmpresaPorId(@PathVariable UUID id) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.buscarEmpresaPorId(id); // Chamando o método original do serviço
        return ResponseEntity.ok(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa encontrada.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeFantasia,asc).
     * @return ResponseEntity com uma página de DTOs de Empresas e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<EmpresaResponseDTO>>> listarEmpresas(
            @PageableDefault(size = 10, page = 0, sort = "nomeFantasia") Pageable pageable) {
        Page<EmpresaResponseDTO> responsePage = servicoEmpresa.listarEmpresas(pageable); // Chamando o método original
                                                                                         // do serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<EmpresaResponseDTO>>builder()
                        .message("Lista de empresas recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id         ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return ResponseEntity com o DTO da Empresa atualizada e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> atualizarEmpresa(
            @PathVariable UUID id,
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.atualizarEmpresa(id, requestDTO); // Chamando o método original
                                                                                          // do serviço
        return ResponseEntity.ok(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa atualizada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirEmpresa(@PathVariable UUID id) {
        servicoEmpresa.excluirEmpresa(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Empresa excluída com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoProfissional;
import jakarta.validation.Valid;

/**
 * @class ControladorProfissional
 * @brief Controlador REST para gerenciar operações relacionadas a
 *        Profissionais.
 *        Expõe endpoints para CRUD de Profissionais.
 */
@RestController
@RequestMapping("/api/v1/profissionais")
public class ControladorProfissional {

    private final ServicoProfissional servicoProfissional;

    @Autowired
    public ControladorProfissional(ServicoProfissional servicoProfissional) {
        this.servicoProfissional = servicoProfissional;
    }

    /**
     * @brief Cadastra um novo Profissional.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return ResponseEntity com o DTO do Profissional cadastrado e status 201
     *         Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> cadastrarProfissional(
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.cadastrarProfissional(requestDTO); // Chamando o
                                                                                                     // método original
                                                                                                     // do serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Profissional por ID.
     * @param id ID do Profissional a ser buscado.
     * @return ResponseEntity com o DTO do Profissional encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> buscarProfissionalPorId(@PathVariable UUID id) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.buscarProfissionalPorId(id); // Chamando o método
                                                                                               // original do serviço
        return ResponseEntity.ok(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Profissionais e status 200
     *         OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> listarProfissionais(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ProfissionalResponseDTO> responsePage = servicoProfissional.listarProfissionais(pageable); // Chamando o
                                                                                                        // método
                                                                                                        // original do
                                                                                                        // serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                        .message("Lista de profissionais recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return ResponseEntity com o DTO do Profissional atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> atualizarProfissional(
            @PathVariable UUID id,
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.atualizarProfissional(id, requestDTO); // Chamando o
                                                                                                         // método
                                                                                                         // original do
                                                                                                         // serviço
        return ResponseEntity.ok(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirProfissional(@PathVariable UUID id) {
        servicoProfissional.excluirProfissional(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Profissional excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorRequestDTO
 * @brief DTO para requisições de criação ou atualização de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorResponseDTO
 * @brief DTO para respostas de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorResponseDTO extends PessoaResponseDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteRequestDTO
 * @brief DTO para requisições de criação ou atualização de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteResponseDTO
 * @brief DTO para respostas de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteResponseDTO extends PessoaResponseDTO {
    private String status;
    private String tipo;
}
```
```java
package br.com.legalconnect.dto;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaRequestDTO
 * @brief DTO para requisições de criação ou atualização de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O nome fantasia não pode estar em branco.")
    @Size(max = 255, message = "O nome fantasia deve ter no máximo 255 caracteres.")
    private String nomeFantasia;

    @NotBlank(message = "A razão social não pode estar em branco.")
    @Size(max = 255, message = "A razão social deve ter no máximo 255 caracteres.")
    private String razaoSocial;

    @NotBlank(message = "O CNPJ não pode estar em branco.")
    @Pattern(regexp = "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}", message = "Formato de CNPJ inválido. Use XX.XXX.XXX/XXXX-XX.")
    private String cnpj;

    @Email(message = "Formato de email de contato inválido.")
    @Size(max = 255, message = "O email de contato deve ter no máximo 255 caracteres.")
    private String emailContato;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos;

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaResponseDTO
 * @brief DTO para respostas de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaResponseDTO {
    private UUID id;
    private String nomeFantasia;
    private String razaoSocial;
    private String cnpj;
    private String emailContato;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoRequestDTO
 * @brief DTO para requisições de criação ou atualização de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número não pode estar em branco.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade não pode estar em branco.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado não pode estar em branco.")
    @Size(min = 2, max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "\\d{5}-\\d{3}", message = "Formato de CEP inválido. Use XXXXX-XXX.")
    private String cep;

    @NotBlank(message = "O país não pode estar em branco.")
    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais;

    @NotNull(message = "O tipo de endereço não pode ser nulo.")
    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoResponseDTO
 * @brief DTO para respostas de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;
    private String logradouro;
    private String numero;
    private String complemento;
    private String bairro;
    private String cidade;
    private String estado;
    private String cep;
    private String pais;
    private TipoEndereco tipoEndereco;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.util.List; // Usar List para Enderecos para manter a ordem se necessário
import java.util.Set;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaRequestDTO
 * @brief DTO base para requisições de criação ou atualização de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // Não incluir o ID aqui, pois ele será definido pela entidade base (BaseEntity)
    // e retornado no ResponseDTO.

    @NotNull(message = "Os dados do usuário não podem ser nulos.")
    @Valid // Valida o DTO aninhado
    private UserRequestDTO usuario;

    @NotBlank(message = "O nome completo não pode estar em branco.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Pattern(regexp = "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}", message = "Formato de CPF inválido. Use XXX.XXX.XXX-XX.")
    private String cpf;

    @PastOrPresent(message = "A data de nascimento não pode ser futura.")
    private LocalDate dataNascimento;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos; // Usar List para manter a ordem se necessário

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaResponseDTO
 * @brief DTO base para respostas de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaResponseDTO {
    private UUID id;
    private UserResponseDTO usuario;
    private String nomeCompleto;
    private String cpf;
    private LocalDate dataNascimento;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Plano.VisibilidadeDestaque;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class PlanoResponseDTO
 * @brief DTO para respostas de Plano.
 *        Esta classe é um DTO simplificado para ser usado em outros
 *        microsserviços.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PlanoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
    private BigDecimal precoMensal;
    private BigDecimal precoAnual;
    private Integer limiteServicosAgendaveis;
    private VisibilidadeDestaque visibilidadeDestaque;
    private Boolean acessoRelatoriosAvancados;
    private Boolean permitePedidosOrcamento;
    private Integer periodoTesteDias;
    private Boolean isDefault;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalRequestDTO
 * @brief DTO para requisições de criação ou atualização de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalRequestDTO extends PessoaRequestDTO {
    @NotBlank(message = "O número da OAB não pode estar em branco.")
    @Size(max = 50, message = "O número da OAB deve ter no máximo 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "O status profissional não pode ser nulo.")
    private StatusProfissional statusProfissional;

    @NotNull(message = "A indicação de uso do marketplace não pode ser nula.")
    private Boolean usaMarketplace;

    @NotNull(message = "A indicação de participação em plano não pode ser nula.")
    private Boolean fazParteDePlano;

    private UUID empresaId; // ID da empresa associada (opcional)

    @NotNull(message = "O ID do plano não pode ser nulo.")
    private UUID planoId; // ID do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalResponseDTO
 * @brief DTO para respostas de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalResponseDTO extends PessoaResponseDTO {
    private String numeroOab;
    private StatusProfissional statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private EmpresaResponseDTO empresa; // DTO da empresa associada (simplificado)
    private PlanoResponseDTO plano; // DTO do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserRequestDTO
 * @brief DTO para requisições de criação ou atualização de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    private UUID id;
    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    private String email;

    // @NotBlank(message = "A senha não pode estar em branco.")
    // @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // private String password;

    // O papel (Role) pode ser definido aqui ou inferido pelo serviço de
    // autenticação/usuário
    // dependendo da lógica de negócio. Para simplificar, pode ser incluído se for
    // um input direto.
    // private String role;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserResponseDTO
 * @brief DTO para respostas de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // private String role; // Incluir se o papel for relevante na resposta
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Administrador
 * @brief Entidade que representa um administrador da plataforma.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_administrador' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_administrador")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Administrador extends Pessoa {
    private String status;

    // Atualmente, não há campos adicionais específicos para Administrador além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, nível de acesso
    // administrativo, etc.
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Cliente
 * @brief Entidade que representa um cliente.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_cliente' que se junta a 'tb_pessoa' pela
 *        chave primária.
 */
@Entity
@Table(name = "tb_cliente")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Cliente extends Pessoa {
    private String status;
    private String tipo;

    // Atualmente, não há campos adicionais específicos para Cliente além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, histórico de preferências,
    // etc.
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Empresa
 * @brief Entidade que representa uma empresa que pode contratar planos na
 *        plataforma.
 *        Esta entidade não estende Pessoa, pois representa uma pessoa jurídica.
 *        Mapeada para a tabela 'tb_empresa'.
 */
@Entity
@Table(name = "tb_empresa")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Empresa extends BaseEntity {

    @Column(name = "nome_fantasia", nullable = false, length = 255)
    private String nomeFantasia; // Nome fantasia da empresa

    @Column(name = "razao_social", nullable = false, length = 255)
    private String razaoSocial; // Razão social da empresa

    @Column(name = "cnpj", nullable = false, unique = true, length = 18) // CNPJ com máscara
    private String cnpj; // Número do Cadastro Nacional de Pessoas Jurídicas (CNPJ), único por empresa

    @Column(name = "email_contato", length = 255)
    private String emailContato; // E-mail de contato da empresa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma empresa pode ter múltiplos endereços (sede, filiais, etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Empresa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'empresa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da empresa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_empresa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_empresa_telefones", joinColumns = @JoinColumn(name = "empresa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da empresa

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionais = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id")
    private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set; // Usaremos Set para evitar duplicatas e garantir unicidade

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public abstract class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da pessoa
}
```
```java
package br.com.legalconnect.entity;

import java.math.BigDecimal;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 *        plataforma.
 *        Esta classe é um placeholder e deve ser definida em seu próprio
 *        microsserviço (marketplace).
 *        Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault; // Indica se é o plano padrão para novos cadastros

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     *        plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        PREMIUM,
        DESTAQUE_MAXIMO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Profissional
 * @brief Entidade que representa um profissional do direito.
 *        Estende a entidade Pessoa e adiciona campos específicos de um
 *        profissional.
 *        Mapeado para a tabela 'tb_profissional' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_profissional")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab; // Número de registro na OAB, único por profissional

    @Enumerated(EnumType.STRING)
    @Column(name = "status_profissional", nullable = false, length = 50)
    private StatusProfissional statusProfissional; // Status específico do profissional (ex: ATIVO, LICENCIADO)

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false; // Indica se o profissional deseja aparecer no marketplace

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false; // Indica se o profissional está associado a um plano pago

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um profissional pode pertencer a uma empresa.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id") // Coluna de chave estrangeira para a empresa
    private Empresa empresa; // A empresa à qual o profissional está associado (se houver)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Plano.
     *        Um profissional está associado a um plano de assinatura.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira para o plano
    private Plano plano; // O plano de assinatura do advogado
    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_profissionals_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "profissional_profissionals_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<RoleProfissional> roleProfissionals = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum StatusProfissional
     * @brief Enumeração para representar o status específico de um Profissional.
     */
    public enum StatusProfissional {
        ATIVO, // Profissional ativo e em dia
        LICENCIADO, // Profissional com licença temporariamente suspensa
        SUSPENSO, // Profissional suspenso (ex: por infração)
        EM_ANALISE // Profissional aguardando aprovação/verificação
    }
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 *        Esta tabela de roles agora reside nos schemas de tenant, o que
 *        significa
 *        que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 *        IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RoleProfissional extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface AdministradorMapper
 * @brief Mapper MapStruct para conversão entre Administrador e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface AdministradorMapper extends PessoaMapper {

    AdministradorMapper INSTANCE = Mappers.getMapper(AdministradorMapper.class);

    /**
     * @brief Mapeia um AdministradorRequestDTO para uma entidade Administrador.
     * @param dto O DTO de requisição do administrador.
     * @return A entidade Administrador.
     */
    Administrador toEntity(AdministradorRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Administrador para um AdministradorResponseDTO.
     * @param entity A entidade Administrador.
     * @return O DTO de resposta do administrador.
     */
    @Mapping(source = "status", target = "status")
    AdministradorResponseDTO toResponseDTO(Administrador entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ClienteMapper
 * @brief Mapper MapStruct para conversão entre Cliente e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface ClienteMapper extends PessoaMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    /**
     * @brief Mapeia um ClienteRequestDTO para uma entidade Cliente.
     * @param dto O DTO de requisição do cliente.
     * @return A entidade Cliente.
     */
    Cliente toEntity(ClienteRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Cliente para um ClienteResponseDTO.
     * @param entity A entidade Cliente.
     * @return O DTO de resposta do cliente.
     */
    @Mapping(source = "status", target = "status")
    @Mapping(target = "tipo", ignore = true) // O campo 'tipo' não existe na entidade Cliente, apenas no DTO de resposta
    ClienteResponseDTO toResponseDTO(Cliente entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EmpresaMapper
 * @brief Mapper MapStruct para conversão entre Empresa e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class})
public interface EmpresaMapper {

    EmpresaMapper INSTANCE = Mappers.getMapper(EmpresaMapper.class);

    /**
     * @brief Converte um EmpresaRequestDTO para uma entidade Empresa.
     * @param dto O DTO de requisição da empresa.
     * @return A entidade Empresa.
     */
    @Mapping(target = "id", ignore = true) // ID é gerado, não vem do DTO de requisição
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    Empresa toEntity(EmpresaRequestDTO dto);

    /**
     * @brief Converte uma entidade Empresa para um EmpresaResponseDTO.
     * @param entity A entidade Empresa.
     * @return O DTO de resposta da empresa.
     */
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    EmpresaResponseDTO toResponseDTO(Empresa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Endereco.TipoEndereco; // Importa o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EnderecoMapper
 * @brief Mapper MapStruct para conversão entre Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * @brief Converte um EnderecoRequestDTO para uma entidade Endereco.
     * @param dto O DTO de requisição do endereço.
     * @return A entidade Endereco.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "pessoa", ignore = true) // Será setado no serviço
    @Mapping(target = "empresa", ignore = true) // Será setado no serviço
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * @brief Converte uma entidade Endereco para um EnderecoResponseDTO.
     * @param entity A entidade Endereco.
     * @return O DTO de resposta do endereço.
     */
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * @brief Converte uma lista de EnderecoRequestDTOs para um Set de entidades Endereco.
     * @param dtoList A lista de DTOs de requisição de endereços.
     * @return Um Set de entidades Endereco.
     */
    Set<Endereco> toEntitySet(List<EnderecoRequestDTO> dtoList);

    /**
     * @brief Converte um Set de entidades Endereco para uma lista de EnderecoResponseDTOs.
     * @param entitySet Um Set de entidades Endereco.
     * @return Uma lista de DTOs de resposta de endereços.
     */
    List<EnderecoResponseDTO> toResponseDTOList(Set<Endereco> entitySet);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.InheritInverseConfiguration; // Importar se for usar @InheritInverseConfiguration
import org.mapstruct.factory.Mappers;

/**
 * @interface PessoaMapper
 * @brief Mapper MapStruct para conversão entre Pessoa e seus DTOs.
 * Esta é uma interface base para ser estendida por mappers de subclasses de Pessoa.
 */
@Mapper(componentModel = "spring", uses = {UserMapper.class, EnderecoMapper.class})
public interface PessoaMapper {

    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * @brief Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta da pessoa.
     */
    @Mapping(source = "usuario", target = "usuario")
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    PessoaResponseDTO toResponseDTO(Pessoa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano; // Importar Plano da entidade
import br.com.legalconnect.dto.EmpresaResponseDTO; // Importar EmpresaResponseDTO
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa; // Importar Empresa da entidade
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.Profissional.StatusProfissional; // Importar o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ProfissionalMapper
 * @brief Mapper MapStruct para conversão entre Profissional e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class, EmpresaMapper.class})
public interface ProfissionalMapper extends PessoaMapper {

    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * @brief Mapeia um ProfissionalRequestDTO para uma entidade Profissional.
     * @param dto O DTO de requisição do profissional.
     * @return A entidade Profissional.
     */
    @Mapping(target = "empresa", ignore = true) // Empresa será setada no serviço
    @Mapping(target = "plano", ignore = true)   // Plano será setado no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Não presente no DTO
    Profissional toEntity(ProfissionalRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * @param entity A entidade Profissional.
     * @return O DTO de resposta do profissional.
     */
    @Mapping(source = "empresa", target = "empresa")
    @Mapping(source = "plano", target = "plano")
    ProfissionalResponseDTO toResponseDTO(Profissional entity);

    /**
     * @brief Mapeia uma entidade Plano para um PlanoResponseDTO.
     * @param plano A entidade Plano.
     * @return O DTO de resposta do Plano.
     */
    PlanoResponseDTO toPlanoResponseDTO(Plano plano);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper MapStruct para conversão entre User e seus DTOs.
 */
@Mapper(componentModel = "spring") // Integração com Spring para injeção de dependência
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * @brief Converte um UserRequestDTO para uma entidade User.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserRequestDTO.
     * @param dto O DTO de requisição do usuário.
     * @return A entidade User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "nomeCompleto", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "cpf", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "telefone", ignore = true) // Não presente no DTO de requisição
    // @Mapping(target = "senhaHash", source = "password") // Mapeia password do DTO
    // para senhaHash da entidade
    @Mapping(target = "fotoUrl", ignore = true) // Não presente no DTO de requisição
    User toEntity(UserRequestDTO dto);

    /**
     * @brief Converte uma entidade User para um UserResponseDTO.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserResponseDTO.
     * @param entity A entidade User.
     * @return O DTO de resposta do usuário.
     */
    @Mapping(target = "email", source = "email")
    UserResponseDTO toResponseDTO(User entity);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Administrador;

/**
 * @interface RepositorioAdministrador
 * @brief Repositório Spring Data JPA para a entidade Administrador.
 *        Fornece métodos CRUD e de busca personalizados para Administrador.
 */
@Repository
public interface RepositorioAdministrador extends JpaRepository<Administrador, UUID> {

    /**
     * @brief Busca um Administrador pelo CPF.
     * @param cpf O CPF do administrador.
     * @return Um Optional contendo o Administrador, se encontrado.
     */
    Optional<Administrador> findByCpf(String cpf);

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Administradores.
     */
    Page<Administrador> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Cliente;

/**
 * @interface RepositorioCliente
 * @brief Repositório Spring Data JPA para a entidade Cliente.
 *        Fornece métodos CRUD e de busca personalizados para Cliente.
 */
@Repository
public interface RepositorioCliente extends JpaRepository<Cliente, UUID> {

    /**
     * @brief Busca um Cliente pelo CPF.
     * @param cpf O CPF do cliente.
     * @return Um Optional contendo o Cliente, se encontrado.
     */
    Optional<Cliente> findByCpf(String cpf);

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Clientes.
     */
    Page<Cliente> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Empresa;

/**
 * @interface RepositorioEmpresa
 * @brief Repositório Spring Data JPA para a entidade Empresa.
 *        Fornece métodos CRUD e de busca personalizados para Empresa.
 */
@Repository
public interface RepositorioEmpresa extends JpaRepository<Empresa, UUID> {

    /**
     * @brief Busca uma Empresa pelo CNPJ.
     * @param cnpj O CNPJ da empresa.
     * @return Um Optional contendo a Empresa, se encontrada.
     */
    Optional<Empresa> findByCnpj(String cnpj);

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Empresas.
     */
    Page<Empresa> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Endereco;

/**
 * @interface RepositorioEndereco
 * @brief Repositório Spring Data JPA para a entidade Endereco.
 *        Fornece métodos CRUD básicos para Endereco.
 */
@Repository
public interface RepositorioEndereco extends JpaRepository<Endereco, UUID> {
    // Métodos de busca adicionais podem ser definidos aqui se necessário,
    // como findByPessoaId(UUID pessoaId) ou findByEmpresaId(UUID empresaId)
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Pessoa;

/**
 * @interface RepositorioPessoa
 * @brief Repositório Spring Data JPA para a entidade Pessoa (base).
 * Fornece métodos CRUD básicos para Pessoa e busca por CPF.
 * Como Pessoa é uma entidade base abstrata com estratégia JOINED, este
 * repositório
 * pode ser usado para operações polimórficas se necessário, mas
 * geralmente
 * repositórios específicos para subclasses (Profissional, Cliente,
 * Administrador)
 * são mais comuns para operações de negócio.
 */
@Repository
public interface RepositorioPessoa extends JpaRepository<Pessoa, UUID> {

    /**
     * @brief Busca uma Pessoa pelo CPF.
     * @param cpf O CPF da pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Plano;

/**
 * @interface RepositorioPlano
 * @brief Repositório Spring Data JPA para a entidade Plano.
 *        Fornece métodos CRUD e de busca personalizados para Plano.
 *        **Nota:** Em uma arquitetura de microsserviços ideal, esta entidade e
 *        seu
 *        repositório poderiam residir em um serviço de 'marketplace' ou
 *        'assinatura'.
 *        Aqui, é mantido para fins de completude do modelo de dados do
 *        user-service,
 *        mas a gestão real dos planos pode ser externa.
 */
@Repository
public interface RepositorioPlano extends JpaRepository<Plano, UUID> {

    /**
     * @brief Busca um Plano pelo nome.
     * @param nome O nome do plano.
     * @return Um Optional contendo o Plano, se encontrado.
     */
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Profissional;

/**
 * @interface RepositorioProfissional
 * @brief Repositório Spring Data JPA para a entidade Profissional.
 *        Fornece métodos CRUD e de busca personalizados para Profissional.
 */
@Repository
public interface RepositorioProfissional extends JpaRepository<Profissional, UUID> {

    /**
     * @brief Busca um Profissional pelo CPF.
     * @param cpf O CPF do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByCpf(String cpf);

    /**
     * @brief Busca um Profissional pelo número da OAB.
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Profissionais.
     */
    Page<Profissional> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.RoleProfissional;

/**
 * @interface RepositorioRoleProfissional
 * @brief Repositório Spring Data JPA para a entidade RoleProfissional.
 *        Fornece métodos CRUD e de busca personalizados para RoleProfissional.
 *        **Nota:** Em um ambiente multi-tenant, os papéis podem ser globais ou
 *        por tenant.
 *        Este repositório assume que a entidade RoleProfissional está no schema
 *        do tenant.
 */
@Repository
public interface RepositorioRoleProfissional extends JpaRepository<RoleProfissional, UUID> {

    /**
     * @brief Busca um RoleProfissional pelo nome.
     * @param nome O nome do papel.
     * @return Um Optional contendo o RoleProfissional, se encontrado.
     */
    Optional<RoleProfissional> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.User;

/**
 * @interface RepositorioUser
 * @brief Repositório Spring Data JPA para a entidade User.
 *        Fornece métodos CRUD e de busca personalizados para User.
 *        **Nota:** Este repositório é crucial para o pré-requisito de
 *        associação de Pessoa a um User existente.
 *        As operações de criação/atualização de User em si são de
 *        responsabilidade de outro microsserviço (ex: auth-service).
 */
@Repository
public interface RepositorioUser extends JpaRepository<User, UUID> {

    /**
     * @brief Busca um User pelo email.
     * @param email O email do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.AdministradorMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioAdministrador;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoAdministrador
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Administradores.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Administradores.
 */
@Service
@RequiredArgsConstructor
public class ServicoAdministrador {

    private final RepositorioAdministrador repositorioAdministrador;
    private final RepositorioUser repositorioUser;
    private final AdministradorMapper administradorMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Administrador no sistema.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return DTO com os dados do Administrador cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public AdministradorResponseDTO cadastrarAdministrador(AdministradorRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro administrador.");
        }

        // 3. Mapear DTO para entidade
        Administrador administrador = administradorMapper.toEntity(requestDTO);
        administrador.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Administrador)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(administrador); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        administrador.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Administrador savedAdministrador = repositorioAdministrador.save(administrador);

        // 6. Mapear entidade salva para DTO de resposta
        return administradorMapper.toResponseDTO(savedAdministrador);
    }

    /**
     * @brief Busca um Administrador pelo ID.
     * @param id ID do Administrador a ser buscado.
     * @return DTO com os dados do Administrador encontrado.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional(readOnly = true)
    public AdministradorResponseDTO buscarAdministradorPorId(UUID id) {
        Administrador administrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado."));
        return administradorMapper.toResponseDTO(administrador);
    }

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Administradores.
     */
    @Transactional(readOnly = true)
    public Page<AdministradorResponseDTO> listarAdministradores(Pageable pageable) {
        return repositorioAdministrador.findAll(pageable)
                .map(administradorMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Administrador existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return DTO com os dados do Administrador atualizado.
     * @throws BusinessException Se o Administrador não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public AdministradorResponseDTO atualizarAdministrador(UUID id, AdministradorRequestDTO requestDTO) {
        Administrador existingAdministrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingAdministrador.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro administrador.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Administrador
        // O mapper precisa de um método de atualização, ou fazer manualmente
        existingAdministrador.setNomeCompleto(requestDTO.getNomeCompleto());
        existingAdministrador.setCpf(requestDTO.getCpf());
        existingAdministrador.setDataNascimento(requestDTO.getDataNascimento());
        existingAdministrador.setStatus(requestDTO.getStatus()); // Campo específico de Administrador

        // 3. Atualizar endereços (lógica de sincronização)
        existingAdministrador.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            // Reutiliza o mapper para converter DTO para Endereco
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingAdministrador); // Garante a associação bidirecional
            existingAdministrador.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingAdministrador.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingAdministrador.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Administrador updatedAdministrador = repositorioAdministrador.save(existingAdministrador);

        return administradorMapper.toResponseDTO(updatedAdministrador);
    }

    /**
     * @brief Exclui um Administrador pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional
    public void excluirAdministrador(UUID id) {
        if (!repositorioAdministrador.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Administrador com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioAdministrador.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ClienteMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioCliente;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoCliente
 * @brief Serviço de domínio para gerenciar operações relacionadas a Clientes.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Clientes.
 */
@Service
@RequiredArgsConstructor
public class ServicoCliente {

    private final RepositorioCliente repositorioCliente;
    private final RepositorioUser repositorioUser;
    private final ClienteMapper clienteMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Cliente no sistema.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return DTO com os dados do Cliente cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public ClienteResponseDTO cadastrarCliente(ClienteRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro cliente.");
        }

        // 3. Mapear DTO para entidade
        Cliente cliente = clienteMapper.toEntity(requestDTO);
        cliente.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Cliente)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(cliente); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        cliente.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Cliente savedCliente = repositorioCliente.save(cliente);

        // 6. Mapear entidade salva para DTO de resposta
        return clienteMapper.toResponseDTO(savedCliente);
    }

    /**
     * @brief Busca um Cliente pelo ID.
     * @param id ID do Cliente a ser buscado.
     * @return DTO com os dados do Cliente encontrado.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional(readOnly = true)
    public ClienteResponseDTO buscarClientePorId(UUID id) {
        Cliente cliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado."));
        return clienteMapper.toResponseDTO(cliente);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Clientes.
     */
    @Transactional(readOnly = true)
    public Page<ClienteResponseDTO> listarClientes(Pageable pageable) {
        return repositorioCliente.findAll(pageable)
                .map(clienteMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return DTO com os dados do Cliente atualizado.
     * @throws BusinessException Se o Cliente não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public ClienteResponseDTO atualizarCliente(UUID id, ClienteRequestDTO requestDTO) {
        Cliente existingCliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingCliente.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro cliente.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Cliente
        existingCliente.setNomeCompleto(requestDTO.getNomeCompleto());
        existingCliente.setCpf(requestDTO.getCpf());
        existingCliente.setDataNascimento(requestDTO.getDataNascimento());
        existingCliente.setStatus(requestDTO.getStatus()); // Campo específico de Cliente
        // existingCliente.setTipo(requestDTO.getTipo()); // Campo específico de Cliente

        // 3. Atualizar endereços (lógica de sincronização)
        existingCliente.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingCliente);
            existingCliente.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingCliente.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingCliente.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Cliente updatedCliente = repositorioCliente.save(existingCliente);

        return clienteMapper.toResponseDTO(updatedCliente);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional
    public void excluirCliente(UUID id) {
        if (!repositorioCliente.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Cliente com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioCliente.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EmpresaMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEmpresa
 * @brief Serviço de domínio para gerenciar operações relacionadas a Empresas.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Empresas.
 */
@Service
@RequiredArgsConstructor
public class ServicoEmpresa {

    private final RepositorioEmpresa repositorioEmpresa;
    private final EmpresaMapper empresaMapper;

    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra uma nova Empresa no sistema.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return DTO com os dados da Empresa cadastrada.
     * @throws BusinessException Se o CNPJ já estiver cadastrado.
     */
    @Transactional
    public EmpresaResponseDTO cadastrarEmpresa(EmpresaRequestDTO requestDTO) {
        // 1. Validação de duplicidade de CNPJ
        if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CNPJ, "CNPJ já cadastrado para outra empresa.");
        }

        // 2. Mapear DTO para entidade
        Empresa empresa = empresaMapper.toEntity(requestDTO);

        // 3. Associar endereços à empresa
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setEmpresa(empresa); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        empresa.setEnderecos(enderecos);

        // 4. Salvar a entidade
        Empresa savedEmpresa = repositorioEmpresa.save(empresa);

        // 5. Mapear entidade salva para DTO de resposta
        return empresaMapper.toResponseDTO(savedEmpresa);
    }

    /**
     * @brief Busca uma Empresa pelo ID.
     * @param id ID da Empresa a ser buscada.
     * @return DTO com os dados da Empresa encontrada.
     * @throws BusinessException Se a Empresa não for encontrada.
     */
    @Transactional(readOnly = true)
    public EmpresaResponseDTO buscarEmpresaPorId(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada."));
        return empresaMapper.toResponseDTO(empresa);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Empresas.
     */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDTO> listarEmpresas(Pageable pageable) {
        return repositorioEmpresa.findAll(pageable)
                .map(empresaMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id         ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return DTO com os dados da Empresa atualizada.
     * @throws BusinessException Se a Empresa não for encontrada ou se houver
     *                           duplicidade de CNPJ.
     */
    @Transactional
    public EmpresaResponseDTO atualizarEmpresa(UUID id, EmpresaRequestDTO requestDTO) {
        Empresa existingEmpresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para atualização."));

        // 1. Validação de duplicidade de CNPJ (se o CNPJ foi alterado)
        if (!existingEmpresa.getCnpj().equals(requestDTO.getCnpj())) {
            if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CNPJ, "Novo CNPJ já cadastrado para outra empresa.");
            }
        }

        // 2. Atualizar campos básicos da Empresa
        existingEmpresa.setNomeFantasia(requestDTO.getNomeFantasia());
        existingEmpresa.setRazaoSocial(requestDTO.getRazaoSocial());
        existingEmpresa.setCnpj(requestDTO.getCnpj());
        existingEmpresa.setEmailContato(requestDTO.getEmailContato());

        // 3. Atualizar endereços (lógica de sincronização)
        existingEmpresa.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setEmpresa(existingEmpresa);
            existingEmpresa.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingEmpresa.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingEmpresa.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Empresa updatedEmpresa = repositorioEmpresa.save(existingEmpresa);

        return empresaMapper.toResponseDTO(updatedEmpresa);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @throws BusinessException Se a Empresa não for encontrada ou se possuir
     *                           profissionais associados.
     */
    @Transactional
    public void excluirEmpresa(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para exclusão."));

        // Verificar se existem profissionais associados antes de excluir
        if (!empresa.getProfissionais().isEmpty()) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Empresa não pode ser excluída pois possui profissionais associados.");
        }

        // A exclusão em cascata do Endereco será tratada pelo JPA
        repositorioEmpresa.delete(empresa);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEndereco;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEndereco
 * @brief Serviço de domínio para gerenciar operações relacionadas a Endereços.
 *        Este serviço pode ser usado para operações diretas em Endereços,
 *        embora na maioria dos casos eles sejam gerenciados em cascata por
 *        Pessoa ou Empresa.
 */
@Service
@RequiredArgsConstructor
public class ServicoEndereco {

    private final RepositorioEndereco repositorioEndereco;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Endereco.
     * @param requestDTO DTO com os dados do Endereco a ser cadastrado.
     * @return DTO com os dados do Endereco cadastrado.
     */
    @Transactional
    public EnderecoResponseDTO cadastrarEndereco(EnderecoRequestDTO requestDTO) {
        Endereco endereco = enderecoMapper.toEntity(requestDTO);
        Endereco savedEndereco = repositorioEndereco.save(endereco);
        return enderecoMapper.toResponseDTO(savedEndereco);
    }

    /**
     * @brief Busca um Endereco pelo ID.
     * @param id ID do Endereco a ser buscado.
     * @return DTO com os dados do Endereco encontrado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional(readOnly = true)
    public EnderecoResponseDTO buscarEnderecoPorId(UUID id) {
        Endereco endereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado."));
        return enderecoMapper.toResponseDTO(endereco);
    }

    /**
     * @brief Lista todos os Enderecos.
     * @return Lista de DTOs de Enderecos.
     */
    @Transactional(readOnly = true)
    public List<EnderecoResponseDTO> listarEnderecos() {
        return repositorioEndereco.findAll().stream()
                .map(enderecoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Atualiza os dados de um Endereco existente.
     * @param id         ID do Endereco a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Endereco.
     * @return DTO com os dados do Endereco atualizado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public EnderecoResponseDTO atualizarEndereco(UUID id, EnderecoRequestDTO requestDTO) {
        Endereco existingEndereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado para atualização."));

        // Atualizar campos básicos do Endereco
        existingEndereco.setLogradouro(requestDTO.getLogradouro());
        existingEndereco.setNumero(requestDTO.getNumero());
        existingEndereco.setComplemento(requestDTO.getComplemento());
        existingEndereco.setBairro(requestDTO.getBairro());
        existingEndereco.setCidade(requestDTO.getCidade());
        existingEndereco.setEstado(requestDTO.getEstado());
        existingEndereco.setCep(requestDTO.getCep());
        existingEndereco.setPais(requestDTO.getPais());
        existingEndereco.setTipoEndereco(requestDTO.getTipoEndereco());

        Endereco updatedEndereco = repositorioEndereco.save(existingEndereco);
        return enderecoMapper.toResponseDTO(updatedEndereco);
    }

    /**
     * @brief Exclui um Endereco pelo ID.
     * @param id ID do Endereco a ser excluído.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public void excluirEndereco(UUID id) {
        if (!repositorioEndereco.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Endereço com ID " + id + " não encontrado para exclusão.");
        }
        repositorioEndereco.deleteById(id);
    }
}
```
```java
// br/com/legalconnect/service/ServicoPessoa.java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier; // Importar Qualifier
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import br.com.legalconnect.mapper.PessoaMapper;
import br.com.legalconnect.repository.RepositorioPessoa;

/**
 * @class ServicoPessoa
 * @brief Serviço de domínio para operações genéricas relacionadas a Pessoas.
 *        Como Pessoa é uma entidade base abstrata, este serviço lida com
 *        operações
 *        que podem ser comuns a todas as subclasses (Profissional, Cliente,
 *        Administrador).
 *        Operações de criação/atualização específicas devem ser tratadas nos
 *        serviços das subclasses.
 */
@Service
public class ServicoPessoa {

    private final RepositorioPessoa repositorioPessoa;
    private final PessoaMapper pessoaMapper;

    @Autowired
    public ServicoPessoa(RepositorioPessoa repositorioPessoa,
            @Qualifier("pessoaMapperImpl") PessoaMapper pessoaMapper) {
        this.repositorioPessoa = repositorioPessoa;
        this.pessoaMapper = pessoaMapper;
    }

    /**
     * @brief Busca uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser buscada.
     * @return DTO com os dados da Pessoa encontrada.
     * @throws BusinessException Se a Pessoa não for encontrada.
     */
    @Transactional(readOnly = true)
    public PessoaResponseDTO buscarPessoaPorId(UUID id) {
        Pessoa pessoa = repositorioPessoa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Pessoa com ID " + id + " não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * @brief Lista todas as Pessoas.
     * @return Lista de DTOs de Pessoas.
     */
    @Transactional(readOnly = true)
    public List<PessoaResponseDTO> listarTodasPessoas() {
        return repositorioPessoa.findAll().stream()
                .map(pessoaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Exclui uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser excluída.
     * @throws BusinessException Se a Pessoa não for encontrada.
     *                           **Nota:** A exclusão de Pessoa deve ser feita com
     *                           cautela, pois pode
     *                           impactar subclasses (Profissional, Cliente,
     *                           Administrador) e o User associado.
     *                           Idealmente, a exclusão de subclasses deveria ser o
     *                           ponto de entrada.
     */
    @Transactional
    public void excluirPessoa(UUID id) {
        if (!repositorioPessoa.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Pessoa com ID " + id + " não encontrada para exclusão.");
        }
        repositorioPessoa.deleteById(id);
    }
}

```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.mapper.ProfissionalMapper; // Reutilizando mapper de profissional para plano
import br.com.legalconnect.repository.RepositorioPlano;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoPlano
 * @brief Serviço de domínio para gerenciar operações relacionadas a Planos.
 *        **Nota:** Este serviço é um placeholder. Em uma arquitetura de
 *        microsserviços real,
 *        a gestão de planos seria feita em um microsserviço dedicado (ex:
 *        marketplace ou assinatura).
 *        Aqui, ele apenas fornece métodos de busca para que outros serviços
 *        possam referenciar planos.
 */
@Service
@RequiredArgsConstructor
public class ServicoPlano {

    private final RepositorioPlano repositorioPlano;
    private final ProfissionalMapper profissionalMapper;

    /**
     * @brief Busca um Plano pelo ID.
     * @param id ID do Plano a ser buscado.
     * @return DTO com os dados do Plano encontrado.
     * @throws BusinessException Se o Plano não for encontrado.
     */
    @Transactional(readOnly = true)
    public PlanoResponseDTO buscarPlanoPorId(UUID id) {
        Plano plano = repositorioPlano.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + id + " não encontrado."));
        return profissionalMapper.toPlanoResponseDTO(plano);
    }

    /**
     * @brief Lista todos os Planos disponíveis.
     * @return Lista de DTOs de Planos.
     */
    @Transactional(readOnly = true)
    public List<PlanoResponseDTO> listarTodosPlanos() {
        return repositorioPlano.findAll().stream()
                .map(profissionalMapper::toPlanoResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para cadastrar, atualizar e excluir planos não são implementados
    // aqui,
    // pois seriam responsabilidade do microsserviço de marketplace/assinatura.
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.mapper.ProfissionalMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import br.com.legalconnect.repository.RepositorioPlano;
import br.com.legalconnect.repository.RepositorioProfissional;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoProfissional
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Profissionais.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Profissionais.
 */
@Service
@RequiredArgsConstructor
public class ServicoProfissional {

    private final RepositorioProfissional repositorioProfissional;
    private final RepositorioUser repositorioUser;
    private final RepositorioPlano repositorioPlano;
    private final RepositorioEmpresa repositorioEmpresa;
    private final ProfissionalMapper profissionalMapper;

    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Profissional no sistema.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return DTO com os dados do Profissional cadastrado.
     * @throws BusinessException Se o CPF ou OAB já estiverem cadastrados, ou se o
     *                           User/Plano/Empresa associado não for encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO cadastrarProfissional(ProfissionalRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF e OAB
        if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro profissional.");
        }
        if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_INPUT,
                    "Número da OAB já cadastrado para outro profissional.");
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Mapear DTO para entidade
        Profissional profissional = profissionalMapper.toEntity(requestDTO);
        profissional.setUsuario(user); // Associar o User encontrado
        profissional.setPlano(plano); // Associar o Plano encontrado
        profissional.setEmpresa(empresa); // Associar a Empresa (pode ser null)

        // 5. Associar endereços à pessoa (Profissional)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(profissional); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        profissional.setEnderecos(enderecos);

        // 6. Salvar a entidade
        Profissional savedProfissional = repositorioProfissional.save(profissional);

        // 7. Mapear entidade salva para DTO de resposta
        return profissionalMapper.toResponseDTO(savedProfissional);
    }

    /**
     * @brief Busca um Profissional pelo ID.
     * @param id ID do Profissional a ser buscado.
     * @return DTO com os dados do Profissional encontrado.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional(readOnly = true)
    public ProfissionalResponseDTO buscarProfissionalPorId(UUID id) {
        Profissional profissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado."));
        return profissionalMapper.toResponseDTO(profissional);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Profissionais.
     */
    @Transactional(readOnly = true)
    public Page<ProfissionalResponseDTO> listarProfissionais(Pageable pageable) {
        return repositorioProfissional.findAll(pageable)
                .map(profissionalMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return DTO com os dados do Profissional atualizado.
     * @throws BusinessException Se o Profissional não for encontrado, ou se houver
     *                           duplicidade de CPF/OAB, ou se Plano/Empresa não for
     *                           encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO atualizarProfissional(UUID id, ProfissionalRequestDTO requestDTO) {
        Profissional existingProfissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingProfissional.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro profissional.");
            }
        }
        // 2. Validação de duplicidade de OAB (se a OAB foi alterada)
        if (!existingProfissional.getNumeroOab().equals(requestDTO.getNumeroOab())) {
            if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_INPUT,
                        "Novo número da OAB já cadastrado para outro profissional.");
            }
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Atualizar campos básicos da Pessoa e Profissional
        existingProfissional.setNomeCompleto(requestDTO.getNomeCompleto());
        existingProfissional.setCpf(requestDTO.getCpf());
        existingProfissional.setDataNascimento(requestDTO.getDataNascimento());
        existingProfissional.setNumeroOab(requestDTO.getNumeroOab());
        existingProfissional.setStatusProfissional(requestDTO.getStatusProfissional());
        existingProfissional.setUsaMarketplace(requestDTO.getUsaMarketplace());
        existingProfissional.setFazParteDePlano(requestDTO.getFazParteDePlano());
        existingProfissional.setPlano(plano);
        existingProfissional.setEmpresa(empresa);

        // 5. Atualizar endereços (lógica de sincronização)
        existingProfissional.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingProfissional);
            existingProfissional.getEnderecos().add(newEndereco);
        });

        // 6. Atualizar telefones
        existingProfissional.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingProfissional.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 7. Salvar a entidade atualizada
        Profissional updatedProfissional = repositorioProfissional.save(existingProfissional);

        return profissionalMapper.toResponseDTO(updatedProfissional);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional
    public void excluirProfissional(UUID id) {
        if (!repositorioProfissional.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Profissional com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioProfissional.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.UserMapper;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoUser
 * @brief Serviço de domínio para gerenciar operações relacionadas a Users.
 *        **Nota:** Este serviço é primariamente para busca e validação de Users
 *        existentes
 *        para associação com entidades Pessoa (Profissional, Cliente,
 *        Administrador).
 *        A criação e gestão principal de Users é responsabilidade de outro
 *        microsserviço (ex: auth-service).
 */
@Service
@RequiredArgsConstructor
public class ServicoUser {

    private final RepositorioUser repositorioUser;
    private final UserMapper userMapper;

    /**
     * @brief Busca um User pelo ID.
     * @param id ID do User a ser buscado.
     * @return DTO com os dados do User encontrado.
     * @throws BusinessException Se o User não for encontrado.
     */
    @Transactional(readOnly = true)
    public UserResponseDTO buscarUserPorId(UUID id) {
        User user = repositorioUser.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário com ID " + id + " não encontrado."));
        return userMapper.toResponseDTO(user);
    }

    /**
     * @brief Lista todos os Users.
     * @return Lista de DTOs de Users.
     */
    @Transactional(readOnly = true)
    public List<UserResponseDTO> listarTodosUsers() {
        return repositorioUser.findAll().stream()
                .map(userMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Verifica se um User existe pelo ID.
     * @param id ID do User a ser verificado.
     * @return true se o User existe, false caso contrário.
     */
    @Transactional(readOnly = true)
    public boolean userExiste(UUID id) {
        return repositorioUser.existsById(id);
    }

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o DTO do User, se encontrado.
     */
    @Transactional(readOnly = true)
    public Optional<UserResponseDTO> buscarUserPorCpf(String cpf) {
        return repositorioUser.findByCpf(cpf)
                .map(userMapper::toResponseDTO);
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada
server.port=8084
# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

# Habilita o Eureka Client
eureka.client.enabled=true
# URL do servidor Eureka onde o auth-service irá se registrar
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância para garantir identificação única no Eureka
eureka.instance.hostname=localhost
eureka.instance.instance-id=${spring.application.name}:${instanceId:${random.value}}
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=00000000-0000-0000-0000-000000000001

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```