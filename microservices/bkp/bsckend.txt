```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
{
  "openapi": "3.0.1",
  "info": { "title": "OpenAPI definition", "version": "v0" },
  "servers": [
    { "url": "http://192.168.1.4:62776", "description": "Generated server url" }
  ],
  "paths": {
    "/api/v1/auth/socios/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerSocio",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/redefinir": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "resetPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ResetPasswordRequest" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/recuperar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "recoverPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecoverPasswordRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/refresh-token": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "refreshToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshTokenRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/login": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "authenticate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/LoginRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/clientes/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerClient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/advogados/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdvogado",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/administradores/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdmin",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/existir/{id}": {
      "get": {
        "tags": ["user-controller"],
        "operationId": "existsById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": { "*/*": { "schema": { "type": "boolean" } } }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "UserRegistrationRequest": {
        "required": ["cpf", "email", "nomeCompleto", "senha", "userType"],
        "type": "object",
        "properties": {
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "email": { "maxLength": 255, "minLength": 0, "type": "string" },
          "cpf": {
            "pattern": "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$",
            "type": "string"
          },
          "telefone": { "maxLength": 20, "minLength": 0, "type": "string" },
          "senha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          },
          "userType": { "type": "string" }
        }
      },
      "BaseResponseUserResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/UserResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "nomeCompleto": { "type": "string" },
          "email": { "type": "string" },
          "cpf": { "type": "string" },
          "telefone": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "status": { "type": "string" }
        }
      },
      "ResetPasswordRequest": {
        "required": ["novaSenha", "token"],
        "type": "object",
        "properties": {
          "token": { "type": "string" },
          "novaSenha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "RecoverPasswordRequest": {
        "required": ["email"],
        "type": "object",
        "properties": { "email": { "type": "string" } }
      },
      "RefreshTokenRequestDTO": {
        "required": ["refreshToken"],
        "type": "object",
        "properties": { "refreshToken": { "type": "string" } }
      },
      "AuthResponse": {
        "type": "object",
        "properties": {
          "accessToken": { "type": "string" },
          "refreshToken": { "type": "string" },
          "tokenType": { "type": "string" },
          "expiresIn": { "type": "integer", "format": "int64" }
        }
      },
      "BaseResponseAuthResponse": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AuthResponse" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "LoginRequestDTO": {
        "required": ["email", "senha"],
        "type": "object",
        "properties": {
          "email": { "type": "string" },
          "senha": { "type": "string" }
        }
      }
    }
  }
}

```
```java
# Read Me First

The following was discovered as part of building this project:

- The original package name 'br.com.legalconnect.auth.auth-service' is invalid and this project uses 'br.com.legalconnect.auth.auth_service' instead.

# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

- [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
- [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
- [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.

docker run --name jusplatform_db -e POSTGRES_DB=jusplatform_db -e POSTGRES_USER=jususer -e POSTGRES_PASSWORD=juspassword -p 5432:5432 -d postgres

```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version> <!-- Mantendo 3.2.5 para consistência com o Gateway, mas você pode usar
        3.2.12 se preferir -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>
    <groupId>br.com.legalconnect</groupId>
    <artifactId>legalconnect-auth-service</artifactId> <!-- Certifique-se de que o artifactId está correto para o auth-service -->
    <version>0.0.1-SNAPSHOT</version>
    <name>legalconnect-auth-service</name>
    <description>Authentication Microservice for LegalConnect</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>

        <jjwt.version>0.11.5</jjwt.version> <!-- Mantido 0.12.5 para compatibilidade com a classe
        JwtUtil -->
        <flyway.version>11.8.2</flyway.version> <!-- CORRIGIDO: Define a versão do Flyway para 11.8.2 -->
        <lombok.version>1.18.30</lombok.version> <!-- Adicionado/Atualizado para garantir
        compatibilidade -->
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Adicionado/Atualizado para
        garantir compatibilidade -->
        <springdoc.version>2.5.0</springdoc.version> <!-- Atualizado para 2.5.0 para consistência com
        o Gateway -->
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <!-- Flyway Core para migrações de banco de dados -->
        <!-- <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
            A versão será gerenciada pela seção dependencyManagement
        </dependency> -->
        <!-- Flyway para PostgreSQL (necessário se você usa recursos específicos do PostgreSQL no
        Flyway) -->
        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-database-postgresql</artifactId>
            <!-- A versão será gerenciada pela seção dependencyManagement -->
        </dependency>

        <!-- JWT Libraries -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- MapStruct for DTO-Entity mapping -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${org.mapstruct.version}</version>
            <scope>provided</scope>
        </dependency>

        <!-- common-lib (se aplicável, mantenha a versão correta) -->
        <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-lib</artifactId>
            <version>1.0.1</version>
        </dependency>
        <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-tenent</artifactId>
            <version>1.0.0</version>
        </dependency>

        <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-role</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <!-- Lombok for boilerplate code reduction -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- OpenAPI/Swagger UI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Jackson for JSON processing (used by JwtAuthEntryPoint) -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>


    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- Adicionado/Atualizado: Força a versão do flyway-core para evitar conflitos de
            dependência transitiva -->
            <dependency>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-core</artifactId>
                <version>${flyway.version}</version>
            </dependency>
            <!-- Adicionado/Atualizado: Força a versão do flyway-database-postgresql para evitar
            conflitos de dependência transitiva -->
            <dependency>
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-database-postgresql</artifactId>
                <version>${flyway.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <!-- Plugin para MapStruct -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <arg>-Amapstruct.defaultComponentModel=spring</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-AuthServiceApplication<local-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.AuthServiceApplication",
      "projectName": "local-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    },
    {
      "type": "java",
      "name": "Spring Boot-AuthServiceApplication<legalconnect-auth-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.AuthServiceApplication",
      "projectName": "legalconnect-auth-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
// import org.springframework.context.annotation.ComponentScan; // REMOVA ESTA LINHA OU COMENTE-A
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

import br.com.legalconnect.common.config.TenantMigrationService;

@EnableDiscoveryClient
@SpringBootApplication(exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui também, se já está no
                                                                // pacote raiz
@EntityScan(basePackages = {
        "br.com.legalconnect.user.entity",
        "br.com.legalconnect.auth.entity"
})
@EnableJpaRepositories(basePackages = {
        "br.com.legalconnect.user.repository",
        "br.com.legalconnect.auth.repository"
})
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class AuthServiceApplication implements CommandLineRunner {

    @Value("${application.tenant.default-id}") // Injeção da propriedade defaultTenantId
    private String defaultTenantIdString;

    @Autowired
    private TenantMigrationService tenantMigrationService;

    private static final Logger log = LoggerFactory.getLogger(AuthServiceApplication.class);

    @Override
    public void run(String... args) throws Exception {
        tenantMigrationService.migrate(defaultTenantIdString);
    }

    public static void main(String[] args) {
        SpringApplication.run(AuthServiceApplication.class, args);
        log.info("LegalConnectApplication iniciada com sucesso!");
    }

}
```
```java
package br.com.legalconnect.auth.config;

import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import org.springframework.web.server.WebFilter;
import org.springframework.web.server.WebFilterChain;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import reactor.core.publisher.Mono;

/**
 * @class JwtAuthEntryPoint
 * @brief Ponto de entrada de autenticação para requisições não autenticadas ou
 *        com falha de autenticação.
 *
 *        Esta classe implementa `AuthenticationEntryPoint` para lidar com
 *        requisições que
 *        chegam sem credenciais válidas ou com credenciais que falham na
 *        autenticação.
 *        Ela retorna uma resposta JSON padronizada com `HTTP 401 Unauthorized`
 *        e um
 *        `BaseResponse` contendo o código e mensagem de erro.
 */
@Component
public class JwtAuthEntryPoint implements WebFilter {

    private static final String TENANT_HEADER = "X-Tenant-ID";
    private static final String CORRELATION_HEADER = "X-Correlation-ID";

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        return Mono.fromRunnable(() -> {
            // 1. Validação do Tenant ID
            String tenantId = exchange.getRequest().getHeaders().getFirst(TENANT_HEADER);
            if (tenantId == null || tenantId.isBlank()) {
                throw new BusinessException(ErrorCode.TENANT_NOT_FOUND, TENANT_HEADER + " header is required");
            }

            // 2. Validação do Correlation ID
            String correlationId = exchange.getRequest().getHeaders().getFirst(CORRELATION_HEADER);
            if (correlationId == null || correlationId.isBlank()) {
                throw new BusinessException(ErrorCode.USER_NOT_FOUND, CORRELATION_HEADER + " header is required");
            }
        }).then(chain.filter(exchange));
    }
}
```
```java
// auth-service/src/main/java/br/com/legalconnect/config/security/SecurityConfig.java
package br.com.legalconnect.auth.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource; // Importar CorsConfigurationSource
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import br.com.legalconnect.auth.service.JwtService; // Importar JwtService
import br.com.legalconnect.user.repository.UserRepository; // Importar UserRepository

/**
 * @class SecurityConfig
 * @brief Configuração de segurança principal para o microsserviço de
 *        autenticação.
 *
 *        Esta classe configura o Spring Security para usar JWTs para
 *        autenticação,
 *        define as regras de autorização para endpoints públicos e protegidos,
 *        e integra o filtro JWT personalizado.
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true) // Habilita segurança baseada em anotações como @PreAuthorize
public class SecurityConfig1 {

    private static final Logger log = LoggerFactory.getLogger(SecurityConfig1.class);
    // @Autowired
    // private JwtAuthEntryPoint unauthorizedHandler;
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private JwtService jwtService; // Injetar JwtService

    @Bean

    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    private static final String[] PUBLIC_ENDPOINTS = {
            "/api/v1/auth/**",
            "/api/v1/public/**",
            "/api/v1/users/register/**",
            "/api/v1/users/recover-password/**",
            "/api/v1/users/reset-password/**",
            "/actuator/**",
            "/h2-console/**",
            "/v3/api-docs/**",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/webjars/**"
    };

    /**
     * @brief Configura o provedor de autenticação.
     *
     *        Define o `UserDetailsService` e o `PasswordEncoder` a serem usados
     *        pelo Spring Security para autenticar usuários.
     *
     * @param userDetailsService O UserDetailsService (será injetado pelo Spring)
     * @return Uma instância de `DaoAuthenticationProvider`.
     */
    @Bean
    public DaoAuthenticationProvider authenticationProvider(UserDetailsService userDetailsService) {
        log.debug("Configurando DaoAuthenticationProvider.");
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }

    /**
     * @brief Obtém o `AuthenticationManager`.
     *
     *        O `AuthenticationManager` é usado para autenticar o objeto
     *        `Authentication`
     *        em métodos de login.
     *
     * @param authConfig A configuração de autenticação.
     * @return Uma instância de `AuthenticationManager`.
     * @throws Exception se ocorrer um erro ao obter o AuthenticationManager.
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authConfig) throws Exception {
        log.debug("Obtendo AuthenticationManager.");
        return authConfig.getAuthenticationManager();
    }

    /**
     * @brief Define o UserDetailsService personalizado.
     *
     *        Este bean é criado pelo Spring e injetará o UserRepository.
     * @return Uma instância de UserDetailsService.
     */
    @Bean
    public UserDetailsService userDetailsService() {
        log.debug("Criando bean UserDetailsService personalizado.");
        return username -> userRepository.findByEmail(username)
                .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado: " + username));
    }

    /**
     * @brief Define o JwtAuthFilter como um bean.
     *
     *        Ao definir o filtro como um bean aqui, o Spring gerencia sua criação
     *        e injeção de dependências, quebrando a referência circular que ocorria
     *        quando ele era um @Component e injetado via @Autowired na
     *        SecurityConfig.
     *
     * @param jwtService         O serviço JWT injetado pelo Spring.
     * @param userDetailsService O serviço de detalhes do usuário injetado pelo
     *                           Spring.
     * @return Uma instância de JwtAuthFilter.
     */
    // @Bean
    // public JwtAuthFilter jwtAuthFilter(JwtService jwtService, UserDetailsService
    // userDetailsService) {
    // log.debug("Criando bean JwtAuthFilter.");
    // return new JwtAuthFilter(jwtService, userDetailsService);
    // }

    /**
     * @brief Configura a cadeia de filtros de segurança HTTP.
     *
     *        Define as regras de autorização para diferentes endpoints,
     *        configura a política de criação de sessão como `STATELESS` (essencial
     *        para JWT),
     *        e adiciona o filtro JWT personalizado antes do filtro de autenticação
     *        padrão do Spring Security.
     *
     * @param http O objeto `HttpSecurity` para configurar a segurança.
     * @return Uma instância de `SecurityFilterChain`.
     * @throws Exception se ocorrer um erro durante a configuração.
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("Configurando SecurityFilterChain.");
        http
                .csrf(csrf -> csrf.disable())
                // Adicionar configuração CORS
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                // .exceptionHandling(exception ->
                // exception.authenticationEntryPoint(unauthorizedHandler))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(PUBLIC_ENDPOINTS).permitAll()
                        .anyRequest().authenticated());

        http.authenticationProvider(authenticationProvider(userDetailsService()));

        // Usa o bean jwtAuthFilter que foi definido acima
        // http.addFilterBefore(jwtAuthFilter(jwtService, userDetailsService()),
        // UsernamePasswordAuthenticationFilter.class);

        http.headers(headers -> headers.frameOptions(frameOptions -> frameOptions.sameOrigin()));

        log.info("SecurityFilterChain configurada com sucesso.");
        return http.build();
    }
    // @Bean
    // public SecurityFilterChain securityFilterChain(HttpSecurity http) throws
    // Exception {
    // log.info("Configurando SecurityFilterChain.");
    // http
    // .csrf(csrf -> csrf.disable())
    // .exceptionHandling(exception ->
    // exception.authenticationEntryPoint(unauthorizedHandler))
    // .sessionManagement(session ->
    // session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
    // .authorizeHttpRequests(auth -> auth
    // .requestMatchers(PUBLIC_ENDPOINTS).permitAll()
    // .anyRequest().authenticated());

    // http.authenticationProvider(authenticationProvider(userDetailsService()));

    // // Usa o bean jwtAuthFilter que foi definido acima
    // http.addFilterBefore(jwtAuthFilter(jwtService, userDetailsService()),
    // UsernamePasswordAuthenticationFilter.class);

    // http.headers(headers -> headers.frameOptions(frameOptions ->
    // frameOptions.sameOrigin()));

    // log.info("SecurityFilterChain configurada com sucesso.");
    // return http.build();
    // }
    /**
     * @brief Configura o CorsConfigurationSource para permitir requisições CORS.
     *
     *        Define as origens permitidas, métodos HTTP, cabeçalhos e credenciais
     *        para as requisições CORS.
     * @return Uma instância de `CorsConfigurationSource`.
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        log.debug("Configurando CorsConfigurationSource.");
        CorsConfiguration configuration = new CorsConfiguration();
        // Permitir todas as origens (em produção, especifique origens seguras, ex:
        // "http://localhost:3000")
        configuration.addAllowedOrigin("*");
        // Permitir todos os métodos HTTP (GET, POST, PUT, DELETE, etc.)
        configuration.addAllowedMethod("*");
        // Permitir todos os cabeçalhos
        configuration.addAllowedHeader("*");
        // Permitir envio de credenciais (cookies, headers de autorização)
        configuration.setAllowCredentials(true);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // Aplicar esta configuração CORS a todos os caminhos (/**)
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

```
```java
package br.com.legalconnect.auth.config;

import org.springframework.context.annotation.Bean;
import org.springframework.web.server.WebFilter;

public class WebConfig {
    private final JwtAuthEntryPoint jwtAuthEntryPoint;

    public WebConfig(JwtAuthEntryPoint jwtAuthEntryPoint) {
        this.jwtAuthEntryPoint = jwtAuthEntryPoint;
    }

    @Bean
    public WebFilter jwtAuthEntryPointFilter() {
        return jwtAuthEntryPoint;
    }

    @Bean
    public WebFilter corsFilter() {
        return (exchange, chain) -> {
            exchange.getResponse().getHeaders().add("Access-Control-Allow-Origin", "*");
            exchange.getResponse().getHeaders().add("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
            exchange.getResponse().getHeaders().add("Access-Control-Allow-Headers", "*");
            exchange.getResponse().getHeaders().add("Access-Control-Max-Age", "3600");

            if (exchange.getRequest().getMethod().name().equals("OPTIONS")) {
                exchange.getResponse().setStatusCode(org.springframework.http.HttpStatus.OK);
                return exchange.getResponse().setComplete();
            }

            return chain.filter(exchange);
        };
    }
}
```
```java
package br.com.legalconnect.auth.controller;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.auth.dto.AuthResponse;
import br.com.legalconnect.auth.dto.LoginRequestDTO;
import br.com.legalconnect.auth.dto.RecoverPasswordRequest;
import br.com.legalconnect.auth.dto.RefreshTokenRequestDTO;
import br.com.legalconnect.auth.dto.ResetPasswordRequest;
import br.com.legalconnect.auth.dto.UserRegistrationRequest;
import br.com.legalconnect.auth.dto.UserResponseDTO;
import br.com.legalconnect.auth.service.AuthService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

/**
 * "/api/v1/usuarios/redefinir-senha/solicitar",
 * "/api/v1/usuarios/redefinir-senha/confirmar",
 * 
 * @class AuthController
 * @brief Controlador REST para endpoints de autenticação.
 *        Gerencia as requisições de login e refresh de tokens JWT.
 */
@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
public class AuthController {

        private static final Logger log = LoggerFactory.getLogger(AuthController.class);

        private final AuthService authService;

        /**
         * Endpoint para autenticação de usuário.
         * 
         * @param request DTO de requisição de login.
         * @return Resposta padronizada com tokens JWT.
         */
        @PostMapping("/login")
        public ResponseEntity<BaseResponse<AuthResponse>> authenticate(@Valid @RequestBody LoginRequestDTO request) {
                log.info("Requisição de login recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                BaseResponse<AuthResponse> response = authService.authenticate(request);
                long endTime = System.currentTimeMillis();
                log.info("Login para o e-mail '{}' processado em {} ms. Status: {}", request.getEmail(),
                                (endTime - startTime),
                                "Sucesso");
                return ResponseEntity.ok(response);
        }

        /**
         * Endpoint para renovar o access token usando um refresh token.
         * 
         * @param request DTO de requisição de refresh token.
         * @return Resposta padronizada com novo access token.
         */
        @PostMapping("/refresh-token")
        public ResponseEntity<BaseResponse<AuthResponse>> refreshToken(
                        @Valid @RequestBody RefreshTokenRequestDTO request) {
                log.info("Requisição de refresh token recebida.");
                long startTime = System.currentTimeMillis();
                BaseResponse<AuthResponse> response = authService.refreshToken(request);
                long endTime = System.currentTimeMillis();
                log.info("Refresh token processado em {} ms. Status: {}", (endTime - startTime), "Sucesso");
                return ResponseEntity.ok(response);
        }

        /**
         * Endpoint para registro de um novo cliente.
         * 
         * @param request DTO de requisição de registro de usuário.
         * @return Resposta padronizada com DTO do usuário registrado.
         */
        @PostMapping("/clientes/registrar")
        public ResponseEntity<BaseResponse<UserResponseDTO>> registerClient(
                        @Valid @RequestBody UserRegistrationRequest request) {
                log.info("Requisição de registro de cliente recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                UserResponseDTO registeredUser = authService.registerClient(request);
                long endTime = System.currentTimeMillis();
                log.info("Registro de cliente para o e-mail '{}' processado em {} ms. Status: Sucesso",
                                request.getEmail(),
                                (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<UserResponseDTO>builder()
                                .data(registeredUser)
                                .message("Cliente registrado com sucesso!")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

        /**
         * Endpoint para registro de um novo advogado.
         * 
         * @param request DTO de requisição de registro de usuário.
         * @return Resposta padronizada com DTO do usuário registrado.
         */
        @PostMapping("/advogados/registrar")
        public ResponseEntity<BaseResponse<UserResponseDTO>> registerAdvogado(
                        @Valid @RequestBody UserRegistrationRequest request) {
                log.info("Requisição de registro de advogado recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                UserResponseDTO registeredUser = authService.registerAdvogado(request);
                long endTime = System.currentTimeMillis();
                log.info("Registro de advogado para o e-mail '{}' processado em {} ms. Status: Sucesso",
                                request.getEmail(),
                                (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<UserResponseDTO>builder()
                                .data(registeredUser)
                                .message("Advogado pré-registrado com sucesso! Aguardando aprovação.")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

        /**
         * Endpoint para registro de um novo sócio.
         * 
         * @param request DTO de requisição de registro de usuário.
         * @return Resposta padronizada com DTO do usuário registrado.
         */
        @PostMapping("/socios/registrar")
        public ResponseEntity<BaseResponse<UserResponseDTO>> registerSocio(
                        @Valid @RequestBody UserRegistrationRequest request) {
                log.info("Requisição de registro de sócio recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                UserResponseDTO registeredUser = authService.registerSocio(request);
                long endTime = System.currentTimeMillis();
                log.info("Registro de sócio para o e-mail '{}' processado em {} ms. Status: Sucesso",
                                request.getEmail(),
                                (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<UserResponseDTO>builder()
                                .data(registeredUser)
                                .message("Sócio registrado com sucesso! Aguardando aprovação.")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

        /**
         * Endpoint para registro de um novo administrador da plataforma.
         * 
         * @param request DTO de requisição de registro de usuário.
         * @return Resposta padronizada com DTO do usuário registrado.
         */
        @PostMapping("/administradores/registrar")
        public ResponseEntity<BaseResponse<UserResponseDTO>> registerAdmin(
                        @Valid @RequestBody UserRegistrationRequest request) {
                log.info("Requisição de registro de administrador recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                UserResponseDTO registeredUser = authService.registerAdmin(request);
                long endTime = System.currentTimeMillis();
                log.info("Registro de administrador para o e-mail '{}' processado em {} ms. Status: Sucesso",
                                request.getEmail(), (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<UserResponseDTO>builder()
                                .data(registeredUser)
                                .message("Administrador registrado com sucesso! Aguardando aprovação.")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

        /**
         * Endpoint para iniciar o processo de recuperação de senha.
         * 
         * @param request DTO contendo o e-mail do usuário.
         * @return Resposta padronizada de sucesso.
         */
        @PostMapping("/senhas/recuperar")
        public ResponseEntity<BaseResponse<Void>> recoverPassword(@Valid @RequestBody RecoverPasswordRequest request) {
                log.info("Requisição de recuperação de senha recebida para o e-mail: {}", request.getEmail());
                long startTime = System.currentTimeMillis();
                authService.recoverPassword(request.getEmail());
                long endTime = System.currentTimeMillis();
                log.info("Processo de recuperação de senha para o e-mail '{}' processado em {} ms. Status: Sucesso",
                                request.getEmail(), (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .message("Se o e-mail estiver cadastrado, um link de redefinição de senha foi enviado.")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

        /**
         * Endpoint para redefinir a senha usando um token.
         * 
         * @param request DTO contendo o token e a nova senha.
         * @return Resposta padronizada de sucesso.
         */
        @PostMapping("/senhas/redefinir")
        public ResponseEntity<BaseResponse<Void>> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
                log.info("Requisição de redefinição de senha recebida com token.");
                long startTime = System.currentTimeMillis();
                authService.resetPassword(request.getToken(), request.getNovaSenha());
                long endTime = System.currentTimeMillis();
                log.info("Redefinição de senha processada em {} ms. Status: Sucesso", (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .message("Senha redefinida com sucesso!")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }

}
```
```java
package br.com.legalconnect.auth.controller;

import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.auth.dto.UserResponseDTO;
import br.com.legalconnect.auth.dto.UserStatusUpdateRequest;
import br.com.legalconnect.auth.service.AuthService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1/privado/auth")
@RequiredArgsConstructor
public class AuthPrivateController {
        private static final Logger log = LoggerFactory.getLogger(AuthController.class);

        private final AuthService authService;

        /**
         * Endpoint para atualizar o status de um usuário.
         * Este endpoint está protegido e o acesso é controlado pela
         * anotação @PreAuthorize no serviço.
         * 
         * @param userId  O ID do usuário a ser atualizado.
         * @param request DTO contendo o novo status.
         * @return Resposta padronizada com DTO do usuário atualizado.
         */
        @PutMapping("/users/{userId}/status")
        public ResponseEntity<BaseResponse<UserResponseDTO>> updateUserStatus(
                        @PathVariable UUID userId,
                        @Valid @RequestBody UserStatusUpdateRequest request) {
                log.info("Requisição para atualizar status do usuário ID: {} para: {}", userId, request.getNewStatus());
                long startTime = System.currentTimeMillis();
                UserResponseDTO updatedUser = authService.updateUserStatus(userId, request.getNewStatus());
                long endTime = System.currentTimeMillis();
                log.info("Atualização de status para o usuário ID: {} processada em {} ms. Status: Sucesso",
                                userId, (endTime - startTime));
                return ResponseEntity.ok(BaseResponse.<UserResponseDTO>builder()
                                .data(updatedUser)
                                .message("Status do usuário atualizado com sucesso!")
                                .status(StatusResponse.SUCESSO)
                                .build());
        }
}

```
```java
package br.com.legalconnect.auth.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class AuthResponse
 * @brief DTO para a resposta de autenticação, contendo os tokens JWT.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AuthResponse {
    private String accessToken;
    private String refreshToken;
    private String tokenType = "Bearer";
    private Long expiresIn; // Tempo de expiração do access token em segundos
}
```
```java
package br.com.legalconnect.auth.dto;

import java.util.Map;

import lombok.Data;

@Data
public class EmailRequest {
    private String to;
    private String subject;
    private String htmlBody; // Para e-mails com HTML direto
    private String templateName; // Para e-mails com template Thymeleaf
    private Map<String, Object> templateVariables; // Variáveis para o template

}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class LoginRequestDTO
 * @brief DTO para a requisição de login.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDTO {
    @NotBlank(message = "O e-mail é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    private String email;

    @NotBlank(message = "A senha é obrigatória.")
    private String senha;
}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class RecoverPasswordRequest
 * @brief DTO para a requisição de recuperação de senha.
 *
 *        Contém o e-mail do usuário que solicitou a recuperação de senha.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RecoverPasswordRequest {
    @NotBlank(message = "O e-mail é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    private String email;
}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class RefreshTokenRequestDTO
 * @brief DTO para a requisição de refresh de token.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RefreshTokenRequestDTO {
    @NotBlank(message = "O refresh token é obrigatório.")
    private String refreshToken;
}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class ResetPasswordRequest
 * @brief DTO para a requisição de redefinição de senha.
 *
 *        Contém o token de redefinição e a nova senha do usuário.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResetPasswordRequest {
    @NotBlank(message = "O token de redefinição é obrigatório.")
    private String token;

    @NotBlank(message = "A nova senha é obrigatória.")
    @Size(min = 8, message = "A nova senha deve ter no mínimo 8 caracteres.")
    // Adicione regex para complexidade de senha se necessário (ex: maiúscula,
    // minúscula, número, caractere especial)
    private String novaSenha;
}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * @class UserProfileUpdate
 * @brief DTO para a requisição de atualização de perfil de usuário.
 *
 *        Contém os campos que podem ser atualizados no perfil de um usuário,
 *        incluindo validações para garantir a integridade dos dados.
 *        Os campos são opcionais, permitindo atualizações parciais.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserProfileUpdate {

    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail deve ter no máximo 255 caracteres.")
    private String email;

    @Size(max = 20, message = "O telefone deve ter no máximo 20 caracteres.")
    private String telefone;

    @Size(max = 255, message = "A URL da foto deve ter no máximo 255 caracteres.")
    private String fotoUrl;

    // Campos para alteração de senha (opcionais, mas devem ser fornecidos juntos)
    private String senhaAtual;
    @Size(min = 8, message = "A nova senha deve ter no mínimo 8 caracteres.")
    private String novaSenha;
    // Adicione regex para complexidade de senha se necessário
}
```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * @class UserRegistrationRequest
 * @brief DTO para a requisição de registro de um novo usuário.
 *
 *        Contém os dados necessários para registrar um novo usuário na
 *        plataforma,
 *        incluindo validações para garantir a integridade dos dados.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRegistrationRequest {

    @NotBlank(message = "O nome completo é obrigatório.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O e-mail é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail deve ter no máximo 255 caracteres.")
    private String email;

    // @NotBlank(message = "O CPF é obrigatório.")
    // @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$", message = "Formato de
    // CPF inválido. Use XXX.XXX.XXX-XX")
    // private String cpf;

    @Size(max = 20, message = "O telefone deve ter no máximo 20 caracteres.")
    private String telefone;

    @NotBlank(message = "A senha é obrigatória.")
    @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // Adicione regex para complexidade de senha se necessário (ex: maiúscula,
    // minúscula, número, caractere especial)
    private String senha;

    // @NotBlank(message = "O tipo de usuário é obrigatório.")
    // private String userType; // Adicionado para especificar o tipo de usuário
    // (CLIENTE, ADVOGADO, SOCIO,
    // // PLATAFORMA_ADMIN)
}

```
```java
package br.com.legalconnect.auth.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * @class UserResponseDTO
 * @brief DTO para a resposta de um usuário.
 *
 *        Representa os dados de um usuário que são retornados pela API,
 *        incluindo informações básicas, tipo de usuário, status e roles.
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    // private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private String status; // Representação em String do enum UserStatus

}

```
```java
package br.com.legalconnect.auth.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserStatusUpdateRequest
 * @brief DTO (Data Transfer Object) para a requisição de atualização de status
 *        de usuário.
 *
 *        Esta classe é utilizada para encapsular o novo status que será enviado
 *        na requisição para alterar o estado de um usuário no sistema.
 */
@Data // Adiciona getters, setters, toString, equals e hashCode
@NoArgsConstructor // Adiciona construtor sem argumentos
@AllArgsConstructor // Adiciona construtor com todos os argumentos
public class UserStatusUpdateRequest {
    /**
     * @brief O novo status do usuário.
     *        Deve ser uma string que corresponde a um dos valores do enum
     *        User.UserStatus
     *        (ex: "ACTIVE", "INACTIVE", "PENDING_APPROVAL", "REJECTED", "PENDING").
     *
     * @NotBlank Garante que o campo não seja nulo e não contenha apenas espaços em
     *           branco.
     */
    @NotBlank(message = "O novo status é obrigatório.")
    private String newStatus;
}

```
```java
package br.com.legalconnect.auth.service;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import br.com.legalconnect.auth.dto.AuthResponse;
import br.com.legalconnect.auth.dto.LoginRequestDTO;
import br.com.legalconnect.auth.dto.RefreshTokenRequestDTO;
import br.com.legalconnect.auth.dto.UserProfileUpdate;
import br.com.legalconnect.auth.dto.UserRegistrationRequest;
import br.com.legalconnect.auth.dto.UserResponseDTO;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.common.exception.Roles;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.user.entity.PasswordResetToken;
import br.com.legalconnect.user.entity.Role;
import br.com.legalconnect.user.entity.User;
import br.com.legalconnect.user.entity.User.UserStatus;
import br.com.legalconnect.user.entity.User.UserType;
import br.com.legalconnect.user.repository.PasswordResetTokenRepository;
import br.com.legalconnect.user.repository.RoleRepository;
import br.com.legalconnect.user.repository.UserRepository;
import jakarta.mail.MessagingException;
import lombok.RequiredArgsConstructor;

/**
 * @class AuthService
 * @brief Serviço de lógica de negócios para autenticação e refresh de tokens.
 */
@Service
@RequiredArgsConstructor
public class AuthService {

    private static final Logger log = LoggerFactory.getLogger(AuthService.class);

    private final UserRepository userRepository;
    private final JwtService jwtService;

    private final AuthenticationManager authenticationManager;

    private final PasswordEncoder passwordEncoder;

    private final RoleRepository roleRepository;

    private final RefreshTokenService refreshTokenService;

    private final PasswordResetTokenRepository passwordResetTokenRepository;

    private final EmailService emailService;

    private final UserMapper userMapper;

    @Value("${app.frontend.url}") // INJETAR A URL DO FRONTEND
    private String frontendBaseUrl;

    private long passwordResetExpirationMinutes;

    @Value("${application.tenant.default-id:00000000-0000-0000-0000-000000000001}")
    private String defaultTenantIds;

    /*
     * /
     * Autentica um usuário e gera tokens JWT.
     * Inclui id do usuário e id do tenant nos claims do JWT.
     * * @param request DTO de requisição de login.
     * 
     * @return DTO de resposta de login com tokens.
     * 
     * @throws ResponseStatusException se o usuário não for encontrado ou as
     * credenciais forem inválidas.
     */
    @Transactional
    public BaseResponse<AuthResponse> authenticate(LoginRequestDTO request) {
        log.debug("Iniciando autenticação para o e-mail: {}", request.getEmail());

        User user = userRepository.findByEmail(request.getEmail())
                .orElseThrow(() -> {
                    log.error("Usuário não encontrado no banco de dados para o e-mail: {}", request.getEmail());
                    return new BusinessException(ErrorCode.USER_NOT_FOUND,
                            "Usuário não encontrado com o e-mail: " + request.getEmail());
                });

        try {
            authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            request.getEmail(),
                            request.getSenha()));
            log.info("Credenciais válidas para o e-mail: {}", request.getEmail());
        } catch (Exception e) {
            log.warn("Falha na autenticação para o e-mail: {}. Erro: {}", request.getEmail(), e.getMessage());
            throw new BusinessException(ErrorCode.INVALID_CREDENTIALS, "Credenciais inválidas.");
        }

        List<String> roles = user.getRoles().stream().map(Role::getNome).toList();

        // Adiciona id do usuário e id do tenant aos claims do JWT
        Map<String, Object> claims = new HashMap<>();

        claims.put("roles", roles);

        claims.put("X-Correlation-ID", user.getId());

        claims.put("X-Tenant-ID", "public");

        // Gera os tokens com os claims adicionais
        String jwtToken = jwtService.generateToken(claims, user);
        String refreshToken = jwtService.generateRefreshToken(user);

        // Adiciona informações ao MDC após autenticação bem-sucedida para logs
        // subsequentes
        MDC.put("X-Correlation-ID", String.valueOf(user.getId()));

        return BaseResponse.<AuthResponse>builder()
                .status(StatusResponse.SUCESSO)
                .message("Autenticação realizada com sucesso.")
                .timestamp(LocalDateTime.now())
                .data(AuthResponse.builder()
                        .accessToken(jwtToken)
                        .refreshToken(refreshToken)
                        .tokenType("Bearer")
                        .expiresIn(jwtService.extractExpiration(jwtToken).getTime() / 1000)
                        .build())
                .build();
    }

    /**
     * Renova o access token usando um refresh token.
     * * @param request DTO de requisição de refresh token.
     * 
     * @return DTO de resposta de login com novo access token.
     * @throws ResponseStatusException se o refresh token for inválido ou expirado.
     */
    @Transactional
    public BaseResponse<AuthResponse> refreshToken(RefreshTokenRequestDTO request) {
        log.debug("Iniciando processo de refresh token.");
        String userEmail = jwtService.extractUsername(request.getRefreshToken());

        if (userEmail == null) {
            log.warn("Refresh token não contém e-mail de usuário válido.");
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Refresh token inválido ou expirado.");
        }

        User user = userRepository.findByEmail(userEmail)
                .orElseThrow(() -> {
                    log.error("Usuário não encontrado para o e-mail do refresh token: {}", userEmail);
                    return new ResponseStatusException(HttpStatus.NOT_FOUND,
                            "Usuário não encontrado com o e-mail: " + userEmail);
                });

        if (jwtService.isTokenValid(request.getRefreshToken(), user)) {
            log.info("Refresh token válido para o usuário: {}", userEmail);
            // Ao gerar um novo access token, re-incluímos os claims de userId e tenantId
            Map<String, Object> claims = new HashMap<>();
            claims.put("userId", user.getId());

            claims.put("tenantId", "public");

            String accessToken = jwtService.generateToken(claims, user);

            // Adiciona informações ao MDC para logs subsequentes
            MDC.put("userId", String.valueOf(user.getId()));

            return br.com.legalconnect.common.dto.BaseResponse.<AuthResponse>builder()
                    .status(StatusResponse.SUCESSO)
                    .message("Token atualizado com sucesso.")
                    .timestamp(LocalDateTime.now())
                    .data(AuthResponse.builder()
                            .accessToken(accessToken)
                            .refreshToken(request.getRefreshToken()) // Mantém o mesmo refresh token
                            .tokenType("Bearer")
                            .expiresIn(jwtService.extractExpiration(accessToken).getTime() / 1000)
                            .build())
                    .build();
        } else {
            log.warn("Refresh token inválido ou expirado para o usuário: {}", userEmail);
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Refresh token inválido ou expirado.");
        }
    }

    /**
     * @brief Registra um novo usuário na plataforma com base no tipo especificado.
     * @param request  DTO contendo os dados de registro do usuário.
     * @param userType O tipo de usuário a ser registrado (CLIENTE, ADVOGADO, SOCIO,
     *                 PLATAFORMA_ADMIN).
     * @return DTO do usuário registrado.
     * @throws BusinessException se o e-mail ou CPF já estiverem cadastrados, ou se
     *                           a role não for encontrada.
     */
    // @Transactional
    public UserResponseDTO registerUser(UserRegistrationRequest request, UserType userType) {
        log.info("Iniciando registro de novo usuário do tipo {} com e-mail: {}", userType, request.getEmail());

        // 1. Valida unicidade de e-mail e CPF
        if (userRepository.existsByEmail(request.getEmail())) {
            log.warn("Falha no registro: E-mail '{}' já cadastrado.", request.getEmail());
            throw new BusinessException(ErrorCode.EMAIL_ALREADY_REGISTERED);
        }
        // if (userRepository.existsByCpf(request.getCpf())) {
        // log.warn("Falha no registro: CPF '{}' já cadastrado.", request.getCpf());
        // throw new BusinessException(ErrorCode.INVALID_CPF);
        // }
        // 2. Busca o tenant padrão
        // 2. Busca o tenant padrão ou cria um novo se não existir
        // Tenant defaultTenant = tenantRepository.findBySchemaName(defaultTenantIds)
        // .orElseGet(() -> {
        // log.info("Tenant padrão não encontrado. Criando novo tenant com schema: {}",
        // defaultTenantIds);
        // return tenantRepository.save(Tenant.builder()
        // .schemaName(defaultTenantIds)
        // .createdAt(LocalDateTime.now())
        // .updatedAt(LocalDateTime.now())
        // .nome("Tenant Padrão")
        // .build());
        // });

        // 3. Cria a entidade User
        User user = userMapper.toEntity(request);
        user.setSenhaHash(passwordEncoder.encode(request.getSenha())); // Criptografa a senha
        user.setUserType(userType);
        // user.setTenant(defaultTenant); // Associa ao tenant padrão

        // 4. Define o status inicial e atribui a role com base no tipo de usuário
        Role assignedRole;
        switch (userType) {
            case CLIENTE:
                user.setStatus(UserStatus.ACTIVE); // Clientes são ativos por padrão
                assignedRole = roleRepository.findByNome(Roles.ROLE_CLIENT)
                        .orElseThrow(() -> {
                            log.error("Falha no registro: Role CLIENTE não encontrada no banco de dados.");
                            return new BusinessException(ErrorCode.USER_NOT_FOUND, "Role CLIENTE não encontrada.");
                        });
                break;
            case ADVOGADO:
                user.setStatus(UserStatus.PENDING_APPROVAL); // Advogados aguardam aprovação
                assignedRole = roleRepository.findByNome(Roles.ROLE_ADVOCATE)
                        .orElseThrow(() -> {
                            log.error("Falha no registro: Role ADVOGADO não encontrada no banco de dados.");
                            return new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE,
                                    "Role ADVOGADO não encontrada.");
                        });
                break;
            case SOCIO:
                user.setStatus(UserStatus.PENDING); // Sócios aguardam aprovação inicial
                assignedRole = roleRepository.findByNome(Roles.ROLE_TENANT_ADMIN) // Exemplo: Sócio pode ser um ADMIN do
                                                                                  // Tenant
                        .orElseThrow(() -> {
                            log.error("Falha no registro: Role SOCIO (TENANT_ADMIN) não encontrada no banco de dados.");
                            return new BusinessException(ErrorCode.USER_NOT_FOUND, "Role SOCIO não encontrada.");
                        });
                break;
            case PLATAFORMA_ADMIN:
                user.setStatus(UserStatus.PENDING); // Administradores da plataforma aguardam aprovação
                assignedRole = roleRepository.findByNome(Roles.ROLE_ADMIN)
                        .orElseThrow(() -> {
                            log.error("Falha no registro: Role PLATAFORMA_ADMIN não encontrada no banco de dados.");
                            return new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                                    "Role PLATAFORMA_ADMIN não encontrada.");
                        });
                break;
            default:
                log.error("Tipo de usuário inválido para registro: {}", userType);
                throw new BusinessException(ErrorCode.INVALID_INPUT, "Tipo de usuário inválido.");
        }

        if (user.getRoles() == null) {
            user.setRoles(new HashSet<>());
        }
        user.getRoles().add(assignedRole);
        log.debug("Role {} atribuída ao usuário: {}", assignedRole.getNome(), user.getEmail());

        // 5. Salva o usuário no banco de dados
        user = userRepository.save(user);
        log.info("Usuário do tipo {} registrado com sucesso: {} (ID: {})", userType, user.getEmail(), user.getId());

        // TODO: Disparar evento para NotificationService para enviar e-mail de
        // boas-vindas/confirmação
        log.debug("E-mail de boas-vindas/confirmação enviado para: {}", user.getEmail());
        user = userRepository.save(user);
        return userMapper.toDto(user);
    }

    /**
     * @brief Registra um novo cliente na plataforma (RF048).
     * @param request DTO contendo os dados de registro do cliente.
     * @return DTO do usuário registrado.
     * @throws BusinessException se o e-mail ou CPF já estiverem cadastrados.
     */
    @Transactional
    public UserResponseDTO registerClient(UserRegistrationRequest request) {
        // Delega para o método genérico com UserType.CLIENTE
        return registerUser(request, UserType.CLIENTE);
    }

    /**
     * @brief Realiza o pré-cadastro de um novo advogado na plataforma (RF001).
     * @param request DTO contendo os dados de pré-registro do advogado.
     * @return DTO do usuário advogado pré-registrado.
     * @throws BusinessException se o e-mail, CPF ou número da OAB já estiverem
     *                           cadastrados.
     */
    @Transactional
    public UserResponseDTO registerAdvogado(UserRegistrationRequest request) {
        // Delega para o método genérico com UserType.ADVOGADO
        return registerUser(request, UserType.ADVOGADO);
    }

    /**
     * @brief Registra um novo sócio na plataforma.
     * @param request DTO contendo os dados de registro do sócio.
     * @return DTO do usuário sócio registrado.
     * @throws BusinessException se o e-mail ou CPF já estiverem cadastrados.
     */
    @Transactional
    public UserResponseDTO registerSocio(UserRegistrationRequest request) {
        // Delega para o método genérico com UserType.SOCIO
        return registerUser(request, User.UserType.CLIENTE);
    }

    /**
     * @brief Registra um novo administrador da plataforma.
     * @param request DTO contendo os dados de registro do administrador.
     * @return DTO do usuário administrador registrado.
     * @throws BusinessException se o e-mail ou CPF já estiverem cadastrados.
     */
    // @Transactional
    public UserResponseDTO registerAdmin(UserRegistrationRequest request) {
        // Delega para o método genérico com UserType.PLATAFORMA_ADMIN
        return registerUser(request, UserType.PLATAFORMA_ADMIN);
    }

    /**
     * @brief Inicia o processo de recuperação de senha (RF053).
     *
     *        Gera um token temporário e envia um e-mail com o link de redefinição.
     *
     * @param email O e-mail do usuário que solicitou a recuperação.
     * @throws BusinessException se o usuário não for encontrado.
     */
    // @Transactional
    public void recoverPassword(String email) {
        log.info("Solicitação de recuperação de senha para o e-mail: {}", email);
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> {
                    log.warn("Falha na recuperação de senha: Usuário não encontrado para o e-mail: {}", email);
                    return new BusinessException(ErrorCode.USER_NOT_FOUND, "Usuário não encontrado.");
                });

        // 1. Invalida qualquer token de redefinição anterior para este usuário
        passwordResetTokenRepository.findByUser(user).ifPresent(passwordResetTokenRepository::delete);

        // 2. Gera um novo token único e define a expiração
        String token = UUID.randomUUID().toString();
        Instant expiryDate = Instant.now().plus(60 * 12, ChronoUnit.MINUTES);

        final PasswordResetToken resetToken = passwordResetTokenRepository.findByUserAndUsado(user, true)
                .orElseGet(() -> {
                    PasswordResetToken newToken = PasswordResetToken.builder()
                            .token(token)
                            .user(user)
                            .expiraEm(expiryDate)
                            .usado(false)
                            .tentativas(0)
                            .build();
                    return passwordResetTokenRepository.save(newToken);
                });
        log.info("Token de redefinição de senha gerado e salvo para o usuário: {}", user.getEmail());

        // CONSTRUIR O LINK DE REDEFINIÇÃO DE SENHA
        String resetLink = frontendBaseUrl + "/reset-password?token=" + token; // Adapte a rota do seu frontend

        // CHAMAR O NOVO MÉTODO PARA ENVIAR O EMAIL
        try {
            // sendPasswordResetEmail(user.getEmail(), user.getNomeCompleto(), resetLink);
            // // Assumindo que User tem
            // getNome()
        } finally {
            log.error("Erro ao enviar e-mail de recuperação de senha para: {}", user.getEmail());
        }
        // TODO: [PRODUÇÃO] Enviar e-mail com o link de redefinição de senha
        // O link deve apontar para o frontend, contendo o token:
        // String resetLink =
        // "[https://seufrontend.com/reset-password?token=](https://seufrontend.com/reset-password?token=)"
        // + token;
        // notificationService.sendPasswordResetEmail(user.getEmail(), resetLink);
        log.info("E-mail de recuperação de senha enviado para: {} com token: {}", user.getEmail(), token);
    }

    /**
     * @brief Redefine a senha do usuário utilizando um token de recuperação
     *        (RF053).
     * @param token     O token de redefinição de senha.
     * @param novaSenha A nova senha a ser definida.
     * @throws BusinessException se o token for inválido/expirado/usado ou a senha
     *                           for
     *                           fraca.
     */
    // @Transactional
    public void resetPassword(String email, String novaSenha) {
        log.info("Tentativa de redefinição de senha com token.");

        // 1. Busca e valida o token
        User user = userRepository.findByEmail(email)
                .orElseThrow(
                        () -> {
                            log.warn("Falha na redefinição de senha: Usuário não encontrado para o e-mail: {}", email);
                            return new BusinessException(ErrorCode.USER_NOT_FOUND, "Usuário não encontrado.");
                        });

        PasswordResetToken resetToken = passwordResetTokenRepository.findFirstByUserId(user.getId()).get();
        if (resetToken == null) {
            log.warn("Falha na redefinição de senha: Token inválido ou não encontrado.");
            new BusinessException(ErrorCode.PASSWORD_RESET_TOKEN_INVALID,
                    "Falha na redefinição de senha: Token inválido ou não encontrado.");
        }

        if (resetToken.isUsado()) {
            log.warn("Falha na redefinição de senha: Token já utilizado para o usuário: {}",
                    resetToken.getUser().getEmail());
            throw new BusinessException(ErrorCode.PASSWORD_RESET_TOKEN_USED,
                    "Falha na redefinição de senha: Token já utilizado para o usuário");
        }
        var tentativas = resetToken.getTentativas();
        resetToken.setTentativas(tentativas + 1);

        passwordResetTokenRepository.save(resetToken);
        if (tentativas >= 3) {
            log.warn("Falha na redefinição de senha: Tentativas de redefinição excedidas para o usuário: {}",
                    resetToken.getUser().getEmail());
            throw new BusinessException(ErrorCode.PASSWORD_RESET_TOKEN_EXCEEDED,
                    "Falha na redefinição de senha: Tentativas de redefinição excedidas");
        }
        var inspiracao = resetToken.getExpiraEm();
        var inspiracao2 = Instant.now();
        if (inspiracao.isBefore(inspiracao2)) {
            log.warn("Falha na redefinição de senha: Token expirado para o usuário: {}",
                    resetToken.getUser().getEmail());
            resetToken.setUsado(true);
            passwordResetTokenRepository.save(resetToken);
            // passwordResetTokenRepository.delete(resetToken); // Opcional: deletar tokens
            // expirados
            throw new BusinessException(ErrorCode.PASSWORD_RESET_TOKEN_EXPIRED,
                    "Falha na redefinição de senha: Token expirado para o usuário");
        }

        // 2. Busca o usuário associado ao token
        log.debug("Usuário encontrado para redefinição de senha: {}", user.getEmail());

        // 3. Criptografa e atualiza a nova senha
        user.setSenhaHash(passwordEncoder.encode(novaSenha));
        userRepository.save(user);
        log.info("Senha redefinida com sucesso para o usuário: {}", user.getEmail());

        // 4. Invalida o token de redefinição (marca como usado)
        resetToken.setUsado(true);
        passwordResetTokenRepository.save(resetToken);
        log.debug("Token de redefinição de senha marcado como usado.");

        // 5. Invalida todos os refresh tokens do usuário para forçar novo login
        refreshTokenService.deleteByUser(user);
        log.debug("Refresh tokens invalidados para o usuário: {}", user.getEmail());

        // TODO: [PRODUÇÃO] Envia e-mail de confirmação de redefinição de senha
        // notificationService.sendPasswordResetConfirmationEmail(user.getEmail());
        log.debug("E-mail de confirmação de redefinição de senha enviado para: {}", user.getEmail());
    }

    /**
     * @brief Atualiza o perfil de um usuário (RF055).
     * @param userId        O ID do usuário a ser atualizado.
     * @param updateRequest DTO com os dados de atualização.
     * @return DTO do usuário atualizado.
     * @throws BusinessException se o usuário não for encontrado, e-mail/CPF já em
     *                           uso, ou senha atual inválida.
     */
    @Transactional
    public UserResponseDTO updateUserProfile(UUID userId, UserProfileUpdate updateRequest) {
        log.info("Tentativa de atualização de perfil para o usuário ID: {}", userId);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> {
                    log.warn("Falha na atualização de perfil: Usuário não encontrado com ID: {}", userId);

                    return new BusinessException(ErrorCode.USER_NOT_FOUND,
                            "Falha na atualização de perfil: Usuário não encontrado com ID");
                });

        // Valida unicidade de e-mail, se o e-mail for alterado
        if (updateRequest.getEmail() != null && !updateRequest.getEmail().equals(user.getEmail())) {
            if (userRepository.existsByEmail(updateRequest.getEmail())) {
                log.warn("Falha na atualização de perfil: Novo e-mail '{}' já em uso.", updateRequest.getEmail());

                throw new BusinessException(ErrorCode.EMAIL_ALREADY_REGISTERED,
                        "Falha na atualização de perfil: Novo e-mail " + updateRequest.getEmail() + " já em uso.");
            }
            user.setEmail(updateRequest.getEmail());
            log.debug("E-mail do usuário {} atualizado para: {}", userId, updateRequest.getEmail());
        }

        // Atualiza outros campos do usuário
        userMapper.updateEntityFromDto(updateRequest, user);
        log.debug("Outros campos do perfil do usuário {} atualizados.", userId);

        // Lógica para alteração de senha
        if (updateRequest.getSenhaAtual() != null && updateRequest.getNovaSenha() != null) {
            log.info("Tentativa de alteração de senha para o usuário ID: {}", userId);
            if (!passwordEncoder.matches(updateRequest.getSenhaAtual(), user.getSenhaHash())) {
                log.warn("Falha na alteração de senha: Senha atual inválida para o usuário ID: {}", userId);

                throw new BusinessException(ErrorCode.PASSWORD_TOO_WEAK,
                        "Falha na alteração de senha: Senha atual inválida para o usuário ID");
            }
            user.setSenhaHash(passwordEncoder.encode(updateRequest.getNovaSenha()));
            // Invalida todos os refresh tokens do usuário para forçar novo login após a
            // mudança de senha
            refreshTokenService.deleteByUser(user);
            log.info("Senha do usuário {} alterada com sucesso. Refresh tokens invalidados.", userId);
        }

        user = userRepository.save(user);
        log.info("Perfil do usuário {} atualizado com sucesso.", userId);
        return userMapper.toDto(user);
    }

    /**
     * Método dedicado ao envio do e-mail de recuperação de senha.
     * Utiliza o template HTML e variáveis dinâmicas.
     *
     * @param to        Endereço de e-mail do destinatário.
     * @param userName  Nome do usuário para personalização do e-mail.
     * @param resetLink Link completo para a página de redefinição de senha no
     *                  frontend.
     */
    public void sendPasswordResetEmail(String to, String userName, String resetLink) {
        // PREPARAR VARIÁVEIS PARA O TEMPLATE DO EMAIL
        Map<String, Object> templateVariables = new HashMap<>();
        templateVariables.put("userName", userName);
        templateVariables.put("resetLink", resetLink);
        templateVariables.put("expirationMinutes", passwordResetExpirationMinutes);
        templateVariables.put("currentYear", Instant.now().atZone(ZoneId.of("America/Sao_Paulo")).getYear()); // Pega o
                                                                                                              // ano
                                                                                                              // atual
                                                                                                              // para
                                                                                                              // Parnaíba

        try {
            // ENVIAR O E-MAIL USANDO O SERVIÇO DE E-MAIL COM TEMPLATE
            emailService.sendTemplatedEmail(
                    to,
                    "Recuperação de Senha - [Seu Nome de Aplicação]", // Assunto do e-mail
                    "password-reset-email", // Nome do template HTML (sem .html)
                    templateVariables);
            log.info("E-mail de recuperação de senha enviado com sucesso para: {}", to);
        } catch (MessagingException e) {
            log.error("Erro ao enviar e-mail de recuperação de senha para {}: {}", to, e.getMessage(), e);
            // Opcional: Você pode relançar uma BusinessException ou tratar de outra forma
            throw new BusinessException(ErrorCode.INVALID_EMAIL, "Falha ao enviar e-mail de recuperação de senha.");
        }
    }

    /**
     * @brief Atualiza o status de um usuário.
     *        Este método só pode ser acessado por usuários que NÃO POSSUAM a role
     *        'ROLE_ADMIN'.
     * @param userId    O ID do usuário cujo status será atualizado.
     * @param newStatus O novo status para o usuário, deve corresponder a um valor
     *                  do enum {@link UserStatus}.
     * @return DTO do usuário atualizado.
     * @throws BusinessException se o usuário não for encontrado ou se o status
     *                           fornecido for inválido.
     */
    @Transactional
    @PreAuthorize("hasRole('ROLE_ADMIN')") // Garante que usuários autenticados, mas NÃO ADMIN,
                                           // podem usar este método.
    public UserResponseDTO updateUserStatus(UUID userId, String newStatus) {
        log.info("Tentativa de atualização de status para o usuário ID: {} com o novo status: {}", userId, newStatus);

        User user = userRepository.findById(userId)
                .orElseThrow(() -> {
                    log.warn("Falha na atualização de status: Usuário não encontrado com ID: {}", userId);
                    return new BusinessException(ErrorCode.USER_NOT_FOUND, "Usuário não encontrado.");
                });

        try {
            UserStatus statusEnum = UserStatus.valueOf(newStatus.toUpperCase());
            user.setStatus(statusEnum);
            user = userRepository.save(user);
            log.info("Status do usuário {} atualizado com sucesso para: {}", userId, newStatus);
            return userMapper.toDto(user);
        } catch (IllegalArgumentException e) {
            log.warn("Falha na atualização de status: Status inválido fornecido '{}' para o usuário ID: {}", newStatus,
                    userId);
            throw new BusinessException(ErrorCode.INVALID_INPUT, "Status de usuário inválido: " + newStatus
                    + ". Status permitidos: ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING.");
        }
    }
}
```
```java
package br.com.legalconnect.auth.service;

import java.nio.charset.StandardCharsets;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;

@Service
public class EmailService {

    @Autowired
    private JavaMailSender mailSender;

    @Autowired
    private TemplateEngine templateEngine; // Injetar o TemplateEngine do Thymeleaf

    // Método para enviar e-mail sem template Thymeleaf (HTML direto)
    public void sendHtmlEmail(String to, String subject, String htmlContent) throws MessagingException {
        MimeMessage message = mailSender.createMimeMessage();
        MimeMessageHelper helper = new MimeMessageHelper(message, true, StandardCharsets.UTF_8.name());

        helper.setTo(to);
        helper.setSubject(subject);
        helper.setText(htmlContent, true); // O 'true' indica que o conteúdo é HTML

        mailSender.send(message);
    }

    // Método para enviar e-mail com template Thymeleaf
    public void sendTemplatedEmail(String to, String subject, String templateName,
            Map<String, Object> templateVariables) throws MessagingException {
        // Criar um contexto Thymeleaf e adicionar as variáveis
        Context context = new Context();
        context.setVariables(templateVariables);

        // Processar o template Thymeleaf
        String htmlContent = templateEngine.process(templateName, context);

        sendHtmlEmail(to, subject, htmlContent);
    }
}
```
```java
package br.com.legalconnect.auth.service;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;

/**
 * @class JwtService
 * @brief Serviço para geração, validação e extração de informações de tokens
 *        JWT.
 */
@Service
public class JwtService {

    private static final Logger log = LoggerFactory.getLogger(JwtService.class);

    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    @Value("${application.security.jwt.expiration}")
    private long jwtExpiration;

    @Value("${application.security.jwt.refresh-expiration}")
    private long refreshExpiration;

    /**
     * Extrai o nome de usuário (subject) do token JWT.
     * 
     * @param token O token JWT.
     * @return O nome de usuário.
     */
    public String extractUsername(String token) {
        try {
            return extractClaim(token, Claims::getSubject);
        } catch (Exception e) {
            log.warn("Erro ao extrair username do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extrai uma claim específica do token JWT.
     * 
     * @param token          O token JWT.
     * @param claimsResolver Função para resolver a claim.
     * @param <T>            Tipo da claim.
     * @return O valor da claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Extrai o ID do usuário dos claims do token JWT.
     * 
     * @param token O token JWT.
     * @return O ID do usuário.
     */
    public Long extractUserId(String token) {
        try {
            return extractClaim(token, claims -> claims.get("userId", Long.class));
        } catch (Exception e) {
            log.warn("Erro ao extrair userId do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extrai o ID do tenant dos claims do token JWT.
     * 
     * @param token O token JWT.
     * @return O ID do tenant.
     */
    public Long extractTenantId(String token) {
        try {
            return extractClaim(token, claims -> claims.get("tenantId", Long.class));
        } catch (Exception e) {
            log.warn("Erro ao extrair tenantId do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Gera um token JWT para um usuário.
     * 
     * @param userDetails Detalhes do usuário.
     * @return O token JWT gerado.
     */
    public String generateToken(UserDetails userDetails) {
        return generateToken(new HashMap<>(), userDetails);
    }

    /**
     * Gera um token JWT com claims extras para um usuário.
     * 
     * @param extraClaims Claims adicionais.
     * @param userDetails Detalhes do usuário.
     * @return O token JWT gerado.
     */
    public String generateToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails) {
        log.debug("Gerando token JWT para o usuário: {}", userDetails.getUsername());
        return buildToken(extraClaims, userDetails, jwtExpiration);
    }

    /**
     * Gera um refresh token JWT para um usuário.
     * 
     * @param userDetails Detalhes do usuário.
     * @return O refresh token JWT gerado.
     */
    public String generateRefreshToken(
            UserDetails userDetails) {
        log.debug("Gerando refresh token para o usuário: {}", userDetails.getUsername());
        return buildToken(new HashMap<>(), userDetails, refreshExpiration);
    }

    /**
     * Constrói o token JWT.
     * 
     * @param extraClaims Claims adicionais.
     * @param userDetails Detalhes do usuário.
     * @param expiration  Tempo de expiração em milissegundos.
     * @return O token JWT construído.
     */
    private String buildToken(
            Map<String, Object> extraClaims,
            UserDetails userDetails,
            long expiration) {
        return Jwts
                .builder()
                .setClaims(extraClaims)
                .setSubject(userDetails.getUsername()) // O email do usuário será o subject
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256)
                .compact();
    }

    @Value("${application.security.jwt.secret-key}")
    private String secret;

    // Modifique a geração da chave para:
    private final SecretKey getSigningKey() {
        byte[] keyBytes = this.secret.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }

    // E na geração do token:
    public String generateToken(Map<String, Object> claims, UserDetails user, long expiration) {
        return Jwts.builder()
                .setClaims(claims)
                .setSubject(user.getUsername())
                .setIssuedAt(new Date(System.currentTimeMillis()))
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // Forçar HS256
                .compact();
    }

    /**
     * Valida se um token JWT é válido para um determinado usuário.
     * 
     * @param token       O token JWT.
     * @param userDetails Detalhes do usuário.
     * @return True se o token é válido, false caso contrário.
     */
    public boolean isTokenValid(String token, UserDetails userDetails) {
        try {
            final String username = extractUsername(token);
            boolean isValid = (username != null && username.equals(userDetails.getUsername()))
                    && !isTokenExpired(token);
            if (!isValid) {
                log.warn("Validação de token falhou para usuário: {}. Token válido: {}, Token expirado: {}",
                        username, (username != null && username.equals(userDetails.getUsername())),
                        isTokenExpired(token));
            }
            return isValid;
        } catch (Exception e) {
            log.error("Erro durante a validação do token: {}", e.getMessage(), e);
            return false;
        }
    }

    /**
     * Verifica se o token JWT expirou.
     * 
     * @param token O token JWT.
     * @return True se o token expirou, false caso contrário.
     */
    private boolean isTokenExpired(String token) {
        Date expiration = extractExpiration(token);
        boolean expired = expiration.before(new Date());
        if (expired) {
            log.debug("Token expirado em: {}", expiration);
        }
        return expired;
    }

    /**
     * Extrai a data de expiração do token JWT.
     * 
     * @param token O token JWT.
     * @return A data de expiração.
     */
    Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    /**
     * Extrai todas as claims do token JWT.
     * 
     * @param token O token JWT.
     * @return As claims do token.
     */
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSigningKey())
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    /**
     * Obtém a chave de assinatura para o JWT.
     * 
     * @return A chave de assinatura.
     */
    // private Key getSignInKey() {
    // byte[] keyBytes = Decoders.BASE64.decode(secretKey);
    // return Keys.hmacShaKeyFor(keyBytes);
    // }
}
```
```java
package br.com.legalconnect.auth.service;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Optional;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.user.entity.RefreshToken;
import br.com.legalconnect.user.entity.User;
import br.com.legalconnect.user.repository.RefreshTokenRepository;
import jakarta.persistence.EntityManager; // Importar EntityManager

/**
 * @class RefreshTokenService
 * @brief Serviço para gerenciamento de Refresh Tokens.
 *
 *        Responsável por criar, validar e invalidar refresh tokens, garantindo
 *        a
 *        renovação segura de sessões de usuário.
 */
@Service
public class RefreshTokenService {

    private static final Logger log = LoggerFactory.getLogger(RefreshTokenService.class);
    @Autowired
    private RefreshTokenRepository refreshTokenRepository;

    @Autowired // Injetar EntityManager
    private EntityManager entityManager;
    @Value("${application.security.jwt.refresh-expiration}")
    private long refreshTokenExpirationMs;

    /**
     * @brief Cria e salva um novo Refresh Token para um usuário.
     *
     * @param user O usuário para o qual o Refresh Token será criado.
     * @return O RefreshToken criado e persistido.
     */
    @Transactional
    public RefreshToken createRefreshToken(User user) {
        log.info("Criando refresh token para o usuário: {}", user.getEmail());
        // Invalida qualquer refresh token existente para este usuário para garantir
        // apenas um por vez
        refreshTokenRepository.findByUser(user).ifPresent(existingToken -> {
            log.debug("Deletando refresh token existente para o usuário: {}", user.getEmail());
            refreshTokenRepository.delete(existingToken);
            // Força o Hibernate a sincronizar a deleção com o banco de dados imediatamente
            entityManager.flush();
        });

        // Gera um novo token único
        String token = UUID.randomUUID().toString();
        Instant expiryDate = Instant.now().plus(refreshTokenExpirationMs, ChronoUnit.MILLIS);

        RefreshToken refreshToken = RefreshToken.builder()
                .user(user)
                .token(token)
                .expiraEm(expiryDate)
                .build();

        refreshToken = refreshTokenRepository.save(refreshToken);
        log.info("Refresh token criado e salvo com sucesso para o usuário: {}", user.getEmail());
        return refreshToken;
    }

    /**
     * @brief Busca um Refresh Token pelo seu valor.
     *
     * @param token O valor do Refresh Token.
     * @return Um `Optional` contendo o RefreshToken, se encontrado.
     */
    public Optional<RefreshToken> findByToken(String token) {
        log.debug("Buscando refresh token pelo valor: {}", token);
        return refreshTokenRepository.findByToken(token);
    }

    /**
     * @brief Verifica se um Refresh Token expirou.
     *
     * @param token O RefreshToken a ser verificado.
     * @return O RefreshToken se não estiver expirado.
     * @throws BusinessException se o Refresh Token estiver expirado.
     */
    public RefreshToken verifyExpiration(RefreshToken token) {
        log.debug("Verificando expiração do refresh token para o usuário: {}", token.getUser().getEmail());
        if (token.getExpiraEm().isBefore(Instant.now())) {
            refreshTokenRepository.delete(token); // Remove o token expirado
            entityManager.flush(); // Força o Hibernate a sincronizar a deleção
            log.warn("Refresh token expirado para o usuário: {}. Token deletado.", token.getUser().getEmail());
            throw new BusinessException(ErrorCode.REFRESH_TOKEN_EXPIRED,
                    "Refresh token expirado. Por favor, faça login novamente.");
        }
        log.debug("Refresh token para o usuário {} ainda é válido.", token.getUser().getEmail());
        return token;
    }

    /**
     * @brief Deleta um Refresh Token pelo seu valor.
     *
     * @param token O valor do Refresh Token a ser deletado.
     * @throws BusinessException se o Refresh Token não for encontrado.
     */
    @Transactional
    public void deleteByToken(String token) {
        log.info("Deletando refresh token pelo valor: {}", token);
        RefreshToken refreshToken = refreshTokenRepository.findByToken(token)
                .orElseThrow(() -> {
                    log.warn("Tentativa de deletar refresh token não encontrado: {}", token);

                    return new BusinessException(ErrorCode.INVALID_TOKEN, "Refresh token não encontrado.");
                });
        refreshTokenRepository.delete(refreshToken);
        entityManager.flush(); // Força o Hibernate a sincronizar a deleção
        log.info("Refresh token deletado com sucesso para o usuário: {}", refreshToken.getUser().getEmail());
    }

    /**
     * @brief Deleta um Refresh Token pelo usuário associado.
     *
     * @param user O usuário cujo Refresh Token será deletado.
     */
    @Transactional
    public void deleteByUser(User user) {
        log.info("Deletando refresh token para o usuário: {}", user.getEmail());
        refreshTokenRepository.findByUser(user).ifPresent(refreshToken -> {
            refreshTokenRepository.delete(refreshToken);
            entityManager.flush(); // Força o Hibernate a sincronizar a deleção
            log.info("Refresh token deletado com sucesso para o usuário: {}", user.getEmail());
        });
    }
}
```
```java
package br.com.legalconnect.auth.service;

import java.util.Set;
import java.util.stream.Collectors;

import org.mapstruct.Mapper;
import org.mapstruct.Named;
import org.mapstruct.ReportingPolicy;

import br.com.legalconnect.user.entity.Role;

/**
 * @interface RoleMapper
 * @brief Mapper para conversão entre a entidade `Role` e suas representações em
 *        String.
 *
 *        Esta interface utiliza MapStruct para gerar automaticamente o código
 *        de mapeamento.
 *        É usada principalmente para converter um `Set<Role>` em um
 *        `Set<String>` contendo
 *        os nomes das roles, o que é útil para DTOs de resposta de usuário.
 */
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface RoleMapper {

    /**
     * @brief Mapeia uma entidade Role para o seu nome (String).
     * @param role A entidade Role.
     * @return O nome da role.
     */
    String toRoleName(Role role);

    /**
     * @brief Mapeia um conjunto de entidades Role para um conjunto de nomes de
     *        roles (String).
     * @param roles O conjunto de entidades Role.
     * @return Um conjunto de Strings contendo os nomes das roles.
     */
    @Named("roleSetToStringSet") // Nomeia este método para ser referenciado em outros mappers (ex: UserMapper)
    default Set<String> roleSetToStringSet(Set<Role> roles) {
        if (roles == null) {
            return null;
        }
        return roles.stream()
                .map(Role::getNome) // Mapeia cada Role para o seu nome
                .collect(Collectors.toSet()); // Coleta os nomes em um Set
    }
}

```
```java
package br.com.legalconnect.auth.service;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.ReportingPolicy;

import br.com.legalconnect.auth.dto.UserProfileUpdate;
import br.com.legalconnect.auth.dto.UserRegistrationRequest;
import br.com.legalconnect.auth.dto.UserResponseDTO;
import br.com.legalconnect.user.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper para conversão entre a entidade `User` e seus DTOs.
 *
 *        Utiliza MapStruct para gerar automaticamente o código de mapeamento,
 *        incluindo a conversão de `UserType`, `UserStatus` e `Set<Role>` para
 *        Strings.
 */
@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE, uses = { RoleMapper.class })
public interface UserMapper {

    UserResponseDTO toDto(User entity);

    @Named("localDateTimeToInstant")
    default Instant localDateTimeToInstant(LocalDateTime dateTime) {
        return dateTime != null ? dateTime.atZone(ZoneId.systemDefault()).toInstant() : null;
    }

    @Mapping(target = "id", ignore = true)
    // @Mapping(target = "tenant", ignore = true) // Tenant é definido no serviço
    @Mapping(target = "roles", ignore = true) // Roles são definidas no serviço
    @Mapping(target = "senhaHash", ignore = true) // Senha é criptografada no serviço
    @Mapping(target = "userType", ignore = true) // userType é definido no serviço
    @Mapping(target = "status", ignore = true) // status é definido no serviço
    User toEntity(UserRegistrationRequest dto);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    // @Mapping(target = "tenant", ignore = true)
    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "senhaHash", ignore = true)
    @Mapping(target = "userType", ignore = true)
    @Mapping(target = "cpf", ignore = true)
    @Mapping(target = "status", ignore = true)
    void updateEntityFromDto(UserProfileUpdate dto, @MappingTarget User entity);

    default String mapUserType(User.UserType userType) {
        return userType != null ? userType.name() : null;
    }

    default String mapUserStatus(User.UserStatus userStatus) {
        return userStatus != null ? userStatus.name() : null;
    }

    // // Método para mapear Set<Role> para Set<String> de nomes de roles
    // @Named("roleSetToStringSet")
    // default Set<String> roleSetToStringSet(Set<Role> roles) {
    // if (roles == null) {
    // return null;
    // }
    // return roles.stream()
    // .map(Role::getNome)
    // .collect(Collectors.toSet());
    // }
}

```
```java
package br.com.legalconnect.common; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.TenantMigrationService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    @Autowired
    private TenantMigrationService tenantMigrationService;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String tenantIdHeader = request.getHeader(TENANT_HEADER);
        String tenantId = "public";

        if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
            try {
                tenantId = (tenantIdHeader);
            } catch (IllegalArgumentException e) {
                // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                return;
            }
        } else {
            // Usar o tenant padrão se o cabeçalho não for fornecido
            try {
                tenantId = (defaultTenantId);
            } catch (IllegalArgumentException e) {
                System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                        "Configuração de Tenant padrão inválida.");
                return;
            }
        }

        tenantMigrationService.migrateTenant(tenantId);
        filterChain.doFilter(request, response);

    }
}
```
```java
package br.com.legalconnect.user.controller;

import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.user.service.UserService;
import lombok.RequiredArgsConstructor;

@RestController
@RequestMapping("/api/v1/usuarios/up-data")
@RequiredArgsConstructor
public class UserController {

    private final UserService userService;

    // - Listar usuários
    @GetMapping("existir/{id}")
    public ResponseEntity<Boolean> existsById(@PathVariable("id") UUID id) {
        Boolean userResponseDTO = userService.existsById(id);
        return ResponseEntity.ok(userResponseDTO);
    }

}

```
```java
package br.com.legalconnect.user.entity;

import java.time.Instant;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class PasswordResetToken
 * @brief Entidade que representa um token de redefinição de senha no banco de
 *        dados.
 *
 *        Este token é gerado quando um usuário solicita a recuperação de senha
 *        e é usado
 *        para validar a solicitação antes de permitir a alteração da senha.
 */
@Entity
@Table(name = "tb_password_reset_token")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class PasswordResetToken extends BaseEntity {

    @Column(name = "token", nullable = false, unique = true, columnDefinition = "TEXT")
    private String token; // O valor real do token de redefinição

    @OneToOne(targetEntity = User.class, fetch = FetchType.EAGER)
    @JoinColumn(nullable = false, name = "user_id")
    private User user; // Usuário ao qual este token está associado

    @Column(name = "expira_em", nullable = false)
    private Instant expiraEm; // Data e hora em que este token se tornará inválido

    @Column(name = "usado", nullable = false)
    private boolean usado; // Indica se o token já foi usado

    @Column(name = "tentativas", nullable = false, columnDefinition = "INT DEFAULT 0")
    private Integer tentativas; // Número de tentativas de uso do token
}
```
```java
package br.com.legalconnect.user.entity;

import java.time.Instant;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class RefreshToken
 * @brief Entidade que representa o Refresh Token no banco de dados.
 *
 *        Esta tabela de refresh tokens agora reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_refresh_token") // A tabela tb_refresh_token agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RefreshToken extends BaseEntity {

    @OneToOne(fetch = FetchType.LAZY) // Relacionamento um-para-um com User
    @JoinColumn(name = "user_id", nullable = false, unique = true) // Coluna de chave estrangeira
    private User user; // Usuário ao qual este refresh token está associado

    @Column(name = "token", nullable = false, unique = true, columnDefinition = "TEXT")
    private String token; // O valor real do refresh token

    @Column(name = "expira_em", nullable = false)
    private Instant expiraEm; // Data e hora em que este refresh token se tornará inválido
}
```
```java
package br.com.legalconnect.user.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 * Esta tabela de roles agora reside nos schemas de tenant, o que
 * significa
 * que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 * IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class Role extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.user.entity;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity implements UserDetails { // Implementa UserDetails

    private static final Logger log = LoggerFactory.getLogger(User.class);

    // @ManyToOne(fetch = FetchType.LAZY) // Relacionamento muitos-para-um com
    // Tenant
    // // Referencia a tabela tb_tenant que está no schema public (global)
    // @JoinColumn(name = "tenant_id", nullable = false, referencedColumnName =
    // "id")
    // private Tenant tenant; // Identificador do tenant ao qual o usuário pertence

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    @Enumerated(EnumType.STRING)
    @Column(name = "user_type", nullable = false, length = 50)
    private UserType userType; // Categoria principal do usuário (ex: CLIENTE, ADVOGADO)

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 50)
    private UserStatus status; // Status atual da conta do usuário (ex: ACTIVE, PENDING_APPROVAL)

    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "user_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<Role> roles = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN // Administrador da plataforma com privilégios totais
        , SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

    /**
     * Retorna as autoridades concedidas ao usuário.
     * 
     * @return Coleção de GrantedAuthority.
     */
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        log.trace("Obtendo autoridades para o usuário: {}", this.email);
        return this.roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.getNome()))
                .collect(Collectors.toList());
    }

    /**
     * Retorna a senha usada para autenticar o usuário.
     * 
     * @return A senha criptografada.
     */
    @Override
    public String getPassword() {
        return this.senhaHash;
    }

    /**
     * Retorna o nome de usuário usado para autenticar o usuário.
     * Neste caso, o e-mail do usuário.
     * 
     * @return O e-mail do usuário.
     */
    @Override
    public String getUsername() {
        return this.email;
    }

    /**
     * Indica se a conta do usuário não expirou.
     * 
     * @return True se a conta é válida (não expirada), false caso contrário.
     */
    @Override
    public boolean isAccountNonExpired() {
        return true; // Adapte esta lógica conforme a necessidade do projeto (ex: baseado em data de
                     // expiração)
    }

    /**
     * Indica se a conta do usuário não está bloqueada.
     * 
     * @return True se a conta não está bloqueada, false caso contrário.
     */
    @Override
    public boolean isAccountNonLocked() {
        return this.status == UserStatus.ACTIVE; // A conta não está bloqueada se o status for ATIVO
    }

    /**
     * Indica se as credenciais do usuário (senha) não expiraram.
     * 
     * @return True se as credenciais são válidas (não expiradas), false caso
     *         contrário.
     */
    @Override
    public boolean isCredentialsNonExpired() {
        return true; // Adapte esta lógica conforme a necessidade do projeto (ex: baseado em política
                     // de troca de senha)
    }

    /**
     * Indica se o usuário está habilitado.
     * 
     * @return True se o usuário está habilitado, false caso contrário.
     */
    @Override
    public boolean isEnabled() {
        return this.status == UserStatus.ACTIVE; // O usuário está habilitado se o status for ATIVO
    }
}
```
```java
package br.com.legalconnect.user.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.user.entity.PasswordResetToken;
import br.com.legalconnect.user.entity.User; // Importar User

/**
 * @interface PasswordResetTokenRepository
 * @brief Repositório JPA para a entidade PasswordResetToken.
 *
 *        Fornece operações CRUD e métodos de consulta personalizados para
 *        gerenciar
 *        os tokens de redefinição de senha.
 */
@Repository
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, UUID> {

    /**
     * @brief Busca um PasswordResetToken pelo seu valor de token.
     * @param token O valor String do token de redefinição.
     * @return Um Optional contendo o PasswordResetToken, se encontrado.
     */
    Optional<PasswordResetToken> findByToken(String token);

    /**
     * @brief Busca um PasswordResetToken associado a um usuário específico.
     * @param user O objeto User para o qual o token é procurado.
     * @return Um Optional contendo o PasswordResetToken, se encontrado.
     */
    Optional<PasswordResetToken> findByUser(User user);

    Optional<PasswordResetToken> findByUserAndUsado(User user, boolean b);

    Optional<PasswordResetToken> findFirstByUserId(UUID id);

}
```
```java
package br.com.legalconnect.user.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.user.entity.RefreshToken;
import br.com.legalconnect.user.entity.User;

/**
 * @interface RefreshTokenRepository
 * @brief Repositório JPA para a entidade RefreshToken.
 *
 *        Fornece operações CRUD (Create, Read, Update, Delete) e métodos de
 *        consulta personalizados
 *        para gerenciar os tokens de atualização de sessão dos usuários.
 */
@Repository
public interface RefreshTokenRepository extends JpaRepository<RefreshToken, UUID> {

    /**
     * @brief Busca um RefreshToken pelo seu valor de token.
     * @param token O valor String do refresh token.
     * @return Um Optional contendo o RefreshToken, se encontrado.
     */
    Optional<RefreshToken> findByToken(String token);

    /**
     * @brief Busca um RefreshToken associado a um usuário específico.
     * @param user O objeto User para o qual o refresh token é procurado.
     * @return Um Optional contendo o RefreshToken, se encontrado.
     */
    Optional<RefreshToken> findByUser(User user);

    /**
     * @brief Deleta um RefreshToken pelo seu valor de token.
     * @param token O valor String do refresh token a ser deletado.
     */
    void deleteByToken(String token);
}
```
```java
package br.com.legalconnect.user.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.user.entity.Role;

@Repository
public interface RoleRepository extends JpaRepository<Role, UUID> {

    Optional<Role> findByNome(String roleClient);

}

```
```java
package br.com.legalconnect.user.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.user.entity.User;

/**
 * @interface UserRepository
 * @brief Repositório para a entidade User.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu e-mail.
     * 
     * @param email O e-mail do usuário.
     * @return Um Optional contendo o usuário, se encontrado.
     */
    Optional<User> findByEmail(String email);

    boolean existsByEmail(String email);

    boolean existsByCpf(String cpf);
}
```
```java
package br.com.legalconnect.user.service;

import java.util.UUID;

import org.springframework.stereotype.Service;

import br.com.legalconnect.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;

    public Boolean existsById(UUID id) {
        return userRepository.existsById(id);

    }
}

```
```java
package br.com.legalconnect.util;

public class Util {
    public static String sanitizeTenantId(String tenantId) {
        // Remove caracteres que não são letras, números ou underscore
        String cleaned = tenantId.replaceAll("[^a-zA-Z0-9]", "_");
        return cleaned;
    }
}

```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=auth-service

 
# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

# Habilita o Eureka Client
eureka.client.enabled=true
# URL do servidor Eureka onde o auth-service irá se registrar
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
application.security.jwt.password-reset-expiration-minutes=60
# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=360000000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=true
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
-- V1__initial_schema.sql
--
-- Flyway migration file for initial schema creation
-- Generated from PostgreSQL database dump on 2025-07-25
 

--
-- Table: tb_area_atuacao
--
CREATE TABLE tb_area_atuacao (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    descricao text,
    nome character varying(255) NOT NULL
);

--
-- Table: tb_certificacao_profissional
--
CREATE TABLE tb_certificacao_profissional (
    data_conclusao date,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    profissional_id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    instituicao character varying(255),
    nome character varying(255) NOT NULL
);

--
-- Table: tb_documento_profissional
--
CREATE TABLE tb_documento_profissional (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    profissional_id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    tipo_documento character varying(100) NOT NULL,
    url_s3 character varying(500) NOT NULL,
    nome_arquivo character varying(255) NOT NULL
);

--
-- Table: tb_endereco
--
CREATE TABLE tb_endereco (
    estado character varying(2) NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    cep character varying(9) NOT NULL,
    id uuid NOT NULL,
    pessoa_id uuid,
    numero character varying(20) NOT NULL,
    pais character varying(50) NOT NULL,
    tipo_endereco character varying(50) NOT NULL,
    bairro character varying(100) NOT NULL,
    cidade character varying(100) NOT NULL,
    complemento character varying(255),
    logradouro character varying(255) NOT NULL,
    CONSTRAINT tb_endereco_tipo_endereco_check CHECK (((tipo_endereco)::text = ANY ((ARRAY['RESIDENCIAL'::character varying, 'COMERCIAL'::character varying, 'ESCRITORIO'::character varying, 'COBRANCA'::character varying, 'ENTREGA'::character varying, 'OUTRO'::character varying])::text[])))
);

--
-- Table: tb_experiencia_profissional
--
CREATE TABLE tb_experiencia_profissional (
    data_fim date,
    data_inicio date NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    profissional_id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    cargo character varying(255) NOT NULL,
    descricao text,
    empresa character varying(255) NOT NULL
);

--
-- Table: tb_formacao_academica
--
CREATE TABLE tb_formacao_academica (
    data_conclusao date NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    profissional_id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    curso character varying(255) NOT NULL,
    instituicao character varying(255) NOT NULL
);

--
-- Table: tb_idioma
--
CREATE TABLE tb_idioma (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    codigo character varying(10) NOT NULL,
    id uuid NOT NULL,
    nivel character varying(50),
    nome character varying(100) NOT NULL
);

--
-- Table: tb_local_atuacao
--
CREATE TABLE tb_local_atuacao (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    nome character varying(255) NOT NULL
);

--
-- Table: tb_password_reset_token
--
CREATE TABLE tb_password_reset_token (
    tentativas integer DEFAULT 0 NOT NULL,
    usado boolean NOT NULL,
    created_at timestamp(6) without time zone NOT NULL,
    expira_em timestamp(6) with time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token text NOT NULL
);

--
-- Table: tb_pessoa
--
CREATE TABLE tb_pessoa (
    data_nascimento date,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    cpf character varying(14) NOT NULL,
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    nome_completo character varying(255) NOT NULL
);

--
-- Table: tb_pessoa_telefones
--
CREATE TABLE tb_pessoa_telefones (
    pessoa_id uuid NOT NULL,
    numero_telefone character varying(20)
);

--
-- Table: tb_profissional
--
CREATE TABLE tb_profissional (
    faz_parte_de_plano boolean NOT NULL,
    usa_marketplace boolean NOT NULL,
    empresa_id uuid,
    id uuid NOT NULL,
    pessoa_id uuid NOT NULL,
    plano_id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    numero_oab character varying(50) NOT NULL,
    status_profissional character varying(50) NOT NULL
);

--
-- Table: tb_profissional_area_atuacao
--
CREATE TABLE tb_profissional_area_atuacao (
    area_atuacao_id uuid NOT NULL,
    profissional_id uuid NOT NULL
);

--
-- Table: tb_profissional_idioma
--
CREATE TABLE tb_profissional_idioma (
    idioma_id uuid NOT NULL,
    profissional_id uuid NOT NULL
);

--
-- Table: tb_profissional_local_atuacao
--
CREATE TABLE tb_profissional_local_atuacao (
    local_atuacao_id uuid NOT NULL,
    profissional_id uuid NOT NULL
);

--
-- Table: tb_profissional_roles
--
CREATE TABLE tb_profissional_roles (
    profissional_id uuid NOT NULL,
    role_profissional_id uuid NOT NULL
);

--
-- Table: tb_profissional_tipo_atendimento
--
CREATE TABLE tb_profissional_tipo_atendimento (
    profissional_id uuid NOT NULL,
    tipo_atendimento_id uuid NOT NULL
);

--
-- Table: tb_refresh_token
--
CREATE TABLE tb_refresh_token (
    created_at timestamp(6) without time zone NOT NULL,
    expira_em timestamp(6) with time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    user_id uuid NOT NULL,
    token text NOT NULL
);

--
-- Table: tb_role
--
CREATE TABLE tb_role (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    nome character varying(100) NOT NULL,
    descricao text
);

--
-- Table: tb_role_profissional
--
CREATE TABLE tb_role_profissional (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    tenant_id uuid NOT NULL,
    name character varying(50) NOT NULL
);

--
-- Table: tb_tenant
--
CREATE TABLE tb_tenant (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    nome character varying(255) NOT NULL,
    schema_name character varying(255) NOT NULL
);

--
-- Table: tb_tipo_atendimento
--
CREATE TABLE tb_tipo_atendimento (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    id uuid NOT NULL,
    nome character varying(255) NOT NULL
);

--
-- Table: tb_user
--
CREATE TABLE tb_user (
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    cpf character varying(14),
    id uuid NOT NULL,
    tenant_id uuid  ,
    telefone character varying(20),
    status character varying(50) NOT NULL,
    user_type character varying(50) NOT NULL,
    email character varying(255) NOT NULL,
    foto_url text,
    nome_completo character varying(255) NOT NULL,
    senha_hash text NOT NULL,
    CONSTRAINT tb_user_status_check CHECK (((status)::text = ANY ((ARRAY['ACTIVE'::character varying, 'INACTIVE'::character varying, 'PENDING_APPROVAL'::character varying, 'REJECTED'::character varying, 'PENDING'::character varying])::text[]))),
    CONSTRAINT tb_user_user_type_check CHECK (((user_type)::text = ANY ((ARRAY['CLIENTE'::character varying, 'ADVOGADO'::character varying, 'PLATAFORMA_ADMIN'::character varying, 'SOCIO'::character varying])::text[])))
);

--
-- Table: tb_user_role
--
CREATE TABLE tb_user_role (
    role_id uuid NOT NULL,
    user_id uuid NOT NULL
);


--
-- Primary Key Constraints
--
ALTER TABLE ONLY tb_area_atuacao
    ADD CONSTRAINT tb_area_atuacao_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_certificacao_profissional
    ADD CONSTRAINT tb_certificacao_profissional_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_documento_profissional
    ADD CONSTRAINT tb_documento_profissional_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_endereco
    ADD CONSTRAINT tb_endereco_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_experiencia_profissional
    ADD CONSTRAINT tb_experiencia_profissional_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_formacao_academica
    ADD CONSTRAINT tb_formacao_academica_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_idioma
    ADD CONSTRAINT tb_idioma_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_local_atuacao
    ADD CONSTRAINT tb_local_atuacao_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_password_reset_token
    ADD CONSTRAINT tb_password_reset_token_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_pessoa
    ADD CONSTRAINT tb_pessoa_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_profissional_area_atuacao
    ADD CONSTRAINT tb_profissional_area_atuacao_pkey PRIMARY KEY (area_atuacao_id, profissional_id);

ALTER TABLE ONLY tb_profissional_idioma
    ADD CONSTRAINT tb_profissional_idioma_pkey PRIMARY KEY (idioma_id, profissional_id);

ALTER TABLE ONLY tb_profissional_local_atuacao
    ADD CONSTRAINT tb_profissional_local_atuacao_pkey PRIMARY KEY (local_atuacao_id, profissional_id);

ALTER TABLE ONLY tb_profissional
    ADD CONSTRAINT tb_profissional_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_profissional_roles
    ADD CONSTRAINT tb_profissional_roles_pkey PRIMARY KEY (profissional_id, role_profissional_id);

ALTER TABLE ONLY tb_profissional_tipo_atendimento
    ADD CONSTRAINT tb_profissional_tipo_atendimento_pkey PRIMARY KEY (profissional_id, tipo_atendimento_id);

ALTER TABLE ONLY tb_refresh_token
    ADD CONSTRAINT tb_refresh_token_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_role
    ADD CONSTRAINT tb_role_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_role_profissional
    ADD CONSTRAINT tb_role_profissional_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_tenant
    ADD CONSTRAINT tb_tenant_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_tipo_atendimento
    ADD CONSTRAINT tb_tipo_atendimento_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_user
    ADD CONSTRAINT tb_user_pkey PRIMARY KEY (id);

ALTER TABLE ONLY tb_user_role
    ADD CONSTRAINT tb_user_role_pkey PRIMARY KEY (role_id, user_id);

--
-- Unique Constraints
--
ALTER TABLE ONLY tb_area_atuacao
    ADD CONSTRAINT tb_area_atuacao_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_idioma
    ADD CONSTRAINT tb_idioma_codigo_key UNIQUE (codigo);

ALTER TABLE ONLY tb_idioma
    ADD CONSTRAINT tb_idioma_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_local_atuacao
    ADD CONSTRAINT tb_local_atuacao_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_password_reset_token
    ADD CONSTRAINT tb_password_reset_token_token_key UNIQUE (token);

ALTER TABLE ONLY tb_password_reset_token
    ADD CONSTRAINT tb_password_reset_token_user_id_key UNIQUE (user_id);

ALTER TABLE ONLY tb_pessoa
    ADD CONSTRAINT tb_pessoa_cpf_key UNIQUE (cpf);

ALTER TABLE ONLY tb_pessoa
    ADD CONSTRAINT tb_pessoa_user_id_key UNIQUE (user_id);

ALTER TABLE ONLY tb_profissional
    ADD CONSTRAINT tb_profissional_numero_oab_key UNIQUE (numero_oab);

ALTER TABLE ONLY tb_profissional
    ADD CONSTRAINT tb_profissional_pessoa_id_key UNIQUE (pessoa_id);

ALTER TABLE ONLY tb_refresh_token
    ADD CONSTRAINT tb_refresh_token_token_key UNIQUE (token);

ALTER TABLE ONLY tb_refresh_token
    ADD CONSTRAINT tb_refresh_token_user_id_key UNIQUE (user_id);

ALTER TABLE ONLY tb_role
    ADD CONSTRAINT tb_role_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_role_profissional
    ADD CONSTRAINT tb_role_profissional_name_key UNIQUE (name);

ALTER TABLE ONLY tb_tenant
    ADD CONSTRAINT tb_tenant_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_tenant
    ADD CONSTRAINT tb_tenant_schema_name_key UNIQUE (schema_name);

ALTER TABLE ONLY tb_tipo_atendimento
    ADD CONSTRAINT tb_tipo_atendimento_nome_key UNIQUE (nome);

ALTER TABLE ONLY tb_user
    ADD CONSTRAINT tb_user_cpf_key UNIQUE (cpf);

ALTER TABLE ONLY tb_user
    ADD CONSTRAINT tb_user_email_key UNIQUE (email);

--
-- Foreign Key Constraints
--
ALTER TABLE ONLY tb_user
    ADD CONSTRAINT fk2y7b2wurvfj95cr2sux1ayt0u FOREIGN KEY (tenant_id) REFERENCES tb_tenant(id);

ALTER TABLE ONLY tb_profissional_local_atuacao
    ADD CONSTRAINT fk3v36h6886evi6depyes3ivdux FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_profissional_area_atuacao
    ADD CONSTRAINT fk4aqydql7eiebu149yt2u3ssoy FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_user_role
    ADD CONSTRAINT fk7vn3h53d0tqdimm8cp45gc0kl FOREIGN KEY (user_id) REFERENCES tb_user(id);

ALTER TABLE ONLY tb_password_reset_token
    ADD CONSTRAINT fk84f3gn2ewih92oshfpwlorn0b FOREIGN KEY (user_id) REFERENCES tb_user(id);

ALTER TABLE ONLY tb_profissional_idioma
    ADD CONSTRAINT fk9tf311acnlr50799r9xcgqrwm FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_formacao_academica
    ADD CONSTRAINT fkaketpucc7qq6qt9rk0bndhci4 FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_profissional_roles
    ADD CONSTRAINT fka7ctp74d636vw7k89ggehwt7v FOREIGN KEY (role_profissional_id) REFERENCES tb_role_profissional(id);

ALTER TABLE ONLY tb_profissional_roles
    ADD CONSTRAINT fkcmi65kmf7713ic47pipnimds5 FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_profissional_tipo_atendimento
    ADD CONSTRAINT fkcr4ospg4rmn9nw32b7y6vcq83 FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_user_role
    ADD CONSTRAINT fkea2ootw6b6bb0xt3ptl28bymv FOREIGN KEY (role_id) REFERENCES tb_role(id);

ALTER TABLE ONLY tb_profissional
    ADD CONSTRAINT fkfrod9e0odxnybahs2vyag4h9e FOREIGN KEY (id) REFERENCES tb_pessoa(id);

ALTER TABLE ONLY tb_documento_profissional
    ADD CONSTRAINT fkkj3pae2qtbdbbobeex90odg3x FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_certificacao_profissional
    ADD CONSTRAINT fkkscnhmu05xaimf9rtwftquxdf FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_refresh_token
    ADD CONSTRAINT fkl86d47obg6eykx5gfwgjm1jfa FOREIGN KEY (user_id) REFERENCES tb_user(id);

ALTER TABLE ONLY tb_experiencia_profissional
    ADD CONSTRAINT fkn9vr54fduu4ed4pg1ymnt04mj FOREIGN KEY (profissional_id) REFERENCES tb_profissional(id);

ALTER TABLE ONLY tb_endereco
    ADD CONSTRAINT fkolr88x7vhtskdguw79l1oeaht FOREIGN KEY (pessoa_id) REFERENCES tb_pessoa(id);

ALTER TABLE ONLY tb_pessoa_telefones
    ADD CONSTRAINT fkqe0j8mdopuutux01tifx3fhgg FOREIGN KEY (pessoa_id) REFERENCES tb_pessoa(id);

```
```java
CREATE TABLE IF NOT EXISTS tb_depoimento (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    texto VARCHAR(500) NOT NULL,
    nome VARCHAR(100) NOT NULL,
    local VARCHAR(100),
    foto_url VARCHAR(255),
    user_id UUID NOT NULL,
    tipo_depoimento VARCHAR(20) NOT NULL,
    status VARCHAR(20) NOT NULL DEFAULT 'PENDENTE',
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);
```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.12</version> <!-- Usando a versão que você sugeriu -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <groupId>br.com.legalconnect.common</groupId> <!-- Alterado conforme sua sugestão -->
    <artifactId>common-lib</artifactId>
    <version>1.0.0</version>
    <name>LegalConnect Common Library</name>
    <description>Common utilities, entities, and configurations for LegalConnect microservices</description>
    <packaging>jar</packaging> <!-- Define este como um JAR de biblioteca -->

    <properties>
        <java.version>17</java.version> <!-- Defina a versão do Java que você está usando -->
        <lombok.version>1.18.30</lombok.version> <!-- Versão explícita para Lombok -->
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Versão explícita para
        MapStruct -->
        <springdoc.version>2.3.0</springdoc.version> <!-- Versão explícita para SpringDoc -->
        <flyway.version>9.22.3</flyway.version> <!-- Versão explícita para Flyway -->
    </properties>

    <dependencies>
        <!-- Spring Boot Starter Validation para anotações de validação em DTOs -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency> -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>com.zaxxer</groupId>
                    <artifactId>HikariCP</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!-- Spring Context para anotações como @Configuration, @Component, etc. -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
        <!-- Spring Security Core para GrantedAuthority (usado em UserDetails, por exemplo) -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>

        <!-- <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency> -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version> <!-- Usando a versão definida nas propriedades -->
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version> <!-- Usando a versão definida nas propriedades -->
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
legalconnect/
├── common-lib/
│   ├── pom.xml                                 # Configurações do Maven para a biblioteca comum
│   └── src/
│       └── main/
│           └── java/
│               └── br/com/legalconnect/common/
│                   ├── BaseEntity.java         # Entidade base para todos os modelos de dados
│                   ├── config/
│                   │   ├── FlywayMultiTenantConfig.java # Configuração Flyway para multitenancy (se global)
│                   │   ├── OpenApiConfig.java           # Configuração OpenAPI/Swagger UI
│                   │   └── WebConfig.java               # Configurações CORS e MVC gerais
│                   ├── constants/
│                   │   ├── ErrorCode.java               # Códigos de erro padronizados
│                   │   └── Roles.java                   # Constantes para papéis de usuário
│                   ├── dto/
│                   │   ├── BaseResponse.java            # DTO base para respostas da API
│                   │   └── SuccessResponseDTO.java      # DTO para respostas de sucesso simples
│                   ├── exception/
│                   │   ├── BusinessException.java       # Exceção de negócio personalizada
│                   │   └── GlobalExceptionHandler.java  # Manipulador global de exceções
│                   ├── multitenancy/
│                   │   ├── HibernateMultiTenantConfig.java # Configuração Hibernate para multitenancy
│                   │   ├── SchemaMultiTenantConnectionProvider.java # Provedor de conexão multi-tenant
│                   │   ├── SchemaTenantIdentifierResolver.java    # Resolvedor de identificador de tenant
│                   │   ├── TenantContext.java                     # Contexto da thread para o tenant atual
│                   │   └── TenantFilter.java                    # Filtro HTTP para extrair o tenant ID
│                   └── util/
│                       └── ValidatorUtil.java           # Utilitários de validação (ex: CPF, CNPJ)
```
```java
package br.com.legalconnect.common.dto;
// common/BaseEntity.java

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.persistence.Column;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class BaseEntity
 * @brief Classe base abstrata para todas as entidades persistentes.
 *        Fornece campos comuns como ID, data de criação e data de atualização.
 */
@Getter
@Setter
@NoArgsConstructor
@SuperBuilder
@MappedSuperclass // Indica que esta classe é uma superclasse mapeada para outras entidades
public abstract class BaseEntity implements Serializable {

    private static final Logger log = LoggerFactory.getLogger(BaseEntity.class);

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    protected UUID id; // Identificador único da entidade

    @Column(name = "created_at", nullable = false)
    protected LocalDateTime createdAt; // Data e hora de criação do registro

    @Column(name = "updated_at", nullable = false)
    protected LocalDateTime updatedAt; // Data e hora da última atualização do registro

    /**
     * Define a data de criação antes de persistir a entidade.
     */
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        log.debug("Criando entidade: {}. Data de criação: {}", this.getClass().getSimpleName(), createdAt);
    }

    /**
     * Atualiza a data de atualização antes de atualizar a entidade.
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        log.debug("Atualizando entidade: {}. ID: {}. Data de atualização: {}", this.getClass().getSimpleName(), id,
                updatedAt);
    }
}

```
```java
package br.com.legalconnect.common.dto;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonInclude;

import br.com.legalconnect.enums.StatusResponse;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class BaseResponse
 * @brief DTO base para padronizar as respostas da API.
 *
 *        Inclui campos comuns para todas as respostas, como status, mensagem,
 *        timestamp e, opcionalmente, uma lista de erros.
 *        Utiliza Lombok para reduzir boilerplate (getters, setters,
 *        construtores, builder).
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL) // Inclui apenas campos não nulos na serialização JSON
public class BaseResponse<T> {

    private StatusResponse status; // Status da resposta (ex: StatusResponse.SUCESSO, StatusResponse.ERRO,
                                   // "WARNING")
    private String message; // Mensagem descritiva da resposta
    private LocalDateTime timestamp; // Data e hora da resposta
    private T data; // Payload da resposta (dados de sucesso)
    private List<String> errors; // Lista de mensagens de erro, se houver
}
```
```java
package br.com.legalconnect.common.dto;

import java.time.LocalDateTime;

import br.com.legalconnect.enums.StatusResponse;
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * @class SuccessResponseDTO
 * @brief DTO para respostas de sucesso simples da API.
 *
 *        Estende {@link BaseResponse} e é usado para indicar operações
 *        bem-sucedidas
 *        que podem ou não retornar dados específicos.
 */
@Data
@EqualsAndHashCode(callSuper = true) // Inclui campos da superclasse no equals e hashCode
public class SuccessResponseDTO extends BaseResponse {

    /**
     * Construtor padrão para uma resposta de sucesso.
     * Define o status como StatusResponse.SUCESSO e o timestamp atual.
     */
    public SuccessResponseDTO() {
        this.setStatus(StatusResponse.SUCESSO);
        this.setTimestamp(LocalDateTime.now());
    }

    /**
     * Construtor para uma resposta de sucesso com uma mensagem específica.
     *
     * @param message A mensagem descritiva do sucesso.
     */
    public SuccessResponseDTO(String message) {
        this(); // Chama o construtor padrão para definir status e timestamp
        this.setMessage(message);
    }
}
```
```java
package br.com.legalconnect.common.exception;

import org.springframework.http.HttpStatus;

import lombok.Getter;

/**
 * @class BusinessException
 * @brief Exceção personalizada para representar erros de negócio na aplicação.
 *
 *        Esta exceção é lançada quando uma regra de negócio não é satisfeita.
 *        Ela encapsula um {@link ErrorCode} e, opcionalmente, argumentos para
 *        formatar
 *        a mensagem de erro, além de um status HTTP para a resposta da API.
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode; // O código de erro padronizado
    private final String[] args; // Argumentos para formatar a mensagem do erro
    private final HttpStatus httpStatus; // Status HTTP associado a esta exceção

    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String args) {
        super(args);
        this.errorCode = errorCode;
        this.args = new String[] { args, errorCode.getMessage() };
        this.httpStatus = httpStatus;
    }

    /**
     * Construtor para BusinessException com um ErrorCode e status HTTP padrão
     * (BAD_REQUEST).
     *
     * @param errorCode O código de erro que define o tipo de exceção de negócio.
     * @param args      Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, String... args) {
        this(errorCode, HttpStatus.BAD_REQUEST, args); // Por padrão, erros de negócio são BAD_REQUEST
    }

    /**
     * Construtor para BusinessException com um ErrorCode e um status HTTP
     * específico.
     *
     * @param errorCode  O código de erro que define o tipo de exceção de negócio.
     * @param httpStatus O status HTTP a ser retornado na resposta da API.
     * @param args       Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String... args) {
        super(errorCode.getFormattedMessage(args)); // Define a mensagem da exceção usando a mensagem formatada do
                                                    // ErrorCode
        this.errorCode = errorCode;
        this.args = args;
        this.httpStatus = httpStatus;

    }

    /**
     * @brief Retorna a mensagem de erro formatada.
     * @return A mensagem de erro formatada.
     */
    @Override
    public String getMessage() {
        return errorCode.getFormattedMessage(args);
    }

    /**
     * @brief Retorna o código de erro.
     * @return O código de erro.
     */
    public String getCode() {
        return errorCode.getCode();
    }
}
```
```java
package br.com.legalconnect.common.exception;

import lombok.Getter;

/**
 * @enum ErrorCode
 * @brief Enumeração que define códigos de erro padronizados para a aplicação.
 *
 *        Cada código de erro possui uma mensagem associada, facilitando a
 *        padronização
 *        de respostas de erro na API e a internacionalização ou localização
 *        futura.
 */
@Getter
public enum ErrorCode {
    // Erros gerais de validação
    DADOS_INVALIDOS("001", "Dados fornecidos são inválidos."),
    REQUISICAO_MAL_FORMADA("002", "A requisição está mal formada."),
    PARAMETRO_AUSENTE("003", "Parâmetro obrigatório ausente."),

    // Erros de entidade / negócio
    ENTIDADE_NAO_ENCONTRADA("100", "Entidade não encontrada."),
    EMPRESA_NAO_ENCONTRADA("101", "Empresa não encontrada."),
    PROFISSIONAL_NAO_ENCONTRADO("102", "Profissional não encontrado."),
    CLIENTE_NAO_ENCONTRADO("103", "Cliente não encontrado."),
    ADMINISTRADOR_NAO_ENCONTRADO("104", "Administrador não encontrado."),
    PLANO_NAO_ENCONTRADO("105", "Plano não encontrado."),
    USER_NAO_ENCONTRADO("106", "Usuário associado não encontrado."),

    // Erros de duplicidade
    CNPJ_DUPLICADO("200", "CNPJ já cadastrado."),
    CPF_DUPLICADO("201", "CPF já cadastrado."),
    OAB_DUPLICADA("202", "Número da OAB já cadastrado."),
    EMAIL_DUPLICADO("203", "Email já cadastrado."),
    NOME_PLANO_DUPLICADO("204", "Nome do plano já cadastrado."),

    // Erros de integridade
    INTEGRIDADE_VIOLADA("300", "Violação de integridade de dados."),
    RECURSO_EM_USO("301", "Recurso não pode ser excluído pois está em uso."),

    // Erros de sistema / internos
    ERRO_INTERNO_SERVIDOR("500", "Ocorreu um erro interno no servidor."),
    SERVICO_INDISPONIVEL("503", "Serviço temporariamente indisponível."),

    // Erros Gerais/Comuns (1000-1999)
    GENERIC_ERROR("1000", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde."),
    INVALID_INPUT("1001", "Dados de entrada inválidos."),
    RESOURCE_NOT_FOUND("1002", "Recurso não encontrado."),
    UNAUTHORIZED_ACCESS("1003", "Acesso não autorizado. Credenciais inválidas ou ausentes."),
    FORBIDDEN_ACCESS("1004", "Acesso negado. Você não tem permissão para realizar esta ação."),
    SERVICE_UNAVAILABLE("1005", "O serviço está temporariamente indisponível. Tente novamente mais tarde."),
    TOO_MANY_REQUESTS("1006", "Muitas requisições. Por favor, aguarde e tente novamente."),
    VALIDATION_ERROR("1007", "Erro de validação nos dados fornecidos."),
    DATABASE_ERROR("1008", "Erro ao acessar o banco de dados."),
    INTEGRATION_ERROR("1009", "Erro de integração com serviço externo."),

    // Erros de Autenticação e Autorização (2000-2999)
    INVALID_CREDENTIALS("2000", "Credenciais de autenticação inválidas."),
    ACCOUNT_LOCKED("2001", "Sua conta está bloqueada."),
    ACCOUNT_DISABLED("2002", "Sua conta está desativada."),
    TOKEN_EXPIRED("2003", "O token de acesso expirou."),
    INVALID_TOKEN("2004", "O token de acesso é inválido."),
    REFRESH_TOKEN_EXPIRED("2005", "O refresh token expirou. Faça login novamente."),
    INVALID_REFRESH_TOKEN("2006", "O refresh token é inválido."),
    USER_NOT_FOUND("2007", "Usuário não encontrado."),
    EMAIL_ALREADY_REGISTERED("2008", "Este e-mail já está cadastrado."),
    PASSWORD_RESET_FAILED("2009", "Falha ao redefinir a senha."),
    INVALID_CURRENT_PASSWORD("2010", "A senha atual fornecida está incorreta."), // Novo erro
    PASSWORD_RESET_TOKEN_INVALID("2011", "Token de redefinição de senha inválido."), // Novo erro
    PASSWORD_RESET_TOKEN_EXPIRED("2012", "Token de redefinição de senha expirado."), // Novo erro
    PASSWORD_RESET_TOKEN_USED("2013", "Token de redefinição de senha já utilizado."), // Novo erro
    PASSWORD_RESET_TOKEN_EXCEEDED("2014", "Limite de redefinições de senha excedido."), // Novo erro

    // Erros de Negócio Específicos (3000-3999) - Exemplo
    TENANT_NOT_FOUND("3000", "Tenant não encontrado."),
    TENANT_DISABLED("3001", "O tenant está desativado."),
    SUBSCRIPTION_EXPIRED("3002", "Sua assinatura expirou."),
    PLAN_NOT_ACTIVE("3003", "O plano selecionado não está ativo."),
    SERVICE_LIMIT_EXCEEDED("3004", "Limite de serviços agendáveis excedido para o seu plano."),
    ADVOCATE_NOT_AVAILABLE("3005", "Advogado não disponível no horário selecionado."),
    APPOINTMENT_CONFLICT("3006", "Conflito de agendamento. O horário já está ocupado."),
    PAYMENT_FAILED("3007", "Falha no processamento do pagamento."),
    INVALID_PROMO_CODE("3008", "Código promocional inválido ou expirado."),
    DOCUMENT_UPLOAD_FAILED("3009", "Falha ao fazer upload do documento."),
    INVALID_DOCUMENT_FORMAT("3010", "Formato de documento inválido."),

    // Erros de Validação de Campo (4000-4999) - Mais específicos, geralmente
    // tratados por @Valid
    FIELD_REQUIRED("4000", "O campo '%s' é obrigatório."),
    INVALID_FORMAT("4001", "O campo '%s' possui formato inválido."),
    MIN_LENGTH("4002", "O campo '%s' deve ter no mínimo %d caracteres."),
    MAX_LENGTH("4003", "O campo '%s' deve ter no máximo %d caracteres."),
    INVALID_EMAIL("4004", "O e-mail fornecido é inválido."),
    INVALID_CPF("4005", "O CPF fornecido é inválido."),
    INVALID_CNPJ("4006", "O CNPJ fornecido é inválido."),
    PASSWORD_TOO_WEAK("4007", "A senha é muito fraca."),
    DATE_IN_PAST("4008", "A data não pode ser no passado."),
    INVALID_ENUM_VALUE("4009", "Valor inválido para o campo '%s'.");

    private final String code;
    private final String message;

    /**
     * Construtor para ErrorCode.
     *
     * @param code    O código único do erro.
     * @param message A mensagem descritiva do erro.
     */
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    /**
     * @brief Retorna a mensagem de erro formatada com argumentos.
     * @param args Argumentos para formatar a mensagem.
     * @return A mensagem de erro formatada.
     */
    public String getFormattedMessage(Object... args) {
        return String.format(this.message, args);
    }
}

```
```java
package br.com.legalconnect.common.exception;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import lombok.extern.slf4j.Slf4j;

/**
 * @class GlobalExceptionHandler
 * @brief Manipulador global de exceções para a aplicação Spring Boot.
 *
 *        Esta classe intercepta exceções lançadas em qualquer parte da
 *        aplicação
 *        e as transforma em respostas de erro padronizadas da API, utilizando
 *        {@link BaseResponse}.
 *        Lida com {@link BusinessException} e exceções de validação do Spring,
 *        além de capturar exceções genéricas.
 */
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

        /**
         * @brief Manipula exceções de negócio personalizadas
         *        ({@link BusinessException}).
         *
         *        Retorna uma resposta de erro com o status HTTP e a mensagem definidos
         *        na BusinessException.
         *
         * @param ex      A exceção de negócio lançada.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro.
         */
        @ExceptionHandler(BusinessException.class)
        public ResponseEntity<BaseResponse> handleBusinessException(BusinessException ex, WebRequest request) {
                log.warn("Business Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ex.getMessage())
                                .errors(List.of(ex.getCode())) // Adiciona o código de erro como parte dos erros
                                .timestamp(LocalDateTime.now())
                                .errors(Arrays.asList(ex.getArgs())) // Adiciona os argumentos da exceção como parte dos
                                .build();

                return new ResponseEntity<>(errorResponse, ex.getHttpStatus());
        }

        /**
         * @brief Manipula exceções de validação de argumentos de método
         *        ({@link MethodArgumentNotValidException}).
         *
         *        Ocorre quando a validação de um DTO de entrada falha (ex:
         *        campos @NotNull, @Size).
         *        Coleta todos os erros de campo e os retorna em uma lista na resposta.
         *
         * @param ex      A exceção de validação.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} com os
         *         erros de validação.
         */
        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<BaseResponse> handleValidationExceptions(MethodArgumentNotValidException ex,
                        WebRequest request) {
                List<String> errors = ex.getBindingResult().getAllErrors().stream()
                                .map(error -> {
                                        String fieldName = (error instanceof FieldError)
                                                        ? ((FieldError) error).getField()
                                                        : error.getObjectName();
                                        String errorMessage = error.getDefaultMessage();
                                        return String.format("Campo '%s': %s", fieldName, errorMessage);
                                })
                                .collect(Collectors.toList());

                log.warn("Validation Exception: {} - Errors: {} - Path: {}", ex.getMessage(), errors,
                                request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.VALIDATION_ERROR.getMessage())
                                .errors(errors)
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
        }

        /**
         * @brief Manipula todas as outras exceções não tratadas especificamente.
         *
         *        Captura qualquer {@link Exception} genérica, registra o erro e retorna
         *        uma resposta de erro genérica com status HTTP 500 (Internal Server
         *        Error).
         *
         * @param ex      A exceção genérica.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro
         *         genérico.
         */
        @ExceptionHandler(Exception.class)
        public ResponseEntity<BaseResponse> handleGlobalException(Exception ex, WebRequest request) {
                log.error("Unhandled Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false), ex);

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.GENERIC_ERROR.getMessage())
                                .errors(List.of(ErrorCode.GENERIC_ERROR.getCode())) // Adiciona o código de erro
                                                                                    // genérico
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
        }
}
```
```java
package br.com.legalconnect.common.exception;

/**
 * @class Roles
 * @brief Classe de constantes para os papéis (roles) de usuário na aplicação.
 *
 *        Define os nomes dos papéis como constantes estáticas para evitar erros
 *        de digitação
 *        e centralizar a gestão dos papéis utilizados na segurança da
 *        aplicação.
 */
public final class Roles {

    // Papéis de Usuário
    public static final String ROLE_ADMIN = "ROLE_ADMIN"; // Administrador do sistema
    public static final String ROLE_TENANT_ADMIN = "ROLE_TENANT_ADMIN"; // Administrador de um tenant específico
    public static final String ROLE_ADVOCATE = "ROLE_ADVOCATE"; // Advogado
    public static final String ROLE_CLIENT = "ROLE_CLIENT"; // Cliente final
    public static final String ROLE_USER = "ROLE_USER"; // Usuário genérico (pode ser usado para usuários logados sem um
                                                        // papel específico mais alto)

    // Prefixos e Sufixos (se necessário, para Spring Security, por exemplo)
    public static final String PREFIX = "ROLE_"; // Prefixo padrão para papéis no Spring Security

    /**
     * Construtor privado para evitar instanciação.
     */
    private Roles() {
        // Construtor privado para garantir que a classe não seja instanciada.
        // É uma classe de utilidade com apenas constantes estáticas.
    }

    /**
     * @brief Converte um nome de papel para o formato esperado pelo Spring Security
     *        (com prefixo "ROLE_").
     * @param roleName O nome do papel sem o prefixo.
     * @return O nome do papel com o prefixo "ROLE_".
     */
    public static String withPrefix(String roleName) {
        if (roleName != null && !roleName.startsWith(PREFIX)) {
            return PREFIX + roleName;
        }
        return roleName;
    }

    /**
     * @brief Remove o prefixo "ROLE_" de um nome de papel.
     * @param roleName O nome do papel com ou sem o prefixo.
     * @return O nome do papel sem o prefixo "ROLE_".
     */
    public static String withoutPrefix(String roleName) {
        if (roleName != null && roleName.startsWith(PREFIX)) {
            return roleName.substring(PREFIX.length());
        }
        return roleName;
    }
}
```
```java
package br.com.legalconnect.common.util;

import java.util.InputMismatchException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @class ValidatorUtil
 * @brief Classe utilitária para validações comuns, como CPF e CNPJ.
 *
 *        Contém métodos estáticos para validar documentos brasileiros,
 *        que são frequentemente necessários em aplicações de negócio.
 */
public final class ValidatorUtil {

    private static final String EMAIL_REGEX = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
    private static final Pattern EMAIL_PATTERN = Pattern.compile(EMAIL_REGEX);

    /**
     * Construtor privado para evitar instanciação.
     */
    private ValidatorUtil() {
        // Construtor privado para garantir que a classe não seja instanciada.
        // É uma classe de utilidade com apenas métodos estáticos.
    }

    /**
     * @brief Valida se um CPF é válido.
     *
     *        Implementa o algoritmo de validação de CPF brasileiro,
     *        incluindo a verificação dos dígitos verificadores.
     *
     * @param cpf O número do CPF (apenas dígitos).
     * @return True se o CPF for válido, false caso contrário.
     */
    public static boolean isValidCPF(String cpf) {
        if (cpf == null || cpf.length() != 11 || cpf.matches("(\\d)\\1{10}")) {
            return false; // CPF nulo, com tamanho diferente de 11 ou com todos os dígitos iguais
        }

        char dig10, dig11;
        int sm, i, r, num, peso;

        try {
            // Calculo do 1o. Digito Verificador
            sm = 0;
            peso = 10;
            for (i = 0; i < 9; i++) {
                num = (int) (cpf.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso - 1;
            }

            r = 11 - (sm % 11);
            if ((r == 10) || (r == 11))
                dig10 = '0';
            else
                dig10 = (char) (r + 48);

            // Calculo do 2o. Digito Verificador
            sm = 0;
            peso = 11;
            for (i = 0; i < 10; i++) {
                num = (int) (cpf.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso - 1;
            }

            r = 11 - (sm % 11);
            if ((r == 10) || (r == 11))
                dig11 = '0';
            else
                dig11 = (char) (r + 48);

            // Verifica se os dígitos calculados conferem com os dígitos informados.
            return (dig10 == cpf.charAt(9)) && (dig11 == cpf.charAt(10));
        } catch (InputMismatchException erro) {
            return false;
        }
    }

    /**
     * @brief Valida se um CNPJ é válido.
     *
     *        Implementa o algoritmo de validação de CNPJ brasileiro,
     *        incluindo a verificação dos dígitos verificadores.
     *
     * @param cnpj O número do CNPJ (apenas dígitos).
     * @return True se o CNPJ for válido, false caso contrário.
     */
    public static boolean isValidCNPJ(String cnpj) {
        if (cnpj == null || cnpj.length() != 14 || cnpj.matches("(\\d)\\1{13}")) {
            return false; // CNPJ nulo, com tamanho diferente de 14 ou com todos os dígitos iguais
        }

        char dig13, dig14;
        int sm, i, r, num, peso;

        try {
            // Calculo do 1o. Digito Verificador
            sm = 0;
            peso = 2;
            for (i = 11; i >= 0; i--) {
                num = (int) (cnpj.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso + 1;
                if (peso == 10)
                    peso = 2;
            }

            r = sm % 11;
            if ((r == 0) || (r == 1))
                dig13 = '0';
            else
                dig13 = (char) ((11 - r) + 48);

            // Calculo do 2o. Digito Verificador
            sm = 0;
            peso = 2;
            for (i = 12; i >= 0; i--) {
                num = (int) (cnpj.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso + 1;
                if (peso == 10)
                    peso = 2;
            }

            r = sm % 11;
            if ((r == 0) || (r == 1))
                dig14 = '0';
            else
                dig14 = (char) ((11 - r) + 48);

            // Verifica se os dígitos calculados conferem com os dígitos informados.
            return (dig13 == cnpj.charAt(12)) && (dig14 == cnpj.charAt(13));
        } catch (InputMismatchException erro) {
            return false;
        }
    }

    /**
     * @brief Valida se um endereço de e-mail é válido.
     *
     *        Utiliza uma expressão regular para verificar o formato do e-mail.
     *
     * @param email O endereço de e-mail a ser validado.
     * @return True se o e-mail for válido, false caso contrário.
     */
    public static boolean isValidEmail(String email) {
        if (email == null) {
            return false;
        }
        Matcher matcher = EMAIL_PATTERN.matcher(email);
        return matcher.matches();
    }
}
```
```java
package br.com.legalconnect.enums;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
spring.application.name=common-lib

# Configuração Multi-Tenant
# spring.jpa.properties.hibernate.multiTenancy=SCHEMA 
# spring.jpa.properties.hibernate.tenant_identifier_resolver=br.com.legalconnect.common.multitenancy.HeaderTenantIdentifierResolver
# # For application.properties
# spring.jpa.properties.hibernate.multi_tenant_connection_provider=br.com.legalconnect.common.multitenancy.SchemaMultiTenantConnectionProvider
# # Configuração do tenant
# application.tenant.header-name=X-Tenant-ID
# application.tenant.default-id=public

# # Configurações do DataSource
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.main.allow-bean-definition-overriding=true
springdoc.packages-to-scan=br.com.legalconnect
springdoc.paths-to-match=/api/v1/**
springdoc.openapi.version=3.0.1
spring.flyway.enabled=true
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
```
```java
PK
    7EúZ            	   META-INF/PK   7EúZeU´ï   £      META-INF/MANIFEST.MFeA
0E÷Bî0´¸(dW³ª(H[º©&cÁÛWwîß{ÿwÈþE³èåÙ'6p,ª°PÈéz5Ðáóú°¡*«©nÜ[ß&6ñ¤KEbAÙbúî%F61Ó `S¡õÏyýS~ì+ªøPK
    7EúZ               br/PK
    7EúZ               br/com/PK
    7EúZ               br/com/legalconnect/PK
    7EúZ               br/com/legalconnect/common/PK
    7EúZ               br/com/legalconnect/common/dto/PK
    7EúZ            %   br/com/legalconnect/common/exception/PK
    7EúZ                br/com/legalconnect/common/util/PK
    7EúZ               br/com/legalconnect/enums/PK
    7EúZ               META-INF/maven/PK
    7EúZ            *   META-INF/maven/br.com.legalconnect.common/PK
    7EúZ            5   META-INF/maven/br.com.legalconnect.common/common-lib/PK   6EúZÙëÛî       application.propertiesMnÛ0÷>dTÓ´Zvda ¨»èN#E²$eÃ(z.z ëèÏq]-¼ßÌ¼yOÁye*Îi% *k¸3aÆ¦U±XÜ$+kJUµ^~¿ü²É¦ÕQ±¯hÀDz
Ãî¼uè£ÂÀkU 77ÞÓâmW7+Úb??WMT¥B{VïÑgç$k¬@kÈÅÃ²8,ãý ôé4çË84Ü$¬OÎ¯ríeù(tBCr÷¤ûz¡[QcQquöyÕ«½BÚ$N)1yÝÏú@¿y±§õ<,±ÚÏÌ\[Ðëâ¿0t+×ak[/p1$©ú
o½Îv²KgC¬(±ïz¦Ú
Ð5Uïß=¼Mwmpbi}ËbnJè&ÙDvß3ÖË¾g0éEÍ&dpÂú¿ãë:PÖöÀ
ÃÈeTç³y%Ê¢o§Û¥$E<CEË 3û?x¬{¶(ê,§Òý}zwwÆÐÏf¨Îig åÙÃï'¥>àÈ(4Ês5ÓSÂíÙt~^¢dï<;fpÙp2~®iz¼lê~ÎÅõIt,e6ªò}ý/PK   7EúZ^!f  R	  A   br/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder.class¥UÛrE=cË^IYð-¶0\À	+å²Ü!YÉÁmì âTÙI¨âi¤ìW;®Ý«ò|U¨<ð|EÏîÆ-¡²J;==Ó}NoO÷Ì?ÿ¾ú@
ß1I9Sf}ÎO¸ððÀÝm=mÍ0]¡ÔkNùiy,m\Íàµ"·­:n xÐVaHf¡£B××Ê­óXlZê«½i½+_DÒ'ÆfBÙÕ2p<ÙÙðDñ¶Ì2äbüÄðÀ)7Ç`òLÔó6p¡Ð×Â_§_[N¹µì·©Ú<Ø }Ò%¥Ä£{ì§E,ã]+6ÞÃûgµ§#0X'<è]ù¦Ó<K¯Ü<ïáÍÓ1\µq
×J~$*lsýLêCÅ:fxèô{^de !%µ¡|Á0Ó¡xÔí´D´Ï[­Ì'9xÊ#iôl1§%EPë Îb¿8~¿9pu¿áí×½5"ØuÎÒx5CÇû½ÐÊÌ#ÞZDÂ<¹îFøb?!Âðó¿U5nDW@'ÜSN&[ÆáÎ(ù7Hæµz]ÑEôsµqèúÆCy­¿§{ªµÅ4å4Ós¾klé_Xo«X[¸ÏP¾pT u¥t¬#~VB<3Zkx`áÓ³ë«½dx¢D¢´·x[« ~y³3Ãt~ âÕ¦RGÝãá]}ÆÑôÐ ó_;DÁÔÂË£ÁP}#i}Éw¤_c·¯^F9½k¬Ì`ïP£FÀãXPÌõAXøáÆ`aê|¸)½I©qî:]ÓtNÒHÍ&Ì-ÈR"-0ó²Ñøië$É©Ê`¿%Ò8,^Å*vj¸Iò£3+IFDeò3pÆÐ+·þUy·~¹Zefv)Aí¡3ôa2³¸üÅmÚ^ÀAs£¬!\8%¼KÛ¥Á£z¹yìÉ(ÕÝÃÇøäTÿfáóì¹[©üë/¼Cb.$^á
08Â4¾s]ÉâÊè¾Àü
_'ò<y²­ÒWÇió´§Í\[ØÆC,ÿPK   7EúZÄÝ÷  »  /   br/com/legalconnect/common/dto/BaseEntity.class¥VßWGþlÑÖ²mÕZ
 Ä¦
H
ÐmífwÝÍ¦=¶§MúZ¬Zí9íoý£zzgv	!¬-çø¹?¾{ï7wîæïþøÀ,Ü4úSWÑÃè¶þ®ùVk×ÐíEÝçktb9î÷'ó7SH"¥ ­b *ÃdÍÓ·¡Ù¼®Ûë8Üð á:é»ÚÞâ·ßò0¤9ï3øÏ C*2=ÕnQÅQJÒvëÙëÕµýðÊ6!ÔëÜ+&ñÃTÉ³tÇtsÂºÉoä~üi:GøzÎä9´¯yý³+Äiâ¸*ÞÅIa­;uínm*aHÖ¹_²õVáè.+Ò@
iÆc*rgÈôèÉ¿j56_ÑÁÇöT}ÏrêÅÅs*Îã¥Ñ[C¿Ékm*úzþ w¥7ëÉäFÅy¿­ÛÖü÷ó¤®Ä
L©¸K}IiaÚ¾ekëëåEY&jx!èý¨¼Ä|¨â2®0$f,Çòçèó)|)×(ëC÷ØÄÞv¡mÙ&÷JJü¥QÄYs¸Io ä%Ýð]O´)]Ù.ïçò®|ò`ß)§«U9µ ®fÓ¸×vDoX-óãúºo¹5Çq¬{¾®5¹×²Z>w®Í"ÃD¤êw¸'Än·9%[¾8×üÅ[{ÒqqU§"­K®Ýn8ÂÊÝ_ì]<§mÛ¢¨
2|ÒuJÒ|K®IK¦b9|¥Ý¨qo- "+úNôÐ9ÆýGQ1U9ô%Sz¹ÈìW=¾2¡uÃØ¬2¾?|ø=F]ÌÀj³oÂ0² º°¤ù·)æ|xû\sU÷èj}":½jÕzèX|+
dAC?=2
ìîÛª¦{ß q\ßðäÚ
\æ{=°ÚÚç{*ÿÆÈ®utrÆ°ÃÑ®ºmÏàKà5³WÈ´c8Ù+Ëz³ÉÍjd+¼å/sÑÞÄ¤Z&º<9 8 (>Nãs^Í-ÄécCß1zCq1MI¶@û#ô.ÑºHçÛK¸CjúÄêaZ?!râ³-THÒ.ÚÒ¯à
Éî~NÖÂK°çPeð)³Ç
/0ò§
Ï ¼Â{qì]Vé7K^ W1D#ô,®ás¨î¡J« É,h½ó[)¦»åbt3¬nÆ)j¡ºÙOË`õ¦c]Ñ æÌE¿I$ÍwEî¼!#_Æä!"ÐGëéÂïø 0õW£ ÖEé´^§tD ¤9&a ±û¤ßêû´ûöýÃøZæü
	PÕLæ Ñ*ÌEi_;E±.tÓÆbÐ¥¶×Yéu.D:×"{/E:0ÃK»R(Lg;=Þ§»8Jt8J]2rQv#ÇÃ(Hå°Aç²
9xXÈL7dFBÒ¿¬QÏô"`-Gçq©RÙäKÜø
Ã;Ö=³ÔÝîtícZmÙ¹ÞVvi¹KÂ§þPK   7EúZ& ç:    E   br/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder.class½WmSÛF~µv ¸@´ÄMõô%R ¥¤1Æyi¿í+(ÈG:3þþvÆtÒþþ¨L÷$Ù`,<fpúÁ·w{»ûìî­îÖÿ¾}óe¼H`ÃqhE!õrÃâö±S~)*!7mS®0ëÙÝqa<Ðî]£âÔKìq«âØ6i(FÍ±ªt5îÇÂ«;¶'æ/Ö¦U.Y÷$
!W²%ìFÍ3¾LKwI9ñ¾$Rñð<¾'&
G¾¥kÚ{¾àI\b&J^«3¤QÅ1
N[÷¹%ZùS¦qa¤Ê%ï´äÄú@Ãf) áºK¤¹4-£`zr)«gÈPs¸¦â:Ã¯zÿùèüÔøºc9éuv71Ç

|ÒQuJú!·bçÞm1ÛíÏ[VCÓ5~ Ö»ÂåSSîÓNÅA[?-ós"¢({6¥Ò¥ò.3"ùnµYwª¤,¶ØnÔÊÂ-ñ²å¡J÷.wMµ#rß¤ðV#Oô_OuÚUoal×xâW¡ÕÎPxÙDÚrß©>â.¯	)Ôäþ.´â~Q|ïÅ»°ÛrúgýÔ/}¾ówh>2ïíäü¾?Ô	``^õ®{r >Z'­F^7b´¬Ö~&¤¹x6àtZOÆ%=òÖó¥»Ýç¿ÒÍbH[¦ºî.»­¤	mÞ÷MÇ£%µæ8Ò.¯·¡À¶ãØQïÐ#ºê0LûÐ9¡WÁÓ´Á+Òq_1üv¼>CÁÀè&·«ðæsÐ¨÷~:Õµ!þSï§44±Î-«hJ±4Ç¥<D½ôWËìæµ°SRÓv/¤ªÍQ4hdYA{@çë®[Üó]ÈãØe¸ÑWjâxÆpµ·(5R0®Ss5DýÂ(ÔdÒlHµz>¥NÎ§Ôá¦?¿E?êÄÚëÛ¤¯´cÄ1h¶J)Nî5Ø4Æ§4Æ|æ|F£às|At±s(#G¾$=en {ñÜÂ4üip*	
ªÙßäéxhú+£ì§B÷¿¦í$¾B{¯o4¯hÉ6Ú]ÚÄRÚÅ¾ÑÔ©ô@l£åi{þuhO£]î-8ûÅ½;í½[´âN·qW9{Q¸é¾qÆ¡ªkãÎ´q¿%æ*Öh¦p ýsÏsMÂoÒ6)ÑM
¿ôk|íLÖÙ®ú
]ÐÖwße_¦êU2ô>jÓËIyèéÂÍ¸£!ò¾÷é&øt?#ÙôûEZMvJÇ:çHÿPK   7EúZ¾cÔ:    1   br/com/legalconnect/common/dto/BaseResponse.classµX[wWþÆÖhFò8¾¤3MNãª²,GÅ ò¥I¤u*;Áv\ÒBÛ±<±K3®friJÃýZ
O<°, ex(kñòÂÿ'JÙûÌE·±¸Äñ}ÎþÎÞçìëIþòÏ·`?VÐ#áÑj®hWresË(mË2./Tl+·éÚ¹³c®Î®m9æxãäl­TÞ4«IHi-Y%w^Bozb=	I
}Ð$Lv¡$9®áÖ	BÔ>ÓªUÜªÀfXá
 TLÇ1¶HÒpáºqÃÈ
k6TKÖ k8û$$ÜA]£²+A÷ ¼+ØE£|ÎpÍ54â0]vÓpf¹6®Ó©ê~
Gp.`V«v.0èájn©+w&I¨cÞ1	jÑ°Î?_3ÊFÒí'bðN`ºeº«¾Y²éÎ
D
)Hk`¥­zø´|µMjÈbJB´-F¼ÔµÑ9
ã4B¯Õ-y$ÀGØ·}PÃ#ø¹¶ælÖàß¡Öð|Ô»ýyß¦Ã¸Ñª)ÌhÅYuÛp¶ìMSâbâ´3Îb¡éúÞEè7rÍ¼tMB*ÊíW¦:¯á0Z1vÌÛ*î%ôZdË¥cZéöÿ«H¤#C­¶,ò¯¿¶6#a¼ÅX³í{ç	¦lx-aaèê¢,¼çBÉ2k
³ºfliåÙµ|»çÿ{¥³t]¾É°¸u£Zb¾Ö»]"§Lu£djus77Ý àdrzB¸$ÕÁ{8%áÔ~*ÝyÎO¬S¤/î¶½yÙ¨Ó59sNCVDÄ'ïÓ¦d>Þ3­8AG0BÄÓtg&ø2AL·¦0#j]4#%¬i»Û¯}ìÚñ ehbµ>Ì°ô{Üp~@°ºÀhXIWö×xzJïë
¦wvv?9±¸³dìú!&_^Y\:Ow]$#VM§V¦Z­7Së·H6Wö§gQ];¨u/vD{¢Hh÷|{_úÿ(§ðê4lÒÑµ§}lºj×ªEóB]1Ôè­¦÷ÂJÍâÓ¬ùëeÙt!$,ð-¯åÝrî:9Ö!Ç!(wæV±\Ûä:#$áTWÇëÔåKËÏ._)(.)L.¹ü9kÛ®ãV]¯8q|%×qKÁW¹}ZDýþ%ë½cúVóúÚ£èÚÕÞhÌpè	}Ü°6Ë¦3^°íÚîþ-¬i#WÔøÓû÷a_ÄQ.¯\sFÅ7$nôQÚË9);æg	að³G/Kæ¤	ÊáEÈêBÙpTDQð	ü'NRð=z¹u³r8Üû;2¾7%ÛJõÄã8½±RôÑÃu¢zø	-Fz!Þ½ôÊ_ôEú¥n8CH %¢ieFþ£þÒÕ·Ðûs¢%\¢oF$oßeÑ³¾¼ëÌ3¿Â[z¶ÃÇè«y ¬`Æµ¦+B	½[#Äõ·ëP=l#Ä
µ;Þ¡8zðú&j7Ò*îÄy6\§5zGÕ[ÅèBì´öq\õÅhdÆ3¿ò¹£Bî!áËeªOH®kûbmT¡(Â$<OD)éïTÉ²§ýI<¥d¨S%û(9(<çH+YoT2Ò©/ÃÖxWBÞEâùêFIç%7PR«wªÖKähµG(µCµGBµ´8!²ÔJ¥±ÖïMf~
9vgòPßÜ{gòP²»xq|9K|lêÏèÓcï`è6´)=vL^Îò7®Ë¿áÛè×e=Þ :W²üUuAªRtµ4OdùÔJú l Ê÷eù«é}Ò|Q(v®k³ã+ÞC;Þ)Ü7?á­õPYû%¶h­üÛDÅð¾Q2Ê×q¨8ÊØ¡ÃPP%e¢T|:r¨~Ó°J¨>ü\±KÖàµ{¾×<ýÏÓZUaEý(PßÅ!)ú«Jïâ°G&þ=8ß$çÇø?,ü<â¸`½2{ûÎ>¡&&é`ÒHnN£k"èï^ÉþNTbÝÍð9:8³MÁ£NÞ2uùçæDÐÄ¡Ç|Ê!å±NæeÁC°¦óqÁ¬xÀ:WK	Y`ïþM{ñ¸Äñ%Ôê!÷}7D0 Pøy
D0\Å4n`pIâ"êVºå[ú7$ß#H*Iä HÒ{$´>ïáÈÁB5/ù°xÃZÙºêæå:>áoQÛ8õ]Ñ<ÚHþtØÅ7È<l»ÿ7go³[=rÚNÑð6Î­o´¡ã¥Ú:^*ìË²À77Ð·ðxk	Õ;ló2>ãäïã4±8Ñ<3Yjn)j>=FÝ!£ËÅú~¡iÞÛfÐßRâÆÖ#(nN½qÅuYmÌçE}Lô õ¡8ûFdÑY(73î0õrÿY:G}/ñe
gPðúý¢IåðUuÎ
6ßRi|~¿N%ïÓK4¶¾ïâû§u*m?Ä ÿPK   7EúZ»¡Ãð  Å  7   br/com/legalconnect/common/dto/SuccessResponseDTO.classTKSAþ&Éf°/!¨ É._ðÅ£*"AÞe]ÜÝh?Åà)õ,^ýMeÏf	o$éÞé¯¿þ¦'¿ÿ~ÿ`O!¬"¢AAÁØrr¦]ÍUÄ¯¶e	Óªmå¶=;÷»â¥p÷lËÑù²Uö13ÙÍ8b«HhhÆ9IXµª+zÜ«¹0jñÕâr±¸Î ¯]6+@*:5t!Å0ýâÅi
·¾´AÕâ®ð¨ËÎn&Ð^}úq¡¿ã9¯\¹5Ûä%î
òHË~ÏÎd×Î9â÷1¨!!É ëñêÃPæÜ,I!°4×5c!AÉjïPÝÞ µÂ­¢ï­Êá&CÏi)2Y	4¦a·b&·ßÖxåÌúÖ.IÏ¾3Õ ËÃQ!Oº24¡aS_âniÑÞþ\¬2DNÇZÙÏkÕ-álð­
ER~SÜ)K?F¼R.dæÌû¸ðFó4JÕR§`è,¯do¿à¯
O8T'æÙÍÏ¤ÌÁ5Oböq´@ÅöJÂah§ù0ßø^ÐAÔn­âQ&5(Ú5Ç+eù¥ÿ4é)	Ò?ùÉ§H6GÞ*E­Ýú>þjíú7t70ðÂ!Ü&Bì ÙAz{iò0M­;¡UÂP]¡UKìUÝhàÚ!ÙQBC&B"õ5OHrw÷ñ>íFëIZeépêÆçnÔuan1£Q
}ÿG´þ	J¤nüBò#pÝødaBo`Ôwuc©ûP%R~á&L²YÌÑ÷^j&O±æ)Úû¤dü YtRóã-J³%ÛW$ú~RGôQZÅ*1w¨O|>ù Q%ùùôEj©·G¾°ýóOþPK   7EúZ(;ó  ã  <   br/com/legalconnect/common/exception/BusinessException.classµTkOÓP~Î.l+Ep0°(\·QèÀ:Âá!	ñéF­Å®S?ùÔpILôø£ïéFY¶lüÒséû\Þ÷=çüþóã5¬	ðÁB@D=£GêU)«FIÙ©¶^Ñ²Ú­CÏªnèöcX<w·-Ý(e{	AÑa¹`)E³¢µZ.¡m¾Q1
E»$U6jUÝÐªÕ&fY¦õÔ<Ðr±d/®1´º0ë!DEba¾;R¡¤ÙÛäR-Ñb(hO'?,b7ªUª2¾ñq·ôÐ¶Oò¶j×(x:gZ%¥zÂ£ÞYjEûhZÇ
P¶Ü0ßÆÆEÜå`z7Ö½ÝÉ¾zÍï
¤?É{=Åpï¶¸yôÈ:±Ç0#bqªsÓ´*ªmknUgãÍÀ#òñ(4gE$yCÄToÐÑÿÉÅ+êo]³?G'÷y­RÐ¬]µP¦hÎ,ªå=ÕÒùº±°uêÂJgÛîCÓ¶Ù 3¾­ÙæÁK·5$6».g¯DªkÓéOÓï¸ÞuçÄâ	>h>§³$ÓISèæäÍUÔ6u^ßá¶Ís1º!azÛ ?¢üA¢Y_Og¤ûGcnÂE¥hõæ'åÔ<CHþDß¾?ß$ÏÑ?CL;ôÂ|§ï0@¤AH01¢ rvå:ppfÜsfÜÏ MïÓ¼ÏO _ Mà.6¼åÊO£ '¿clîWhº]\v¼éÊ
®¬àäïsÄ">GìRhª!ôÀÜµ$'SçvúWêiÒ]Ä5,ÑËºLì+M©K®Éõ ¹©KÏÔ¦éË-S0ò)ù8El}uMô8ÿ8¢u±!ÊøÑàHÓÈÿ9Ç9­ø­&|ØÅ/v¯4ðAo6.øU¢kyâXjÇ<Á'jõ/PK   7EúZN,Ç¨  Ì&  4   br/com/legalconnect/common/exception/ErrorCode.classY	|\Uõ>ç%inÓ×ö5î¥îmJÛ,Ý÷ÉÌ¤Ì¤3I e	¯3/éÔyaPAYQQÄìòX-hÜ÷í¯¸ïî»{îìèà×/ùîwÎ½÷sÏ½¯|ú_§ÝÆÁZ06-lL¹¹Y§ßÎ¦Ü|ÞIsó)g ¡"[¹ig* TPSfáx²7ë	¶Gé'Æöçm§r'LªÜÍIDuGÑP0ÞÛlïm':á L3ÁTYÁD°#Ò÷»XWDÎ0a¦KDÖéH,u%|³L¨çI"H28ä4f+ÉÂÎD¼-LFã1ZÅ]\éæ0]Ú£j	H°PIÃÑX4ÉI§°X	OëlÆâ&,UIÛÌÁrV¨ñ¡Xç½áîÎvZeÂj54=ÔÙ6vd­	
<¶pÎ0a=§6Ò¶µÚhB#¯5ïôê4ÐÂkRTö't*z¢ñvßùf¶ðZPw"I[éèíN²é6¶«¡ÙåVÙ'È;m¹
+¡;MØÅ³3R¢p4ÙE{"íJ°Ç½¼©ýX$
õ*Wl4¡GüJ%ÓÎî.56!¢Fê©$âÝå2ÞE×«áý&ÐÁ»»ÄÑ#po0$jüLªqJµ5Gb£;L±±^p¤ôPP­í\µ&âî«zîUõIv±uÒ.vÍ+vQ1l¨Ç³84l
&##CM8Â^uÆkÂy~t$BHX`;ÏÚkÂì¶AAèêmF8GMHñ*C}µtLèãwÅR"gwFzä	1±gy	YNy"ÒFá?Ð;Á6oËí¥R\hB×«OÇèÜL(«¡yºíH0¬b¼cÄá"NðÁdò¬xBM2ÑM¸ÝG¬; õV,èÕ&\ÊÇ}½#ßR	/7áÚúkM¸R	çO*¤Ý²êõ&\¥T§¿»P²ËÊ7p
g¯+ÒêÇêM&\ËÞÙ·p>vÝ­ÉP"Ú©jd¥o3áz6V
ýC]t&ÕØÛM¸;eå´G;¢]cöNnbI0Ü»ô	sPÞmÂÍ¼`ggÊºCz`u>Åï1áV®ÎàaIßInã^Iõö8YÙõûL¸gÇCÝlJý,òp	wóåRñ0,åûp¯	÷ñÚ¢ö0ãJxî7áªX}ÐÕP]½íØþ®~È5<{ý¨	9H\×jäC&R#ÓK´³Mñ6áIÅÃ<]jà#&<íß¦~Ù¨tV$xP~Ì!6«lÐÒHÅëý	Ïe$ÖÝÑK?vs,?iÂ§àÓµ+¢×@Ó9/÷9PÏÕÂ§Mø<|¡&uóe~ÍÚöãö ½1kçû7Æ'7¤ý|¹¾bÂWákàA$_ÎÑ:ílÙ÷Ñ½³fu(k;GÉR!ïß9zåýÃoÂÿ!LÙÉgJ{¨PÖL´®íQûÿ¶	ÏÁwèu¢P&
ê»&¼ Tµ9§X´û:ø>ü ~hÂàÇt>ÇÑÜ}n!g¶O2÷9ã²v¢J@!T566	øÂÒ°vòLÉ¨C·»L~pèdVý¾¡Öú+µû_#ìlÓ©IbÚ#`ªyæf¿§sa9SÌÝ¥¦t¥¡
ð6Óö¦?±I¿Ð¨Ó.ÝsJ7à-dúíÒÐC°ËE'_rÈb¦¿ESc£R×äK´vy#O¥W*hçõ¥M
u=ä
NÑD9[`
+Öª&[pû2Å"U,­v¬Ü%ù<u,ohãP6£V7r¡À¬Ü$pÂâ`:GåUäáÂ$úÅOcýfs¨;)Æî$º¥ç³nÀô4ì.Nr E7!Ñ$F+.&£f
è¨©&8N9IQÕjËYEQ[Iïj1E
×°Ö@û
Ê9´´ æDýzëYOÛ¨Þ~9;(£5³ÂµòssNö2Àa 'g[IÞ¢6´¢Ðq³¶.6*¥¤¿ Cý§ÎQÄv±íysÂIE?^t E§ -Ý¯æv3E¿v\ \To$ÕÄ!ñ[(8å@9p¨ÃñÔ8W9¤cV «]ÛØÖ} auR

ÝåJNnÀ-Øã:ÊäÓâºÐÉá^©ÛPÍÓ|­çsG%ÐIÕgº3È/W¥;èû¥ %»V©U`§vJHÐCE7
Ú¿£ÏÅè! "°[Ë)ågQÑÛ:; ðÒFÏ¥÷|0EÐWÚå[È\ÌK
4YfÔ²*ÙÅ[®w5ñA½Úªx£F9éqSC÷jßÇ !GGiljAv¦+¨Ú]ä5&0­½ÒI£ã`\gJ¥C'û¿'%Ðõßb{H`F{§j{E £)ÑÎFúá#´·Ñ©²ûËÊ6àOyë×Þ¶
 o:uªDÑµGÓW¹×êÉö,Em»M`2ÛÚô"Å
µ)y£OÈ'´
ÕùÅ
ùôò'¤»}TÈNpÁñy_MÆÍ\«ÑbG'|Pþi[ïe$íd{À×h[*É+éÛ:Y¶ª°l?'G³îeG÷ìÀ«´
ò
ô-?^¦^_ÊjuÀ7i5ÕäÉu<Pr_áäyIº [&qFà[µJîz%ÅC÷²È
¼Q[P9½> ãë>ºmùç6Ú¸Èºýü$»ß­=PÉÜB½o¼q3¾Wë©(n£pø
x ËïÐZ*»T©ÄõÃMXlLo=!ð^mCEð~
o=f«ÊQùì£[¬°© òÇTx/øV7QÖDXÔC»TÖ>d%5<7°2½TàÃÚþ(U[W%Ô;ºv9:
Wü6¦"xªísô¯ø¶¥xaÃÿ²U*2YÝ½\%pH; 2ùÂºöL.SrÆy >zúÖK¿Fà'Éº
=¦çRG±ó¥IÒw­ÀÏi%Eèºvµv\¡+ñu¿¬Å¯[u,èUÉS*
ö¨*¿^à7´öO/ßqÿ-:YJ½}_<CÍp£Àç´mûyz3l»ÒÔÏ|zèä £.OÓº!+ÿe=9»Ià÷´3:8? ë8tûgÕrÕezÌ-èµDrr³Àk'tv~°%äæû²çWÂÇ.øºwSåíèV¿ÐèPý.v]ô4ó@ÁåÉ~øIb÷ûNÜ&ð·ÚÎ×ï¨CC¥3ýlsSú9\¶ê~Uwü£6¦ögzÅ´>ûbz²®VS¦i¡)ïø7¶RîÔ¢ÚøÓA÷ñnÌQ¹Oà¿Ébª7¹Á¤lºâ«WW«î2úÁMúQ­õMÂ oÁUcôn±XÎèü¸ÆTmØ,iÜG¦AuÇTPsC÷ç397°2M"¯ü1C{hõß=<1Ç!µMÂMñJ»¾Ç7ÔSÂ§M6cÇG=}_Rÿ¤0N×ú-ÂXBo`Ò«õK<-eÚ`«0VÐÉ¬ôHÒåÊªZûhª%	cµVnÆZZ}îæ=îªª¶®¢gq6Ù.
Ëzì,½.FÎ?{#qTß}F£i4ÍêK?¡é©Ð²fíËþ§/×yu?g¶Ó4VÎu
]öÑ,1áI¾,×¾üêÛÝíQÏ2rëû®ÎÓQ¤/ê§tÌMÓ7$ýJ S:!¨[áÐwþ
-®qiêY©ÉL?7G[=É*'ûØ¥ï¢~§¤Ï\ÉIwè/|eÿÿûL§Ù~ZDOé ç:cÿ>dØºÃ]©¬ÿUkÔÚZÇýÇ®ç=j¤[.¤¶ðá±
Êõ¾&ú°þ ÷ÍWÿpª¦3}¬÷q¶ó|\èãbú¸ÂÇÕ>6ø¸ÞÇF[|Üâãvwù¸×ÇV#>ðñ 1ùØåãY>ññ</ð1åc³>º>|,ûxÂÇK|¼ÔÇ+|¼ÒÇ«|¼ÆÇk}¼ÎÇë}¼ÑÇ|¼ÙÇ[}¼ÍÇ;|¼ÛÇû||ÀÇ}|ØÇÇ|<åã>>íãÏ(¤,?ßa|A¡µ@ý!ý.`ªÑb4S¯ÙD¿-£ºQÿÔyðì£ð§á³¤ßÐØLNá±TG_5¶ÁúM`0[W
ÃTzc´ÞØJZelSsÛéç4¶]N?«¿×*vv.TQ±ÒÖ-z¾Þ°þøVÃüêGàùÖC5ý#çyF)<AliÔØÁ­l·jxÃÕ<é¬jc§Æ.hh Ýìz\aì5öù»ÚMË2§6<Ï¯{¾7~S'xÎ9Z4<çT#h´R°üí9r!#ìÇv# ××o÷¦ß#IoìL4¶êÔÅ¡ñ»4Àg­à«<¨J®ö 6y¸Æ£FrxÓk=°2yØ"jqó	\D0Õ%TË¦y°Àô`
ÁtÖÌð`ÁL,6Ìò`+A½;¤»	Nó`ÁlBs<h#ëA`íó=,ð A°ÐnEMpºç,öà|%ØÒK=è'XæÁqåäVx0@°Ò"Á*	V{ðJ5¼`­4xðu¼à®&XïÁ	6xðf¼ Ñ<xA³ï"hñàM¼`³·lñàN­ÜC°Í÷l÷à;<ðvzðÁ.'ØíÁ{<x`¯%ØçÁÇ¤0Úý:ÙSÒºk<A©®ÿIUýOëþüò!¨bâ7Õõ¿­ÿµLü¡¦þõf¢¿N©ÿ[ý?ÎÄ¿jëÿ-±#±JH¬89©9aM8Uâ4&çhrºU+qDÉù¬·È\JÍä"MÎµÈvÄL.Ñä"«Nâé0¹LK­iI\ÁäJM®²L«%®er&×YÓ%!që4ÙhÑz$¶0¹A­·HÜÆd&wXÄw3¹I{­Y÷Iler«&ÃV½ÄÄýLîÐdÔ¢=)±ÉÝY§IK<Ää>M&­Ù»$ö0ÒäÙÖ©ð&Û4y5Wâù/`2ªÉ£Å-%Ña²]ýÖ|Ç$g2®É¬µ@bN¢ËdBZ%$ìÖä µHâE_ÉäÙ¼Ä¢\¼Jâ¥L£ÉË­Å¯øZ&Ï×äë¬%_/ñj&mM^c$¾QâµL¦5ùk©Äë$¾É~MÞ`Q~ß.ñL×äMÖrïx39M¾ÇZ!ñV'ÐäíÖJïx'EMÞm­xÄûÔäýÕÌ?Èä+5éYk$>$ñ&_¥ÉÇ¬µxÉË4ùa«Aâ?Âäk4ùQkÄIü8¯Óä3Õá³?ÅäÕüµ^âg%~É7jòÖ_ø&ß¬É¯Y%~]â7|«&¿e5Jü¶Äï0y&¿kQm¿ ñûL¾C?´%þHâO|&fµHü¹Ä_2y&mmø/2ù^MþÞÚ,ñÿÄäíüEçå¯ÿÎäü§µUâ¿¤LÞÃ¤aXÛ¤Q%&ß¯ÉZk»44êü&Mk4¦Kc&&gY;¥Q/Ó|Ds¬]Ò+ùL>®ÉÖni,Æb&ÐdÀÚ#¥ÒXÎäS\iíÆ*i¬aò£l°öIc4Ö3ùñÇÁ³Vº-ÖÑSÞôo==$=pç@æB=Ã|¸À
ôl¾ÁS°¾B¯Ò³ù°ëa9®U¸Vã!hÀ>XÀ¼6âÐ§ 	¿ ÍøChÁ¿Â&cl6Ãz0m5:`qvÁ.ãM°Û8	{Ga¯ñØg¼ AãÐZU¡ª%®Úª(´Uû«p êj8Xu´ÓßQõ,ÄªxÕÐY=U/Du#$«#ÐU}º«]8\}%©¾	Î©~ Î­óª¿	çWÿ
zk¸ f.Ø5gÀÑ Ý8ÿp:`DÏüPK   7EúZó¢	  K  A   br/com/legalconnect/common/exception/GlobalExceptionHandler.classÍX	\×ÿ¿ea`0hmDE]P\k1,j`]º î"5±Ã2,£³3dv$GÓ3IïôLÓ6½Ò6míI Mjz¤mjïûnÓ¦÷}i¿÷fw9v@PÛæÇ7ï}ï;þï»Þ<úÄ© le^<(àQ"²#ÊÐ#ØÛ}DÛE
¡ÙÛ
ü5%(FyÝV n&ºPô¸i´O$M# «ý¶F£]ºÙ­èáìûnÅèÑUêf¡"bZ@JïÝt$1	Õ
c>Ãò¦tJ3ÔTª*·³¾ê¦[ªêªÚ»}(C¹
q	ÃæY)åcÊàK¨vM)	áMdmiF"8°XÂ¥2à2Bã~¾Ôk)IuÐ´ÕnfØê1;`©7¤ÕèT»£Îa>IÙ¡¦â[é?à*ê)xªËe,CÈTp¼EÛ¯öçoL=>V`¥j«°aí¸õØf II©Q5Õo)ÂGêNkz×#DHÍakõÄ&I°~ÔH¨±ëünüT#LNëá
G£{j]UpÛôa=6Èx62l¿@Ý)2RB CÒ?{-.3nÇ&Wb3F2ë·û]ÜábÈ*ÃWóøÈCf:A4HØ*c¶_±i[Ó;ºÇìe¨ö»x^d2©°¤QFB¦jY¦E`ÆüSÉ.aì°KÆn43,l-©RPÅ}b«íôF)É0fs@>ÐyZJø:9A²áÚ-çöÊhÃ>ç­D'ùîCíöËè@g6£0-K¢}EJÊ9©Uþ³<¥.p¡PD?C`n±pÃ·´ÙgÛý,]Ø°5{[{XÆ3 0µ»$	µ5$xZ6ã¤ô!ÄyQ#e·¹øâlpgé²		}24ah.ùwkFO EµûÌ:tR5ìVÓîPt­gB±)#¶ÕiaÃ46
ð­Sµ&î ¡#)Áa\oÝ\63ÈÜt=·
Þó·d¤`$g©JrBP:gû=ÔLÈÄ1r¥¿_bX6¾7mÄ2;3r#np³[ðÌlLæó¦L*däÿÜ¦×ÍgáÙ#ã¹xG2u\BQdNh\îfmR(ÛqdÜæ9Ó|/,ÆiWGî¨òZçòú^ó>á%¼Ix)MÜïÙÔ¾ÝKxWâUëgÕ1	x,óv4Fw4¶7ïm=Ìëo´)¸0¡ó¸å%¸¯p·×áõ+gów÷íÇÚ)yÍ*ãû>ÑtöÌÐK¾÷ofX8[ýV÷r°E¡âH¾]Æ;8¥»Â­áhsÈÛ·Û÷.ïæÆU6·¶£­Ã±p´#uÈ$¼¡æ»SSõÇñ>ïç¸X¬øpÃñ>_{nvNbu&Zsq³)j¯BÉ"Ócê|êYµfUjM}Õª§ñ!	Êxtqpb©×´íÞ©N_x&×²ñ	ñ1|rÄÔfx§Â#M	éíWMÒT*XÇ Òñéº´¦ÝªÕ®tëª¸PùîP,¿g&½vF>¸uvîî~å!¡Gt¹ÜåÞDûã^Ëf¾g¨¢1éìQ)­o9_í(AZÙ;Ð¦óQ|UÜxï_7§ÞÓ©Êm
i«<ÑÄ´AÂ"v<9oÛÈÎ%Ñ´ÁûÏ-¥Ó6iÐ'ë§ÕUô-J6àâµEÒÔe÷¬-I¸Ç?³s´Fÿu7ÞvaêMíMNCýÙtQ=¶!?¹ñ;ûdÆlîXéøÇìÇ`OLÉÿ»¯tÊpïÿA¹¹RWÝ=Jõô1W½áwr/ûn5îsá@©³÷¼kà¥Ò,ÒuîZ)µbñ£-J&4âzæ¢/f¦­¸ºSãóKÝæz.a.ù+D§eñ®ÛjìÐâ¢ 4¦M
¹ÒïTjA~çÃïñ	ñ'üÄqK4cÀ<J·x?íPz³}Æ¼äÄ·³ý(³ÉàèªæÑt0¥é6òr~È÷Öä¯]i¶,Ã_VOÿÙfâÁ÷wñ?Âãex½<ÚíJÅ`¡Ëgº³Y!&1ÝÁf&¥Ó!ÆrRÅCWP*Pü»4h\(~¡· ¸d °ö$Ø	xðhó'éWvð)<*}gáGiÖKÏ¶aH¥kG°`]Á*=ÃR/­.ÆÔñ\A«FQ?kF±cO§÷ÖQDé}×¶Æ¡.NyýItßÓc5Jèw*±KqÝé6ÑÜ¤öfú»
Û±!Ô=k]2zòÑgðY¡{>ÏÇJñ|øÍx ´|Yü
¾JÏù´åkôÿõ`qÁàø¦c0+D&iRTÃQFÞÀp
iÐhÈC6ß:ç{pÁVÊ§«È_ëòÖÅº
3ÅÆðâqñ²¼@ªËÁC Ô{9*K¼ÃxMÊf²hÁB´âRìG5:ÑkÑDÏ]8@+Ã!]G×#Ãè"PÚäC)M |K Î T}ÄéÛ$«/ßÉø³öÝéüù÷ñË&ù1urtÞCçN®ÂµÎ[&¡ó61¸o¢å\gïä9+Èñ+a£l`|e"nÄÜ<Ák:sxtI	<:3xì!ËgðºØüXG&Æî ÈèYWû0ßÒÚ38>÷Þ©v÷Gèç-£Ø(Nö"qb{	¸6þ¥X	í«Ætýþ± \à§$v)*ð3yðsà)I}1~üåÂH2¨¢xgtBD÷xô/#d~)Lü0Ïþ¿ÉøÂoIö_ð7üÿ¢
¢[O¨?AûoÆXüPK   7EúZ¿_çô  £  0   br/com/legalconnect/common/exception/Roles.classT]SÓ@=K¡
¡åûÃ* ÈwEª"¢*2v¦¤}p¶aÐ4é$[¢þ
|Á|ôÁåx7-R :<$»çî¹÷½»É¯ß'? ,"©£ÃhB¡}ïó¸Åíøz~O!¸`Ú¦|ÆÜ
AcåÝ¸áãØááØ6ñT èØqq`4i¶éXÂÓ 34m®§t	¡56´SÊJ×´wtOrWzoL¹ËÐ3¾È|×I®;ÃèB7C_DÂ±
.U
Í(ßÃX½ÜË!å¨7>\£]ZÂÞQº´ËZ¸Æ
ô34{å¼W5Ø3ªSû\ZYKe:ë1"§î¶¸U:ü¤\2³ÉUr5³Zkk=±KjfhñCt*Éi%O~àu6¹©a¼ol&WSoÎ¶`hK¶ÈyáæxÞÊcpk»¦ÂÕ`£Ü5©YSé«§Úë'êõ+>KÑ/RµHVr£°ÆKÕêíkBî:ÛÜ¥e)\R¨T§,O³õ¬Sv
±j*¾îL«ÞQò²ãHê:/UªxmA<ÖñOCWÇ¿À0rÖfÓÞw
¢ÚíÊXåtÜCÏµw¡J¬}ÉímI;N¡\¿|lÿJÌDúûôÅçÜ¥«HpËÊRÌk o*è$c§¨ïnÂâ'¼F¯d;Ãàÿ©$S!ã>Bô½AD1A0Ü$Ô[jðmÂÃ5xðh
#<^'OÖàfèMÄ(2C#£±)öìO¹CoÝ7ÓFJ¢Y¸BÂ]LÓØ8º¡
¼¢Q­õÆ~¢+ÖÙ|¯Ðc'è bG´ð+¶Ò²!;Ý9«Ú{dÔÅeÝx ¤EÒÌ_¥\U)JJ½¥/øcD/=$±YúÌÕEÏõÕ(C5`hÔ?GÏ"û
axe¬ úPK   7EúZíÊ  l
  3   br/com/legalconnect/common/util/ValidatorUtil.class­ïoSUÇ¿§?vûkãRè! µûÑa¶Áæ0hÇd@Ø]{éîhoKw(Î¨!
/4Ñ	(þHöf¾@Í øB%¾7£/4?Ãù½··Ý`#ÄhÒÞsÎsó<ç|Ï9?ý}ûøàS+ 7ªäIå¼Í(z:zx|RMUÝ®{Máã>xààÀÀî#FAÓÓtÏ¨zÚ°Ü=¨ð5¦Â£;Ú§Íår +²P§BMñãtO¾«¡AJ¡q5
û%¬Øh-)Z&:¨çFB²\HªyCËé¬[»sÚõh°!'°Q u¼Mæ²ÑV2É®ó°¦!ÓKQ+-¥¹Â1ª}ñÓÃ}GX_Ø@AM«¢Ãa¨½ËÍxRÂ ±U î~
èçYGÔsEUOª]á%i¥ELÓ°)gó2iåà,Ä	Z§^PZ_îk=ÑÞºëtóÖHëÉæ¦½»GÛXÃ^N,im7Û··ìÞb3@;:x
×2*e]®JÀ_õÈÀþçKSùþ>e(ºÁÂÕK±Y×tu¨WGq3w0K*ãJA3Ç¶ÑeLhd,ÿWõfZ6eú÷QC½îîhg¿ßîóø)sRãr»òêTZ(°Ù§LåLæÏð#<PòöÎåjLäRÃJAÉª§ð÷44|ÐNßi·;2©ç'¶Ó@V1Áu«¥v)°e<ÝÉ}Ë}#¹b!©î³ª|@63 :x|<XíèÀkÔÂ1oûnøpæ)LaZ#7!nX®1~}VZ¸°;Ùð4v±õb7ô` Ç89~üPdì¿@$X=×àvÎ:÷È¾ä¹B.Ùû6GB®9¬ÛS±ªPUHÛ\©tÉ%fæÿý
²?¹CnÙ÷	|lÐ+·wÏXö±÷ºÒ_éû!{*!{ê#²1®cåúì³zk.çìns§__ð+êxZSõü6R¡­i£¸Qlàmkb:)|¿}ï§÷0<EåRTí,_õ,öàöâ"zñ&½ÞÁ3xã1Ï±7¸ê&qqfLà7Y5xUèÄjÆîfùî¤cmßÐ¶6ódíÙ;Ü[É¶ý^ú9±ñûØsqo½ÝÛègOb>å^<fU¹N¶ûù?µbfdÎ	Á_ã<E([,ÜóÜie§±vÁ(lc]/q¹:0	Lh6Xì°ûÀj,ÀÖ. æ:Ð²<c1)$É¾ë¨rTÌÏÌÿl2a"q
ÞÛUF¬ZöÜ)23nàÛ³8®Z Zõ²¨ý¿*¨½Ê{RåQYÆ3h@àM6r>KÝ2T-ÃÈáò#dg0ÅÞyð"¸ÀX/á
Azð]Å+øÓøö¼/ñ:ná
Br	wñwp÷è]F¯0Krg-¸®TlßÒvÈÂ,Ïl¥Ù»Üë!½»ô¾³Ñ;·môð½Þ½EèÝ'þeô¨Õ2èÍcÛAX÷Ãò6½±YbYG©¸È«oÜ7QesX/éªÈ&ª_¡o7ÏaÛ,Í¥
©ð¿W©ä5Ôð)Øi=¿ÖR^Sn«Õ"NªrÒ!6^åò¾Éz¬¹`Ë-´}zó]Vª*kj%¿ÏYoý PK   7EúZ¹û  à  .   br/com/legalconnect/enums/StatusResponse.classTmOÓP~îÚ­[ídàN×P§àKBfB2Ye	ñSWê(éZÓv|ö'ÉHh4|öGÏ½
b4isóîûÏß <Ç3	½vÐ5<§cyvàûßëF[q/j:ÑûÀd
I¤ss½f
Ùúyã¹@ZCÈµf³Á4hÜ\kmÂsYÃr£ØZ«oÖL¹·çO¢"Q9
c¸J²¶øÃ^®ïZ{áY~Çh´wI¸¸¦`RC×)ñB¤©=Ëë9wKúèuÏ¢å3]¿³|2úÓnà&Cªêún¼Â0®Ü(·ÒHªÔüt44þó®{(ñ92"y½|IPÎ_òz°MC©»¾óª×m;á«ígåÅ/"_lËkY¡Ëª²ou~vF!÷Òwí×VHØ	yuñK yâ 6;0pÛõ-!cºrt&éåmRÕö#­þ5øêù;X¡T3è¶óÂåµ&,påÕ
½	úfäÕI¾ÿ afÇ\ï,1ä×Q"~¬B~©}d?áÊ1òÉ¢)q&¿9${Õ<=Âø1ç'NñïÓS°0Bç¥íøÀ©´lDâbBP:ÄÔþ<à]¥Lêä!ÝDÈbNå8lÉ,ZH}ÛúÌ-¹O[É>Mòli,Q_àæ0xáÅæoI¸} I3²0aÜI
C=Bñ Ùýßy/#Ks.Pé'e>ÆOPK   )EúZÆn,ò    <   META-INF/maven/br.com.legalconnect.common/common-lib/pom.xmlÅXÛnÛ6¾ÏSpF/6 g.PÜe	Ò­pÐ`iÝRíÐ¡D¤d{EfØÅ»ÜäÅöd)>ÉiÅ7!ùó?|ÿ
_Ï
*éqïÀßï!³t|Ü»~î½ê½ìJ4êT÷nµÎ ÁM}arK}!ÇÁå»àk¸ì!ø³ÔG3ÅêÓéÔZÚþþþAðëÅð
.'Øc©Ò8%´¼©Ø²CA°¶ÊmZE2S±Ûô,¡ëÞÀ

S~ã ØÓ0hí9²Kj·°c)òìçx ì}IÀk$qB§BÞù:*Å,5a¢aÓ]ñ¥KM¥çdAlq·ôÑàÐïûý0¨Ö(üÂóÐµÂi,¶®¼ÿS ßr
AîÿF*SÉräy
nr@µ Xß¢ dÂ¸Ë3äÔ@#)$i&ÓBÎëûaPa±×">Ïés"ÒÂÅl$"]@áäp°º@62¡ #¶z*mt¯%5p<Î¢e|jlûçRðÊ`h´:uZ¡SË
Y$±¥pÄ1UD²ÌÜ $Ë5ãL3ª^Bfèò?@ÛjÏÆ¹´á©XZbF¤PTPMÖUL;<0L°4°VKÓ±" ¬D <AoO~A1E8lÁ*ÙIQiôk8zì×ø|­ ÜpÍ[ kñÌ(wQÖ$.HÜ-Dø¯üCpÂ}'é¦@g¿ÿ0M´a4´ÄmÆ&±)-s¤ÿoàwúò0XM²QTÍÿgWö^[ªËËX]ß?4Aµ|°Ù¤+K&HÿÏ§x^óøÞïÿ0x°½õ¹%n&dÃóUg4¡·£Ápu¡¡ò +WyÐ
æ,¶qì$àTh|ÿ×ý¿Tp+ì1¬2	:{ÿNµ­ªÅÍ­]*eQë»¦ZMÚö?»²Sº¢fÕéðÜ8]µÚËg¢qWÍµH ù®WÞA½FÉÆZãÿ7 °7Éðçvé¿ãÙÊÜñ»Ã^~>ðWVè]Îôr°
èÓfË{iÖI&RhÐ5ñ?ÝÝ]I¦]ò¡Wäé9X,©3÷ÄÀ2>Éõ­°G_B¿mÅ»6~F5fzÎhqñÕD°*5énzu0t' ;Å&qDVÁ	¼ÐØ7s§]ôzpÃÃÛñUþvÅ(Y)ýv ]·`1a6°ë'ì>n£æ9Ò®¡ðx-~në PE¸âÚ3âÇ­ØªÐøQ2Cd4Æ0X·ÌÚÝE»ROÀhÐvÀcå<ûT°¬ÊjL¿Ðz y
éÖxy|ñaiâþ¸"ÙØiÄQÎx3)2ÃSëA[/wWôÙ&åw÷¡ä³¡³·ÃÁ|^1nüöòßzf®RÓª
Á¥ðÚTBý©ea*¯?^2ºKØdù¶ª°t·CXo\°Ùº]ßñ¯ïzYåG¡°­6<O	Þ¥æsã#PÙ÷ûktW@lçä	
ÉBTjGU©,BöÁn0üPK   7EúZFÙÖE   J   C   META-INF/maven/br.com.legalconnect.common/common-lib/pom.propertiesK,*ÉLKL.ñL±MÎÏÍÍÏÓÍÉLâåJ/Ê/- %éõrRÓsóóòRKô êx¹ÊR3óól
õôx¹ PK
    7EúZ            	          íA    META-INF/PK   7EúZeU´ï   £              ¤'   META-INF/MANIFEST.MFPK
    7EúZ                      íAÜ   br/PK
    7EúZ                      íAý   br/com/PK
    7EúZ                      íA"  br/com/legalconnect/PK
    7EúZ                      íAT  br/com/legalconnect/common/PK
    7EúZ                      íA  br/com/legalconnect/common/dto/PK
    7EúZ            %          íAÊ  br/com/legalconnect/common/exception/PK
    7EúZ                       íA
  br/com/legalconnect/common/util/PK
    7EúZ                      íAK  br/com/legalconnect/enums/PK
    7EúZ                      íA  META-INF/maven/PK
    7EúZ            *          íA°  META-INF/maven/br.com.legalconnect.common/PK
    7EúZ            5          íAø  META-INF/maven/br.com.legalconnect.common/common-lib/PK   6EúZÙëÛî               ¤K  application.propertiesPK   7EúZ^!f  R	  A           ¤m  br/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder.classPK   7EúZÄÝ÷  »  /           ¤2	  br/com/legalconnect/common/dto/BaseEntity.classPK   7EúZ& ç:    E           ¤v  br/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder.classPK   7EúZ¾cÔ:    1           ¤  br/com/legalconnect/common/dto/BaseResponse.classPK   7EúZ»¡Ãð  Å  7           ¤  br/com/legalconnect/common/dto/SuccessResponseDTO.classPK   7EúZ(;ó  ã  <           ¤á  br/com/legalconnect/common/exception/BusinessException.classPK   7EúZN,Ç¨  Ì&  4           ¤V"  br/com/legalconnect/common/exception/ErrorCode.classPK   7EúZó¢	  K  A           ¤P6  br/com/legalconnect/common/exception/GlobalExceptionHandler.classPK   7EúZ¿_çô  £  0           ¤I@  br/com/legalconnect/common/exception/Roles.classPK   7EúZíÊ  l
  3           ¤C  br/com/legalconnect/common/util/ValidatorUtil.classPK   7EúZ¹û  à  .           ¤{I  br/com/legalconnect/enums/StatusResponse.classPK   )EúZÆn,ò    <           ¤GL  META-INF/maven/br.com.legalconnect.common/common-lib/pom.xmlPK   7EúZFÙÖE   J   C           ¤Q  META-INF/maven/br.com.legalconnect.common/common-lib/pom.propertiesPK      	  9R    
```
```java
spring.application.name=common-lib

# Configuração Multi-Tenant
# spring.jpa.properties.hibernate.multiTenancy=SCHEMA 
# spring.jpa.properties.hibernate.tenant_identifier_resolver=br.com.legalconnect.common.multitenancy.HeaderTenantIdentifierResolver
# # For application.properties
# spring.jpa.properties.hibernate.multi_tenant_connection_provider=br.com.legalconnect.common.multitenancy.SchemaMultiTenantConnectionProvider
# # Configuração do tenant
# application.tenant.header-name=X-Tenant-ID
# application.tenant.default-id=public

# # Configurações do DataSource
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.main.allow-bean-definition-overriding=true
springdoc.packages-to-scan=br.com.legalconnect
springdoc.paths-to-match=/api/v1/**
springdoc.openapi.version=3.0.1
spring.flyway.enabled=true
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
```
```java
Êþº¾   = K
      java/lang/Object <init> ()V	  	 
   ;br/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder id Ljava/util/UUID;
     self ?()Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder;	     	createdAt Ljava/time/LocalDateTime;	     	updatedAt
      java/lang/String valueOf &(Ljava/lang/Object;)Ljava/lang/String;      ! makeConcatWithConstants J(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; Code LineNumberTable LocalVariableTable this =Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder; LocalVariableTypeTable ELbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder<TC;TB;>; O(Ljava/util/UUID;)Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder; MethodParameters 	Signature (Ljava/util/UUID;)TB; X(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder; (Ljava/time/LocalDateTime;)TB; ()TB; build -()Lbr/com/legalconnect/common/dto/BaseEntity; ()TC; toString ()Ljava/lang/String; <C:Lbr/com/legalconnect/common/dto/BaseEntity;B:Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder<TC;TB;>;>Ljava/lang/Object; 
SourceFile BaseEntity.java NestHost : )br/com/legalconnect/common/dto/BaseEntity BootstrapMethods =
 > ? @   A $java/lang/invoke/StringConcatFactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; C <BaseEntity.BaseEntityBuilder(id=, createdAt=, updatedAt=) InnerClasses BaseEntityBuilder G %java/lang/invoke/MethodHandles$Lookup I java/lang/invoke/MethodHandles Lookup!                          "   A     *· ±    #        $        % &   '        % (     )  "   P     
*+µ *¶ 
°    #        $       
 % &     
    '       
 % (   *      +    ,   -  "   P     
*+µ *¶ 
°    #        $       
 % &     
    '       
 % (   *      +    .   -  "   P     
*+µ *¶ 
°    #        $       
 % &     
    '       
 % (   *      +    .    +    / 0 1  +    2  3 4  "   W     *´ ¸ *´ ¸ *´ ¸ º   °    #        $        % &   '        % (    +    5 6    7 8    9 ;     <  B D      9 E	 F H J 
```
```java
Êþº¾   = o
      java/time/LocalDateTime now ()Ljava/time/LocalDateTime;	  	 
   )br/com/legalconnect/common/dto/BaseEntity 	createdAt Ljava/time/LocalDateTime;	     	updatedAt	     log Lorg/slf4j/Logger;  +Criando entidade: {}. Data de criaÃ§Ã£o: {}
      java/lang/Object getClass ()Ljava/lang/Class;
      ! java/lang/Class 
getSimpleName ()Ljava/lang/String; # $ % & ' org/slf4j/Logger debug 9(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V ) ;Atualizando entidade: {}. ID: {}. Data de atualizaÃ§Ã£o: {}	  + , - id Ljava/util/UUID; # / & 0 ((Ljava/lang/String;[Ljava/lang/Object;)V
  2 3 4 <init> ()V	 6 + 7 ;br/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder	 6 		 6 
 ; < = > ? org/slf4j/LoggerFactory 	getLogger %(Ljava/lang/Class;)Lorg/slf4j/Logger; A java/io/Serializable RuntimeVisibleAnnotations Ljakarta/persistence/Id; $Ljakarta/persistence/GeneratedValue; strategy $Ljakarta/persistence/GenerationType; UUID Ljakarta/persistence/Column; name 
created_at nullable     
updated_at onCreate Code LineNumberTable LocalVariableTable this +Lbr/com/legalconnect/common/dto/BaseEntity;  Ljakarta/persistence/PrePersist; onUpdate Ljakarta/persistence/PreUpdate; @(Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder;)V b =Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder; LocalVariableTypeTable ALbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder<**>; MethodParameters 	Signature D(Lbr/com/legalconnect/common/dto/BaseEntity$BaseEntityBuilder<**>;)V getId ()Ljava/util/UUID; getCreatedAt getUpdatedAt setId (Ljava/util/UUID;)V setCreatedAt (Ljava/time/LocalDateTime;)V setUpdatedAt <clinit> 
SourceFile BaseEntity.java &Ljakarta/persistence/MappedSuperclass; NestMembers InnerClasses BaseEntityBuilder!    @        , -  B     C   D  Ee F G     B     H  Is J KZ L     B     H  Is M KZ L   N 4  O   Z     $*¸ µ *¸ µ 
² *¶ ¶ *´ ¹ " ±    P       4  5  6 # 7 Q       $ R S   B     T    U 4  O   `     .*¸ µ 
² (½ Y*¶ ¶ SY*´ *SY*´ 
S¹ . ±    P       >  ? - A Q       . R S   B     V    3 W  O   c     *· 1*+´ 5µ **+´ 8µ *+´ 9µ 
±    P        Q        R S      X Y  Z        X [  \    X  ]    ^  _ `  O   /     *´ *°    P       ' Q        R S    a   O   /     *´ °    P       * Q        R S    b   O   /     *´ 
°    P       - Q        R S    c d  O   :     *+µ *±    P        Q        R S      , -  \    ,   e f  O   :     *+µ ±    P        Q        R S         \       g f  O   :     *+µ 
±    P        Q        R S         \       3 4  O   /     *· 1±    P        Q        R S    h 4  O   !      	¸ :³ ±    P       #  i    j B     k   l     6 m   
  6  n	
```
```java
Êþº¾   = Z
      java/lang/Object <init> ()V	  	 
   ?br/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder status *Lbr/com/legalconnect/enums/StatusResponse;	     message Ljava/lang/String;	     	timestamp Ljava/time/LocalDateTime;	     data Ljava/lang/Object;	     errors Ljava/util/List;  +br/com/legalconnect/common/dto/BaseResponse
     ! z(Lbr/com/legalconnect/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;Ljava/lang/Object;Ljava/util/List;)V
 # $ % & ' java/lang/String valueOf &(Ljava/lang/Object;)Ljava/lang/String;   ) * + makeConcatWithConstants n(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 	Signature TT; $Ljava/util/List<Ljava/lang/String;>; Code LineNumberTable LocalVariableTable this ALbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; LocalVariableTypeTable FLbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; m(Lbr/com/legalconnect/enums/StatusResponse;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; MethodParameters r(Lbr/com/legalconnect/enums/StatusResponse;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; U(Ljava/lang/String;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; Z(Ljava/lang/String;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; \(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; a(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; U(Ljava/lang/Object;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; K(TT;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; S(Ljava/util/List;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; l(Ljava/util/List<Ljava/lang/String;>;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; build /()Lbr/com/legalconnect/common/dto/BaseResponse; 4()Lbr/com/legalconnect/common/dto/BaseResponse<TT;>; toString ()Ljava/lang/String; (<T:Ljava/lang/Object;>Ljava/lang/Object; 
SourceFile BaseResponse.java NestHost BootstrapMethods L
 M N O * P $java/lang/invoke/StringConcatFactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; R TBaseResponse.BaseResponseBuilder(status=, message=, timestamp=, data=, errors=) InnerClasses BaseResponseBuilder V %java/lang/invoke/MethodHandles$Lookup X java/lang/invoke/MethodHandles Lookup !                         ,    -     ,    .       /   A     *· ±    0        1        2 3   4        2 5     6  /   M     *+µ *°    0        1        2 3         4        2 5   7      ,    8   9  /   M     *+µ 
*°    0        1        2 3         4        2 5   7      ,    :   ;  /   M     *+µ *°    0        1        2 3         4        2 5   7      ,    <   =  /   W     *+µ *°    0        1        2 3         4        2 5       -  7      ,    >   ?  /   W     *+µ *°    0        1        2 3         4        2 5       .  7      ,    @  A B  /   X     » Y*´ *´ 
*´ *´ *´ · °    0        1        2 3   4        2 5   ,    C  D E  /   b     &*´ ¸ "*´ 
*´ ¸ "*´ ¸ "*´ ¸ "º (  °    0        1       & 2 3   4       & 2 5    ,    F G    H I     J     K  Q S       T 	 U W Y 
```
```java
Êþº¾   =   ?br/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder
     <init> ()V	  	 
   +br/com/legalconnect/common/dto/BaseResponse status *Lbr/com/legalconnect/enums/StatusResponse;	     message Ljava/lang/String;	     	timestamp Ljava/time/LocalDateTime;	     data Ljava/lang/Object;	     errors Ljava/util/List;
      canEqual (Ljava/lang/Object;)Z
  " # $ 	getStatus ,()Lbr/com/legalconnect/enums/StatusResponse;
 & ' ( )   java/lang/Object equals
  + , - 
getMessage ()Ljava/lang/String;
  / 0 1 getTimestamp ()Ljava/time/LocalDateTime;
  3 4 5 getData ()Ljava/lang/Object;
  7 8 9 	getErrors ()Ljava/util/List;
 & ; < = hashCode ()I
 ? @ A B C java/lang/String valueOf &(Ljava/lang/Object;)Ljava/lang/String;   E F G makeConcatWithConstants n(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
 &  	Signature TT; $Ljava/util/List<Ljava/lang/String;>; builder C()Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder; Code LineNumberTable ^<T:Ljava/lang/Object;>()Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder<TT;>; LocalVariableTable this -Lbr/com/legalconnect/common/dto/BaseResponse; LocalVariableTypeTable 2Lbr/com/legalconnect/common/dto/BaseResponse<TT;>; ()TT; &()Ljava/util/List<Ljava/lang/String;>; 	setStatus -(Lbr/com/legalconnect/enums/StatusResponse;)V MethodParameters 
setMessage (Ljava/lang/String;)V setTimestamp (Ljava/time/LocalDateTime;)V setData (Ljava/lang/Object;)V (TT;)V 	setErrors (Ljava/util/List;)V '(Ljava/util/List<Ljava/lang/String;>;)V o other this$status other$status this$message 
other$message this$timestamp other$timestamp 	this$data 
other$data this$errors other$errors 0Lbr/com/legalconnect/common/dto/BaseResponse<*>; 
StackMapTable PRIME I result $status $message 
$timestamp $data $errors toString z(Lbr/com/legalconnect/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;Ljava/lang/Object;Ljava/util/List;)V (Lbr/com/legalconnect/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;TT;Ljava/util/List<Ljava/lang/String;>;)V (<T:Ljava/lang/Object;>Ljava/lang/Object; 
SourceFile BaseResponse.java RuntimeVisibleAnnotations .Lcom/fasterxml/jackson/annotation/JsonInclude; value 6Lcom/fasterxml/jackson/annotation/JsonInclude$Include; NON_NULL NestMembers BootstrapMethods 
    F  $java/lang/invoke/StringConcatFactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;  @BaseResponse(status=, message=, timestamp=, data=, errors=) InnerClasses BaseResponseBuilder  4com/fasterxml/jackson/annotation/JsonInclude$Include  ,com/fasterxml/jackson/annotation/JsonInclude Include  %java/lang/invoke/MethodHandles$Lookup  java/lang/invoke/MethodHandles Lookup !  &                       I    J     I    K  	 L M  N          » Y· °    O        I    P  # $  N   A     *´ °    O        Q        R S   T        R U    , -  N   A     *´ 
°    O         Q        R S   T        R U    0 1  N   A     *´ °    O       ! Q        R S   T        R U    4 5  N   A     *´ °    O       " Q        R S   T        R U   I    V  8 9  N   A     *´ °    O       # Q        R S   T        R U   I    W  X Y  N   L     *+µ ±    O        Q        R S         T        R U   Z       [ \  N   L     *+µ 
±    O        Q        R S         T        R U   Z       ] ^  N   L     *+µ ±    O        Q        R S         T        R U   Z       _ `  N   V     *+µ ±    O        Q        R S         T        R U       J  Z      I    a  b c  N   V     *+µ ±    O        Q        R S         T        R U       K  Z      I    d  )    N  Ü  
   ×+*¦ ¬+Á  ¬+À M,*¶  ¬*¶ !N,¶ !:-Ç Æ § -¶ % ¬*¶ *:,¶ *:Ç Æ § 
¶ % ¬*¶ .:,¶ .:Ç Æ § 
¶ % ¬*¶ 2:	,¶ 2:
	Ç 
Æ § 
	
¶ % ¬*¶ 6:,¶ 6:Ç Æ § 
¶ % ¬¬    O        Q    
   × R S     × e    Â f S  $ ³ g   * ­ h   G  i   M  j   l k k   r e l    F m  	  @ n  
 ¶ ! o   ¼  p   T       × R U    Â f q  r   A ü  ý  & &ý  & &	ý  & &	ý  & &	ý  & &	 Z    e       N   K     +Á ¬    O        Q        R S      f   T        R U   Z    f   < =  N  ö     ;<=*¶ !N;h-Ç +§ -¶ :`=*¶ *:;hÇ +§ ¶ :`=*¶ .:;hÇ +§ ¶ :`=*¶ 2:;hÇ +§ ¶ :`=*¶ 6:;hÇ +§ ¶ :`=¬    O        Q   R     R S     s t    u t  
  v   # h w   > M x   Y 2 y   t  z   T        R U   r   ã 
ÿ    & ÿ    & ÿ    & & ÿ    & & ÿ    & & & ÿ    & & & ÿ    & & & & ÿ    & & & & ÿ    & & & & & ÿ    & & & & &   { -  N   b     &*¶ !¸ >*¶ **¶ .¸ >*¶ 2¸ >*¶ 6¸ >º D  °    O        Q       & R S   T       & R U       N   A     *· H±    O        Q        R S   T        R U     |  N   ¢      *· H*+µ *,µ 
*-µ *µ *µ ±    O        Q   >      R S                                      T          R U        J       K  Z              I    }  I    ~         
    e                         	   @    
```
```java
Êþº¾   = A
      +br/com/legalconnect/common/dto/BaseResponse <init> ()V	  	 
   (br/com/legalconnect/enums/StatusResponse SUCESSO *Lbr/com/legalconnect/enums/StatusResponse;
      1br/com/legalconnect/common/dto/SuccessResponseDTO 	setStatus -(Lbr/com/legalconnect/enums/StatusResponse;)V
      java/time/LocalDateTime now ()Ljava/time/LocalDateTime;
     setTimestamp (Ljava/time/LocalDateTime;)V
  
     ! 
setMessage (Ljava/lang/String;)V # SuccessResponseDTO()
  % & ' canEqual (Ljava/lang/Object;)Z
  ) * ' equals
  , - . hashCode ()I Code LineNumberTable LocalVariableTable this 3Lbr/com/legalconnect/common/dto/SuccessResponseDTO; message Ljava/lang/String; MethodParameters toString ()Ljava/lang/String; o Ljava/lang/Object; other 
StackMapTable result I 
SourceFile SuccessResponseDTO.java !            /   I     *· *² ¶ 
*¸ ¶ ±    0              1        2 3     !  /   F     
*· *+¶ ±    0       $  % 	 & 1       
 2 3     
 4 5  6    4    7 8  /   -     "°    0        1        2 3    * '  /   z     ++*¦ ¬+Á  ¬+À M,*¶ $ ¬*+· ( ¬¬    0        1        + 2 3     + 9 :    ; 3  <    ü  	 6    9   & '  /   9     +Á ¬    0        1        2 3      ; :  6    ;   - .  /   ;     *· +<¬    0        1        2 3     = >   ?    @
```
```java
Êþº¾   = =
      java/lang/RuntimeException <init> (Ljava/lang/String;)V	  	 
   6br/com/legalconnect/common/exception/BusinessException 	errorCode 0Lbr/com/legalconnect/common/exception/ErrorCode;  java/lang/String
      .br/com/legalconnect/common/exception/ErrorCode 
getMessage ()Ljava/lang/String;	     args [Ljava/lang/String;	     
httpStatus %Lorg/springframework/http/HttpStatus;	     !  #org/springframework/http/HttpStatus BAD_REQUEST
  #  $ k(Lbr/com/legalconnect/common/exception/ErrorCode;Lorg/springframework/http/HttpStatus;[Ljava/lang/String;)V
  & ' ( getFormattedMessage '([Ljava/lang/Object;)Ljava/lang/String;
  * +  getCode j(Lbr/com/legalconnect/common/exception/ErrorCode;Lorg/springframework/http/HttpStatus;Ljava/lang/String;)V Code LineNumberTable LocalVariableTable this 8Lbr/com/legalconnect/common/exception/BusinessException; Ljava/lang/String; MethodParameters F(Lbr/com/legalconnect/common/exception/ErrorCode;[Ljava/lang/String;)V getErrorCode 2()Lbr/com/legalconnect/common/exception/ErrorCode; getArgs ()[Ljava/lang/String; 
getHttpStatus '()Lorg/springframework/http/HttpStatus; 
SourceFile BusinessException.java !                        ,  -   {     #*-· *+µ *½ 
Y-SY+¶ Sµ *,µ ±    .          
    "  /   *    # 0 1     #      #      #  2  3   
            4  -   L     
*+² ,· "±    .   
    & 	 ' /        
 0 1     
      
    3   	         $  -   q     *+-¶ %· *+µ *-µ *,µ ±    .       2 	 4  5  6  8 /   *     0 1                     3   
              -   6     *´ *´ ¶ %°    .       @ /        0 1    +   -   2     *´ ¶ )°    .       H /        0 1    5 6  -   /     *´ °    .        /        0 1    7 8  -   /     *´ °    .        /        0 1    9 :  -   /     *´ °    .        /        0 1    ;    <
```
```java
Êþº¾   =K  .br/com/legalconnect/common/exception/ErrorCode	     DADOS_INVALIDOS 0Lbr/com/legalconnect/common/exception/ErrorCode;	   	  REQUISICAO_MAL_FORMADA	     PARAMETRO_AUSENTE	     ENTIDADE_NAO_ENCONTRADA	     EMPRESA_NAO_ENCONTRADA	     PROFISSIONAL_NAO_ENCONTRADO	     CLIENTE_NAO_ENCONTRADO	     ADMINISTRADOR_NAO_ENCONTRADO	     PLANO_NAO_ENCONTRADO	    !  USER_NAO_ENCONTRADO	  # $  CNPJ_DUPLICADO	  & '  
CPF_DUPLICADO	  ) *  
OAB_DUPLICADA	  , -  EMAIL_DUPLICADO	  / 0  NOME_PLANO_DUPLICADO	  2 3  INTEGRIDADE_VIOLADA	  5 6  RECURSO_EM_USO	  8 9  ERRO_INTERNO_SERVIDOR	  ; <  SERVICO_INDISPONIVEL	  > ?  
GENERIC_ERROR	  A B  
INVALID_INPUT	  D E  RESOURCE_NOT_FOUND	  G H  UNAUTHORIZED_ACCESS	  J K  FORBIDDEN_ACCESS	  M N  SERVICE_UNAVAILABLE	  P Q  TOO_MANY_REQUESTS	  S T  VALIDATION_ERROR	  V W  DATABASE_ERROR	  Y Z  INTEGRATION_ERROR	  \ ]  INVALID_CREDENTIALS	  _ `  ACCOUNT_LOCKED	  b c  ACCOUNT_DISABLED	  e f  
TOKEN_EXPIRED	  h i  
INVALID_TOKEN	  k l  REFRESH_TOKEN_EXPIRED	  n o  INVALID_REFRESH_TOKEN	  q r  USER_NOT_FOUND	  t u  EMAIL_ALREADY_REGISTERED	  w x  PASSWORD_RESET_FAILED	  z {  INVALID_CURRENT_PASSWORD	  } ~  PASSWORD_RESET_TOKEN_INVALID	     PASSWORD_RESET_TOKEN_EXPIRED	     PASSWORD_RESET_TOKEN_USED	     PASSWORD_RESET_TOKEN_EXCEEDED	     TENANT_NOT_FOUND	     TENANT_DISABLED	     SUBSCRIPTION_EXPIRED	     PLAN_NOT_ACTIVE	     SERVICE_LIMIT_EXCEEDED	     ADVOCATE_NOT_AVAILABLE	     APPOINTMENT_CONFLICT	     PAYMENT_FAILED	  ¡ ¢  INVALID_PROMO_CODE	  ¤ ¥  DOCUMENT_UPLOAD_FAILED	  § ¨  INVALID_DOCUMENT_FORMAT	  ª «  FIELD_REQUIRED	  ­ ®  INVALID_FORMAT	  ° ±  
MIN_LENGTH	  ³ ´  
MAX_LENGTH	  ¶ ·  
INVALID_EMAIL	  ¹ º  INVALID_CPF	  ¼ ½  INVALID_CNPJ	  ¿ À  PASSWORD_TOO_WEAK	  Â Ã  DATE_IN_PAST	  Å Æ  INVALID_ENUM_VALUE	  È É Ê $VALUES 1[Lbr/com/legalconnect/common/exception/ErrorCode;
 Ì Í Ê Î Ï clone ()Ljava/lang/Object;
 Ñ Ò Ó Ô Õ java/lang/Enum valueOf 5(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
 Ñ × Ø Ù <init> (Ljava/lang/String;I)V	  Û Ü Ý code Ljava/lang/String;	  ß à Ý message
 â ã ä å æ java/lang/String format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;  é 001 ë !Dados fornecidos sÃ£o invÃ¡lidos.
  í Ø î :(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V 	 ñ 002 ó !A requisiÃ§Ã£o estÃ¡ mal formada.  ö 003 ø  ParÃ¢metro obrigatÃ³rio ausente.  û 100 ý Entidade nÃ£o encontrada.   101 Empresa nÃ£o encontrada.  102 Profissional nÃ£o encontrado. 
 103 Cliente nÃ£o encontrado.  104 Administrador nÃ£o encontrado.  105 Plano nÃ£o encontrado. ! 106 #UsuÃ¡rio associado nÃ£o encontrado. $ 200  CNPJ jÃ¡ cadastrado. '# 201% CPF jÃ¡ cadastrado. *( 202* NÃºmero da OAB jÃ¡ cadastrado. -- 203/ Email jÃ¡ cadastrado. 02 2044 Nome do plano jÃ¡ cadastrado. 37 3009 #ViolaÃ§Ã£o de integridade de dados. 6< 301> 2Recurso nÃ£o pode ser excluÃ­do pois estÃ¡ em uso. 9A 500C $Ocorreu um erro interno no servidor. <F 503H 'ServiÃ§o temporariamente indisponÃ­vel. ?K 1000M BOcorreu um erro inesperado. Por favor, tente novamente mais tarde. BP 1001R Dados de entrada invÃ¡lidos. EU 1002W Recurso nÃ£o encontrado. HZ 1003\ ;Acesso nÃ£o autorizado. Credenciais invÃ¡lidas ou ausentes. K_ 1004a CAcesso negado. VocÃª nÃ£o tem permissÃ£o para realizar esta aÃ§Ã£o. Nd 1005f KO serviÃ§o estÃ¡ temporariamente indisponÃ­vel. Tente novamente mais tarde. Qi 1006k ;Muitas requisiÃ§Ãµes. Por favor, aguarde e tente novamente. Tn 1007p )Erro de validaÃ§Ã£o nos dados fornecidos. Ws 1008u !Erro ao acessar o banco de dados. Zx 1009z *Erro de integraÃ§Ã£o com serviÃ§o externo. ]} 2000 )Credenciais de autenticaÃ§Ã£o invÃ¡lidas. ` 2001 Sua conta estÃ¡ bloqueada. c 2002 Sua conta estÃ¡ desativada. f 2003 O token de acesso expirou. i 2004 O token de acesso Ã© invÃ¡lido. l 2005 /O refresh token expirou. FaÃ§a login novamente. o 2006 O refresh token Ã© invÃ¡lido. r  2007¢ UsuÃ¡rio nÃ£o encontrado. u¥ 2008§ !Este e-mail jÃ¡ estÃ¡ cadastrado. xª 2009¬ Falha ao redefinir a senha. {¯ 2010± (A senha atual fornecida estÃ¡ incorreta. ~´ 2011¶ *Token de redefiniÃ§Ã£o de senha invÃ¡lido. ¹ 2012» )Token de redefiniÃ§Ã£o de senha expirado. ¾ 2013À .Token de redefiniÃ§Ã£o de senha jÃ¡ utilizado. Ã 2014Å +Limite de redefiniÃ§Ãµes de senha excedido. È 3000Ê Tenant nÃ£o encontrado. Í 3001Ï O tenant estÃ¡ desativado. Ò 3002Ô Sua assinatura expirou. × 3003Ù %O plano selecionado nÃ£o estÃ¡ ativo. Ü 3004Þ :Limite de serviÃ§os agendÃ¡veis excedido para o seu plano. á 3005ã 2Advogado nÃ£o disponÃ­vel no horÃ¡rio selecionado. æ 3006è 6Conflito de agendamento. O horÃ¡rio jÃ¡ estÃ¡ ocupado. ë 3007í $Falha no processamento do pagamento. ¢ð 3008ò *CÃ³digo promocional invÃ¡lido ou expirado. ¥õ 3009÷ #Falha ao fazer upload do documento. ¨ú 3010ü Formato de documento invÃ¡lido. «ÿ 4000 O campo '%s' Ã© obrigatÃ³rio. ® 4001 &O campo '%s' possui formato invÃ¡lido. ±	 4002 /O campo '%s' deve ter no mÃ­nimo %d caracteres. ´ 4003 /O campo '%s' deve ter no mÃ¡ximo %d caracteres. · 4004  O e-mail fornecido Ã© invÃ¡lido. º 4005 O CPF fornecido Ã© invÃ¡lido. ½ 4006 O CNPJ fornecido Ã© invÃ¡lido. À" 4007$ A senha Ã© muito fraca. Ã' 4008)  A data nÃ£o pode ser no passado. Æ, 4009. "Valor invÃ¡lido para o campo '%s'.
 012 $values 3()[Lbr/com/legalconnect/common/exception/ErrorCode; values Code LineNumberTable D(Ljava/lang/String;)Lbr/com/legalconnect/common/exception/ErrorCode; LocalVariableTable name MethodParameters this 
$enum$name 
$enum$ordinal 	Signature '(Ljava/lang/String;Ljava/lang/String;)V getFormattedMessage '([Ljava/lang/Object;)Ljava/lang/String; args [Ljava/lang/Object; getCode ()Ljava/lang/String; 
getMessage <clinit> ()V BLjava/lang/Enum<Lbr/com/legalconnect/common/exception/ErrorCode;>; 
SourceFile ErrorCode.java@1  Ñ   D@    @ 	   @    @    @    @    @    @    @    @ !   @ $   @ '   @ *   @ -   @ 0   @ 3   @ 6   @ 9   @ <   @ ?   @ B   @ E   @ H   @ K   @ N   @ Q   @ T   @ W   @ Z   @ ]   @ `   @ c   @ f   @ i   @ l   @ o   @ r   @ u   @ x   @ {   @ ~   @    @    @    @    @    @    @    @    @    @    @    @ ¢   @ ¥   @ ¨   @ «   @ ®   @ ±   @ ´   @ ·   @ º   @ ½   @ À   @ Ã   @ Æ     Ü Ý    à Ý   É Ê    	32 4   "      
² Ç¶ ËÀ Ì°   5        	 Ô6 4   4     
*¸ ÐÀ °   5       7       
8 Ý  9   8   Ø î 4   \     *+· Ö*-µ Ú*µ Þ±   5       m  n  o  p7        :       Ü Ý     à Ý 9   ; <  Ü   à  =   > ?@ 4   =     	*´ Þ+¸ á°   5       x7       	:      	AB 9   A   CD 4   /     *´ Ú°   5       d7       :    ED 4   /     *´ Þ°   5       e7       :   
12 4  ß     ÇA½ Y² SY² SY² 
SY² 
SY² SY² SY² SY² SY² SY	² SY
² "SY² %SY² (SY
² +SY² .SY² 1SY² 4SY² 7SY² :SY² =SY² @SY² CSY² FSY² ISY² LSY² OSY² RSY² USY² XSY² [SY² ^SY² aSY ² dSY!² gSY"² jSY#² mSY$² pSY%² sSY&² vSY'² ySY(² |SY)² SY*² SY+² SY,² SY-² SY.² SY/² SY0² SY1² SY2² SY3² SY4²  SY5² £SY6² ¦SY7² ©SY8² ¬SY9² ¯SY:² ²SY;² µSY<² ¸SY=² »SY>² ¾SY?² ÁSY@² ÄS°   5        FG 4  d     H» Yçèê· ì³ » Yïðò· ì³ » Yôõ÷· ì³ 
» Yùúü· ì³ 
» Yþÿ· ì³ » Y· ì³ » Y	· ì³ » Y
· ì³ » Y· ì³ » Y	· ì³ » Y
· ì³ "» Y!"$· ì³ %» Y&')· ì³ (» Y+
,.· ì³ +» Y013· ì³ .» Y568· ì³ 1» Y:;=· ì³ 4» Y?@B· ì³ 7» YDEG· ì³ :» YIJL· ì³ =» YNOQ· ì³ @» YSTV· ì³ C» YXY[· ì³ F» Y]^`· ì³ I» Ybce· ì³ L» Yghj· ì³ O» Ylmo· ì³ R» Yqrt· ì³ U» Yvwy· ì³ X» Y{|~· ì³ [» Y· ì³ ^» Y· ì³ a» Y · ì³ d» Y!· ì³ g» Y"· ì³ j» Y#· ì³ m» Y$¡· ì³ p» Y£%¤¦· ì³ s» Y¨&©«· ì³ v» Y­'®°· ì³ y» Y²(³µ· ì³ |» Y·)¸º· ì³ » Y¼*½¿· ì³ » YÁ+ÂÄ· ì³ » YÆ,ÇÉ· ì³ » YË-ÌÎ· ì³ » YÐ.ÑÓ· ì³ » YÕ/ÖØ· ì³ » YÚ0ÛÝ· ì³ » Yß1àâ· ì³ » Yä2åç· ì³ » Yé3êì· ì³ » Yî4ïñ· ì³  » Yó5ôö· ì³ £» Yø6ùû· ì³ ¦» Yý7þ · ì³ ©» Y8· ì³ ¬» Y9
· ì³ ¯» Y:
· ì³ ²» Y;· ì³ µ» Y<· ì³ ¸» Y=· ì³ »» Y >!#· ì³ ¾» Y%?&(· ì³ Á» Y*@+-· ì³ Ä¸/³ Ç±   5  
 B      "  3  D  V  j      ©  ¾  Ó   è ! ý " #' &< 'Q *f +{ . /¥ 0º 1Ï 2ä 3ù 4 5# 68 7M :b ;w < =¡ >¶ ?Ë @à Aõ B
 C D4 EI F^ Gs H K L² MÇ NÜ Oñ P Q R0 SE TZ Uo Y Z [® \Ã ]Ø ^í _ ` a, bA  =   HI   J
```
```java
Êþº¾   =
      java/lang/Object <init> ()V	  	 
   ;br/com/legalconnect/common/exception/GlobalExceptionHandler log Lorg/slf4j/Logger;  !Business Exception: {} - Path: {}
      6br/com/legalconnect/common/exception/BusinessException 
getMessage ()Ljava/lang/String;      2org/springframework/web/context/request/WebRequest getDescription (Z)Ljava/lang/String;       org/slf4j/Logger warn 9(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/Object;)V
 " # $ % & +br/com/legalconnect/common/dto/BaseResponse builder C()Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder;	 ( ) * + , (br/com/legalconnect/enums/StatusResponse ERRO *Lbr/com/legalconnect/enums/StatusResponse;
 . / 0 1 2 ?br/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder status m(Lbr/com/legalconnect/enums/StatusResponse;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder;
 . 4 5 6 message U(Ljava/lang/String;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder;
  8 9  getCode ; < = > ? java/util/List of $(Ljava/lang/Object;)Ljava/util/List;
 . A B C errors S(Ljava/util/List;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder;
 E F G H I java/time/LocalDateTime now ()Ljava/time/LocalDateTime;
 . K L M 	timestamp \(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/common/dto/BaseResponse$BaseResponseBuilder;
  O P Q getArgs ()[Ljava/lang/String;
 S T U V W java/util/Arrays asList %([Ljava/lang/Object;)Ljava/util/List;
 . Y Z [ build /()Lbr/com/legalconnect/common/dto/BaseResponse; ] 'org/springframework/http/ResponseEntity
  _ ` a 
getHttpStatus '()Lorg/springframework/http/HttpStatus;
 \ c  d >(Ljava/lang/Object;Lorg/springframework/http/HttpStatusCode;)V
 f g h i j <org/springframework/web/bind/MethodArgumentNotValidException getBindingResult 0()Lorg/springframework/validation/BindingResult; l m n o p ,org/springframework/validation/BindingResult getAllErrors ()Ljava/util/List; ; r s t stream ()Ljava/util/stream/Stream;   v w x apply ()Ljava/util/function/Function; z { | } ~ java/util/stream/Stream map 8(Ljava/util/function/Function;)Ljava/util/stream/Stream;
      java/util/stream/Collectors toList ()Ljava/util/stream/Collector; z    collect 0(Ljava/util/stream/Collector;)Ljava/lang/Object;  0Validation Exception: {} - Errors: {} - Path: {}
 f      ((Ljava/lang/String;[Ljava/lang/Object;)V	      .br/com/legalconnect/common/exception/ErrorCode VALIDATION_ERROR 0Lbr/com/legalconnect/common/exception/ErrorCode;
  	      #org/springframework/http/HttpStatus BAD_REQUEST %Lorg/springframework/http/HttpStatus;  "Unhandled Exception: {} - Path: {}
     java/lang/Exception  ¢ £  error	  ¥ ¦  
GENERIC_ERROR
  8	  © ª  INTERNAL_SERVER_ERROR ¬ )org/springframework/validation/FieldError
 « ® ¯  getField
 ± ² ³ ´  *org/springframework/validation/ObjectError 
getObjectName
 ± ¶ ·  getDefaultMessage ¹ Campo '%s': %s
 » ¼ ½ ¾ ¿ java/lang/String format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;
 Á Â Ã Ä Å org/slf4j/LoggerFactory 	getLogger %(Ljava/lang/Class;)Lorg/slf4j/Logger; Code LineNumberTable LocalVariableTable this =Lbr/com/legalconnect/common/exception/GlobalExceptionHandler; handleBusinessException (Lbr/com/legalconnect/common/exception/BusinessException;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity; ex 8Lbr/com/legalconnect/common/exception/BusinessException; request 4Lorg/springframework/web/context/request/WebRequest; 
errorResponse -Lbr/com/legalconnect/common/dto/BaseResponse; MethodParameters 	Signature Æ(Lbr/com/legalconnect/common/exception/BusinessException;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity<Lbr/com/legalconnect/common/dto/BaseResponse;>; RuntimeVisibleAnnotations :Lorg/springframework/web/bind/annotation/ExceptionHandler; value handleValidationExceptions (Lorg/springframework/web/bind/MethodArgumentNotValidException;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity; >Lorg/springframework/web/bind/MethodArgumentNotValidException; Ljava/util/List; LocalVariableTypeTable $Ljava/util/List<Ljava/lang/String;>; Ì(Lorg/springframework/web/bind/MethodArgumentNotValidException;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity<Lbr/com/legalconnect/common/dto/BaseResponse;>; handleGlobalException t(Ljava/lang/Exception;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity; Ljava/lang/Exception; £(Ljava/lang/Exception;Lorg/springframework/web/context/request/WebRequest;)Lorg/springframework/http/ResponseEntity<Lbr/com/legalconnect/common/dto/BaseResponse;>; #lambda$handleValidationExceptions$0 @(Lorg/springframework/validation/ObjectError;)Ljava/lang/String; ,Lorg/springframework/validation/ObjectError; 	fieldName Ljava/lang/String; errorMessage 
StackMapTable <clinit> 
SourceFile GlobalExceptionHandler.java :Lorg/springframework/web/bind/annotation/ControllerAdvice; BootstrapMethods ñ
 ò ó ô õ ö "java/lang/invoke/LambdaMetafactory metafactory Ì(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite; ø &(Ljava/lang/Object;)Ljava/lang/Object; ú
  û ä å å InnerClasses BaseResponseBuilder  %java/lang/invoke/MethodHandles$Lookup java/lang/invoke/MethodHandles Lookup !                Æ   /     *· ±    Ç       ! È        É Ê    Ë Ì  Æ   ¸     P² 
+¶ ,¹  ¹  ¸ !² '¶ -+¶ ¶ 3+¶ 7¸ :¶ @¸ D¶ J+¶ N¸ R¶ @¶ XN» \Y-+¶ ^· b°    Ç   & 	   0  2  3  4 & 5 / 6 6 7 ? 8 C : È   *    P É Ê     P Í Î    P Ï Ð  C 
 Ñ Ò  Ó   	 Í   Ï   Ô    Õ Ö     ×  Ø[ c Î  Ù Ú  Æ  	     u+¶ e¹ k ¹ q º u  ¹ y ¸ ¹  À ;N² ½ Y+¶ SY-SY,¹  S¹  ¸ !² '¶ -² ¶ ¶ 3-¶ @¸ D¶ J¶ X:» \Y² · b°    Ç   6 
   M  N  U $ W < X B W G Z M [ S \ Z ] ] ^ c _ h a È   4    u É Ê     u Í Û    u Ï Ð  $ Q B Ü  h 
 Ñ Ò  Ý     $ Q B Þ  Ó   	 Í   Ï   Ô    ß Ö     ×  Ø[ c Û  à á  Æ   »     W² ½ Y+¶ SY,¹  SY+S¹ ¡ ¸ !² '¶ -² ¤¶ ¶ 3² ¤¶ §¸ :¶ @¸ D¶ J¶ XN» \Y-² ¨· b°    Ç   "    r # t ) u / v 8 w A y G z K | È   *    W É Ê     W Í â    W Ï Ð  K  Ñ Ò  Ó   	 Í   Ï   Ô    ã Ö     ×  Ø[ c â
 ä å  Æ        -*Á « 
*À «¶ ­§ *¶ °L*¶ µM¸½ Y+SY,S¸ º°    Ç       O  P  Q  R  S È        - £ æ     ç è    é è  ê    C »  ë   Æ   !      	¸ À³ ±    Ç         ì    í Ö     î   ï     ð  ÷ ù ü ý     . " þ 	 ÿ 
```
```java
Êþº¾   = E
      java/lang/Object <init> ()V  *br/com/legalconnect/common/exception/Roles 
 ROLE_
  
    java/lang/String 
startsWith (Ljava/lang/String;)Z      makeConcatWithConstants &(Ljava/lang/String;)Ljava/lang/String;
     length ()I
     	substring (I)Ljava/lang/String; 
ROLE_ADMIN Ljava/lang/String; 
ConstantValue  ROLE_TENANT_ADMIN ! 
ROLE_ADVOCATE # ROLE_CLIENT % 	ROLE_USER ' PREFIX Code LineNumberTable LocalVariableTable this ,Lbr/com/legalconnect/common/exception/Roles; 
withPrefix roleName 
StackMapTable MethodParameters 
withoutPrefix 
SourceFile 
Roles.java BootstrapMethods 8
 9 : ;  < $java/lang/invoke/StringConcatFactory (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; > ROLE_ InnerClasses A %java/lang/invoke/MethodHandles$Lookup C java/lang/invoke/MethodHandles Lookup 1                 !       "  #       $  %       &  '       (  )       	      *   3     *· ±    +   
       ,        - .   	 /   *   Q     *Æ *	¶  
*º   °*°    +       ( 
 )  + ,        0    1     2    0   	 3   *   T     *Æ *	¶  
*	¶ ¶ °*°    +       4 
 5  7 ,        0    1     2    0    4    5 6     7  = ?   
  @ B D 
```
```java
Êþº¾   = S
      java/lang/Object <init> ()V
  	 
   java/lang/String length ()I  
(\d)\1{10}
     matches (Ljava/lang/String;)Z
     charAt (I)C   java/util/InputMismatchException  
(\d)\1{13}	       -br/com/legalconnect/common/util/ValidatorUtil 
EMAIL_PATTERN Ljava/util/regex/Pattern;
 " # $ % & java/util/regex/Pattern matcher 3(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;
 ( ) *  + java/util/regex/Matcher ()Z - M^[a-zA-Z0-9_+&*-]+(?:\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,7}$
 " / 0 1 compile -(Ljava/lang/String;)Ljava/util/regex/Pattern; EMAIL_REGEX Ljava/lang/String; 
ConstantValue Code LineNumberTable LocalVariableTable this /Lbr/com/legalconnect/common/util/ValidatorUtil; 
isValidCPF num I dig10 C dig11 sm i r peso erro "Ljava/util/InputMismatchException; cpf 
StackMapTable MethodParameters isValidCNPJ dig13 dig14 cnpj isValidEmail email Ljava/util/regex/Matcher; <clinit> 
SourceFile ValidatorUtil.java 1       2 3  4    ,            5   3     *· ±    6   
       7        8 9   	 :   5  H  	   Ü*Æ *¶   *
¶  ¬>
66	¢ "*¶ 0d6h`>d6§ÿÝpd6
 
  	0<§ 
0`<>66
¢ "*¶ 0d6h`>d6§ÿÝpd6
 
  	0=§ 
0`=*	¶   *
¶   § ¬:¬   × Ø   6   n    %  &  .  /  0 ( 1 3 2 ; 3 A 0 G 6 P 7 ^ 8 d : k = m > q ? { @  A  B  ?  E £ F ± G · I ¾ L Ø M Ú N 7   z  3  ; <  a  = >    ; <  ´  ? >  k m = >  ¾  ? >   ¾ @ <  ! · A <  P  B <   º C <  Ú  D E    Ü F 3   G   ^ ÿ         %ÿ        ÿ       %ÿ      @ÿ       H    F   	 I   5  ¤  	   æ*Æ *¶   *¶  ¬>66 ,*¶ 0d6h`>`6
  6ÿ§ÿÕp6 	  	0<§ 
d0`<>66 ,*¶ 0d6h`>`6
  6ÿ§ÿÕp6 	  	0=§ 
d0`=*¶   *
¶   § ¬:¬   á â   6   ~    \  ]  e  f  g & h 1 i 9 j ? k F l I g O o U p ` q f s p v r w u x ~ y  z  {  |  } ¡ x §  ­  ¸  ¾  È  â  ä  7   z  1  ; <  c  J >    ; <  »  K >  p r J >  È  K >   È @ <  ! Á A <  U  B <   Å C <  ä  D E    æ L 3   G     ÿ         ÿ '       ÿ         ÿ        ÿ 	      ÿ '     ÿ       ÿ 	     @ÿ       H    L   	 M   5   \     *Ç ¬² *¶ !L+¶ '¬    6              7        N 3     % O  G     H    N    P   5   !      	,¸ .³ ±    6         Q    R
```
```java
Êþº¾   = 9  (br/com/legalconnect/enums/StatusResponse	     SUCESSO *Lbr/com/legalconnect/enums/StatusResponse;	   	  ERRO	     AVISO	     $VALUES +[Lbr/com/legalconnect/enums/StatusResponse;
      clone ()Ljava/lang/Object;
      java/lang/Enum valueOf 5(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum;
     <init> (Ljava/lang/String;I)V 
   	 
  % & ' $values -()[Lbr/com/legalconnect/enums/StatusResponse; values Code LineNumberTable >(Ljava/lang/String;)Lbr/com/legalconnect/enums/StatusResponse; LocalVariableTable name Ljava/lang/String; MethodParameters this 
$enum$name 
$enum$ordinal 	Signature ()V <clinit> <Ljava/lang/Enum<Lbr/com/legalconnect/enums/StatusResponse;>; 
SourceFile StatusResponse.java@1     @    @ 	   @          	 ( '  )   "      
² 
¶ À °    *        	  +  )   4     
*¸ À °    *        ,       
 - .   /    -      )   1     *+· ±    *        ,        0    /   	 1  2  3    4
 & '  )   /      ½ Y² SY² SY² 
S°    *         5 4  )   R      .» Y · !³ » Y"· !³ » Y#· !³ 
¸ $³ 
±    *        
    '   3    6 7    8
```
```java
artifactId=common-lib
groupId=br.com.legalconnect.common
version=1.0.0

```
```java
br\com\legalconnect\common\dto\BaseEntity.class
br\com\legalconnect\common\exception\BusinessException.class
br\com\legalconnect\common\exception\Roles.class
br\com\legalconnect\common\exception\GlobalExceptionHandler.class
br\com\legalconnect\common\dto\SuccessResponseDTO.class
br\com\legalconnect\common\dto\BaseResponse$BaseResponseBuilder.class
br\com\legalconnect\enums\StatusResponse.class
br\com\legalconnect\common\exception\ErrorCode.class
br\com\legalconnect\common\dto\BaseResponse.class
br\com\legalconnect\common\dto\BaseEntity$BaseEntityBuilder.class
br\com\legalconnect\common\util\ValidatorUtil.class

```
```java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\exception\ErrorCode.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\exception\GlobalExceptionHandler.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\dto\BaseEntity.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\dto\SuccessResponseDTO.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\dto\BaseResponse.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\exception\Roles.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\util\ValidatorUtil.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\common\exception\BusinessException.java
E:\legalconnect\legalconnect\microservices\common-lib\src\main\java\br\com\legalconnect\enums\StatusResponse.java

```
```java

```
```java

```
```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.12</version> <!-- Mantém a versão do Spring Boot -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <groupId>br.com.legalconnect.common</groupId>
    <artifactId>common-lib</artifactId>
    <version>1.0.1</version>
    <name>LegalConnect Common Library</name>
    <description>Common utilities, entities, and configurations for LegalConnect microservices</description>
    <packaging>jar</packaging> <!-- Define como um JAR de biblioteca -->

    <properties>
        <java.version>17</java.version> <!-- Defina a versão do Java que você está usando -->
        <lombok.version>1.18.30</lombok.version> <!-- Versão explícita para Lombok -->
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Versão explícita para
        MapStruct -->
        <!-- Removido springdoc.version e flyway.version pois são configurações mais específicas de
        aplicação -->
    </properties>

    <dependencies>
        <!-- Spring Boot Starter Validation para anotações de validação em DTOs, útil em qualquer
        camada -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Spring Boot Starter Data JPA para BaseEntity e classes de persistência/multitenancy -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <!-- Excluí HikariCP, pois a aplicação pode fornecer sua própria implementação ou o
            default é OK -->
            <exclusions>
                <exclusion>
                    <groupId>com.zaxxer</groupId>
                    <artifactId>HikariCP</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- Spring Context para anotações como @Configuration, @Component, etc., fundamental para
        uma lib Spring -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>

        <!-- Spring Security Core para GrantedAuthority (usado em UserDetails, por exemplo) em
        Roles.java -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
        </dependency>

        <!-- Spring Boot Starter JDBC, geralmente uma dependência transitória do JPA, mas explícito
        é bom -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>

        <!-- Jakarta Servlet API, necessário para WebRequest em GlobalExceptionHandler.
             Definido como 'provided' pois o container (Tomcat, Jetty) da aplicação cliente deve fornecê-lo. -->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version> <!-- Mantenha a versão compatível com seu Spring Boot -->
            <scope>provided</scope>
        </dependency>

        <!-- Adicionando spring-boot-starter-web para incluir as classes HTTP do Spring (como
        HttpStatus)
             e também o Jackson (com.fasterxml.jackson) transitivamente. -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <!-- Excluir Tomcat se a lib não precisar de um servidor web embutido para testes ou
                bootstrap.
                     Se a lib for apenas um conjunto de classes utilitárias e não uma API com endpoints,
                     você pode mantê-lo excluído. Para uma lib que pode conter GlobalExceptionHandler,
                     ter o web starter é geralmente útil. -->
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>

        <!-- Removida a dependência explícita do jackson-databind, pois spring-boot-starter-web a
        traz transitivamente. -->

        <!-- Lombok para reduzir boilerplate (getters, setters, construtores, builder) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope> <!-- Apenas em tempo de compilação/desenvolvimento -->
        </dependency>

        <!-- MapStruct para mappers de DTOs, se a lib contiver mappers genéricos -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>

        <!-- Dependência para logging, usada em BaseEntity e GlobalExceptionHandler -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.13</version> <!-- Use uma versão compatível ou deixe o Spring Boot gerenciar -->
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version> <!-- Mantenha esta versão para compatibilidade -->
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
legalconnect/
├── common-lib/
│   ├── pom.xml                                 # Configurações do Maven para a biblioteca comum
│   └── src/
│       └── main/
│           └── java/
│               └── br/com/legalconnect/common/
│                   ├── BaseEntity.java         # Entidade base para todos os modelos de dados
│                   ├── config/
│                   │   ├── FlywayMultiTenantConfig.java # Configuração Flyway para multitenancy (se global)
│                   │   ├── OpenApiConfig.java           # Configuração OpenAPI/Swagger UI
│                   │   └── WebConfig.java               # Configurações CORS e MVC gerais
│                   ├── constants/
│                   │   ├── ErrorCode.java               # Códigos de erro padronizados
│                   │   └── Roles.java                   # Constantes para papéis de usuário
│                   ├── dto/
│                   │   ├── BaseResponse.java            # DTO base para respostas da API
│                   │   └── SuccessResponseDTO.java      # DTO para respostas de sucesso simples
│                   ├── exception/
│                   │   ├── BusinessException.java       # Exceção de negócio personalizada
│                   │   └── GlobalExceptionHandler.java  # Manipulador global de exceções
│                   ├── multitenancy/
│                   │   ├── HibernateMultiTenantConfig.java # Configuração Hibernate para multitenancy
│                   │   ├── SchemaMultiTenantConnectionProvider.java # Provedor de conexão multi-tenant
│                   │   ├── SchemaTenantIdentifierResolver.java    # Resolvedor de identificador de tenant
│                   │   ├── TenantContext.java                     # Contexto da thread para o tenant atual
│                   │   └── TenantFilter.java                    # Filtro HTTP para extrair o tenant ID
│                   └── util/
│                       └── ValidatorUtil.java           # Utilitários de validação (ex: CPF, CNPJ)
```
```java
package br.com.legalconnect.common.dto;

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.persistence.Column;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class BaseEntity
 * @brief Classe base abstrata para todas as entidades persistentes.
 *        Fornece campos comuns como ID, data de criação e data de atualização.
 */
@Getter
@Setter
@NoArgsConstructor
@SuperBuilder
@MappedSuperclass // Indica que esta classe é uma superclasse mapeada para outras entidades
public abstract class BaseEntity implements Serializable {

    private static final Logger log = LoggerFactory.getLogger(BaseEntity.class);

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    protected UUID id; // Identificador único da entidade

    @Column(name = "created_at", nullable = false)
    protected LocalDateTime createdAt; // Data e hora de criação do registro

    @Column(name = "updated_at", nullable = false)
    protected LocalDateTime updatedAt; // Data e hora da última atualização do registro

    /**
     * Define a data de criação antes de persistir a entidade.
     */
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        log.debug("Criando entidade: {}. Data de criação: {}", this.getClass().getSimpleName(), createdAt);
    }

    /**
     * Atualiza a data de atualização antes de atualizar a entidade.
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        log.debug("Atualizando entidade: {}. ID: {}. Data de atualização: {}", this.getClass().getSimpleName(), id,
                updatedAt);
    }
}

```
```java
package br.com.legalconnect.common.dto;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonInclude;

import br.com.legalconnect.enums.StatusResponse;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class BaseResponse
 * @brief DTO base para padronizar as respostas da API.
 *
 *        Inclui campos comuns para todas as respostas, como status, mensagem,
 *        timestamp e, opcionalmente, uma lista de erros.
 *        Utiliza Lombok para reduzir boilerplate (getters, setters,
 *        construtores, builder).
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL) // Inclui apenas campos não nulos na serialização JSON
public class BaseResponse<T> {

    private StatusResponse status; // Status da resposta (ex: StatusResponse.SUCESSO, StatusResponse.ERRO,
                                   // "WARNING")
    private String message; // Mensagem descritiva da resposta
    private LocalDateTime timestamp; // Data e hora da resposta
    private T data; // Payload da resposta (dados de sucesso)
    private List<String> errors; // Lista de mensagens de erro, se houver
}

```
```java
package br.com.legalconnect.common.dto;

import java.time.LocalDateTime;

import br.com.legalconnect.enums.StatusResponse;
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * @class SuccessResponseDTO
 * @brief DTO para respostas de sucesso simples da API.
 *
 *        Estende {@link BaseResponse} e é usado para indicar operações
 *        bem-sucedidas
 *        que podem ou não retornar dados específicos.
 */
@Data
@EqualsAndHashCode(callSuper = true) // Inclui campos da superclasse no equals e hashCode
public class SuccessResponseDTO extends BaseResponse {

    /**
     * Construtor padrão para uma resposta de sucesso.
     * Define o status como StatusResponse.SUCESSO e o timestamp atual.
     */
    public SuccessResponseDTO() {
        this.setStatus(StatusResponse.SUCESSO);
        this.setTimestamp(LocalDateTime.now());
    }

    /**
     * Construtor para uma resposta de sucesso com uma mensagem específica.
     *
     * @param message A mensagem descritiva do sucesso.
     */
    public SuccessResponseDTO(String message) {
        this(); // Chama o construtor padrão para definir status e timestamp
        this.setMessage(message);
    }
}
```
```java
package br.com.legalconnect.common.enums;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
package br.com.legalconnect.common.exception;

import org.springframework.http.HttpStatus;

import lombok.Getter;

/**
 * @class BusinessException
 * @brief Exceção personalizada para representar erros de negócio na aplicação.
 *
 *        Esta exceção é lançada quando uma regra de negócio não é satisfeita.
 *        Ela encapsula um {@link ErrorCode} e, opcionalmente, argumentos para
 *        formatar
 *        a mensagem de erro, além de um status HTTP para a resposta da API.
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode; // O código de erro padronizado
    private final String[] args; // Argumentos para formatar a mensagem do erro
    private final HttpStatus httpStatus; // Status HTTP associado a esta exceção

    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String args) {
        super(args);
        this.errorCode = errorCode;
        this.args = new String[] { args, errorCode.getMessage() };
        this.httpStatus = httpStatus;
    }

    /**
     * Construtor para BusinessException com um ErrorCode e status HTTP padrão
     * (BAD_REQUEST).
     *
     * @param errorCode O código de erro que define o tipo de exceção de negócio.
     * @param args      Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, String... args) {
        this(errorCode, HttpStatus.BAD_REQUEST, args); // Por padrão, erros de negócio são BAD_REQUEST
    }

    /**
     * Construtor para BusinessException com um ErrorCode e um status HTTP
     * específico.
     *
     * @param errorCode  O código de erro que define o tipo de exceção de negócio.
     * @param httpStatus O status HTTP a ser retornado na resposta da API.
     * @param args       Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String... args) {
        super(errorCode.getFormattedMessage(args)); // Define a mensagem da exceção usando a mensagem formatada do
                                                    // ErrorCode
        this.errorCode = errorCode;
        this.args = args;
        this.httpStatus = httpStatus;

    }

    /**
     * @brief Retorna a mensagem de erro formatada.
     * @return A mensagem de erro formatada.
     */
    @Override
    public String getMessage() {
        return errorCode.getFormattedMessage(args);
    }

    /**
     * @brief Retorna o código de erro.
     * @return O código de erro.
     */
    public String getCode() {
        return errorCode.getCode();
    }
}

```
```java
package br.com.legalconnect.common.exception;

import lombok.Getter;

/**
 * @enum ErrorCode
 * @brief Enumeração que define códigos de erro padronizados para a aplicação.
 *
 *        Cada código de erro possui uma mensagem associada, facilitando a
 *        padronização
 *        de respostas de erro na API e a internacionalização ou localização
 *        futura.
 */
@Getter
public enum ErrorCode {
    // Erros gerais de validação
    DADOS_INVALIDOS("001", "Dados fornecidos são inválidos."),
    REQUISICAO_MAL_FORMADA("002", "A requisição está mal formada."),
    PARAMETRO_AUSENTE("003", "Parâmetro obrigatório ausente."),

    // Erros de entidade / negócio
    ENTIDADE_NAO_ENCONTRADA("100", "Entidade não encontrada."),
    EMPRESA_NAO_ENCONTRADA("101", "Empresa não encontrada."),
    PROFISSIONAL_NAO_ENCONTRADO("102", "Profissional não encontrado."),
    CLIENTE_NAO_ENCONTRADO("103", "Cliente não encontrado."),
    ADMINISTRADOR_NAO_ENCONTRADO("104", "Administrador não encontrado."),
    PLANO_NAO_ENCONTRADO("105", "Plano não encontrado."),
    USER_NAO_ENCONTRADO("106", "Usuário associado não encontrado."),

    // Erros de duplicidade
    CNPJ_DUPLICADO("200", "CNPJ já cadastrado."),
    CPF_DUPLICADO("201", "CPF já cadastrado."),
    OAB_DUPLICADA("202", "Número da OAB já cadastrado."),
    EMAIL_DUPLICADO("203", "Email já cadastrado."),
    NOME_PLANO_DUPLICADO("204", "Nome do plano já cadastrado."),

    // Erros de integridade
    INTEGRIDADE_VIOLADA("300", "Violação de integridade de dados."),
    RECURSO_EM_USO("301", "Recurso não pode ser excluído pois está em uso."),

    // Erros de sistema / internos
    ERRO_INTERNO_SERVIDOR("500", "Ocorreu um erro interno no servidor."),
    SERVICO_INDISPONIVEL("503", "Serviço temporariamente indisponível."),

    // Erros Gerais/Comuns (1000-1999)
    GENERIC_ERROR("1000", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde."),
    INVALID_INPUT("1001", "Dados de entrada inválidos."),
    RESOURCE_NOT_FOUND("1002", "Recurso não encontrado."),
    UNAUTHORIZED_ACCESS("1003", "Acesso não autorizado. Credenciais inválidas ou ausentes."),
    FORBIDDEN_ACCESS("1004", "Acesso negado. Você não tem permissão para realizar esta ação."),
    SERVICE_UNAVAILABLE("1005", "O serviço está temporariamente indisponível. Tente novamente mais tarde."),
    TOO_MANY_REQUESTS("1006", "Muitas requisições. Por favor, aguarde e tente novamente."),
    VALIDATION_ERROR("1007", "Erro de validação nos dados fornecidos."),
    DATABASE_ERROR("1008", "Erro ao acessar o banco de dados."),
    INTEGRATION_ERROR("1009", "Erro de integração com serviço externo."),
    DEPOIMENTO_ALREADY_APPROVED("1010", "Depoimento já está aprovado."), // Erro específico do módulo de Depoimentos
    DEPOIMENTO_ALREADY_REJECTED("1011", "Depoimento já está reprovado."), // Erro específico do módulo de Depoimentos

    // Erros de Autenticação e Autorização (2000-2999)
    INVALID_CREDENTIALS("2000", "Credenciais de autenticação inválidas."),
    ACCOUNT_LOCKED("2001", "Sua conta está bloqueada."),
    ACCOUNT_DISABLED("2002", "Sua conta está desativada."),
    TOKEN_EXPIRED("2003", "O token de acesso expirou."),
    INVALID_TOKEN("2004", "O token de acesso é inválido."),
    REFRESH_TOKEN_EXPIRED("2005", "O refresh token expirou. Faça login novamente."),
    INVALID_REFRESH_TOKEN("2006", "O refresh token é inválido."),
    USER_NOT_FOUND("2007", "Usuário não encontrado."),
    EMAIL_ALREADY_REGISTERED("2008", "Este e-mail já está cadastrado."),
    PASSWORD_RESET_FAILED("2009", "Falha ao redefinir a senha."),
    INVALID_CURRENT_PASSWORD("2010", "A senha atual fornecida está incorreta."), // Novo erro
    PASSWORD_RESET_TOKEN_INVALID("2011", "Token de redefinição de senha inválido."), // Novo erro
    PASSWORD_RESET_TOKEN_EXPIRED("2012", "Token de redefinição de senha expirado."), // Novo erro
    PASSWORD_RESET_TOKEN_USED("2013", "Token de redefinição de senha já utilizado."), // Novo erro
    PASSWORD_RESET_TOKEN_EXCEEDED("2014", "Limite de redefinições de senha excedido."), // Novo erro

    // Erros de Negócio Específicos (3000-3999) - Exemplo
    TENANT_NOT_FOUND("3000", "Tenant não encontrado."),
    TENANT_DISABLED("3001", "O tenant está desativado."),
    SUBSCRIPTION_EXPIRED("3002", "Sua assinatura expirou."),
    PLAN_NOT_ACTIVE("3003", "O plano selecionado não está ativo."),
    SERVICE_LIMIT_EXCEEDED("3004", "Limite de serviços agendáveis excedido para o seu plano."),
    ADVOCATE_NOT_AVAILABLE("3005", "Advogado não disponível no horário selecionado."),
    APPOINTMENT_CONFLICT("3006", "Conflito de agendamento. O horário já está ocupado."),
    PAYMENT_FAILED("3007", "Falha no processamento do pagamento."),
    INVALID_PROMO_CODE("3008", "Código promocional inválido ou expirado."),
    DOCUMENT_UPLOAD_FAILED("3009", "Falha ao fazer upload do documento."),
    INVALID_DOCUMENT_FORMAT("3010", "Formato de documento inválido."),

    // Erros de Validação de Campo (4000-4999) - Mais específicos, geralmente
    // tratados por @Valid
    FIELD_REQUIRED("4000", "O campo '%s' é obrigatório."),
    INVALID_FORMAT("4001", "O campo '%s' possui formato inválido."),
    MIN_LENGTH("4002", "O campo '%s' deve ter no mínimo %d caracteres."),
    MAX_LENGTH("4003", "O campo '%s' deve ter no máximo %d caracteres."),
    INVALID_EMAIL("4004", "O e-mail fornecido é inválido."),
    INVALID_CPF("4005", "O CPF fornecido é inválido."),
    INVALID_CNPJ("4006", "O CNPJ fornecido é inválido."),
    PASSWORD_TOO_WEAK("4007", "A senha é muito fraca."),
    DATE_IN_PAST("4008", "A data não pode ser no passado."),
    INVALID_ENUM_VALUE("4009", "Valor inválido para o campo '%s'.");

    private final String code;
    private final String message;

    /**
     * Construtor para ErrorCode.
     *
     * @param code    O código único do erro.
     * @param message A mensagem descritiva do erro.
     */
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    /**
     * @brief Retorna a mensagem de erro formatada com argumentos.
     * @param args Argumentos para formatar a mensagem.
     * @return A mensagem de erro formatada.
     */
    public String getFormattedMessage(Object... args) {
        return String.format(this.message, args);
    }
}

```
```java
package br.com.legalconnect.common.exception;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import lombok.extern.slf4j.Slf4j;

/**
 * @class GlobalExceptionHandler
 * @brief Manipulador global de exceções para a aplicação Spring Boot.
 *
 *        Esta classe intercepta exceções lançadas em qualquer parte da
 *        aplicação
 *        e as transforma em respostas de erro padronizadas da API, utilizando
 *        {@link BaseResponse}.
 *        Lida com {@link BusinessException} e exceções de validação do Spring,
 *        além de capturar exceções genéricas.
 */
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

        /**
         * @brief Manipula exceções de negócio personalizadas
         *        ({@link BusinessException}).
         *
         *        Retorna uma resposta de erro com o status HTTP e a mensagem definidos
         *        na BusinessException.
         *
         * @param ex      A exceção de negócio lançada.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro.
         */
        @ExceptionHandler(BusinessException.class)
        public ResponseEntity<BaseResponse> handleBusinessException(BusinessException ex, WebRequest request) {
                log.warn("Business Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ex.getMessage())
                                .errors(List.of(ex.getCode())) // Adiciona o código de erro como parte dos erros
                                .timestamp(LocalDateTime.now())
                                .errors(Arrays.asList(ex.getArgs())) // Adiciona os argumentos da exceção como parte dos
                                .build();

                return new ResponseEntity<>(errorResponse, ex.getHttpStatus());
        }

        /**
         * @brief Manipula exceções de validação de argumentos de método
         *        ({@link MethodArgumentNotValidException}).
         *
         *        Ocorre quando a validação de um DTO de entrada falha (ex:
         *        campos @NotNull, @Size).
         *        Coleta todos os erros de campo e os retorna em uma lista na resposta.
         *
         * @param ex      A exceção de validação.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} com os
         *         erros de validação.
         */
        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<BaseResponse> handleValidationExceptions(MethodArgumentNotValidException ex,
                        WebRequest request) {
                List<String> errors = ex.getBindingResult().getAllErrors().stream()
                                .map(error -> {
                                        String fieldName = (error instanceof FieldError)
                                                        ? ((FieldError) error).getField()
                                                        : error.getObjectName();
                                        String errorMessage = error.getDefaultMessage();
                                        return String.format("Campo '%s': %s", fieldName, errorMessage);
                                })
                                .collect(Collectors.toList());

                log.warn("Validation Exception: {} - Errors: {} - Path: {}", ex.getMessage(), errors,
                                request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.VALIDATION_ERROR.getMessage())
                                .errors(errors)
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
        }

        /**
         * @brief Manipula todas as outras exceções não tratadas especificamente.
         *
         *        Captura qualquer {@link Exception} genérica, registra o erro e retorna
         *        uma resposta de erro genérica com status HTTP 500 (Internal Server
         *        Error).
         *
         * @param ex      A exceção genérica.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro
         *         genérico.
         */
        @ExceptionHandler(Exception.class)
        public ResponseEntity<BaseResponse> handleGlobalException(Exception ex, WebRequest request) {
                log.error("Unhandled Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false), ex);

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.GENERIC_ERROR.getMessage())
                                .errors(List.of(ErrorCode.GENERIC_ERROR.getCode())) // Adiciona o código de erro
                                                                                    // genérico
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);

        }

        @ExceptionHandler(AccessDeniedException.class)
        public ResponseEntity<BaseResponse> handleGlobalException(AccessDeniedException ex, WebRequest request) {
                log.error("Unhandled Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false), ex);

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.UNAUTHORIZED_ACCESS.getMessage())
                                .errors(List.of(ErrorCode.UNAUTHORIZED_ACCESS.getCode())) // Adiciona o código de erro
                                                                                          // genérico
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.FORBIDDEN);
        }
}
```
```java
package br.com.legalconnect.common.exception;

/**
 * @class Roles
 * @brief Classe de constantes para os papéis (roles) de usuário na aplicação.
 *
 *        Define os nomes dos papéis como constantes estáticas para evitar erros
 *        de digitação
 *        e centralizar a gestão dos papéis utilizados na segurança da
 *        aplicação.
 */
public final class Roles {

    // Papéis de Usuário
    public static final String ROLE_ADMIN = "ROLE_ADMIN"; // Administrador do sistema
    public static final String ROLE_TENANT_ADMIN = "ROLE_TENANT_ADMIN"; // Administrador de um tenant específico
    public static final String ROLE_ADVOCATE = "ROLE_ADVOCATE"; // Advogado
    public static final String ROLE_CLIENT = "ROLE_CLIENT"; // Cliente final
    public static final String ROLE_USER = "ROLE_USER"; // Usuário genérico (pode ser usado para usuários logados sem um
                                                        // papel específico mais alto)

    // Prefixos e Sufixos (se necessário, para Spring Security, por exemplo)
    public static final String PREFIX = "ROLE_"; // Prefixo padrão para papéis no Spring Security

    /**
     * Construtor privado para evitar instanciação.
     */
    private Roles() {
        // Construtor privado para garantir que a classe não seja instanciada.
        // É uma classe de utilidade com apenas constantes estáticas.
    }

    /**
     * @brief Converte um nome de papel para o formato esperado pelo Spring Security
     *        (com prefixo "ROLE_").
     * @param roleName O nome do papel sem o prefixo.
     * @return O nome do papel com o prefixo "ROLE_".
     */
    public static String withPrefix(String roleName) {
        if (roleName != null && !roleName.startsWith(PREFIX)) {
            return PREFIX + roleName;
        }
        return roleName;
    }

    /**
     * @brief Remove o prefixo "ROLE_" de um nome de papel.
     * @param roleName O nome do papel com ou sem o prefixo.
     * @return O nome do papel sem o prefixo "ROLE_".
     */
    public static String withoutPrefix(String roleName) {
        if (roleName != null && roleName.startsWith(PREFIX)) {
            return roleName.substring(PREFIX.length());
        }
        return roleName;
    }
}
```
```java
package br.com.legalconnect.common.util;

import java.util.InputMismatchException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @class ValidatorUtil
 * @brief Classe utilitária para validações comuns, como CPF e CNPJ.
 *
 *        Contém métodos estáticos para validar documentos brasileiros,
 *        que são frequentemente necessários em aplicações de negócio.
 */
public final class ValidatorUtil {

    private static final String EMAIL_REGEX = "^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$";
    private static final Pattern EMAIL_PATTERN = Pattern.compile(EMAIL_REGEX);

    /**
     * Construtor privado para evitar instanciação.
     */
    private ValidatorUtil() {
        // Construtor privado para garantir que a classe não seja instanciada.
        // É uma classe de utilidade com apenas métodos estáticos.
    }

    /**
     * @brief Valida se um CPF é válido.
     *
     *        Implementa o algoritmo de validação de CPF brasileiro,
     *        incluindo a verificação dos dígitos verificadores.
     *
     * @param cpf O número do CPF (apenas dígitos).
     * @return True se o CPF for válido, false caso contrário.
     */
    public static boolean isValidCPF(String cpf) {
        if (cpf == null || cpf.length() != 11 || cpf.matches("(\\d)\\1{10}")) {
            return false; // CPF nulo, com tamanho diferente de 11 ou com todos os dígitos iguais
        }

        char dig10, dig11;
        int sm, i, r, num, peso;

        try {
            // Calculo do 1o. Digito Verificador
            sm = 0;
            peso = 10;
            for (i = 0; i < 9; i++) {
                num = (int) (cpf.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso - 1;
            }

            r = 11 - (sm % 11);
            if ((r == 10) || (r == 11))
                dig10 = '0';
            else
                dig10 = (char) (r + 48);

            // Calculo do 2o. Digito Verificador
            sm = 0;
            peso = 11;
            for (i = 0; i < 10; i++) {
                num = (int) (cpf.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso - 1;
            }

            r = 11 - (sm % 11);
            if ((r == 10) || (r == 11))
                dig11 = '0';
            else
                dig11 = (char) (r + 48);

            // Verifica se os dígitos calculados conferem com os dígitos informados.
            return (dig10 == cpf.charAt(9)) && (dig11 == cpf.charAt(10));
        } catch (InputMismatchException erro) {
            return false;
        }
    }

    /**
     * @brief Valida se um CNPJ é válido.
     *
     *        Implementa o algoritmo de validação de CNPJ brasileiro,
     *        incluindo a verificação dos dígitos verificadores.
     *
     * @param cnpj O número do CNPJ (apenas dígitos).
     * @return True se o CNPJ for válido, false caso contrário.
     */
    public static boolean isValidCNPJ(String cnpj) {
        if (cnpj == null || cnpj.length() != 14 || cnpj.matches("(\\d)\\1{13}")) {
            return false; // CNPJ nulo, com tamanho diferente de 14 ou com todos os dígitos iguais
        }

        char dig13, dig14;
        int sm, i, r, num, peso;

        try {
            // Calculo do 1o. Digito Verificador
            sm = 0;
            peso = 2;
            for (i = 11; i >= 0; i--) {
                num = (int) (cnpj.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso + 1;
                if (peso == 10)
                    peso = 2;
            }

            r = sm % 11;
            if ((r == 0) || (r == 1))
                dig13 = '0';
            else
                dig13 = (char) ((11 - r) + 48);

            // Calculo do 2o. Digito Verificador
            sm = 0;
            peso = 2;
            for (i = 12; i >= 0; i--) {
                num = (int) (cnpj.charAt(i) - 48);
                sm = sm + (num * peso);
                peso = peso + 1;
                if (peso == 10)
                    peso = 2;
            }

            r = sm % 11;
            if ((r == 0) || (r == 1))
                dig14 = '0';
            else
                dig14 = (char) ((11 - r) + 48);

            // Verifica se os dígitos calculados conferem com os dígitos informados.
            return (dig13 == cnpj.charAt(12)) && (dig14 == cnpj.charAt(13));
        } catch (InputMismatchException erro) {
            return false;
        }
    }

    /**
     * @brief Valida se um endereço de e-mail é válido.
     *
     *        Utiliza uma expressão regular para verificar o formato do e-mail.
     *
     * @param email O endereço de e-mail a ser validado.
     * @return True se o e-mail for válido, false caso contrário.
     */
    public static boolean isValidEmail(String email) {
        if (email == null) {
            return false;
        }
        Matcher matcher = EMAIL_PATTERN.matcher(email);
        return matcher.matches();
    }
}
```
```java
package br.com.legalconnect.enums;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
spring.application.name=common-lib

# Configuração Multi-Tenant
# spring.jpa.properties.hibernate.multiTenancy=SCHEMA 
# spring.jpa.properties.hibernate.tenant_identifier_resolver=br.com.legalconnect.common.multitenancy.HeaderTenantIdentifierResolver
# # For application.properties
# spring.jpa.properties.hibernate.multi_tenant_connection_provider=br.com.legalconnect.common.multitenancy.SchemaMultiTenantConnectionProvider
# # Configuração do tenant
# application.tenant.header-name=X-Tenant-ID
# application.tenant.default-id=public

# # Configurações do DataSource
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.main.allow-bean-definition-overriding=true
springdoc.packages-to-scan=br.com.legalconnect
springdoc.paths-to-match=/api/v1/**
springdoc.openapi.version=3.0.1
spring.flyway.enabled=true
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.7</version> <!-- Use a versão do seu Spring Boot -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect.common</groupId> <!-- GroupId da biblioteca -->
	<artifactId>common-role</artifactId> <!-- ArtifactId da biblioteca -->
	<version>0.0.1-SNAPSHOT</version>
	<name>common-role</name>
	<description>Biblioteca comum para gestão de roles via cabeçalho X-User-Roles</description>
	<properties>
		<java.version>17 </java.version>
	</properties>
	<dependencies>
		<!-- Dependências mínimas necessárias para a funcionalidade de segurança da lib -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>jakarta.servlet</groupId>
			<artifactId>jakarta.servlet-api</artifactId>
			<scope>provided</scope> <!-- Providenciado pelo ambiente de execução (Spring Boot Web) -->
		</dependency>
		<!-- Lombok é opcional, mas útil para o filtro se usado -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<executions>
					<execution>
						<id>repackage</id>
						<goals>
							<goal>repackage</goal>
						</goals>
						<configuration>
							<classifier>exec</classifier>
							<mainClass>none</mainClass> <!-- Não é uma aplicação executável principal -->
						</configuration>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
package br.com.legalconnect.output.config; // Pacote da lib

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;

/**
 * Configuração para habilitar a segurança em nível de método na aplicação que
 * consumir a lib.
 * Isso permite o uso de anotações como @PreAuthorize e @PostAuthorize.
 */
@Configuration
@EnableMethodSecurity // Habilita a segurança em nível de método para o Spring Security 6+
public class MethodSecurityConfig {
    // Esta classe não precisa de conteúdo adicional para habilitar a
    // funcionalidade.
}
```
```java
package br.com.legalconnect.output.config; // Pacote da lib

import java.util.Arrays;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import br.com.legalconnect.output.security.UserRolesHeaderFilter;

/**
 * Configuração principal do Spring Security para integrar o filtro de roles.
 * Esta classe é parte da biblioteca common-role e deve ser importada ou
 * escaneada
 * pela aplicação consumidora.
 */
@Configuration
@EnableWebSecurity // Habilita a integração de segurança da web do Spring Security
public class SecurityConfig {

    private final UserRolesHeaderFilter userRolesHeaderFilter;

    public SecurityConfig(UserRolesHeaderFilter userRolesHeaderFilter) {
        this.userRolesHeaderFilter = userRolesHeaderFilter;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(request -> new CorsConfiguration().applyPermitDefaultValues()))
                .csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers("/api/v1/publico/**").permitAll()
                        .anyRequest().permitAll())
                .addFilterBefore(userRolesHeaderFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    // @Bean
    // public SecurityFilterChain securityFilterChain(HttpSecurity http) throws
    // Exception {
    // http
    // .csrf(csrf -> csrf.disable()) // Desabilita CSRF se for uma API REST
    // stateless
    // .cors(cors -> cors.configurationSource(corsConfigurationSource())) //
    // Habilita e configura CORS
    // // ... outras configurações de autorização e autenticação
    // .authorizeHttpRequests(authorize -> authorize
    // .requestMatchers("/api/v1/publico/**").permitAll() // Permite acesso público
    // a endpoints específicos
    // .anyRequest().authenticated()
    // );
    // return http.build();
    // }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("*", "http://localhost:4200", "http://localhost:8080"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration); // Aplica CORS a todos os caminhos
        return source;
    }
}
```
```java
package br.com.legalconnect.output.security; // Pacote da lib

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * Filtro customizado para ler o cabeçalho 'X-User-Roles' e configurar as
 * autoridades
 * (roles) no contexto de segurança do Spring.
 * Assume que as roles no cabeçalho são separadas por vírgulas (ex:
 * "ROLE_USER,ROLE_ADMIN").
 * Esta classe é parte da biblioteca common-role e será injetada na aplicação
 * consumidora.
 */
@Component
public class UserRolesHeaderFilter extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String userRolesHeader = request.getHeader("X-User-Roles");

        if (userRolesHeader != null && !userRolesHeader.trim().isEmpty()) {
            List<SimpleGrantedAuthority> authorities = Arrays.stream(userRolesHeader.split(","))
                    .map(role -> new SimpleGrantedAuthority(role.trim()))
                    .collect(Collectors.toList());

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken("user", null,
                    authorities);

            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }
}
```
```java
spring.application.name=common-lib

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.12</version> <!-- Usando a versão que você sugeriu -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>

    <groupId>br.com.legalconnect.common</groupId> <!-- Alterado conforme sua sugestão -->
    <artifactId>common-tenent</artifactId>
    <version>1.0.0</version>
    <name>LegalConnect Common Library</name>
    <description>Common utilities, entities, and configurations for LegalConnect microservices</description>
    <packaging>jar</packaging> <!-- Define este como um JAR de biblioteca -->

    <properties>
        <java.version>17</java.version> <!-- Defina a versão do Java que você está usando -->
        <lombok.version>1.18.30</lombok.version> <!-- Versão explícita para Lombok -->
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Versão explícita para
        MapStruct -->
        <springdoc.version>2.3.0</springdoc.version> <!-- Versão explícita para SpringDoc -->
        <flyway.version>9.22.3</flyway.version> <!-- Versão explícita para Flyway -->
    </properties>

    <dependencies>
        <!-- Spring Boot Starter Validation para anotações de validação em DTOs -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-tomcat</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>com.zaxxer</groupId>
                    <artifactId>HikariCP</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        <!-- Spring Context para anotações como @Configuration, @Component, etc. -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
        </dependency>
        <!-- Spring Security Core para GrantedAuthority (usado em UserDetails, por exemplo) -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.0.0</version>
            <scope>provided</scope>
        </dependency>

        <dependency>
            <groupId>org.flywaydb</groupId>
            <artifactId>flyway-core</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version> <!-- Usando a versão definida nas propriedades -->
            <scope>provided</scope>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version> <!-- Usando a versão definida nas propriedades -->
        </dependency>

        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
legalconnect/
├── common-lib/
│   ├── pom.xml                                 # Configurações do Maven para a biblioteca comum
│   └── src/
│       └── main/
│           └── java/
│               └── br/com/legalconnect/common/
│                   ├── BaseEntity.java         # Entidade base para todos os modelos de dados
│                   ├── config/
│                   │   ├── FlywayMultiTenantConfig.java # Configuração Flyway para multitenancy (se global)
│                   │   ├── OpenApiConfig.java           # Configuração OpenAPI/Swagger UI
│                   │   └── WebConfig.java               # Configurações CORS e MVC gerais
│                   ├── constants/
│                   │   ├── ErrorCode.java               # Códigos de erro padronizados
│                   │   └── Roles.java                   # Constantes para papéis de usuário
│                   ├── dto/
│                   │   ├── BaseResponse.java            # DTO base para respostas da API
│                   │   └── SuccessResponseDTO.java      # DTO para respostas de sucesso simples
│                   ├── exception/
│                   │   ├── BusinessException.java       # Exceção de negócio personalizada
│                   │   └── GlobalExceptionHandler.java  # Manipulador global de exceções
│                   ├── multitenancy/
│                   │   ├── HibernateMultiTenantConfig.java # Configuração Hibernate para multitenancy
│                   │   ├── SchemaMultiTenantConnectionProvider.java # Provedor de conexão multi-tenant
│                   │   ├── SchemaTenantIdentifierResolver.java    # Resolvedor de identificador de tenant
│                   │   ├── TenantContext.java                     # Contexto da thread para o tenant atual
│                   │   └── TenantFilter.java                    # Filtro HTTP para extrair o tenant ID
│                   └── util/
│                       └── ValidatorUtil.java           # Utilitários de validação (ex: CPF, CNPJ)
```
```java
package br.com.legalconnect.common; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.TenantMigrationService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    @Autowired
    private TenantMigrationService tenantMigrationService;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        String tenantIdHeader = request.getHeader(TENANT_HEADER);
        String tenantId = "public";

        if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
            try {
                tenantId = (tenantIdHeader);
            } catch (IllegalArgumentException e) {
                // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                return;
            }
        } else {
            // Usar o tenant padrão se o cabeçalho não for fornecido
            try {
                tenantId = (defaultTenantId);
            } catch (IllegalArgumentException e) {
                System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                        "Configuração de Tenant padrão inválida.");
                return;
            }
        }

        tenantMigrationService.migrateTenant(tenantId);
        filterChain.doFilter(request, response);

    }
}
```
```java
package br.com.legalconnect.common.config;

import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.orm.jpa.JpaVendorAdapter;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;

import br.com.legalconnect.common.config.multitenancy.CurrentTenantIdentifierResolverImpl;
import br.com.legalconnect.common.config.multitenancy.MultiTenantConnectionProviderImpl;

/**
 * @class HibernateConfig
 * @brief Configuração do Hibernate para suporte a multitenancy.
 *        Define como o Hibernate interage com o banco de dados em um ambiente
 *        multi-tenant por schema.
 */
@Configuration
public class HibernateConfig {

    private static final Logger log = LoggerFactory.getLogger(HibernateConfig.class);

    private final JpaProperties jpaProperties;
    private final DataSource dataSource;
    private final MultiTenantConnectionProviderImpl multiTenantConnectionProvider;
    private final CurrentTenantIdentifierResolverImpl currentTenantIdentifierResolver;

    @Autowired
    public HibernateConfig(
            JpaProperties jpaProperties,
            DataSource dataSource,
            MultiTenantConnectionProviderImpl multiTenantConnectionProvider,
            CurrentTenantIdentifierResolverImpl currentTenantIdentifierResolver) {
        this.jpaProperties = jpaProperties;
        this.dataSource = dataSource;
        this.multiTenantConnectionProvider = multiTenantConnectionProvider;
        this.currentTenantIdentifierResolver = currentTenantIdentifierResolver;
        log.debug("HibernateConfig inicializado.");
    }

    /**
     * Configura o JpaVendorAdapter para Hibernate.
     * 
     * @return O JpaVendorAdapter configurado.
     */
    @Bean
    public JpaVendorAdapter jpaVendorAdapter() {
        log.debug("Configurando JpaVendorAdapter.");
        return new HibernateJpaVendorAdapter();
    }

    /**
     * Configura o EntityManagerFactory para suportar multitenancy.
     * 
     * @return O LocalContainerEntityManagerFactoryBean configurado.
     */
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        log.info("Configurando EntityManagerFactory para multitenancy de schema.");
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource);
        em.setPackagesToScan(
                "br.com.legalconnect.user.entity", "br.com.legalconnect.entity",
                "br.com.legalconnect.auth.entity"); // Pacotes onde suas entidades estão localizadas
        em.setJpaVendorAdapter(jpaVendorAdapter());

        Map<String, Object> properties = new HashMap<>(jpaProperties.getProperties());
        properties.put("hibernate.multiTenancy", "SCHEMA");
        properties.put("hibernate.multi_tenant_connection_provider", multiTenantConnectionProvider);
        properties.put("hibernate.tenant_identifier_resolver", currentTenantIdentifierResolver);
        properties.put("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        properties.put("hibernate.show_sql", true);
        properties.put("hibernate.format_sql", true);

        em.setJpaPropertyMap(properties);
        log.debug("EntityManagerFactory configurado com propriedades de multitenancy: {}", properties);
        return em;
    }
}
```
```java
package br.com.legalconnect.common.config;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Map;

import javax.sql.DataSource;

import org.flywaydb.core.Flyway;
import org.flywaydb.core.api.exception.FlywayValidateException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.config.multitenancy.TenantContext;
import jakarta.annotation.PostConstruct;
import jakarta.persistence.EntityManagerFactory;

/**
 * @class TenantMigrationService
 * @brief Serviço responsável por gerenciar as migrações do Flyway para cada
 *        tenant.
 *        Garante que cada esquema de tenant tenha a versão mais recente do
 *        banco de dados.
 */
@Service
public class TenantMigrationService {

    private static final Logger log = LoggerFactory.getLogger(TenantMigrationService.class);

    private final DataSource dataSource;
    // private final TenantRepository tenantRepository;

    @Value("${spring.flyway.locations}")
    private String[] flywayLocations; // Localização dos scripts de migração (ex: classpath:db/migration)

    @Value("${spring.flyway.baseline-on-migrate}")
    private boolean flywayBaselineOnMigrate;

    @Value("${spring.flyway.baseline-version}")
    private String flywayBaselineVersion;

    @Value("${application.tenant.default-id}") // Injeção da propriedade defaultTenantId
    private String defaultTenantIdString; // Usar String para o valor da propriedade

    private String defaultTenantId; // Para armazenar o UUID parseado
    @Autowired
    private EntityManagerFactory entityManagerFactory;

    public TenantMigrationService(DataSource dataSource) {
        this.dataSource = dataSource;
        // this.tenantRepository = tenantRepository;
    }

    @PostConstruct
    public void init() {
        this.defaultTenantId = (defaultTenantIdString);
    }

    public void setarSchemaPadrao(String schemaName) {
        Map<String, Object> properties = entityManagerFactory.getProperties();
        properties.put("hibernate.default_schema", schemaName);
    }

    /**
     * Executa as migrações do Flyway para todos os tenants existentes ao iniciar a
     * aplicação.
     * Marcado com @PostConstruct para ser executado após a injeção de dependências.
     */
    @PostConstruct
    public void migrateAllTenantsOnStartup() { // Renomeado para clareza
        log.info("Iniciando migrações do Flyway para todos os tenants existentes.");
        // Temporariamente define o TenantContext para o schema do tenant padrão (onde
        // tb_tenant reside)
        // Isso é crucial para que o tenantRepository consiga acessar a tabela
        // tb_tenant.
        // Assumimos que o schema do defaultTenantId é o "public" ou o schema onde
        // tb_tenant está.
        // Se tb_tenant estiver em um schema diferente do defaultTenantId, isso precisa
        // ser ajustado.
        // Pelo seu SQL, tb_tenant não especifica schema, então estará no schema padrão
        // do DB (geralmente public).
        TenantContext.setCurrentTenant(defaultTenantId.toString()); // Ou o schema onde tb_tenant está.
        setarSchemaPadrao(defaultTenantId.toString());
        migrateTenant(defaultTenantId.toString());
        try {
            // List<Tenant> tenants = tenantRepository.findAll();
            // for (Tenant tenant : tenants) {
            // log.info("Migrando esquema para o tenant: {}", tenant.getSchemaName());
            // migrateTenant(tenant.getSchemaName());
            // }
            log.info("Migrações do Flyway para todos os tenants concluídas.");
        } catch (Exception e) {
            log.error("Erro ao executar migrações do Flyway para tenants: {}", e.getMessage(), e);
            throw new RuntimeException("Falha ao migrar tenants na inicialização.", e);
        }
        // finally {
        // TenantContext.clear(); // Limpa o contexto do tenant
        // }
    }

    public void migrate(String schemaName) {
        migrateTenant(schemaName);
        TenantContext.setCurrentTenant(schemaName); // Ou o schema onde tb_tenant está.
        setarSchemaPadrao(schemaName);
        migrateTenant(schemaName);
        Flyway flyway = Flyway.configure()
                .dataSource(dataSource)
                .locations(flywayLocations)
                .schemas(schemaName) // Define o esquema específico para esta migração
                .baselineOnMigrate(flywayBaselineOnMigrate)
                .baselineVersion(flywayBaselineVersion)
                .load();

        try {
            flyway.migrate();
            log.info("Migração do Flyway concluída com sucesso para o esquema: {}",
                    schemaName);
        } catch (FlywayValidateException ve) {
            log.error("Validação do Flyway falhou para o schema {}: {}", schemaName,
                    ve.getMessage());

            // Verifica se o erro foi por incompatibilidade de checksum e executa o repair
            if (ve.getMessage() != null && ve.getMessage().contains("Migration checksum mismatch")) {
                log.warn("Checksum mismatch detectado para o schema {}. Executando Flyway.repair()...", schemaName);
                try {
                    flyway.repair();
                    log.info("Flyway.repair() executado com sucesso. Tentando migrar novamente para o schema: {}",
                            schemaName);
                    flyway.migrate();
                } catch (Exception re) {
                    log.error("Falha ao executar Flyway.repair() ou nova tentativa de migrate  para o schema {}: {}",
                            schemaName, re.getMessage(), re);
                    throw new RuntimeException(
                            "Falha na migração mesmo após tentativa de repair para o schema " + schemaName, re);
                }
            } else {
                throw new RuntimeException("Erro de validação Flyway para o schema " + schemaName, ve);
            }
        }
    }

    /**
     * Executa as migrações do Flyway para um esquema de tenant específico.
     * Pode ser chamado ao provisionar um novo tenant.
     *
     * @param schemaName O nome do esquema do tenant a ser migrado.
     */
    public void migrateTenant(String schemaName) {
        // Garante que o esquema exista antes de tentar migrar
        createSchemaIfNotExist(schemaName);
        setarSchemaPadrao(schemaName);

    }

    /**
     * Cria o esquema no banco de dados se ele ainda não existir.
     *
     * @param schemaName O nome do esquema a ser criado.
     */
    private void createSchemaIfNotExist(String schemaName) {
        try (Connection connection = dataSource.getConnection();
                Statement statement = connection.createStatement()) {
            String sql = String.format("CREATE SCHEMA IF NOT EXISTS \"%s\"", schemaName);
            statement.execute(sql);
            TenantContext.setCurrentTenant(schemaName);
            log.debug("Esquema '{}' verificado/criado com sucesso.", schemaName);
        } catch (SQLException e) {
            log.error("Erro ao criar/verificar esquema '{}': {}", schemaName, e.getMessage(), e);
            throw new RuntimeException("Falha ao criar/verificar esquema " + schemaName, e);
        }
    }
}
```
```java
package br.com.legalconnect.common.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import br.com.legalconnect.common.config.multitenancy.TenantInterceptor;
import lombok.RequiredArgsConstructor;

/**
 * @class WebConfig
 * @brief Configuração web para registrar interceptores.
 *        Adiciona o TenantInterceptor para gerenciar o contexto do tenant em
 *        cada requisição.
 */
@Configuration
@RequiredArgsConstructor
public class WebConfig implements WebMvcConfigurer {

    private static final Logger log = LoggerFactory.getLogger(WebConfig.class);

    private final TenantInterceptor tenantInterceptor;

    /**
     * Adiciona interceptores à lista de interceptores do Spring MVC.
     * 
     * @param registry O registro de interceptores.
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        log.debug("Registrando TenantInterceptor.");
        registry.addInterceptor(tenantInterceptor);
    }
}
```
```java
package br.com.legalconnect.common.config.multitenancy;

import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

/**
 * @class CurrentTenantIdentifierResolverImpl
 * @brief Implementação de CurrentTenantIdentifierResolver do Hibernate.
 *        Informa ao Hibernate qual é o tenant atual para rotear as operações de
 *        banco de dados.
 */
@Component
public class CurrentTenantIdentifierResolverImpl implements CurrentTenantIdentifierResolver {

    private static final Logger log = LoggerFactory.getLogger(CurrentTenantIdentifierResolverImpl.class);
    private static final String DEFAULT_TENANT_ID = "public"; // Schema padrão para tabelas globais (ex: tb_tenant)

    /**
     * Resolve o identificador do tenant atual.
     * Se um tenant estiver definido no TenantContext, ele é retornado.
     * Caso contrário, o tenant padrão "public" é retornado.
     * 
     * @return O identificador do tenant atual.
     */
    @Override
    public String resolveCurrentTenantIdentifier() {
        String tenantId = TenantContext.getCurrentTenant();
        if (tenantId == null) {
            log.debug("Nenhum tenant definido no contexto, usando tenant padrão: {}", DEFAULT_TENANT_ID);
            return DEFAULT_TENANT_ID;
        }
        log.trace("Resolvendo tenant atual: {}", tenantId);
        return tenantId;
    }

    /**
     * Indica se o identificador do tenant é validado.
     * 
     * @return True se a validação é necessária, false caso contrário.
     */
    @Override
    public boolean validateExistingCurrentSessions() {
        return true;
    }
}
```
```java
package br.com.legalconnect.common.config.multitenancy;

import java.sql.Connection;
import java.sql.SQLException;

import javax.sql.DataSource;

import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * @class MultiTenantConnectionProviderImpl
 * @brief Implementação de MultiTenantConnectionProvider do Hibernate.
 *        Fornece a conexão de banco de dados para o schema do tenant atual.
 */
@Component
public class MultiTenantConnectionProviderImpl implements MultiTenantConnectionProvider {

    private static final Logger log = LoggerFactory.getLogger(MultiTenantConnectionProviderImpl.class);

    private final DataSource dataSource;

    @Autowired
    public MultiTenantConnectionProviderImpl(DataSource dataSource) {
        this.dataSource = dataSource;
        log.debug("MultiTenantConnectionProviderImpl inicializado com DataSource.");
    }

    /**
     * Obtém uma conexão para o tenant especificado.
     * 
     * @return A conexão SQL para o tenant.
     * @throws SQLException Se ocorrer um erro ao obter a conexão.
     */
    @Override
    public Connection getAnyConnection() throws SQLException {
        log.trace("Obtendo qualquer conexão do DataSource.");
        return dataSource.getConnection();
    }

    /**
     * Libera a conexão para qualquer tenant.
     * 
     * @param connection A conexão a ser liberada.
     * @throws SQLException Se ocorrer um erro ao liberar a conexão.
     */
    @Override
    public void releaseAnyConnection(Connection connection) throws SQLException {
        log.trace("Liberando qualquer conexão.");
        connection.close();
    }

    /**
     * Obtém uma conexão para o tenant especificado.
     * Define o schema da conexão com base no tenantIdentifier.
     * 
     * @param tenantIdentifier O identificador do tenant (nome do schema).
     * @return A conexão SQL para o tenant.
     * @throws SQLException Se ocorrer um erro ao obter ou definir o schema da
     *                      conexão.
     */
    @Override
    public Connection getConnection(Object tenantIdentifier) throws SQLException {
        log.debug("Obtendo conexão para o tenant: {}", tenantIdentifier);
        final Connection connection = getAnyConnection();
        // Define o schema para a conexão. Isso é crucial para o multitenancy por
        // schema.
        try {
            connection.createStatement().execute("SET search_path to \"" + tenantIdentifier + "\", public");
            log.trace("Schema da conexão definido para: {}", tenantIdentifier);
        } catch (SQLException e) {
            log.error("Erro ao definir search_path para o tenant {}: {}", tenantIdentifier, e.getMessage(), e);
            throw e;
        }
        return connection;
    }

    /**
     * Libera a conexão para o tenant especificado.
     * 
     * @param tenantIdentifier O identificador do tenant.
     * @param connection       A conexão a ser liberada.
     * @throws SQLException Se ocorrer um erro ao liberar a conexão.
     */
    @Override
    public void releaseConnection(Object tenantIdentifier, Connection connection) throws SQLException {
        log.debug("Liberando conexão para o tenant: {}", tenantIdentifier);
        releaseAnyConnection(connection);
    }

    /**
     * Indica se este provedor de conexão suporta o conceito de "multi-tenancy".
     * 
     * @return True, pois suporta.
     */
    @Override
    public boolean supportsAggressiveRelease() {
        return false;
    }

    /**
     * Indica se a conexão atual é para o tenant especificado.
     * 
     * @param connection       A conexão a ser verificada.
     * @param tenantIdentifier O identificador do tenant.
     * @return True se a conexão pertence ao tenant, false caso contrário.
     */
    @Override
    public boolean isUnwrappableAs(Class unwrapType) {
        return unwrapType.isAssignableFrom(getClass());
    }

    /**
     * Verifica se o provedor de conexão é um proxy.
     * 
     * @return False, pois esta não é uma implementação de proxy.
     */
    @Override
    public <T> T unwrap(Class<T> unwrapType) {
        if (unwrapType.isAssignableFrom(getClass())) {
            return (T) this;
        } else {
            return null;
        }
    }
}
```
```java
package br.com.legalconnect.common.config.multitenancy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;

/**
 * @class TenantContext
 * @brief Contexto de Tenant usando ThreadLocal para armazenar o ID do tenant
 *        atual.
 *        Permite que o ID do tenant seja acessado em qualquer parte da
 *        aplicação
 *        dentro do mesmo thread de execução.
 *        Adiciona o tenantId ao MDC para logging contextual.
 */
public class TenantContext {

    private static final Logger log = LoggerFactory.getLogger(TenantContext.class);
    private static final ThreadLocal<String> currentTenant = new ThreadLocal<>();
    private static final String MDC_TENANT_ID_KEY = "tenantId";

    /**
     * Define o ID do tenant atual para o thread e o adiciona ao MDC.
     * 
     * @param tenantId O ID do tenant a ser definido.
     */
    public static void setCurrentTenant(String tenantId) {
        currentTenant.set(tenantId);
        MDC.put(MDC_TENANT_ID_KEY, tenantId);
        log.trace("Tenant ID '{}' definido no contexto e MDC.", tenantId);
    }

    /**
     * Obtém o ID do tenant atual do thread.
     * 
     * @return O ID do tenant atual.
     */
    public static String getCurrentTenant() {
        return currentTenant.get();
    }

    /**
     * Limpa o ID do tenant do thread e remove do MDC.
     * Deve ser chamado ao final de cada requisição para evitar vazamentos de
     * contexto.
     */
    public static void clear() {
        currentTenant.remove();
        MDC.remove(MDC_TENANT_ID_KEY);
        log.trace("Tenant ID removido do contexto e MDC.");
    }
}
```
```java
package br.com.legalconnect.common.config.multitenancy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.lang.NonNull;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;
import org.springframework.web.servlet.ModelAndView;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantInterceptor
 * @brief Interceptor de requisições para definir o ID do tenant no
 *        TenantContext.
 *        Extrai o ID do tenant do cabeçalho da requisição (ex: "X-Tenant-ID").
 */
@Component
public class TenantInterceptor implements HandlerInterceptor {

    private static final Logger log = LoggerFactory.getLogger(TenantInterceptor.class);
    private static final String TENANT_HEADER = "X-Tenant-ID";

    @Value("${application.tenant.default-id}") // Injeção da propriedade defaultTenantId
    private String defaultTenantId;

    /**
     * Pré-processamento da requisição: extrai o ID do tenant do cabeçalho
     * e o define no TenantContext.
     * 
     * @param request  A requisição HTTP.
     * @param response A resposta HTTP.
     * @param handler  O handler da requisição.
     * @return True para continuar o processamento, false para interromper.
     * @throws Exception Se ocorrer um erro.
     */
    @Override
    public boolean preHandle(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull Object handler) throws Exception {

        String tenantId = request.getHeader(TENANT_HEADER);

        if (tenantId != null && !tenantId.isEmpty()) {
            TenantContext.setCurrentTenant(defaultTenantId);
            log.debug("Tenant ID '{}' extraído do cabeçalho da requisição.", tenantId);
        } else {
            // Se o cabeçalho não for fornecido, usa o defaultTenantId configurado
            TenantContext.setCurrentTenant(defaultTenantId);
            log.warn("Cabeçalho '{}' não encontrado ou vazio. Usando tenant padrão '{}'.", TENANT_HEADER,
                    defaultTenantId);
        }
        return true;
    }

    /**
     * Pós-processamento da requisição: limpa o TenantContext.
     * 
     * @param request      A requisição HTTP.
     * @param response     A resposta HTTP.
     * @param handler      O handler da requisição.
     * @param modelAndView O ModelAndView gerado pelo handler.
     * @throws Exception Se ocorrer um erro.
     */
    @Override
    public void postHandle(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull Object handler,
            ModelAndView modelAndView) throws Exception {
        // Não é estritamente necessário limpar aqui se o afterCompletion for sempre
        // chamado,
        // mas pode ser útil para cenários específicos.
    }

    /**
     * Conclusão da requisição: garante que o TenantContext seja limpo,
     * independentemente do resultado da requisição (sucesso ou erro).
     * 
     * @param request  A requisição HTTP.
     * @param response A resposta HTTP.
     * @param handler  O handler da requisição.
     * @param ex       A exceção que ocorreu durante o processamento (se houver).
     * @throws Exception Se ocorrer um erro.
     */
    @Override
    public void afterCompletion(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull Object handler,
            Exception ex) throws Exception {
        TenantContext.clear(); // Garante que o ThreadLocal e MDC sejam limpos após a requisição
        log.debug("TenantContext limpo após a requisição.");
    }
}
```
```java
spring.application.name=common-lib

# Configuração Multi-Tenant
# spring.jpa.properties.hibernate.multiTenancy=SCHEMA 
# spring.jpa.properties.hibernate.tenant_identifier_resolver=br.com.legalconnect.common.multitenancy.HeaderTenantIdentifierResolver
# # For application.properties
# spring.jpa.properties.hibernate.multi_tenant_connection_provider=br.com.legalconnect.common.multitenancy.SchemaMultiTenantConnectionProvider
# # Configuração do tenant
# application.tenant.header-name=X-Tenant-ID
# application.tenant.default-id=public

# # Configurações do DataSource
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.main.allow-bean-definition-overriding=true
springdoc.packages-to-scan=br.com.legalconnect
springdoc.paths-to-match=/api/v1/**
springdoc.openapi.version=3.0.1
spring.flyway.enabled=true
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.legal-usuario' is invalid and this project uses 'br.com.legalconnect.legal_usuario' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Spring Data JPA](https://docs.spring.io/spring-boot/3.5.3/reference/data/sql.html#data.sql.jpa-and-spring-data)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)
* [PostgresML](https://docs.spring.io/spring-ai/reference/api/embeddings/postgresml-embeddings.html)
* [Spring Web](https://docs.spring.io/spring-boot/3.5.3/reference/web/servlet.html)

### Guides
The following guides illustrate how to use some features concretely:

* [Accessing Data with JPA](https://spring.io/guides/gs/accessing-data-jpa/)
* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version> <!-- Mantendo 3.2.5 para consistência com o Gateway, mas você pode usar
        3.2.12 se preferir -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>legalconnect-advogado</artifactId> <!-- Certifique-se de que o artifactId está correto para o auth-service -->
	<version>0.0.1-SNAPSHOT</version>
	<name>legalconnect-advogado</name>
	<description>Authentication Microservice for LegalConnect</description>

	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.1</spring-cloud.version>

		<jjwt.version>0.11.5</jjwt.version> <!-- Mantido 0.12.5 para compatibilidade com a classe
        JwtUtil -->
		<flyway.version>11.8.2</flyway.version> <!-- CORRIGIDO: Define a versão do Flyway para 11.8.2 -->
		<lombok.version>1.18.30</lombok.version> <!-- Adicionado/Atualizado para garantir
        compatibilidade -->
		<org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Adicionado/Atualizado para
        garantir compatibilidade -->
		<springdoc.version>2.5.0</springdoc.version> <!-- Atualizado para 2.5.0 para consistência com
        o Gateway -->
	</properties>

	<dependencies>
		<!-- Spring Boot Starters -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-mail</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-thymeleaf</artifactId>
		</dependency>

		<!-- Database -->
		<dependency>
			<groupId>org.postgresql</groupId>
			<artifactId>postgresql</artifactId>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>${jjwt.version}</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>${jjwt.version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>${jjwt.version}</version>
			<scope>runtime</scope>
		</dependency>

		<!-- MapStruct for DTO-Entity mapping -->
		<dependency>
			<groupId>org.mapstruct</groupId>
			<artifactId>mapstruct</artifactId>
			<version>${org.mapstruct.version}</version>
		</dependency>
		<dependency>
			<groupId>org.mapstruct</groupId>
			<artifactId>mapstruct-processor</artifactId>
			<version>${org.mapstruct.version}</version>
			<scope>provided</scope>
		</dependency>

		<!-- common-lib (se aplicável, mantenha a versão correta) -->
		<dependency>
			<groupId>br.com.legalconnect.common</groupId>
			<artifactId>common-lib</artifactId>
			<version>1.0.1</version>
		</dependency>

		<dependency>
			<groupId>br.com.legalconnect.common</groupId> <!-- GroupId da biblioteca -->
			<artifactId>common-role</artifactId> <!-- ArtifactId da biblioteca -->
			<version>0.0.1-SNAPSHOT</version>
		</dependency>
		<!-- Lombok for boilerplate code reduction -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<!-- Spring Boot Test -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>

		<!-- OpenAPI/Swagger UI -->
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>${springdoc.version}</version>
		</dependency>

		<!-- Jackson for JSON processing (used by JwtAuthEntryPoint) -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
		</dependency>


	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>

		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
			<!-- Plugin para MapStruct -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.8.1</version>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>${lombok.version}</version>
						</path>
						<path>
							<groupId>org.mapstruct</groupId>
							<artifactId>mapstruct-processor</artifactId>
							<version>${org.mapstruct.version}</version>
						</path>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok-mapstruct-binding</artifactId>
							<version>0.2.0</version>
						</path>
					</annotationProcessorPaths>
					<compilerArgs>
						<arg>-Amapstruct.defaultComponentModel=spring</arg>
					</compilerArgs>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
{
  "openapi": "3.0.1",
  "info": { "title": "OpenAPI definition", "version": "v0" },
  "servers": [
    { "url": "http://localhost:8080", "description": "Generated server url" }
  ],
  "tags": [
    {
      "name": "Locais de Atuação",
      "description": "Gerenciamento de dados mestre de Locais de Atuação"
    },
    {
      "name": "Idiomas",
      "description": "Gerenciamento de dados mestre de Idiomas"
    },
    {
      "name": "Profissionais",
      "description": "Gerenciamento de perfis de Advogados"
    },
    {
      "name": "Agendamentos",
      "description": "Gerenciamento de agendamentos de consultas e avaliações"
    },
    {
      "name": "Áreas de Atuação",
      "description": "Gerenciamento de dados mestre de Áreas de Atuação"
    },
    {
      "name": "Tipos de Atendimento",
      "description": "Gerenciamento de dados mestre de Tipos de Atendimento"
    }
  ],
  "paths": {
    "/api/v1/profissionais/{profissionalId}/formacoes/{formacaoId}": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Busca uma formação acadêmica específica de um profissional",
        "description": "Retorna os detalhes de uma formação acadêmica específica de um advogado.",
        "operationId": "getFormacaoAcademicaById",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "formacaoId",
            "in": "path",
            "description": "ID da formação",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Formação acadêmica encontrada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (formação pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Formação acadêmica não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Profissionais"],
        "summary": "Atualiza uma formação acadêmica de um profissional",
        "description": "Atualiza os detalhes de uma formação acadêmica existente associada a um advogado.",
        "operationId": "updateFormacaoAcademica",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "formacaoId",
            "in": "path",
            "description": "ID da formação a ser atualizada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormacaoAcademicaRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Formação acadêmica atualizada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (formação pertence a outro tenant ou profissional)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Formação acadêmica não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Profissionais"],
        "summary": "Deleta uma formação acadêmica de um profissional",
        "description": "Remove uma formação acadêmica específica do perfil de um advogado.",
        "operationId": "deleteFormacaoAcademica",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "formacaoId",
            "in": "path",
            "description": "ID da formação a ser deletada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Formação acadêmica deletada com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso negado (formação pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Formação acadêmica não encontrada para deleção",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/experiencias/{experienciaId}": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Busca uma experiência profissional específica de um profissional",
        "description": "Retorna os detalhes de uma experiência profissional específica de um advogado.",
        "operationId": "getExperienciaProfissionalById",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "experienciaId",
            "in": "path",
            "description": "ID da experiência",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Experiência profissional encontrada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (experiência pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Experiência profissional não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Profissionais"],
        "summary": "Atualiza uma experiência profissional de um profissional",
        "description": "Atualiza os detalhes de uma experiência profissional existente associada a um advogado.",
        "operationId": "updateExperienciaProfissional",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "experienciaId",
            "in": "path",
            "description": "ID da experiência a ser atualizada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExperienciaProfissionalRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Experiência profissional atualizada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (experiência pertence a outro tenant ou profissional)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Experiência profissional não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Profissionais"],
        "summary": "Deleta uma experiência profissional de um profissional",
        "description": "Remove uma experiência profissional específica do perfil de um advogado.",
        "operationId": "deleteExperienciaProfissional",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "experienciaId",
            "in": "path",
            "description": "ID da experiência a ser deletada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Experiência profissional deletada com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso negado (experiência pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Experiência profissional não encontrada para deleção",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/certificacoes/{certificacaoId}": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Busca uma certificação específica de um profissional",
        "description": "Retorna os detalhes de uma certificação específica de um advogado.",
        "operationId": "getCertificacaoById",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "certificacaoId",
            "in": "path",
            "description": "ID da certificação",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Certificação encontrada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (certificação pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Certificação não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Profissionais"],
        "summary": "Atualiza uma certificação de um profissional",
        "description": "Atualiza os detalhes de uma certificação existente associada a um advogado.",
        "operationId": "updateCertificacao",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "certificacaoId",
            "in": "path",
            "description": "ID da certificação a ser atualizada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificacaoRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Certificação atualizada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (certificação pertence a outro tenant ou profissional)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Certificação não encontrada para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Profissionais"],
        "summary": "Deleta uma certificação de um profissional",
        "description": "Remove uma certificação específica do perfil de um advogado.",
        "operationId": "deleteCertificacao",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "certificacaoId",
            "in": "path",
            "description": "ID da certificação a ser deletada",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Certificação deletada com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso negado (certificação pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Certificação não encontrada para deleção",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{id}": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Busca um profissional pelo ID",
        "description": "Retorna os detalhes completos de um advogado específico.",
        "operationId": "getProfissionalById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Profissional encontrado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["Profissionais"],
        "summary": "Atualiza um profissional existente",
        "description": "Atualiza os dados de um advogado, incluindo informações pessoais e coleções relacionadas.",
        "operationId": "updateProfissional",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do profissional a ser atualizado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProfissionalUpdateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Profissional atualizado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "409": {
            "description": "Conflito de dados (ex: email duplicado)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Profissionais"],
        "summary": "Deleta um profissional pelo ID",
        "description": "Remove um advogado e todos os seus dados associados do sistema.",
        "operationId": "deleteProfissional",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do profissional a ser deletado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Profissional deletado com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Lista todos os profissionais com paginação",
        "description": "Retorna uma lista paginada de todos os advogados associados ao tenant atual.",
        "operationId": "getAllProfissionais",
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "description": "Número da página (0-indexed)",
            "required": false,
            "schema": { "type": "integer", "format": "int32", "default": 0 },
            "example": 0
          },
          {
            "name": "size",
            "in": "query",
            "description": "Tamanho da página",
            "required": false,
            "schema": { "type": "integer", "format": "int32", "default": 10 },
            "example": 10
          },
          {
            "name": "sort",
            "in": "query",
            "description": "Critério de ordenação (ex: nomeCompleto,asc ou numeroOab,desc)",
            "required": false,
            "schema": {
              "type": "array",
              "items": { "type": "string" },
              "default": ["nomeCompleto", "asc"]
            },
            "example": "nomeCompleto,asc"
          }
        ],
        "responses": {
          "200": {
            "description": "Profissionais listados com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Profissionais"],
        "summary": "Cria um novo profissional",
        "description": "Registra um novo advogado com seus dados pessoais e informações profissionais.",
        "operationId": "createProfissional",
        "parameters": [
          {
            "name": "X-Correlation-Id",
            "in": "header",
            "required": false,
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ProfissionalCreateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Profissional criado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "409": {
            "description": "OAB, CPF ou Email já cadastrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseProfissionalResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/formacoes": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Lista todas as formações acadêmicas de um profissional",
        "description": "Retorna uma lista de todas as formações acadêmicas associadas a um advogado específico.",
        "operationId": "getAllFormacoesAcademicas",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Formações acadêmicas listadas com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListFormacaoAcademicaResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Profissionais"],
        "summary": "Adiciona uma formação acadêmica a um profissional",
        "description": "Adiciona uma nova formação acadêmica ao perfil de um advogado.",
        "operationId": "addFormacaoAcademica",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FormacaoAcademicaRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Formação acadêmica adicionada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseFormacaoAcademicaResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/experiencias": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Lista todas as experiências profissionais de um profissional",
        "description": "Retorna uma lista de todas as experiências profissionais associadas a um advogado específico.",
        "operationId": "getAllExperienciasProfissionais",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Experiências profissionais listadas com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListExperienciaProfissionalResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Profissionais"],
        "summary": "Adiciona uma experiência profissional a um profissional",
        "description": "Adiciona uma nova experiência profissional ao perfil de um advogado.",
        "operationId": "addExperienciaProfissional",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ExperienciaProfissionalRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Experiência profissional adicionada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseExperienciaProfissionalResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/documentos/upload": {
      "post": {
        "tags": ["Profissionais"],
        "summary": "Realiza o upload de um documento para um profissional",
        "description": "Faz o upload de um documento para o S3 e persiste seus metadados para um advogado.",
        "operationId": "uploadDocumento",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DocumentoUploadRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Documento enviado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos (ex: Base64 inválido)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Falha ao fazer upload do documento ou erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/certificacoes": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Lista todas as certificações de um profissional",
        "description": "Retorna uma lista de todas as certificações associadas a um advogado específico.",
        "operationId": "getAllCertificacoes",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Certificações listadas com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListCertificacaoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListCertificacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListCertificacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListCertificacaoResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Profissionais"],
        "summary": "Adiciona uma certificação a um profissional",
        "description": "Adiciona uma nova certificação ao perfil de um advogado.",
        "operationId": "addCertificacao",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CertificacaoRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Certificação adicionada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseCertificacaoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/agendamentos/avaliar": {
      "post": {
        "tags": ["Agendamentos"],
        "summary": "Avalia uma consulta",
        "description": "Permite a um cliente fornecer uma nota e um comentário para uma consulta já realizada.",
        "operationId": "avaliarConsulta",
        "parameters": [
          {
            "name": "agendamentoId",
            "in": "query",
            "description": "ID do agendamento a ser avaliado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "clienteId",
            "in": "query",
            "description": "ID do cliente que está avaliando",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "rating",
            "in": "query",
            "description": "Nota da avaliação (1 a 5)",
            "required": true,
            "schema": { "type": "integer", "format": "int32" }
          },
          {
            "name": "comentario",
            "in": "query",
            "description": "Comentário opcional sobre a avaliação",
            "required": false,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "200": {
            "description": "Consulta avaliada com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos (ex: nota fora do intervalo)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "404": {
            "description": "Agendamento não encontrado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          }
        }
      }
    },
    "/api/v1/agendamentos/agendar": {
      "post": {
        "tags": ["Agendamentos"],
        "summary": "Agenda uma nova consulta",
        "description": "Permite a um cliente agendar uma consulta com um profissional, verificando disponibilidade e enviando notificações.",
        "operationId": "agendarConsulta",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "query",
            "description": "ID do profissional para o agendamento",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "clienteId",
            "in": "query",
            "description": "ID do cliente que está agendando",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "horarioAgendamento",
            "in": "query",
            "description": "Horário desejado para a consulta (formato ISO 8601, ex: 2024-07-25T10:00:00)",
            "required": true,
            "schema": { "type": "string", "format": "date-time" }
          },
          {
            "name": "tipoServico",
            "in": "query",
            "description": "Tipo de serviço a ser agendado (ex: 'Consulta Online', 'Reunião Presencial')",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "responses": {
          "201": {
            "description": "Consulta agendada com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "400": {
            "description": "Dados de requisição inválidos (ex: horário indisponível)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "409": {
            "description": "Conflito de agendamento (horário já ocupado)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseBoolean" }
              }
            }
          }
        }
      }
    },
    "/api/v1/tipos-atendimento": {
      "get": {
        "tags": ["Tipos de Atendimento"],
        "summary": "Lista todos os tipos de atendimento",
        "description": "Retorna uma lista de todos os tipos de atendimento cadastrados.",
        "operationId": "getAllTiposAtendimento",
        "responses": {
          "200": {
            "description": "Tipos de Atendimento listados com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListTipoAtendimentoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListTipoAtendimentoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/tipos-atendimento/{id}": {
      "get": {
        "tags": ["Tipos de Atendimento"],
        "summary": "Busca um tipo de atendimento pelo ID",
        "description": "Retorna os detalhes de um tipo de atendimento específico.",
        "operationId": "getTipoAtendimentoById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do Tipo de Atendimento",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Tipo de Atendimento encontrado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseTipoAtendimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Tipo de Atendimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseTipoAtendimentoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseTipoAtendimentoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/documentos": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Lista todos os documentos de um profissional",
        "description": "Retorna uma lista de todos os documentos associados a um advogado específico.",
        "operationId": "getAllDocumentos",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Documentos listados com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDocumentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (profissional pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDocumentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Profissional não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDocumentoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDocumentoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/profissionais/{profissionalId}/documentos/{documentoId}": {
      "get": {
        "tags": ["Profissionais"],
        "summary": "Busca um documento específico de um profissional",
        "description": "Retorna os detalhes de um documento específico de um advogado.",
        "operationId": "getDocumentoById",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "documentoId",
            "in": "path",
            "description": "ID do documento",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Documento encontrado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso negado (documento pertence a outro tenant ou profissional)",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Documento não encontrado para este profissional",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDocumentoResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["Profissionais"],
        "summary": "Deleta um documento de um profissional",
        "description": "Remove um documento específico do perfil de um advogado, incluindo a remoção do S3.",
        "operationId": "deleteDocumento",
        "parameters": [
          {
            "name": "profissionalId",
            "in": "path",
            "description": "ID do profissional",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          },
          {
            "name": "documentoId",
            "in": "path",
            "description": "ID do documento a ser deletado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Documento deletado com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso negado (documento pertence a outro tenant)",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Documento não encontrado para deleção",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "500": {
            "description": "Falha ao deletar o documento do S3 ou erro interno do servidor",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/locais-atuacao": {
      "get": {
        "tags": ["Locais de Atuação"],
        "summary": "Lista todos os locais de atuação",
        "description": "Retorna uma lista de todos os locais de atuação cadastrados.",
        "operationId": "getAllLocaisAtuacao",
        "responses": {
          "200": {
            "description": "Locais de Atuação listados com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListLocalAtuacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListLocalAtuacaoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/locais-atuacao/{id}": {
      "get": {
        "tags": ["Locais de Atuação"],
        "summary": "Busca um local de atuação pelo ID",
        "description": "Retorna os detalhes de um local de atuação específico.",
        "operationId": "getLocalAtuacaoById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do Local de Atuação",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Local de Atuação encontrado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseLocalAtuacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Local de Atuação não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseLocalAtuacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseLocalAtuacaoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/idiomas": {
      "get": {
        "tags": ["Idiomas"],
        "summary": "Lista todos os idiomas",
        "description": "Retorna uma lista de todos os idiomas cadastrados.",
        "operationId": "getAllIdiomas",
        "responses": {
          "200": {
            "description": "Idiomas listados com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListIdiomaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListIdiomaResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/idiomas/{id}": {
      "get": {
        "tags": ["Idiomas"],
        "summary": "Busca um idioma pelo ID",
        "description": "Retorna os detalhes de um idioma específico.",
        "operationId": "getIdiomaById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do idioma",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Idioma encontrado com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseIdiomaResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Idioma não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseIdiomaResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseIdiomaResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/areas-atuacao": {
      "get": {
        "tags": ["Áreas de Atuação"],
        "summary": "Lista todas as áreas de atuação",
        "description": "Retorna uma lista de todas as áreas de atuação cadastradas.",
        "operationId": "getAllAreasAtuacao",
        "responses": {
          "200": {
            "description": "Áreas de Atuação listadas com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListAreaAtuacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListAreaAtuacaoResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/areas-atuacao/{id}": {
      "get": {
        "tags": ["Áreas de Atuação"],
        "summary": "Busca uma área de atuação pelo ID",
        "description": "Retorna os detalhes de uma área de atuação específica.",
        "operationId": "getAreaAtuacaoById",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID da Área de Atuação",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "Área de Atuação encontrada com sucesso",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAreaAtuacaoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Área de Atuação não encontrada",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAreaAtuacaoResponseDTO"
                }
              }
            }
          },
          "500": {
            "description": "Erro interno do servidor",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAreaAtuacaoResponseDTO"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "FormacaoAcademicaRequestDTO": {
        "required": ["curso", "dataConclusao", "instituicao"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "curso": { "maxLength": 255, "minLength": 0, "type": "string" },
          "instituicao": { "maxLength": 255, "minLength": 0, "type": "string" },
          "dataConclusao": { "type": "string", "format": "date" }
        }
      },
      "BaseResponseFormacaoAcademicaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "$ref": "#/components/schemas/FormacaoAcademicaResponseDTO"
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "FormacaoAcademicaResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "curso": { "type": "string" },
          "instituicao": { "type": "string" },
          "dataConclusao": { "type": "string", "format": "date" }
        }
      },
      "ExperienciaProfissionalRequestDTO": {
        "required": ["cargo", "dataInicio", "empresa"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "cargo": { "maxLength": 255, "minLength": 0, "type": "string" },
          "empresa": { "maxLength": 255, "minLength": 0, "type": "string" },
          "dataInicio": { "type": "string", "format": "date" },
          "dataFim": { "type": "string", "format": "date" },
          "descricao": { "type": "string" }
        }
      },
      "BaseResponseExperienciaProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "$ref": "#/components/schemas/ExperienciaProfissionalResponseDTO"
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "ExperienciaProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "cargo": { "type": "string" },
          "empresa": { "type": "string" },
          "dataInicio": { "type": "string", "format": "date" },
          "dataFim": { "type": "string", "format": "date" },
          "descricao": { "type": "string" }
        }
      },
      "CertificacaoRequestDTO": {
        "required": ["dataConclusao", "nome"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "maxLength": 255, "minLength": 0, "type": "string" },
          "instituicao": { "maxLength": 255, "minLength": 0, "type": "string" },
          "dataConclusao": { "type": "string", "format": "date" }
        }
      },
      "BaseResponseCertificacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/CertificacaoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "CertificacaoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "type": "string" },
          "instituicao": { "type": "string" },
          "dataConclusao": { "type": "string", "format": "date" }
        }
      },
      "EnderecoRequestDTO": {
        "required": [
          "bairro",
          "cep",
          "cidade",
          "estado",
          "logradouro",
          "numero",
          "tipoEndereco"
        ],
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "logradouro": { "maxLength": 255, "minLength": 0, "type": "string" },
          "numero": { "maxLength": 20, "minLength": 0, "type": "string" },
          "complemento": { "maxLength": 255, "minLength": 0, "type": "string" },
          "bairro": { "maxLength": 100, "minLength": 0, "type": "string" },
          "cidade": { "maxLength": 100, "minLength": 0, "type": "string" },
          "estado": { "maxLength": 2, "minLength": 0, "type": "string" },
          "cep": { "maxLength": 9, "minLength": 0, "type": "string" },
          "pais": { "maxLength": 50, "minLength": 0, "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          }
        }
      },
      "PessoaRequestDTO": {
        "required": ["cpf", "dataNascimento", "nomeCompleto", "usuario"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "maxLength": 14,
            "minLength": 11,
            "pattern": "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "telefones": {
            "maxItems": 10,
            "minItems": 0,
            "type": "array",
            "items": { "type": "string" }
          },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          }
        }
      },
      "ProfissionalUpdateRequest": {
        "required": ["id", "numeroOab", "usaMarketplace"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "pessoa": { "$ref": "#/components/schemas/PessoaRequestDTO" },
          "numeroOab": { "type": "string" },
          "usaMarketplace": { "type": "boolean" },
          "empresaId": { "type": "string", "format": "uuid" },
          "planoId": { "type": "string", "format": "uuid" },
          "locaisAtuacaoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "areaAtuacaoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "idiomaIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "tipoAtendimentoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "certificacoes": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/CertificacaoRequestDTO" }
          },
          "experiencias": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperienciaProfissionalRequestDTO"
            }
          },
          "formacoes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormacaoAcademicaRequestDTO"
            }
          }
        }
      },
      "UserRequestDTO": {
        "required": ["email"],
        "type": "object",
        "properties": {
          "id": { "type": "string" },
          "email": { "maxLength": 255, "minLength": 0, "type": "string" },
          "senha": { "maxLength": 255, "minLength": 8, "type": "string" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": { "maxLength": 14, "minLength": 0, "type": "string" },
          "telefone": { "maxLength": 20, "minLength": 0, "type": "string" },
          "fotoUrl": { "type": "string" }
        }
      },
      "AreaAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "type": "string" },
          "descricao": { "type": "string" }
        }
      },
      "BaseResponseProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/ProfissionalResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "DocumentoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeArquivo": { "type": "string" },
          "urlS3": { "type": "string" },
          "tipoDocumento": { "type": "string" }
        }
      },
      "EnderecoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "logradouro": { "type": "string" },
          "numero": { "type": "string" },
          "complemento": { "type": "string" },
          "bairro": { "type": "string" },
          "cidade": { "type": "string" },
          "estado": { "type": "string" },
          "cep": { "type": "string" },
          "pais": { "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          }
        }
      },
      "IdiomaResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "type": "string" },
          "codigo": { "type": "string" },
          "nivel": { "type": "string" }
        }
      },
      "LocalAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "type": "string" }
        }
      },
      "PessoaResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserResponseDTO" },
          "nomeCompleto": { "type": "string" },
          "cpf": { "type": "string" },
          "dataNascimento": { "type": "string", "format": "date" },
          "telefones": { "type": "array", "items": { "type": "string" } },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          }
        }
      },
      "ProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "pessoa": { "$ref": "#/components/schemas/PessoaResponseDTO" },
          "numeroOab": { "type": "string" },
          "statusProfissional": { "type": "string" },
          "usaMarketplace": { "type": "boolean" },
          "fazParteDePlano": { "type": "boolean" },
          "empresaId": { "type": "string", "format": "uuid" },
          "planoId": { "type": "string", "format": "uuid" },
          "tenantId": { "type": "string", "format": "uuid" },
          "certificacoes": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/CertificacaoResponseDTO" }
          },
          "documentos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/DocumentoResponseDTO" }
          },
          "experiencias": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperienciaProfissionalResponseDTO"
            }
          },
          "formacoes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormacaoAcademicaResponseDTO"
            }
          },
          "locaisAtuacao": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/LocalAtuacaoResponseDTO" }
          },
          "areasAtuacao": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/AreaAtuacaoResponseDTO" }
          },
          "idiomas": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/IdiomaResponseDTO" }
          },
          "tiposAtendimento": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TipoAtendimentoResponseDTO"
            }
          },
          "rolesProfissional": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/RoleProfissionalResponseDTO"
            }
          }
        }
      },
      "RoleProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "name": { "type": "string" }
        }
      },
      "TipoAtendimentoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nome": { "type": "string" }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeCompleto": { "type": "string" },
          "email": { "type": "string" },
          "cpf": { "type": "string" },
          "telefone": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "userType": {
            "type": "string",
            "enum": ["CLIENTE", "ADVOGADO", "PLATAFORMA_ADMIN", "SOCIO"]
          },
          "userStatus": {
            "type": "string",
            "enum": [
              "ACTIVE",
              "INACTIVE",
              "PENDING_APPROVAL",
              "REJECTED",
              "PENDING"
            ]
          }
        }
      },
      "ProfissionalCreateRequest": {
        "required": [
          "cpf",
          "dataNascimento",
          "nomeCompleto",
          "numeroOab",
          "planoId",
          "tenantId",
          "usaMarketplace",
          "usuario"
        ],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "maxLength": 14,
            "minLength": 11,
            "pattern": "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "telefones": {
            "maxItems": 10,
            "minItems": 0,
            "type": "array",
            "items": { "type": "string" }
          },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "numeroOab": { "maxLength": 50, "minLength": 5, "type": "string" },
          "usaMarketplace": { "type": "boolean" },
          "planoId": { "type": "string", "format": "uuid" },
          "tenantId": { "type": "string", "format": "uuid" },
          "locaisAtuacaoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "areaAtuacaoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "idiomaIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "tipoAtendimentoIds": {
            "type": "array",
            "items": { "type": "string", "format": "uuid" }
          },
          "certificacoes": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/CertificacaoRequestDTO" }
          },
          "experiencias": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperienciaProfissionalRequestDTO"
            }
          },
          "formacoes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormacaoAcademicaRequestDTO"
            }
          }
        }
      },
      "DocumentoUploadRequest": {
        "required": [
          "arquivoBase64",
          "mimeType",
          "nomeArquivo",
          "tipoDocumento"
        ],
        "type": "object",
        "properties": {
          "nomeArquivo": { "maxLength": 255, "minLength": 0, "type": "string" },
          "tipoDocumento": {
            "type": "string",
            "enum": ["OAB", "RG", "CPF", "COMPROVANTE_ENDERECO", "OUTRO"]
          },
          "arquivoBase64": { "type": "string" },
          "mimeType": { "maxLength": 100, "minLength": 0, "type": "string" }
        }
      },
      "BaseResponseDocumentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/DocumentoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseBoolean": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "boolean" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListTipoAtendimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/TipoAtendimentoResponseDTO"
            }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseTipoAtendimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/TipoAtendimentoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponsePageProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "$ref": "#/components/schemas/PageProfissionalResponseDTO"
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "totalElements": { "type": "integer", "format": "int64" },
          "totalPages": { "type": "integer", "format": "int32" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ProfissionalResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "PageableObject": {
        "type": "object",
        "properties": {
          "offset": { "type": "integer", "format": "int64" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "unpaged": { "type": "boolean" },
          "paged": { "type": "boolean" },
          "pageNumber": { "type": "integer", "format": "int32" },
          "pageSize": { "type": "integer", "format": "int32" }
        }
      },
      "SortObject": {
        "type": "object",
        "properties": {
          "direction": { "type": "string" },
          "nullHandling": { "type": "string" },
          "ascending": { "type": "boolean" },
          "property": { "type": "string" },
          "ignoreCase": { "type": "boolean" }
        }
      },
      "BaseResponseListFormacaoAcademicaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/FormacaoAcademicaResponseDTO"
            }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListExperienciaProfissionalResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExperienciaProfissionalResponseDTO"
            }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListDocumentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/DocumentoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListCertificacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/CertificacaoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListLocalAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/LocalAtuacaoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseLocalAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/LocalAtuacaoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListIdiomaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/IdiomaResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseIdiomaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/IdiomaResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListAreaAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/AreaAtuacaoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseAreaAtuacaoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AreaAtuacaoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}

```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "LegalUsuarioApplication",
      "request": "launch",
      "mainClass": "br.com.legalconnect.LegalUsuarioApplication",
      "projectName": "legalconnect-advogado"
    },
    {
      "type": "java",
      "name": "Spring Boot-LegalUsuarioApplication<legal-usuario>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.LegalUsuarioApplication",
      "projectName": "legal-usuario",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
```java
```java
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(basePackages = {
		"br.com.legalconnect.advogado.repository",
		"br.com.legalconnect.commom.repository" })
@EntityScan(basePackages = {
		"br.com.legalconnect.commom.model",
		"br.com.legalconnect.advogado.domain" })
@EnableDiscoveryClient
@SpringBootApplication
public class LegalUsuarioApplication {
	// @Value("${application.tenant.default-id}")
	// private String defaultTenantId;

	// @Autowired
	// private TenantMigrationService tenantMigrationService;

	public static void main(String[] args) {
		SpringApplication.run(LegalUsuarioApplication.class, args);
	}
}
// @Bean
// boolean inicio() {
// tenantMigrationService.migrateTenant(defaultTenantId);
// return true;
// }
// }

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.ERRO;
import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.service.AgendamentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.NotNull;

/**
 * Controller para o módulo de Agendamento de Consultas.
 * Gerencia as operações relacionadas ao agendamento e avaliação de consultas
 * entre clientes e profissionais.
 */
@RestController
@RequestMapping("/api/v1/advogados/agendamentos")
@Tag(name = "Agendamentos", description = "Gerenciamento de agendamentos de consultas e avaliações")
public class AgendamentoController {

        private final AgendamentoService agendamentoService;

        @Autowired
        public AgendamentoController(AgendamentoService agendamentoService) {
                this.agendamentoService = agendamentoService;
        }

        /**
         * Realiza o agendamento de uma consulta.
         * Funcionalidade Completa: Cenário 1 (Cliente busca e agenda) e Cenário 2
         * (Advogado recebe e confirma).
         * Regras de Negócio: Verifica disponibilidade do profissional, profissional
         * deve estar ativo e usar marketplace, integração com Google Calendar, envio de
         * e-mails.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta (formato ISO).
         * @param tipoServico        Tipo de serviço agendado.
         * @return ResponseEntity indicando o sucesso do agendamento.
         */
        @Operation(summary = "Agenda uma nova consulta", description = "Permite a um cliente agendar uma consulta com um profissional, verificando disponibilidade e enviando notificações.", responses = {
                        @ApiResponse(responseCode = "201", description = "Consulta agendada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: horário indisponível)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de agendamento (horário já ocupado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/agendar")
        public ResponseEntity<BaseResponse<Boolean>> agendarConsulta(
                        @Parameter(description = "ID do profissional para o agendamento") @RequestParam @NotNull UUID profissionalId,
                        @Parameter(description = "ID do cliente que está agendando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Horário desejado para a consulta (formato ISO 8601, ex: 2024-07-25T10:00:00)") @RequestParam @NotNull @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime horarioAgendamento,
                        @Parameter(description = "Tipo de serviço a ser agendado (ex: 'Consulta Online', 'Reunião Presencial')") @RequestParam @NotNull String tipoServico) {

                boolean sucesso = agendamentoService.agendarConsulta(profissionalId, clienteId, horarioAgendamento,
                                tipoServico);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Boolean>builder()
                                                .status(SUCESSO)
                                                .message("Consulta agendada com sucesso.")
                                                .data(sucesso)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Permite ao cliente avaliar uma consulta.
         * Funcionalidade Completa: Cenário 3 (Cliente avalia e influencia ranking).
         * Regras de Negócio: Associa avaliação ao agendamento e profissional, atualiza
         * média de avaliação.
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return ResponseEntity indicando o sucesso da avaliação.
         */
        @Operation(summary = "Avalia uma consulta", description = "Permite a um cliente fornecer uma nota e um comentário para uma consulta já realizada.", responses = {
                        @ApiResponse(responseCode = "200", description = "Consulta avaliada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: nota fora do intervalo)"),
                        @ApiResponse(responseCode = "404", description = "Agendamento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/avaliar")
        public ResponseEntity<BaseResponse<Boolean>> avaliarConsulta(
                        @Parameter(description = "ID do agendamento a ser avaliado") @RequestParam @NotNull UUID agendamentoId,
                        @Parameter(description = "ID do cliente que está avaliando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Nota da avaliação (1 a 5)") @RequestParam @NotNull int rating,
                        @Parameter(description = "Comentário opcional sobre a avaliação") @RequestParam(required = false) String comentario) {

                // Regra de Negócio: Rating deve estar entre 1 e 5
                if (rating < 1 || rating > 5) {
                        return ResponseEntity.badRequest().body(BaseResponse.<Boolean>builder()
                                        .status(ERRO)
                                        .message("A nota da avaliação deve ser entre 1 e 5.")
                                        .data(false)
                                        .timestamp(java.time.LocalDateTime.now())
                                        .build());
                }

                boolean sucesso = agendamentoService.avaliarConsulta(agendamentoId, clienteId, rating, comentario);
                return ResponseEntity.ok(BaseResponse.<Boolean>builder()
                                .status(SUCESSO)
                                .message("Consulta avaliada com sucesso.")
                                .data(sucesso)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Áreas de Atuação (dados mestre).
 * Oferece endpoints para consultar as áreas de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/areas-atuacao")
@Tag(name = "Áreas de Atuação", description = "Gerenciamento de dados mestre de Áreas de Atuação")
public class AreaAtuacaoController {

        private final AreaAtuacaoService areaAtuacaoService;

        @Autowired
        public AreaAtuacaoController(AreaAtuacaoService areaAtuacaoService) {
                this.areaAtuacaoService = areaAtuacaoService;
        }

        /**
         * Busca uma Área de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID da Área de Atuação.
         * @return ResponseEntity com o DTO da Área de Atuação.
         */
        @Operation(summary = "Busca uma área de atuação pelo ID", description = "Retorna os detalhes de uma área de atuação específica.", responses = {
                        @ApiResponse(responseCode = "200", description = "Área de Atuação encontrada com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Área de Atuação não encontrada"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<AreaAtuacaoResponseDTO>> getAreaAtuacaoById(
                        @Parameter(description = "ID da Área de Atuação") @PathVariable UUID id) {
                AreaAtuacaoResponseDTO response = areaAtuacaoService.findAreaAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<AreaAtuacaoResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Área de Atuação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.service.IdiomaService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Idiomas (dados mestre).
 * Oferece endpoints para consultar os idiomas disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/idiomas")
@Tag(name = "Idiomas", description = "Gerenciamento de dados mestre de Idiomas")
public class IdiomaController {

        private final IdiomaService idiomaService;

        @Autowired
        public IdiomaController(IdiomaService idiomaService) {
                this.idiomaService = idiomaService;
        }

        /**
         * Busca um Idioma pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Idioma.
         * @return ResponseEntity com o DTO do Idioma.
         */
        @Operation(summary = "Busca um idioma pelo ID", description = "Retorna os detalhes de um idioma específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idioma encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Idioma não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<IdiomaResponseDTO>> getIdiomaById(
                        @Parameter(description = "ID do idioma") @PathVariable UUID id) {
                IdiomaResponseDTO response = idiomaService.findIdiomaById(id);
                return ResponseEntity.ok(BaseResponse.<IdiomaResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idioma encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Idiomas.
         * Funcionalidade Completa: Listagem de todos os idiomas disponíveis para
         * seleção pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Idiomas.
         */
        @Operation(summary = "Lista todos os idiomas", description = "Retorna uma lista de todos os idiomas cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idiomas listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<IdiomaResponseDTO>>> getAllIdiomas() {
                List<IdiomaResponseDTO> response = idiomaService.findAllIdiomas();
                return ResponseEntity.ok(BaseResponse.<List<IdiomaResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idiomas listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.LocalAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Locais de Atuação (dados mestre).
 * Oferece endpoints para consultar os locais de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/locais-atuacao")
@Tag(name = "Locais de Atuação", description = "Gerenciamento de dados mestre de Locais de Atuação")
public class LocalAtuacaoController {

        private final LocalAtuacaoService localAtuacaoService;

        @Autowired
        public LocalAtuacaoController(LocalAtuacaoService localAtuacaoService) {
                this.localAtuacaoService = localAtuacaoService;
        }

        /**
         * Busca um Local de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Local de Atuação.
         * @return ResponseEntity com o DTO do Local de Atuação.
         */
        @Operation(summary = "Busca um local de atuação pelo ID", description = "Retorna os detalhes de um local de atuação específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Local de Atuação encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Local de Atuação não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<LocalAtuacaoResponseDTO>> getLocalAtuacaoById(
                        @Parameter(description = "ID do Local de Atuação") @PathVariable UUID id) {
                LocalAtuacaoResponseDTO response = localAtuacaoService.findLocalAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<LocalAtuacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Local de Atuação encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Locais de Atuação.
         * Funcionalidade Completa: Listagem de todos os locais disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Locais de Atuação.
         */
        @Operation(summary = "Lista todos os locais de atuação", description = "Retorna uma lista de todos os locais de atuação cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Locais de Atuação listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<LocalAtuacaoResponseDTO>>> getAllLocaisAtuacao() {
                List<LocalAtuacaoResponseDTO> response = localAtuacaoService.findAllLocaisAtuacao();
                return ResponseEntity.ok(BaseResponse.<List<LocalAtuacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Locais de Atuação listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.service.CertificacaoService;
import br.com.legalconnect.advogado.service.DocumentoService;
import br.com.legalconnect.advogado.service.ExperienciaProfissionalService;
import br.com.legalconnect.advogado.service.FormacaoAcademicaService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * Controller para o módulo de Profissionais (Advogados).
 * Gerencia as operações REST para perfis de advogados,
 * incluindo suas certificações, experiências, formações e documentos.
 */
@RestController
@RequestMapping("/api/v1/advogados/profissionais")
@Tag(name = "Profissionais", description = "Gerenciamento de perfis de Advogados")
public class ProfissionalController {

        private final ProfissionalService profissionalService;
        private final CertificacaoService certificacaoService;
        private final ExperienciaProfissionalService experienciaProfissionalService;
        private final FormacaoAcademicaService formacaoAcademicaService;
        private final DocumentoService documentoService;

        @Autowired
        public ProfissionalController(ProfissionalService profissionalService,
                        CertificacaoService certificacaoService,
                        ExperienciaProfissionalService experienciaProfissionalService,
                        FormacaoAcademicaService formacaoAcademicaService,
                        DocumentoService documentoService) {
                this.profissionalService = profissionalService;
                this.certificacaoService = certificacaoService;
                this.experienciaProfissionalService = experienciaProfissionalService;
                this.formacaoAcademicaService = formacaoAcademicaService;
                this.documentoService = documentoService;
        }

        // ***************************************

        /**
         * Lista todas as localizações (estados e cidades) onde há profissionais.
         * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
         * cidades.
         *
         * @return ResponseEntity com o mapa de localizações.
         */
        @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/localizacoes")
        public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
                Map<String, List<String>> response = profissionalService.listarLocalizacoesDisponiveis();

                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Map<String, List<String>>>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        // ************************************************ */
        /**
         * Cria um novo profissional (advogado) no sistema.
         * Funcionalidade Completa: Cadastro de Advogado com dados aninhados.
         * Regras de Negócio: Validação de unicidade de OAB, CPF e Email. Associação a
         * um tenant.
         *
         * @param request      DTO com os dados do profissional a ser criado.
         * @param userIdHeader Opcional. ID do usuário logado/solicitante, vindo do
         *                     cabeçalho X-Correlation-Id.
         * @return ResponseEntity com o DTO do profissional criado.
         */
        @Operation(summary = "Cria um novo profissional", description = "Registra um novo advogado com seus dados pessoais e informações profissionais.", responses = {
                        @ApiResponse(responseCode = "201", description = "Profissional criado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "409", description = "OAB, CPF ou Email já cadastrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> createProfissional(
                        @Valid @RequestBody ProfissionalCreateRequest request,
                        @RequestHeader(value = "X-Correlation-Id", required = false) String userIdHeader) {
                if (userIdHeader != null && !userIdHeader.trim().isEmpty()) {
                        try {
                                UUID userUuid = UUID.fromString(userIdHeader); // Validar se é um UUID válido

                                if (request.getUsuario() == null) {
                                        // Se o DTO de usuário não foi fornecido no corpo, cria um com o ID do header
                                        request.setUsuario(UserRequestDTO.builder().id(userUuid).build());
                                } else if (request.getUsuario().getId() == null) {
                                        // Se o DTO de usuário foi fornecido, mas sem ID, usa o do header
                                        request.getUsuario().setId(userUuid);
                                }
                        } catch (IllegalArgumentException e) {
                                // Logar ou tratar erro se userIdHeader não for um UUID válido
                                // Para este caso, vamos apenas logar e ignorar o userIdHeader inválido.
                                System.err.println("X-Correlation-Id inválido: " + userIdHeader
                                                + ". Ignorando ID do cabeçalho.");
                        }
                }

                ProfissionalResponseDTO response = profissionalService.createProfissional(request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza um profissional existente.
         * Funcionalidade Completa: Atualização de perfil de advogado, incluindo dados
         * da Pessoa e coleções aninhadas.
         * Regras de Negócio: Acesso restrito ao próprio tenant, validação de
         * existência.
         *
         * @param id      ID do profissional a ser atualizado.
         * @param request DTO com os dados de atualização.
         * @return ResponseEntity com o DTO do profissional atualizado.
         */
        @Operation(summary = "Atualiza um profissional existente", description = "Atualiza os dados de um advogado, incluindo informações pessoais e coleções relacionadas.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional atualizado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: email duplicado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> updateProfissional(
                        @Parameter(description = "ID do profissional a ser atualizado") @PathVariable UUID id,
                        @Valid @RequestBody ProfissionalUpdateRequest request) {
                ProfissionalResponseDTO response = profissionalService.updateProfissional(id, request);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional atualizado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca um profissional pelo ID.
         * Funcionalidade Completa: Exibição detalhada do perfil de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param id ID do profissional.
         * @return ResponseEntity com o DTO do profissional.
         */
        @Operation(summary = "Busca um profissional pelo ID", description = "Retorna os detalhes completos de um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> getProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID id) {
                ProfissionalResponseDTO response = profissionalService.findProfissionalById(id);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os profissionais do tenant atual com paginação.
         * Funcionalidade Completa: Listagem paginada de advogados para o marketplace ou
         * para gestão interna do tenant.
         * Regras de Negócio: Filtro automático por tenant_id.
         *
         * @param page Número da página (0-indexed).
         * @param size Tamanho da página.
         * @param sort Critério de ordenação (ex: campo,asc ou campo,desc).
         * @return ResponseEntity com a página de DTOs de profissionais.
         */
        @Operation(summary = "Lista todos os profissionais com paginação", description = "Retorna uma lista paginada de todos os advogados associados ao tenant atual.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissionais listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> getAllProfissionais(
                        @Parameter(description = "Número da página (0-indexed)", example = "0") @RequestParam(defaultValue = "0") int page,
                        @Parameter(description = "Tamanho da página", example = "10") @RequestParam(defaultValue = "10") int size,
                        @Parameter(description = "Critério de ordenação (ex: nomeCompleto,asc ou numeroOab,desc)", example = "nomeCompleto,asc") @RequestParam(defaultValue = "nomeCompleto,asc") String[] sort) {

                Sort sortCriteria = Sort.by(Sort.Direction.fromString(sort[1]), sort[0]);
                PageRequest pageable = PageRequest.of(page, size, sortCriteria);

                Page<ProfissionalResponseDTO> response = profissionalService.findAllProfissionais(pageable);
                return ResponseEntity.ok(BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Profissionais listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um profissional pelo ID.
         * Funcionalidade Completa: Remoção completa do perfil do advogado e dados
         * associados.
         * Regras de Negócio: Acesso restrito ao próprio tenant. Deleção em cascata
         * (certificações, experiências, documentos, formação, pessoa).
         *
         * @param id ID do profissional a ser deletado.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um profissional pelo ID", description = "Remove um advogado e todos os seus dados associados do sistema.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deleteProfissional(
                        @Parameter(description = "ID do profissional a ser deletado") @PathVariable UUID id) {
                profissionalService.deleteProfissional(id);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Profissional deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Certificações ---

        /**
         * Adiciona uma certificação a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de certificações.
         * Regras de Negócio: Certificação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da certificação.
         * @return ResponseEntity com a certificação criada.
         */
        @Operation(summary = "Adiciona uma certificação a um profissional", description = "Adiciona uma nova certificação ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Certificação adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> addCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.createCertificacao(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<CertificacaoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Certificação adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma certificação de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma certificação
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a certificação atualizada.
         */
        @Operation(summary = "Atualiza uma certificação de um profissional", description = "Atualiza os detalhes de uma certificação existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> updateCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser atualizada") @PathVariable UUID certificacaoId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.updateCertificacao(profissionalId,
                                certificacaoId,
                                requestDTO);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma certificação específica de um profissional.
         * Funcionalidade Completa: Consulta individual de certificação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity com a certificação encontrada.
         */
        @Operation(summary = "Busca uma certificação específica de um profissional", description = "Retorna os detalhes de uma certificação específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> getCertificacaoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação") @PathVariable UUID certificacaoId) {
                CertificacaoResponseDTO response = certificacaoService.findCertificacaoById(profissionalId,
                                certificacaoId);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as certificações de um profissional.
         * Funcionalidade Completa: Visualização de todas as certificações de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de certificações.
         */
        @Operation(summary = "Lista todas as certificações de um profissional", description = "Retorna uma lista de todas as certificações associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificações listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<List<CertificacaoResponseDTO>>> getAllCertificacoes(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<CertificacaoResponseDTO> response = certificacaoService
                                .findAllCertificacoesByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<CertificacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Certificações listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma certificação de um profissional.
         * Funcionalidade Completa: Remoção de uma certificação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma certificação de um profissional", description = "Remove uma certificação específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser deletada") @PathVariable UUID certificacaoId) {
                certificacaoService.deleteCertificacao(profissionalId, certificacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Certificação deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Experiências Profissionais ---

        /**
         * Adiciona uma experiência profissional a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de experiências.
         * Regras de Negócio: Experiência associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da experiência.
         * @return ResponseEntity com a experiência criada.
         */
        @Operation(summary = "Adiciona uma experiência profissional a um profissional", description = "Adiciona uma nova experiência profissional ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Experiência profissional adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> addExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .createExperienciaProfissional(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Experiência profissional adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma experiência profissional de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma experiência
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a experiência atualizada.
         */
        @Operation(summary = "Atualiza uma experiência profissional de um profissional", description = "Atualiza os detalhes de uma experiência profissional existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> updateExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser atualizada") @PathVariable UUID experienciaId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .updateExperienciaProfissional(profissionalId, experienciaId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma experiência profissional específica de um profissional.
         * Funcionalidade Completa: Consulta individual de experiência.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity com a experiência encontrada.
         */
        @Operation(summary = "Busca uma experiência profissional específica de um profissional", description = "Retorna os detalhes de uma experiência profissional específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> getExperienciaProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência") @PathVariable UUID experienciaId) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .findExperienciaProfissionalById(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         * Funcionalidade Completa: Visualização de todas as experiências de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de experiências.
         */
        @Operation(summary = "Lista todas as experiências profissionais de um profissional", description = "Retorna uma lista de todas as experiências profissionais associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiências profissionais listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<List<ExperienciaProfissionalResponseDTO>>> getAllExperienciasProfissionais(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<ExperienciaProfissionalResponseDTO> response = experienciaProfissionalService
                                .findAllExperienciasProfissionaisByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<ExperienciaProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Experiências profissionais listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         * Funcionalidade Completa: Remoção de uma experiência específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma experiência profissional de um profissional", description = "Remove uma experiência profissional específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<Void>> deleteExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser deletada") @PathVariable UUID experienciaId) {
                experienciaProfissionalService.deleteExperienciaProfissional(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Formações Acadêmicas ---

        /**
         * Adiciona uma formação acadêmica a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de formações.
         * Regras de Negócio: Formação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da formação.
         * @return ResponseEntity com a formação criada.
         */
        @Operation(summary = "Adiciona uma formação acadêmica a um profissional", description = "Adiciona uma nova formação acadêmica ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Formação acadêmica adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> addFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.createFormacaoAcademica(profissionalId,
                                requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Formação acadêmica adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma formação existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a formação atualizada.
         */
        @Operation(summary = "Atualiza uma formação acadêmica de um profissional", description = "Atualiza os detalhes de uma formação acadêmica existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> updateFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser atualizada") @PathVariable UUID formacaoId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.updateFormacaoAcademica(profissionalId,
                                formacaoId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma formação acadêmica específica de um profissional.
         * Funcionalidade Completa: Consulta individual de formação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity com a formação encontrada.
         */
        @Operation(summary = "Busca uma formação acadêmica específica de um profissional", description = "Retorna os detalhes de uma formação acadêmica específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> getFormacaoAcademicaById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação") @PathVariable UUID formacaoId) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.findFormacaoAcademicaById(
                                profissionalId,
                                formacaoId);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         * Funcionalidade Completa: Visualização de todas as formações de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de formações.
         */
        @Operation(summary = "Lista todas as formações acadêmicas de um profissional", description = "Retorna uma lista de todas as formações acadêmicas associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formações acadêmicas listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<List<FormacaoAcademicaResponseDTO>>> getAllFormacoesAcademicas(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<FormacaoAcademicaResponseDTO> response = formacaoAcademicaService
                                .findAllFormacoesAcademicasByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<FormacaoAcademicaResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Formações acadêmicas listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Remoção de uma formação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma formação acadêmica de um profissional", description = "Remove uma formação acadêmica específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser deletada") @PathVariable UUID formacaoId) {
                formacaoAcademicaService.deleteFormacaoAcademica(profissionalId, formacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Documentos ---

        /**
         * Realiza o upload de um documento para um profissional.
         * Funcionalidade Completa: Armazenamento de documentos no S3 e metadados no DB.
         * Regras de Negócio: Associação ao profissional e tenant, validação de formato
         * Base64.
         *
         * @param profissionalId ID do profissional.
         * @param request        DTO com os dados do documento e o arquivo em Base64.
         * @return ResponseEntity com o DTO do documento criado.
         */
        @Operation(summary = "Realiza o upload de um documento para um profissional", description = "Faz o upload de um documento para o S3 e persiste seus metadados para um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Documento enviado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: Base64 inválido)"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Falha ao fazer upload do documento ou erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/documentos/upload")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> uploadDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody DocumentoUploadRequest request) {
                DocumentoResponseDTO response = documentoService.uploadDocumento(profissionalId, request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<DocumentoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Documento enviado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Busca um documento específico de um profissional.
         * Funcionalidade Completa: Consulta individual de documento.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity com o DTO do documento encontrado.
         */
        @Operation(summary = "Busca um documento específico de um profissional", description = "Retorna os detalhes de um documento específico de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> getDocumentoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento") @PathVariable UUID documentoId) {
                DocumentoResponseDTO response = documentoService.findDocumentoById(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<DocumentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Documento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os documentos de um profissional.
         * Funcionalidade Completa: Visualização de todos os documentos de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de documentos.
         */
        @Operation(summary = "Lista todos os documentos de um profissional", description = "Retorna uma lista de todos os documentos associados a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documentos listados com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos")
        public ResponseEntity<BaseResponse<List<DocumentoResponseDTO>>> getAllDocumentos(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<DocumentoResponseDTO> response = documentoService
                                .findAllDocumentosByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<DocumentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Documentos listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um documento de um profissional.
         * Funcionalidade Completa: Remoção do documento do S3 e do banco de dados.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um documento de um profissional", description = "Remove um documento específico do perfil de um advogado, incluindo a remoção do S3.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para deleção"),
                        @ApiResponse(responseCode = "500", description = "Falha ao deletar o documento do S3 ou erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<Void>> deleteDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento a ser deletado") @PathVariable UUID documentoId) {
                documentoService.deleteDocumento(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Documento deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

/**
 * Controller para dados mestre de Localizações.
 * Oferece endpoints para consultar estados e cidades disponíveis.
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/advogados/profissionais") // Caminho da requisição ajustado
@Tag(name = "Localizações", description = "Gerenciamento de dados mestre de Localizações (Estados e Cidades)")
public class ProfissionalPublicoController {

    private final ProfissionalService pessoaService;

    private final AreaAtuacaoService areaAtuacaoService;

    /**
     * Lista todas as localizações (estados e cidades) onde há profissionais.
     * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
     * cidades.
     *
     * @return ResponseEntity com o mapa de localizações.
     */
    @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
            @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/localizacoes")
    public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
        Map<String, List<String>> response = pessoaService.listarLocalizacoesDisponiveis();
        return ResponseEntity.ok(BaseResponse.<Map<String, List<String>>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Localizações listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }

    /**
     * Lista todas as Áreas de Atuação.
     * Funcionalidade Completa: Listagem de todas as áreas disponíveis para seleção
     * pelos advogados.
     * Regras de Negócio: N/A (apenas listagem).
     *
     * @return ResponseEntity com a lista de DTOs de Áreas de Atuação.
     */
    @Operation(summary = "Lista todas as áreas de atuação", description = "Retorna uma lista de todas as áreas de atuação cadastradas.", responses = {
            @ApiResponse(responseCode = "200", description = "Áreas de Atuação listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/areas-atuacao")
    public ResponseEntity<BaseResponse<List<AreaAtuacaoResponseDTO>>> getAllAreasAtuacao() {
        List<AreaAtuacaoResponseDTO> response = areaAtuacaoService.findAllAreasAtuacao();
        return ResponseEntity.ok(BaseResponse.<List<AreaAtuacaoResponseDTO>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Áreas de Atuação listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }
}

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.service.TipoAtendimentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Tipos de Atendimento (dados mestre).
 * Oferece endpoints para consultar os tipos de atendimento disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/tipos-atendimento")
@Tag(name = "Tipos de Atendimento", description = "Gerenciamento de dados mestre de Tipos de Atendimento")
public class TipoAtendimentoController {

        private final TipoAtendimentoService tipoAtendimentoService;

        @Autowired
        public TipoAtendimentoController(TipoAtendimentoService tipoAtendimentoService) {
                this.tipoAtendimentoService = tipoAtendimentoService;
        }

        /**
         * Busca um Tipo de Atendimento pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Tipo de Atendimento.
         * @return ResponseEntity com o DTO do Tipo de Atendimento.
         */
        @Operation(summary = "Busca um tipo de atendimento pelo ID", description = "Retorna os detalhes de um tipo de atendimento específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipo de Atendimento encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Tipo de Atendimento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<TipoAtendimentoResponseDTO>> getTipoAtendimentoById(
                        @Parameter(description = "ID do Tipo de Atendimento") @PathVariable UUID id) {
                TipoAtendimentoResponseDTO response = tipoAtendimentoService.findTipoAtendimentoById(id);
                return ResponseEntity.ok(BaseResponse.<TipoAtendimentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Tipo de Atendimento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Tipos de Atendimento.
         * Funcionalidade Completa: Listagem de todos os tipos disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Tipos de Atendimento.
         */
        @Operation(summary = "Lista todos os tipos de atendimento", description = "Retorna uma lista de todos os tipos de atendimento cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipos de Atendimento listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<TipoAtendimentoResponseDTO>>> getAllTiposAtendimento() {
                List<TipoAtendimentoResponseDTO> response = tipoAtendimentoService.findAllTiposAtendimento();
                return ResponseEntity.ok(BaseResponse.<List<TipoAtendimentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Tipos de Atendimento listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Certificacao extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Documento extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissional extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademica extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Idioma extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.commom.model.Pessoa;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId;

    @Column(name = "empresa_id")
    private UUID empresaId;
    @Column(name = "plano_id", nullable = false)
    private UUID planoId;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Certificacao> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Documento> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissional> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademica> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissional> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissional extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimento extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.enums;

/**
 * Enumeração para os tipos de documentos de um Profissional (Advogado).
 * 
 */
public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CertificacaoRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de upload de documento.
 * O campo 'tipoDocumento' foi alterado de String para o enum DocumentoTipo
 * para garantir tipagem segura e validação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    // Alterado de String para o enum DocumentoTipo para tipagem segura
    @NotNull(message = "O tipo do documento é obrigatório.")
    private DocumentoTipo tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim; // Pode ser nulo se for a experiência atual

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para criação de um novo Profissional.
 * Este DTO agora compõe um PessoaRequestDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ProfissionalCreateRequest extends PessoaRequestDTO {

    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;

    // Relacionamentos para dados mestres que podem ser definidos na criação
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // DTOs para certificações, experiências e formações na criação (opcional)
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para atualização de um Profissional.
 * Permite a atualização dos dados da Pessoa associada e dos campos específicos
 * de Profissional,
 * bem como de listas aninhadas.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalUpdateRequest {
    @NotNull(message = "O ID do profissional é obrigatório para atualização.")
    private UUID id;

    @Valid
    // A PessoaRequestDTO interna deve ter seu próprio ID se for uma atualização de
    // pessoa existente
    private PessoaRequestDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId; // Pode ser nulo se não houver empresa associada ou se for desvinculada

    private UUID planoId; // Pode ser nulo se o plano não for alterado

    // Listas de UUIDs para dados mestres
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // Listas de DTOs aninhados para certificações, experiências, formações
    // O ID em cada DTO aninhado indicará se é uma criação, atualização ou remoção.
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Área de Atuação.
 * Usado para retornar detalhes completos da Área de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AreaAtuacaoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Documento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Idioma.
 * Usado para retornar detalhes completos do Idioma.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdiomaResponseDTO {
    private UUID id;
    private String nome;
    private String codigo;
    private String nivel;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Local de Atuação.
 * Usado para retornar detalhes completos do Local de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LocalAtuacaoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.response.PessoaResponseDTO; // Importar PessoaResponseDTO
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta detalhada para um Profissional.
 * Agora compõe um PessoaResponseDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalResponseDTO {
    private UUID id; // ID do Profissional

    private PessoaResponseDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;

    // IDs de entidades relacionadas
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    // Listas de DTOs aninhados
    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    // Listas de DTOs de dados mestres (detalhados)
    private List<LocalAtuacaoResponseDTO> locaisAtuacao;
    private List<AreaAtuacaoResponseDTO> areasAtuacao;
    private List<IdiomaResponseDTO> idiomas;
    private List<TipoAtendimentoResponseDTO> tiposAtendimento;
    private List<RoleProfissionalResponseDTO> rolesProfissional; // DTO para Role do Profissional
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Role de Profissional.
 * Usado para retornar detalhes completos da Role.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleProfissionalResponseDTO {
    private UUID id;
    private String name;
    // O tenantId pode ser incluído se for relevante para o frontend
    // private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Tipo de Atendimento.
 * Usado para retornar detalhes completos do Tipo de Atendimento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TipoAtendimentoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade AreaAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface AreaAtuacaoMapper {
    AreaAtuacaoMapper INSTANCE = Mappers.getMapper(AreaAtuacaoMapper.class);

    /**
     * Mapeia uma entidade AreaAtuacao para um AreaAtuacaoResponseDTO.
     * 
     * @param entity A entidade AreaAtuacao.
     * @return O DTO de resposta correspondente.
     */
    AreaAtuacaoResponseDTO toResponseDTO(AreaAtuacao entity);

    /**
     * Mapeia um AreaAtuacaoResponseDTO para uma entidade AreaAtuacao.
     * Útil para cenários de re-conversão ou testes, embora a criação normalmente
     * venha de um RequestDTO.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade AreaAtuacao correspondente.
     */
    AreaAtuacao toEntity(AreaAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade Certificacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface CertificacaoMapper {
    CertificacaoMapper INSTANCE = Mappers.getMapper(CertificacaoMapper.class);

    /**
     * Mapeia um CertificacaoRequestDTO para uma entidade Certificacao.
     * O campo 'profissional' e 'tenantId' na entidade devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Certificacao correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    Certificacao toEntity(CertificacaoRequestDTO dto);

    /**
     * Mapeia uma entidade Certificacao para um CertificacaoResponseDTO.
     *
     * @param entity A entidade Certificacao.
     * @return O DTO de resposta correspondente.
     */
    CertificacaoResponseDTO toResponseDTO(Certificacao entity);

    /**
     * Atualiza uma entidade Certificacao existente com os dados de um
     * CertificacaoRequestDTO.
     * O campo 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Certificacao a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(CertificacaoRequestDTO dto, @MappingTarget Certificacao entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;

/**
 * Mapper MapStruct para a entidade Documento e seus DTOs.
 * Gerencia a conversão entre DocumentoUploadRequest, Documento e
 * DocumentoResponseDTO.
 */
@Mapper(componentModel = "spring")
public interface DocumentoMapper {
    DocumentoMapper INSTANCE = Mappers.getMapper(DocumentoMapper.class);

    /**
     * Mapeia um DocumentoUploadRequest para uma entidade Documento.
     * Ignora 'arquivoBase64' e 'mimeType' (dados para upload, não persistentes na
     * entidade).
     * 'urlS3', 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição para upload de documento.
     * @return A entidade Documento correspondente.
     */
    @Mapping(target = "urlS3", ignore = true) // Preenchido após o upload bem-sucedido
    @Mapping(target = "profissional", ignore = true) // Relacionamento com Profissional, preenchido no serviço
    @Mapping(target = "tenantId", ignore = true) // TenantId, preenchido no serviço
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    Documento toEntity(DocumentoUploadRequest dto);

    /**
     * Mapeia uma entidade Documento para um DocumentoResponseDTO.
     *
     * @param entity A entidade Documento.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "tipoDocumento", target = "tipoDocumento") // Mapeamento direto de String para String
    DocumentoResponseDTO toResponseDTO(Documento entity);

    /**
     * Atualiza uma entidade Documento existente com os dados de um
     * DocumentoUploadRequest.
     * Campos ignorados: 'id', 'urlS3', 'profissional', 'tenantId'.
     *
     * @param dto    O DTO de requisição.
     * @param entity A entidade Documento a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "urlS3", ignore = true)
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    void updateEntityFromDto(DocumentoUploadRequest dto, @MappingTarget Documento entity);

    /**
     * Converte um enum DocumentoTipo para sua representação em String.
     * Usado para mapear de DTO (enum) para Entidade (String).
     *
     * @param tipo O enum DocumentoTipo.
     * @return A representação em String do enum.
     */
    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipo) {
        return tipo != null ? tipo.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade ExperienciaProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface ExperienciaProfissionalMapper {
    ExperienciaProfissionalMapper INSTANCE = Mappers.getMapper(ExperienciaProfissionalMapper.class);

    /**
     * Mapeia um ExperienciaProfissionalRequestDTO para uma entidade
     * ExperienciaProfissional.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade ExperienciaProfissional correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    ExperienciaProfissional toEntity(ExperienciaProfissionalRequestDTO dto);

    /**
     * Mapeia uma entidade ExperienciaProfissional para um
     * ExperienciaProfissionalResponseDTO.
     *
     * @param entity A entidade ExperienciaProfissional.
     * @return O DTO de resposta correspondente.
     */
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissional entity);

    /**
     * Atualiza uma entidade ExperienciaProfissional existente com os dados de um
     * ExperienciaProfissionalRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade ExperienciaProfissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(ExperienciaProfissionalRequestDTO dto, @MappingTarget ExperienciaProfissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;

/**
 * Mapper MapStruct para a entidade FormacaoAcademica e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface FormacaoAcademicaMapper {
    FormacaoAcademicaMapper INSTANCE = Mappers.getMapper(FormacaoAcademicaMapper.class);

    /**
     * Mapeia um FormacaoAcademicaRequestDTO para uma entidade FormacaoAcademica.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade FormacaoAcademica correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    FormacaoAcademica toEntity(FormacaoAcademicaRequestDTO dto);

    /**
     * Mapeia uma entidade FormacaoAcademica para um FormacaoAcademicaResponseDTO.
     *
     * @param entity A entidade FormacaoAcademica.
     * @return O DTO de resposta correspondente.
     */
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademica entity);

    /**
     * Atualiza uma entidade FormacaoAcademica existente com os dados de um
     * FormacaoAcademicaRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade FormacaoAcademica a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademica entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;

/**
 * Mapper MapStruct para a entidade Idioma e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface IdiomaMapper {
    IdiomaMapper INSTANCE = Mappers.getMapper(IdiomaMapper.class);

    /**
     * Mapeia uma entidade Idioma para um IdiomaResponseDTO.
     * 
     * @param entity A entidade Idioma.
     * @return O DTO de resposta correspondente.
     */
    IdiomaResponseDTO toResponseDTO(Idioma entity);

    /**
     * Mapeia um IdiomaResponseDTO para uma entidade Idioma.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade Idioma correspondente.
     */
    Idioma toEntity(IdiomaResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade LocalAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface LocalAtuacaoMapper {
    LocalAtuacaoMapper INSTANCE = Mappers.getMapper(LocalAtuacaoMapper.class);

    /**
     * Mapeia uma entidade LocalAtuacao para um LocalAtuacaoResponseDTO.
     * 
     * @param entity A entidade LocalAtuacao.
     * @return O DTO de resposta correspondente.
     */
    LocalAtuacaoResponseDTO toResponseDTO(LocalAtuacao entity);

    /**
     * Mapeia um LocalAtuacaoResponseDTO para uma entidade LocalAtuacao.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade LocalAtuacao correspondente.
     */
    LocalAtuacao toEntity(LocalAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;

/**
 * Mapper MapStruct para a entidade Profissional e seus DTOs de requisição e
 * resposta.
 * Lida com mapeamentos complexos e aninhados, delegando para outros mappers
 * quando necessário.
 */
@Mapper(componentModel = "spring", uses = {
        PessoaMapper.class,
        CertificacaoMapper.class,
        DocumentoMapper.class,
        ExperienciaProfissionalMapper.class,
        FormacaoAcademicaMapper.class,
        RoleProfissionalMapper.class
        // Mappers para AreaAtuacao, Idioma, LocalAtuacao, TipoAtendimento NÃO são
        // usados diretamente aqui
        // para mapear UUIDs para DTOs completos, pois isso é responsabilidade do
        // serviço.
})
public interface ProfissionalMapper {
    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * Mapeia um ProfissionalCreateRequest para uma nova entidade Profissional.
     *
     * @param dto O DTO de requisição para criação.
     * @return A nova entidade Profissional.
     */
    // @Mapping(source = "pessoa.user", target = "usuario") // Mapeia o
    // PessoaRequestDTO (que é 'pessoa') para a superclasse 'usuario'
    @Mapping(target = "id", ignore = true) // ID do Profissional será gerado
    @Mapping(target = "pessoaId", ignore = true) // Será preenchido no serviço após a persistência da Pessoa
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "documentos", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "experiencias", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "formacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    Profissional toEntity(ProfissionalCreateRequest dto);

    /**
     * Atualiza uma entidade Profissional existente com os dados de um
     * ProfissionalUpdateRequest.
     *
     * @param dto    O DTO de requisição para atualização.
     * @param entity A entidade Profissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID da entidade não deve ser alterado pelo DTO
    @Mapping(source = "pessoa.usuario", target = "usuario") // Mapeia o DTO 'pessoa.usuario' para a superclasse
                                                            // 'usuario'
    @Mapping(target = "pessoaId", ignore = true) // Gerenciado pelo sistema
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Gerenciado pelo serviço (criação/atualização/remoção)
    @Mapping(target = "documentos", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "experiencias", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "formacoes", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Gerenciado pelo serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    void updateEntityFromDto(ProfissionalUpdateRequest dto, @MappingTarget Profissional entity);

    /**
     * Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * Campos de dados mestres (locaisAtuacao, areasAtuacao, idiomas,
     * tiposAtendimento)
     * são ignorados aqui e devem ser populados pela camada de serviço,
     * pois a entidade Profissional armazena apenas os IDs dessas relações.
     *
     * @param entity A entidade Profissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "usuario", target = "pessoa") // Mapeia a superclasse 'usuario' para 'pessoa' no DTO
    @Mapping(target = "locaisAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "areasAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "idiomas", ignore = true) // Populado pelo serviço
    @Mapping(target = "tiposAtendimento", ignore = true) // Populado pelo serviço
    @Mapping(source = "roleProfissionals", target = "rolesProfissional") // Mapeia Set<RoleProfissional> para
                                                                         // List<RoleProfissionalResponseDTO>
    ProfissionalResponseDTO toResponseDTO(Profissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.RoleProfissional;
import br.com.legalconnect.advogado.dto.response.RoleProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade RoleProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface RoleProfissionalMapper {
    RoleProfissionalMapper INSTANCE = Mappers.getMapper(RoleProfissionalMapper.class);

    /**
     * Mapeia uma entidade RoleProfissional para um RoleProfissionalResponseDTO.
     * Ignora 'tenantId' na resposta se não for relevante para o frontend.
     *
     * @param entity A entidade RoleProfissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    RoleProfissionalResponseDTO toResponseDTO(RoleProfissional entity);

    /**
     * Mapeia um RoleProfissionalResponseDTO para uma entidade RoleProfissional.
     * 'tenantId' deve ser definido pelo serviço.
     *
     * @param dto O DTO de resposta.
     * @return A entidade RoleProfissional correspondente.
     */
    @Mapping(target = "tenantId", ignore = true)
    RoleProfissional toEntity(RoleProfissionalResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;

/**
 * Mapper MapStruct para a entidade TipoAtendimento e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface TipoAtendimentoMapper {
    TipoAtendimentoMapper INSTANCE = Mappers.getMapper(TipoAtendimentoMapper.class);

    /**
     * Mapeia uma entidade TipoAtendimento para um TipoAtendimentoResponseDTO.
     * 
     * @param entity A entidade TipoAtendimento.
     * @return O DTO de resposta correspondente.
     */
    TipoAtendimentoResponseDTO toResponseDTO(TipoAtendimento entity);

    /**
     * Mapeia um TipoAtendimentoResponseDTO para uma entidade TipoAtendimento.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade TipoAtendimento correspondente.
     */
    TipoAtendimento toEntity(TipoAtendimentoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.AreaAtuacao;

@Repository
public interface AreaAtuacaoRepository extends JpaRepository<AreaAtuacao, UUID> {

    /**
     * Busca uma Área de Atuação pelo nome.
     *
     * @param nome O nome da área de atuação.
     * @return Um Optional contendo a Área de Atuação, se encontrada.
     */
    Optional<AreaAtuacao> findByNome(String nome);

    /**
     * 
     * Busca todas as Áreas de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs das áreas de atuação.
     * 
     * @return Uma lista de Áreas de Atuação.
     */
    List<AreaAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Certificacao;

/**
 * Repositório para a entidade {@link Certificacao}.
 * Gerencia operações de persistência para as certificações de um profissional.
 */
@Repository
public interface CertificacaoRepository extends JpaRepository<Certificacao, UUID> {

    /**
     * Busca uma Certificação pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Certificação, se encontrada.
     */
    Optional<Certificacao> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Certificações de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Certificações.
     */
    List<Certificacao> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Documento;

/**
 * Repositório para a entidade {@link Documento}.
 * Gerencia operações de persistência para os documentos de um profissional.
 */
@Repository
public interface DocumentoRepository extends JpaRepository<Documento, UUID> {

    /**
     * Busca um Documento pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo o Documento, se encontrado.
     */
    Optional<Documento> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todos os Documentos de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Documentos.
     */
    List<Documento> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta um Documento pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

/**
 * Repositório para a entidade {@link ExperienciaProfissional}.
 * Gerencia operações de persistência para as experiências profissionais de um
 * profissional.
 * O método 'save' é automaticamente fornecido por JpaRepository, não deve ser
 * declarado explicitamente aqui com parâmetros extras.
 */
@Repository
public interface ExperienciaProfissionalRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    /**
     * Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional
     * associado.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Experiência Profissional, se encontrada.
     */
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Experiências Profissionais de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Experiências Profissionais.
     */
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);

    // IMPORTANTE: NÃO HÁ MÉTODO 'save' EXPLICITAMENTE DECLARADO AQUI.
    // Ele é herdado de JpaRepository e tem a assinatura: S save(S entity);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

@Repository
public interface ExperienciaRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

/**
 * Repositório para a entidade {@link FormacaoAcademica}.
 * Gerencia operações de persistência para as formações acadêmicas de um
 * profissional.
 */
@Repository
public interface FormacaoAcademicaRepository extends JpaRepository<FormacaoAcademica, UUID> {

    /**
     * Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Formação Acadêmica, se encontrada.
     */
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Formações Acadêmicas de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Formações Acadêmicas.
     */
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

@Repository
public interface FormacaoRepository extends JpaRepository<FormacaoAcademica, UUID> {

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Idioma;

/**
 * Repositório para a entidade {@link Idioma}.
 * Gerencia operações de persistência para os idiomas disponíveis.
 */
@Repository
public interface IdiomaRepository extends JpaRepository<Idioma, UUID> {

    /**
     * Busca um Idioma pelo nome.
     *
     * @param nome O nome do idioma.
     * @return Um Optional contendo o Idioma, se encontrado.
     */
    Optional<Idioma> findByNome(String nome);

    /**
     * Busca todos os Idiomas por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos idiomas.
     * @return Uma lista de Idiomas.
     */
    List<Idioma> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.LocalAtuacao;

/**
 * Repositório para a entidade {@link LocalAtuacao}.
 * Gerencia operações de persistência para os locais de atuação dos
 * profissionais.
 */
@Repository
public interface LocalAtuacaoRepository extends JpaRepository<LocalAtuacao, UUID> {

    /**
     * Busca um Local de Atuação pelo nome.
     *
     * @param nome O nome do local de atuação.
     * @return Um Optional contendo o Local de Atuação, se encontrado.
     */
    Optional<LocalAtuacao> findByNome(String nome);

    /**
     * Busca todos os Locais de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos locais de atuação.
     * @return Uma lista de Locais de Atuação.
     */
    List<LocalAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Profissional;

/**
 * Repositório para a entidade {@link Profissional}.
 * Gerencia operações de persistência para os profissionais (advogados).
 */
@Repository
public interface ProfissionalRepository extends JpaRepository<Profissional, UUID> {

    /**
     * Busca um Profissional pelo número da OAB.
     *
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * Busca todos os Profissionais associados a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de Profissionais.
     */
    Page<Profissional> findAllByTenantId(UUID tenantId, Pageable pageable);

    /**
     * Verifica se um Profissional existe pelo número da OAB.
     * Regra de Negócio: Garante a unicidade do número da OAB.
     *
     * @param numeroOab O número da OAB a ser verificado.
     * @return true se um Profissional com a OAB já existe, false caso contrário.
     */
    boolean existsByNumeroOab(String numeroOab);

    /**
     * Verifica se um Profissional existe pelo ID da pessoa associada.
     *
     * @param pessoaId O ID da pessoa.
     * @return true se um Profissional com o ID da pessoa existe, false caso
     *         contrário.
     */
    boolean existsByPessoaId(UUID pessoaId);

    /**
     * NOVO MÉTODO: Busca todos os estados e cidades (municípios) distintos
     * de todas as Pessoas cadastradas.
     * Retorna uma lista de arrays de objetos, onde cada array contém [estado,
     * cidade].
     *
     * @return Uma lista de Object[] contendo pares [estado, cidade].
     */
    @Query(value = "SELECT DISTINCT e.estado, e.cidade FROM tb_endereco e WHERE e.estado IS NOT NULL AND e.cidade IS NOT NULL ORDER BY e.estado, e.cidade", nativeQuery = true)
    List<Object[]> findDistinctEstadosAndCidades();
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.RoleProfissional;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link RoleProfissional}.
 * Gerencia operações de persistência para os papéis (roles) dos profissionais.
 */
@Repository
public interface RoleProfissionalRepository extends JpaRepository<RoleProfissional, UUID> {

    /**
     * Busca uma Role de Profissional pelo nome.
     *
     * @param name O nome da role.
     * @return Um Optional contendo a RoleProfissional, se encontrada.
     */
    Optional<RoleProfissional> findByName(String name);

    /**
     * Busca todas as Roles de Profissional associadas a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de RoleProfissional.
     */
    List<RoleProfissional> findAllByTenantId(UUID tenantId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.TipoAtendimento;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link TipoAtendimento}.
 * Gerencia operações de persistência para os tipos de atendimento disponíveis.
 */
@Repository
public interface TipoAtendimentoRepository extends JpaRepository<TipoAtendimento, UUID> {

    /**
     * Busca um Tipo de Atendimento pelo nome.
     *
     * @param nome O nome do tipo de atendimento.
     * @return Um Optional contendo o TipoAtendimento, se encontrado.
     */
    Optional<TipoAtendimento> findByNome(String nome);

    /**
     * Busca todos os Tipos de Atendimento por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos tipos de atendimento.
     * @return Uma lista de Tipos de Atendimento.
     */
    List<TipoAtendimento> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.EmailService; // Para enviar e-mails de confirmação
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço responsável pela lógica de agendamento de consultas no Marketplace.
 */
@Slf4j
@Service
public class AgendamentoService {

        private final ProfissionalRepository profissionalRepository;
        private final GoogleCalendarService googleCalendarService;
        private final EmailService emailService;
        // Repositório de agendamentos (assumindo a entidade Agendamento)
        // private final AgendamentoRepository agendamentoRepository;

        @Autowired
        public AgendamentoService(ProfissionalRepository profissionalRepository,
                        GoogleCalendarService googleCalendarService,
                        EmailService emailService) {
                this.profissionalRepository = profissionalRepository;
                this.googleCalendarService = googleCalendarService;
                this.emailService = emailService;
                // this.agendamentoRepository = agendamentoRepository;
        }

        /**
         * Realiza o agendamento de uma consulta entre um cliente e um profissional.
         * Regras de Negócio:
         * - Verifica a disponibilidade do profissional na data/hora solicitada.
         * - Garante que o profissional existe e está ativo no marketplace.
         * - Integra com Google Calendar para adicionar o evento na agenda do
         * profissional.
         * - Envia e-mails de confirmação para cliente e profissional.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta.
         * @param tipoServico        Tipo de serviço agendado.
         * @return Sucesso do agendamento.
         * @throws BusinessException se o profissional não estiver disponível ou outras
         *                           regras de negócio forem violadas.
         */
        @Transactional
        public boolean agendarConsulta(UUID profissionalId, UUID clienteId, LocalDateTime horarioAgendamento,
                        String tipoServico) {
                UUID tenantId = TenantContext.getCurrentTenantId(); // O agendamento ocorre dentro do contexto de um
                                                                    // tenant

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                // Regra de Negócio: Profissional deve estar ativo e usar marketplace
                if (!profissional.getUsaMarketplace() || !profissional.getStatusProfissional().equals("ACTIVE")) { // Assuming
                                                                                                                   // "ACTIVE"
                                                                                                                   // status
                        throw new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE, HttpStatus.BAD_REQUEST,
                                        "Profissional não disponível para agendamento.");
                }

                // Regra de Negócio: Verificar disponibilidade real do profissional (com Google
                // Calendar)
                boolean isAvailable = googleCalendarService.checkAvailability(profissional.getUsuario().getEmail(),
                                horarioAgendamento);
                if (!isAvailable) {
                        throw new BusinessException(ErrorCode.APPOINTMENT_CONFLICT, HttpStatus.CONFLICT,
                                        "Horário indisponível para o profissional.");
                }

                // Regra de Negócio: Criar o registro de agendamento no banco de dados (se
                // houver entidade Agendamento)
                // Agendamento newAppointment = Agendamento.builder()
                // .profissional(profissional)
                // .clienteId(clienteId)
                // .horario(horarioAgendamento)
                // .tipoServico(tipoServico)
                // .tenantId(tenantId)
                // .build();
                // agendamentoRepository.save(newAppointment);

                // Funcionalidade Completa: Adicionar evento ao Google Calendar do profissional
                googleCalendarService.addEvent(
                                profissional.getUsuario().getEmail(),
                                "Consulta: " + tipoServico + " com Cliente " + clienteId, // Supondo que você pode obter
                                                                                          // o nome do
                                                                                          // cliente
                                horarioAgendamento,
                                horarioAgendamento.plusHours(1) // Consulta de 1 hora
                );

                // Funcionalidade Completa: Enviar e-mails de confirmação
                emailService.sendAppointmentConfirmationEmail(
                                profissional.getUsuario().getEmail(),
                                "Você tem uma nova consulta agendada com o cliente " + clienteId + " para "
                                                + horarioAgendamento);
                // emailService.sendAppointmentConfirmationEmail(
                // clienteService.findById(clienteId).getEmail(), // Supondo um clienteService
                // "Sua consulta com " + profissional.getNomeCompleto() + " foi confirmada para
                // " + horarioAgendamento
                // );

                return true;
        }

        /**
         * Simula a avaliação de uma consulta pelo cliente.
         * Regras de Negócio:
         * - Associa a avaliação ao agendamento e ao profissional.
         * - Atualiza a média de avaliação do profissional (lógica simplificada).
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return Sucesso da avaliação.
         */
        @Transactional
        public boolean avaliarConsulta(UUID agendamentoId, UUID clienteId, int rating, String comentario) {
                // Lógica para encontrar o agendamento e associar a avaliação.
                // Agendamento agendamento =
                // agendamentoRepository.findById(agendamentoId).orElseThrow(...)
                // Criar uma entidade Avaliacao.
                // Atualizar a média de avaliação do Profissional.

                // Simulação: Apenas loga a avaliação
                log.info("Cliente {} avaliou agendamento {} com nota {} e comentário: {}", clienteId, agendamentoId,
                                rating,
                                comentario);

                // Para fins de demonstração, vamos considerar um sucesso
                return true;
        }

        // Outras funcionalidades como reagendamento, cancelamento, busca de
        // agendamentos
        // seriam implementadas aqui.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Áreas de Atuação (dados mestre).
 * Essas entidades são consideradas globais ou de um tenant específico da
 * plataforma,
 * mas para este módulo, o acesso é simplificado como dados mestre.
 */
@Service
public class AreaAtuacaoService {

    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;

    @Autowired
    public AreaAtuacaoService(AreaAtuacaoRepository areaAtuacaoRepository, AreaAtuacaoMapper areaAtuacaoMapper) {
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
    }

    /**
     * Busca uma Área de Atuação pelo ID.
     *
     * @param id ID da Área de Atuação.
     * @return DTO da Área de Atuação.
     * @throws BusinessException se a Área de Atuação não for encontrada.
     */
    public AreaAtuacaoResponseDTO findAreaAtuacaoById(UUID id) {
        AreaAtuacao areaAtuacao = areaAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Área de Atuação não encontrada."));
        return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
    }

    /**
     * Lista todas as Áreas de Atuação.
     *
     * @return Lista de DTOs de Áreas de Atuação.
     */
    public List<AreaAtuacaoResponseDTO> findAllAreasAtuacao() {
        return areaAtuacaoRepository.findAll().stream()
                .map(areaAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para criar, atualizar e deletar podem ser adicionados
    // se essas entidades mestre forem gerenciáveis via API
    // Por exemplo, por um ADMIN da plataforma.
    // Ex:
    /*
     * @Transactional
     * public AreaAtuacaoResponseDTO createAreaAtuacao(AreaAtuacaoRequestDTO
     * requestDTO) {
     * if (areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * AreaAtuacao areaAtuacao = areaAtuacaoMapper.toEntity(requestDTO);
     * areaAtuacao = areaAtuacaoRepository.save(areaAtuacao);
     * return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
     * }
     * 
     * @Transactional
     * public AreaAtuacaoResponseDTO updateAreaAtuacao(UUID id,
     * AreaAtuacaoRequestDTO requestDTO) {
     * AreaAtuacao existing = areaAtuacaoRepository.findById(id)
     * .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada."));
     * if (!existing.getNome().equalsIgnoreCase(requestDTO.getNome()) &&
     * areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * areaAtuacaoMapper.updateEntityFromDto(requestDTO, existing); // Supondo um
     * updateEntityFromDto no mapper
     * existing = areaAtuacaoRepository.save(existing);
     * return areaAtuacaoMapper.toResponseDTO(existing);
     * }
     * 
     * @Transactional
     * public void deleteAreaAtuacao(UUID id) {
     * if (!areaAtuacaoRepository.existsById(id)) {
     * throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada para deleção.");
     * }
     * // Regra de Negócio: Verificar se está em uso por algum Profissional antes de
     * deletar
     * // if (profissionalRepository.existsByAreaAtuacaoId(id)) { ... }
     * areaAtuacaoRepository.deleteById(id);
     * }
     */
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das certificações de um Profissional.
 * Este serviço é granular e pode ser usado para operações diretas em
 * certificações,
 * embora o ProfissionalService orquestre a maioria.
 */
@Service
public class CertificacaoService {

    private final CertificacaoRepository certificacaoRepository;
    private final CertificacaoMapper certificacaoMapper;
    private final ProfissionalRepository profissionalRepository;

    @Autowired
    public CertificacaoService(CertificacaoRepository certificacaoRepository,
            CertificacaoMapper certificacaoMapper,
            ProfissionalRepository profissionalRepository) {
        this.certificacaoRepository = certificacaoRepository;
        this.certificacaoMapper = certificacaoMapper;
        this.profissionalRepository = profissionalRepository;
    }

    /**
     * Cria uma nova certificação para um profissional específico.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - A certificação é associada ao profissional e ao tenant.
     *
     * @param profissionalId ID do profissional.
     * @param requestDTO     DTO com os dados da certificação.
     * @return DTO da certificação criada.
     */
    @Transactional
    public CertificacaoResponseDTO createCertificacao(UUID profissionalId, CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        Certificacao certificacao = certificacaoMapper.toEntity(requestDTO);
        certificacao.setProfissional(profissional);
        certificacao.setTenantId(tenantId);

        certificacao = certificacaoRepository.save(certificacao); // profissionalId é passado para o
                                                                  // save no repositório customizado
        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Atualiza uma certificação existente de um profissional.
     * Regras de Negócio:
     * - A certificação deve existir e pertencer ao profissional e tenant corretos.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @param requestDTO     DTO com os dados para atualização.
     * @return DTO da certificação atualizada.
     */
    @Transactional
    public CertificacaoResponseDTO updateCertificacao(UUID profissionalId, UUID certificacaoId,
            CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant ou profissional.");
        }

        certificacaoMapper.updateEntityFromDto(requestDTO, existingCertificacao);
        existingCertificacao = certificacaoRepository.save(existingCertificacao);
        return certificacaoMapper.toResponseDTO(existingCertificacao);
    }

    /**
     * Busca uma certificação pelo ID do profissional e da certificação.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @return DTO da certificação.
     */
    public CertificacaoResponseDTO findCertificacaoById(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao certificacao = certificacaoRepository.findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!certificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Lista todas as certificações de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de certificações.
     */
    public List<CertificacaoResponseDTO> findAllCertificacoesByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se o profissional existe e pertence ao tenant
        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return certificacaoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(certificacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta uma certificação de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação a ser deletada.
     */
    @Transactional
    public void deleteCertificacao(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se a certificação existe e pertence ao profissional e tenant
        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para deleção."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        certificacaoRepository.deleteByIdAndProfissionalId(certificacaoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.Base64; // Para decodificar Base64
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.S3Service;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão de documentos de um Profissional.
 * Inclui o upload de arquivos para o S3 e o armazenamento dos metadados no
 * banco de dados.
 */
@Service
public class DocumentoService {

    private final DocumentoRepository documentoRepository;
    private final DocumentoMapper documentoMapper;
    private final ProfissionalRepository profissionalRepository;
    private final S3Service s3Service; // Serviço para integração com S3

    @Autowired
    public DocumentoService(DocumentoRepository documentoRepository,
            DocumentoMapper documentoMapper,
            ProfissionalRepository profissionalRepository,
            S3Service s3Service) {
        this.documentoRepository = documentoRepository;
        this.documentoMapper = documentoMapper;
        this.profissionalRepository = profissionalRepository;
        this.s3Service = s3Service;
    }

    /**
     * Realiza o upload de um documento para o S3 e persiste seus metadados.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - O conteúdo do arquivo em Base64 é decodificado e enviado ao S3.
     * - A URL do S3 é armazenada no banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param request        DTO com os dados do documento e o arquivo em Base64.
     * @return DTO do documento criado.
     * @throws BusinessException em caso de falha no upload ou se o profissional não
     *                           for encontrado.
     */
    @Transactional
    public DocumentoResponseDTO uploadDocumento(UUID profissionalId, DocumentoUploadRequest request) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para upload de documento."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Decodificar Base64 e fazer upload para S3
        byte[] fileBytes;
        try {
            fileBytes = Base64.getDecoder().decode(request.getArquivoBase64());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.INVALID_DOCUMENT_FORMAT, HttpStatus.BAD_REQUEST,
                    "Conteúdo do arquivo em Base64 inválido.");
        }

        String s3Key = "profissionais/" + profissionalId + "/documentos/" + UUID.randomUUID() + "/"
                + request.getNomeArquivo();
        String fileUrl = s3Service.uploadFile(fileBytes, s3Key, request.getMimeType());

        if (fileUrl == null) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao fazer upload do documento para o S3.");
        }

        Documento documento = documentoMapper.toEntity(request);
        documento.setUrlS3(fileUrl);
        documento.setProfissional(profissional);
        documento.setTenantId(tenantId);

        documento = documentoRepository.save(documento);
        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Busca um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento deve pertencer ao profissional e ao tenant correto.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento.
     * @return DTO do documento encontrado.
     * @throws BusinessException se o documento não for encontrado.
     */
    public DocumentoResponseDTO findDocumentoById(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento documento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para este profissional."));

        if (!documento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant ou profissional.");
        }

        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Lista todos os documentos de um profissional.
     * Regras de Negócio:
     * - Apenas documentos do tenant atual são retornados.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de documentos.
     */
    public List<DocumentoResponseDTO> findAllDocumentosByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return documentoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(documentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento é removido do S3 antes de ser deletado do banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento a ser deletado.
     * @throws BusinessException se o documento não for encontrado ou falha na
     *                           deleção do S3.
     */
    @Transactional
    public void deleteDocumento(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento existingDocumento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para deleção."));

        if (!existingDocumento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant.");
        }

        // Deletar do S3 primeiro
        try {
            s3Service.deleteFile(existingDocumento.getUrlS3());
        } catch (Exception e) {
            throw new BusinessException(ErrorCode.ERRO_INTERNO_SERVIDOR, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao deletar o documento do S3: " + e.getMessage());
        }

        documentoRepository.deleteByIdAndProfissionalId(documentoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das experiências profissionais de um
 * Profissional.
 */
@Service
public class ExperienciaProfissionalService {

        private final ExperienciaRepository experienciaRepository;
        private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public ExperienciaProfissionalService(ExperienciaRepository experienciaRepository,
                        ExperienciaProfissionalMapper experienciaProfissionalMapper,
                        ProfissionalRepository profissionalRepository) {
                this.experienciaRepository = experienciaRepository;
                this.experienciaProfissionalMapper = experienciaProfissionalMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova experiência profissional para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A experiência é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da experiência.
         * @return DTO da experiência criada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO createExperienciaProfissional(UUID profissionalId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                ExperienciaProfissional experiencia = experienciaProfissionalMapper.toEntity(requestDTO);
                experiencia.setProfissional(profissional);
                experiencia.setTenantId(tenantId);

                experiencia = experienciaRepository.save(experiencia);
                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Atualiza uma experiência profissional existente de um profissional.
         * Regras de Negócio:
         * - A experiência deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da experiência atualizada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO updateExperienciaProfissional(UUID profissionalId, UUID experienciaId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant ou profissional.");
                }

                experienciaProfissionalMapper.updateEntityFromDto(requestDTO, existingExperiencia);
                existingExperiencia = experienciaRepository.save(existingExperiencia);
                return experienciaProfissionalMapper.toResponseDTO(existingExperiencia);
        }

        /**
         * Busca uma experiência profissional pelo ID do profissional e da experiência.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return DTO da experiência.
         */
        public ExperienciaProfissionalResponseDTO findExperienciaProfissionalById(UUID profissionalId,
                        UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional experiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!experiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de experiências.
         */
        public List<ExperienciaProfissionalResponseDTO> findAllExperienciasProfissionaisByProfissionalId(
                        UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return experienciaRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(experienciaProfissionalMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência a ser deletada.
         */
        @Transactional
        public void deleteExperienciaProfissional(UUID profissionalId, UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para deleção."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                experienciaRepository.deleteByIdAndProfissionalId(experienciaId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das formações acadêmicas de um Profissional.
 */
@Service
public class FormacaoAcademicaService {

        private final FormacaoRepository formacaoRepository;
        private final FormacaoAcademicaMapper formacaoAcademicaMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public FormacaoAcademicaService(FormacaoRepository formacaoRepository,
                        FormacaoAcademicaMapper formacaoAcademicaMapper,
                        ProfissionalRepository profissionalRepository) {
                this.formacaoRepository = formacaoRepository;
                this.formacaoAcademicaMapper = formacaoAcademicaMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova formação acadêmica para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A formação é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da formação.
         * @return DTO da formação criada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO createFormacaoAcademica(UUID profissionalId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                FormacaoAcademica formacao = formacaoAcademicaMapper.toEntity(requestDTO);
                formacao.setProfissional(profissional);
                formacao.setTenantId(tenantId);

                formacao = formacaoRepository.save(formacao);
                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Atualiza uma formação acadêmica existente de um profissional.
         * Regras de Negócio:
         * - A formação deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da formação atualizada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO updateFormacaoAcademica(UUID profissionalId, UUID formacaoId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant ou profissional.");
                }

                formacaoAcademicaMapper.updateEntityFromDto(requestDTO, existingFormacao);
                existingFormacao = formacaoRepository.save(existingFormacao);
                return formacaoAcademicaMapper.toResponseDTO(existingFormacao);
        }

        /**
         * Busca uma formação acadêmica pelo ID do profissional e da formação.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return DTO da formação.
         */
        public FormacaoAcademicaResponseDTO findFormacaoAcademicaById(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica formacao = formacaoRepository.findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!formacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de formações.
         */
        public List<FormacaoAcademicaResponseDTO> findAllFormacoesAcademicasByProfissionalId(UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return formacaoRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(formacaoAcademicaMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação a ser deletada.
         */
        @Transactional
        public void deleteFormacaoAcademica(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para deleção."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                formacaoRepository.deleteByIdAndProfissionalId(formacaoId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço de integração simulada com a Google Calendar API.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a
 * Google Calendar API
 * utilizando as credenciais OAuth2 do aplicativo.
 */
@Service
public class GoogleCalendarService {

    private static final Logger log = LoggerFactory.getLogger(GoogleCalendarService.class);

    /**
     * Simula a adição de um evento à agenda do Google Calendar de um usuário.
     *
     * @param userEmail    O e-mail do usuário cuja agenda será atualizada.
     * @param eventSummary O título do evento.
     * @param startTime    A data e hora de início do evento.
     * @param endTime      A data e hora de fim do evento.
     * @return true se o evento foi "adicionado" com sucesso, false caso contrário.
     */
    public boolean addEvent(String userEmail, String eventSummary, LocalDateTime startTime, LocalDateTime endTime) {
        log.info("Simulando adição de evento ao Google Calendar para {}:", userEmail);
        log.info("  Sumário: {}", eventSummary);
        log.info("  Início: {}", startTime);
        log.info("  Fim: {}", endTime);
        // Lógica real de integração com Google Calendar API seria aqui, por exemplo:
        // Event event = new Event()
        // .setSummary(eventSummary)
        // .setDescription("Agendamento via LegalConnect");
        // DateTime startDateTime = new DateTime(startTime.toString());
        // EventDateTime start = new
        // EventDateTime().setDateTime(startDateTime).setTimeZone("America/Sao_Paulo");
        // event.setStart(start);
        // ...
        // Calendar service = new Calendar.Builder(...).build();
        // service.events().insert(userEmail, event).execute();
        log.info("Evento simulado adicionado com sucesso ao Google Calendar.");
        return true;
    }

    /**
     * Simula a verificação de disponibilidade na agenda do Google Calendar de um
     * usuário.
     *
     * @param userEmail    O e-mail do usuário.
     * @param proposedTime O horário a ser verificado.
     * @return true se o horário estiver disponível, false caso contrário.
     */
    public boolean checkAvailability(String userEmail, LocalDateTime proposedTime) {
        log.info("Simulando verificação de disponibilidade para {} no horário {}", userEmail, proposedTime);
        // Em um cenário real, você consultaria a API do Google Calendar para Free/Busy
        // Por simplicidade, vamos simular que o horário está sempre disponível, a menos
        // que seja um horário "proibido"
        if (proposedTime.getHour() == 13) { // Exemplo de regra de negócio: almoço indisponível
            log.info("Horário indisponível (simulado).");
            return false;
        }
        log.info("Horário disponível (simulado).");
        return true;
    }

    // Outros métodos como updateEvent, deleteEvent, listEvents podem ser
    // adicionados.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Idiomas (dados mestre).
 */
@Service
public class IdiomaService {

    private final IdiomaRepository idiomaRepository;
    private final IdiomaMapper idiomaMapper;

    @Autowired
    public IdiomaService(IdiomaRepository idiomaRepository, IdiomaMapper idiomaMapper) {
        this.idiomaRepository = idiomaRepository;
        this.idiomaMapper = idiomaMapper;
    }

    /**
     * Busca um Idioma pelo ID.
     *
     * @param id ID do Idioma.
     * @return DTO do Idioma.
     * @throws BusinessException se o Idioma não for encontrado.
     */
    public IdiomaResponseDTO findIdiomaById(UUID id) {
        Idioma idioma = idiomaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Idioma não encontrado."));
        return idiomaMapper.toResponseDTO(idioma);
    }

    /**
     * Lista todos os Idiomas.
     *
     * @return Lista de DTOs de Idiomas.
     */
    public List<IdiomaResponseDTO> findAllIdiomas() {
        return idiomaRepository.findAll().stream()
                .map(idiomaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Locais de Atuação (dados mestre).
 */
@Service
public class LocalAtuacaoService {

    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final LocalAtuacaoMapper localAtuacaoMapper;

    @Autowired
    public LocalAtuacaoService(LocalAtuacaoRepository localAtuacaoRepository, LocalAtuacaoMapper localAtuacaoMapper) {
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.localAtuacaoMapper = localAtuacaoMapper;
    }

    /**
     * Busca um Local de Atuação pelo ID.
     *
     * @param id ID do Local de Atuação.
     * @return DTO do Local de Atuação.
     * @throws BusinessException se o Local de Atuação não for encontrado.
     */
    public LocalAtuacaoResponseDTO findLocalAtuacaoById(UUID id) {
        LocalAtuacao localAtuacao = localAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Local de Atuação não encontrado."));
        return localAtuacaoMapper.toResponseDTO(localAtuacao);
    }

    /**
     * Lista todos os Locais de Atuação.
     *
     * @return Lista de DTOs de Locais de Atuação.
     */
    public List<LocalAtuacaoResponseDTO> findAllLocaisAtuacao() {
        return localAtuacaoRepository.findAll().stream()
                .map(localAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import org.springframework.stereotype.Service;

// Assumindo a existência dessas classes de DTO, Entidade e Repositório
// import br.com.legalconnect.office.application.dto.request.ProcessoRequestDTO;
// import br.com.legalconnect.office.application.dto.response.ProcessoResponseDTO;
// import br.com.legalconnect.office.domain.modal.entity.Processo;
// import br.com.legalconnect.office.domain.repository.ProcessoRepository;
// import br.com.legalconnect.office.application.mapper.ProcessoMapper;

/**
 * Serviço responsável pela gestão de Processos Judiciais e Administrativos no
 * módulo de Gestão de Escritório.
 */
@Service
public class ProcessoService {

    // private final ProcessoRepository processoRepository;
    // private final ProcessoMapper processoMapper;
    // private final AIService aiService; // Para geração de petições com IA
    // private final S3Service s3Service; // Para anexos de documentos

    // @Autowired
    // public ProcessoService(ProcessoRepository processoRepository,
    // ProcessoMapper processoMapper,
    // AIService aiService,
    // S3Service s3Service) {
    // this.processoRepository = processoRepository;
    // this.processoMapper = processoMapper;
    // this.aiService = aiService;
    // this.s3Service = s3Service;
    // }

    /**
     * Cria um novo processo judicial ou administrativo.
     * Regras de Negócio:
     * - Associa o processo ao tenant atual.
     * - Define o status inicial do processo.
     *
     * @param requestDTO DTO com os dados do processo.
     * @return DTO do processo criado.
     */
    // @Transactional
    // public ProcessoResponseDTO createProcesso(ProcessoRequestDTO requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoMapper.toEntity(requestDTO);
    // processo.setTenantId(tenantId);
    // processo.setStatus("INICIADO"); // Regra de Negócio: Status inicial
    //
    // processo = processoRepository.save(processo);
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Atualiza um processo existente.
     * Regras de Negócio:
     * - O processo deve existir e pertencer ao tenant atual.
     *
     * @param id         ID do processo.
     * @param requestDTO DTO com os dados para atualização.
     * @return DTO do processo atualizado.
     */
    // @Transactional
    // public ProcessoResponseDTO updateProcesso(UUID id, ProcessoRequestDTO
    // requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // processoMapper.updateEntityFromDto(requestDTO, existingProcesso);
    // existingProcesso = processoRepository.save(existingProcesso);
    // return processoMapper.toResponseDTO(existingProcesso);
    // }

    /**
     * Busca um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo.
     * @return DTO do processo.
     */
    // public ProcessoResponseDTO findProcessoById(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Lista todos os processos de um tenant.
     *
     * @return Lista de DTOs de processos.
     */
    // public List<ProcessoResponseDTO> findAllProcessos() {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // return processoRepository.findAllByTenantId(tenantId).stream()
    // .map(processoMapper::toResponseDTO)
    // .collect(Collectors.toList());
    // }

    /**
     * Deleta um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo a ser deletado.
     */
    // @Transactional
    // public void deleteProcesso(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para deleção."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Regra de Negócio: Verificar se o processo pode ser deletado (ex: não tem
    // atividades pendentes)
    // // if (hasPendingActivities(existingProcesso)) {
    // // throw new BusinessException(ErrorCode.RECURSO_EM_USO, HttpStatus.CONFLICT,
    // "Processo possui atividades pendentes e não pode ser deletado.");
    // // }
    //
    // processoRepository.deleteById(id);
    // }

    /**
     * Gera um rascunho de petição utilizando IA (OpenAI GPT).
     * Regras de Negócio:
     * - O profissional deve ter permissão e estar em um plano que suporte IA.
     * - A IA gera um texto baseado nas informações do processo.
     *
     * @param processoId ID do processo para o qual a petição será gerada.
     * @param prompt     Instruções adicionais para a IA.
     * @return O rascunho da petição gerado pela IA.
     */
    // public String generatePeticaoWithAI(UUID processoId, String prompt) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    // // Verifica se o usuário logado tem permissão e plano para usar IA
    // // Profissional profissional =
    // profissionalService.findProfissionalById(userIdFromSecurityContext);
    // // if (!profissional.getPlano().supportsAI()) { ... }
    //
    // Processo processo = processoRepository.findById(processoId)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para geração de petição."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Montar o prompt completo para a IA com base nos dados do processo
    // String fullPrompt = String.format("Crie um rascunho de petição para o
    // processo '%s' (Tipo: %s, Partes: %s). Contexto: %s. %s",
    // processo.getNumero(), processo.getTipo(), processo.getPartes(),
    // processo.getDescricao(), prompt);
    //
    // // Chamada ao serviço de IA
    // String generatedText = aiService.generateText(fullPrompt);
    //
    // return generatedText;
    // }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.ProfissionalMapper;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.service.PessoaService;
import br.com.legalconnect.commom.service.S3Service; // Assumindo S3Service para upload de documentos
import br.com.legalconnect.commom.service.TenantContext; // Assumindo TenantContext para multitenancy
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão completa do Profissional (Advogado).
 * Inclui operações de CRUD, validações de negócio e orquestração com serviços
 * de entidades aninhadas
 * e dados mestre. Gerencia também o upload de documentos e a associação com o
 * tenant.
 */
@Service
public class ProfissionalService {

    private final ProfissionalRepository profissionalRepository;
    private final ProfissionalMapper profissionalMapper;
    private final PessoaService pessoaService; // Para gerenciar a entidade Pessoa
    private final CertificacaoMapper certificacaoMapper;
    private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
    private final FormacaoAcademicaMapper formacaoAcademicaMapper;
    private final DocumentoMapper documentoMapper;
    private final CertificacaoRepository certificacaoRepository;
    private final ExperienciaRepository experienciaRepository;
    private final FormacaoRepository formacaoRepository;
    private final DocumentoRepository documentoRepository;
    private final S3Service s3Service; // Serviço para integração com S3
    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final IdiomaRepository idiomaRepository;
    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;
    private final IdiomaMapper idiomaMapper;
    private final LocalAtuacaoMapper localAtuacaoMapper;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public ProfissionalService(ProfissionalRepository profissionalRepository,
            ProfissionalMapper profissionalMapper,
            PessoaService pessoaService,
            CertificacaoMapper certificacaoMapper,
            ExperienciaProfissionalMapper experienciaProfissionalMapper,
            FormacaoAcademicaMapper formacaoAcademicaMapper,
            DocumentoMapper documentoMapper,
            CertificacaoRepository certificacaoRepository,
            ExperienciaRepository experienciaRepository,
            FormacaoRepository formacaoRepository,
            DocumentoRepository documentoRepository,
            S3Service s3Service,
            AreaAtuacaoRepository areaAtuacaoRepository,
            IdiomaRepository idiomaRepository,
            LocalAtuacaoRepository localAtuacaoRepository,
            TipoAtendimentoRepository tipoAtendimentoRepository,
            AreaAtuacaoMapper areaAtuacaoMapper,
            IdiomaMapper idiomaMapper,
            LocalAtuacaoMapper localAtuacaoMapper,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.profissionalRepository = profissionalRepository;
        this.profissionalMapper = profissionalMapper;
        this.pessoaService = pessoaService;
        this.certificacaoMapper = certificacaoMapper;
        this.experienciaProfissionalMapper = experienciaProfissionalMapper;
        this.formacaoAcademicaMapper = formacaoAcademicaMapper;
        this.documentoMapper = documentoMapper;
        this.certificacaoRepository = certificacaoRepository;
        this.experienciaRepository = experienciaRepository;
        this.formacaoRepository = formacaoRepository;
        this.documentoRepository = documentoRepository;
        this.s3Service = s3Service;
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.idiomaRepository = idiomaRepository;
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
        this.idiomaMapper = idiomaMapper;
        this.localAtuacaoMapper = localAtuacaoMapper;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Cria um novo Profissional no sistema.
     * Regras de Negócio:
     * - Valida a unicidade do número da OAB.
     * - Associa o Profissional a um Tenant (obtido do contexto de segurança).
     * - Cria a entidade Pessoa associada através do PessoaService.
     * - Gerencia a criação de certificações, experiências e formações aninhadas.
     * - Define o status inicial do profissional.
     * - Valida a existência do plano.
     *
     * @param createRequest DTO com os dados para criação do Profissional.
     * @return DTO do Profissional criado.
     * @throws BusinessException se a OAB já estiver cadastrada, ou se o
     *                           plano/tenant não existirem.
     */
    @Transactional
    public ProfissionalResponseDTO createProfissional(ProfissionalCreateRequest createRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo que o tenantId vem do contexto de segurança

        // Regra de Negócio: Validar unicidade da OAB
        if (profissionalRepository.existsByNumeroOab(createRequest.getNumeroOab())) {
            throw new BusinessException(ErrorCode.OAB_DUPLICADA, HttpStatus.CONFLICT, createRequest.getNumeroOab());
        }

        // Regra de Negócio: Validar unicidade da Pessoa (CPF/Email) antes de criar o
        // Profissional
        if (pessoaService.findPessoaByCpf(createRequest.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, createRequest.getCpf());
        }
        if (pessoaService.findPessoaByEmail(createRequest.getUsuario().getEmail()).isPresent()) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    createRequest.getUsuario().getEmail());
        }

        // Criar a Pessoa associada primeiro, pois Profissional estende Pessoa
        PessoaRequestDTO pessoaRequestDTO = new PessoaRequestDTO();
        pessoaRequestDTO.setUsuario(createRequest.getUsuario());
        pessoaRequestDTO.setNomeCompleto(createRequest.getNomeCompleto());
        pessoaRequestDTO.setCpf(createRequest.getCpf());
        pessoaRequestDTO.setDataNascimento(createRequest.getDataNascimento());
        pessoaRequestDTO.setTelefones(createRequest.getTelefones());
        pessoaRequestDTO.setEnderecos(createRequest.getEnderecos());

        Pessoa newPessoa = pessoaService.createPessoa(pessoaRequestDTO);

        // Regra de Negócio: Validar que o planoId existe (assumindo um PlanoService ou
        // repositório de Plano)
        // if (!planoService.existsById(createRequest.getPlanoId())) {
        // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
        // HttpStatus.NOT_FOUND);
        // }

        Profissional profissional = profissionalMapper.toEntity(createRequest);
        profissional.setPessoaId(newPessoa.getId()); // Associa o ID da Pessoa recém-criada
        profissional.setUsuario(newPessoa.getUsuario()); // Garante que o usuário de Pessoa esteja associado
        profissional.setTenantId(tenantId); // Regra de Negócio: Define o tenant do profissional
        profissional.setStatusProfissional("PENDING_APPROVAL"); // Regra de Negócio: Status inicial

        // Relacionamentos muitos-para-muitos (apenas IDs aqui)
        if (createRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            profissional.setLocaisAtuacaoIds(createRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            profissional.setAreaAtuacaoIds(createRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(createRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            profissional.setIdiomaIds(createRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(createRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            profissional
                    .setTipoAtendimentoIds(createRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        profissional = profissionalRepository.save(profissional);

        // Gerenciar certificações, experiências e formações
        manageNestedEntities(profissional, createRequest);

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Atualiza um Profissional existente.
     * Regras de Negócio:
     * - Valida a existência do Profissional e do Tenant.
     * - Permite a atualização de dados da Pessoa associada.
     * - Gerencia a adição, atualização e remoção de certificações, experiências e
     * formações.
     * - Atualiza relacionamentos com dados mestre.
     *
     * @param id            ID do Profissional a ser atualizado.
     * @param updateRequest DTO com os dados para atualização.
     * @return DTO do Profissional atualizado.
     * @throws BusinessException se o Profissional não for encontrado, ou por outras
     *                           violações de negócio.
     */
    @Transactional
    public ProfissionalResponseDTO updateProfissional(UUID id, ProfissionalUpdateRequest updateRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo tenantId do contexto de segurança

        Profissional existingProfissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para atualização."));

        // Regra de Negócio: O profissional só pode ser atualizado pelo seu próprio
        // tenant
        if (!existingProfissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Atualiza os dados da Pessoa associada (se fornecidos)
        if (updateRequest.getPessoa() != null) {
            pessoaService.updatePessoa(existingProfissional.getPessoaId(), updateRequest.getPessoa());
        }

        // Mapeia os campos atualizáveis para a entidade Profissional
        profissionalMapper.updateEntityFromDto(updateRequest, existingProfissional);

        // Regra de Negócio: Validar que o planoId existe se for alterado
        if (updateRequest.getPlanoId() != null
                && !existingProfissional.getPlanoId().equals(updateRequest.getPlanoId())) {
            // if (!planoService.existsById(updateRequest.getPlanoId())) {
            // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
            // HttpStatus.NOT_FOUND);
            // }
            existingProfissional.setPlanoId(updateRequest.getPlanoId());
        }

        // Atualiza relacionamentos muitos-para-muitos
        if (updateRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            existingProfissional
                    .setLocaisAtuacaoIds(updateRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            existingProfissional
                    .setAreaAtuacaoIds(updateRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(updateRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            existingProfissional.setIdiomaIds(updateRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(updateRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            existingProfissional
                    .setTipoAtendimentoIds(updateRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        // Gerenciar coleções aninhadas (certificações, experiências, formações)
        manageNestedEntities(existingProfissional, updateRequest);

        existingProfissional = profissionalRepository.save(existingProfissional);
        return mapToResponseDTOWithDetails(existingProfissional);
    }

    /**
     * Busca um Profissional pelo ID.
     * Regras de Negócio:
     * - Garante que o Profissional pertence ao Tenant do contexto de segurança.
     * - Popula os dados mestre relacionados.
     *
     * @param id ID do Profissional.
     * @return DTO do Profissional com detalhes.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    public ProfissionalResponseDTO findProfissionalById(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Busca todos os Profissionais de um determinado Tenant com paginação.
     *
     * @param pageable Objeto Pageable contendo informações de paginação e
     *                 ordenação.
     * @return Página de DTOs de Profissionais.
     */
    public Page<ProfissionalResponseDTO> findAllProfissionais(Pageable pageable) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Filtra por tenant

        Page<Profissional> profissionaisPage = profissionalRepository.findAllByTenantId(tenantId, pageable);
        return profissionaisPage.map(this::mapToResponseDTOWithDetails);
    }

    /**
     * Deleta um Profissional pelo ID.
     * Regras de Negócio:
     * - Apenas o proprietário do tenant pode deletar.
     * - Orquestra a deleção de entidades aninhadas (Certificações, Experiências,
     * Formações, Documentos).
     * - Deleção da Pessoa associada.
     *
     * @param id ID do Profissional a ser deletado.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    @Transactional
    public void deleteProfissional(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para deleção."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Deleta entidades aninhadas (cascade pode fazer isso, mas explicitar é bom
        // para clareza)
        certificacaoRepository.findAllByProfissionalId(id)
                .forEach(c -> certificacaoRepository.deleteByIdAndProfissionalId(c.getId(), id));
        experienciaRepository.findAllByProfissionalId(id)
                .forEach(e -> experienciaRepository.deleteByIdAndProfissionalId(e.getId(), id));
        formacaoRepository.findAllByProfissionalId(id)
                .forEach(f -> formacaoRepository.deleteByIdAndProfissionalId(f.getId(), id));
        documentoRepository.findAllByProfissionalId(id).forEach(d -> {
            s3Service.deleteFile(d.getUrlS3()); // Deleta arquivo do S3
            documentoRepository.deleteByIdAndProfissionalId(d.getId(), id);
        });

        // Deleta o profissional
        profissionalRepository.deleteById(id);

        // Deleta a pessoa associada
        pessoaService.deletePessoa(profissional.getPessoaId());
    }

    /**
     * Método auxiliar para gerenciar a adição, atualização e remoção de entidades
     * aninhadas
     * (certificações, experiências, formações) para um Profissional.
     *
     * @param profissional O Profissional pai.
     * @param request      O DTO de requisição (Create ou Update) contendo as listas
     *                     aninhadas.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalCreateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Remover certificações que não estão mais no DTO
            profissional.getCertificacoes().removeIf(existingCert -> request.getCertificacoes().stream()
                    .noneMatch(dto -> existingCert.getId().equals(dto.getId())));
            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        }

        // Experiências Profissionais
        if (request.getExperiencias() != null) {
            profissional.getExperiencias().removeIf(existingExp -> request.getExperiencias().stream()
                    .noneMatch(dto -> existingExp.getId().equals(dto.getId())));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) { // Nova experiência
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else { // Atualizar experiência existente
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        }

        // Formações Acadêmicas
        if (request.getFormacoes() != null) {
            profissional.getFormacoes().removeIf(existingForm -> request.getFormacoes().stream()
                    .noneMatch(dto -> existingForm.getId().equals(dto.getId())));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova formação
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else { // Atualizar formação existente
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        }
    }

    /**
     * Sobrecarga para o método de gerenciamento de entidades aninhadas para
     * ProfissionalUpdateRequest.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalUpdateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Coleta IDs das certificações no DTO para identificar as que serão removidas
            Set<UUID> dtoCertIds = request.getCertificacoes().stream()
                    .map(c -> c.getId())
                    .collect(Collectors.toSet());

            // Remove certificações que existem na entidade mas não no DTO (deleção)
            profissional.getCertificacoes().removeIf(
                    existingCert -> existingCert.getId() != null && !dtoCertIds.contains(existingCert.getId()));

            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação (ID nulo indica novo)
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId() != null && c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        } else {
            // Se a lista no DTO for nula, assume-se que todas as certificações devem ser
            // removidas
            profissional.getCertificacoes().clear();
        }

        // Experiências Profissionais (lógica similar às certificações)
        if (request.getExperiencias() != null) {
            Set<UUID> dtoExpIds = request.getExperiencias().stream()
                    .map(e -> e.getId())
                    .collect(Collectors.toSet());
            profissional.getExperiencias()
                    .removeIf(existingExp -> existingExp.getId() != null && !dtoExpIds.contains(existingExp.getId()));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) {
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else {
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId() != null && e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        } else {
            profissional.getExperiencias().clear();
        }

        // Formações Acadêmicas (lógica similar às certificações)
        if (request.getFormacoes() != null) {
            Set<UUID> dtoFormIds = request.getFormacoes().stream()
                    .map(f -> f.getId())
                    .collect(Collectors.toSet());
            profissional.getFormacoes().removeIf(
                    existingForm -> existingForm.getId() != null && !dtoFormIds.contains(existingForm.getId()));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) {
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else {
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId() != null && f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        } else {
            profissional.getFormacoes().clear();
        }
    }

    /**
     * Mapeia um Profissional para ProfissionalResponseDTO e popula os dados mestre
     * relacionados.
     * Esta é uma funcionalidade completa para apresentar o perfil do advogado.
     *
     * @param profissional A entidade Profissional.
     * @return O DTO de resposta detalhado.
     */
    private ProfissionalResponseDTO mapToResponseDTOWithDetails(Profissional profissional) {
        ProfissionalResponseDTO responseDTO = profissionalMapper.toResponseDTO(profissional);

        // Popula listas de DTOs de dados mestre
        responseDTO.setLocaisAtuacao(
                localAtuacaoRepository.findAllById(profissional.getLocaisAtuacaoIds())
                        .stream()
                        .map(localAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setAreasAtuacao(
                areaAtuacaoRepository.findAllById(profissional.getAreaAtuacaoIds())
                        .stream()
                        .map(areaAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setIdiomas(
                idiomaRepository.findAllById(profissional.getIdiomaIds())
                        .stream()
                        .map(idiomaMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setTiposAtendimento(
                tipoAtendimentoRepository.findAllById(profissional.getTipoAtendimentoIds())
                        .stream()
                        .map(tipoAtendimentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Popula as coleções aninhadas
        responseDTO.setCertificacoes(
                profissional.getCertificacoes().stream()
                        .map(certificacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setDocumentos(
                profissional.getDocumentos().stream()
                        .map(documentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setExperiencias(
                profissional.getExperiencias().stream()
                        .map(experienciaProfissionalMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setFormacoes(
                profissional.getFormacoes().stream()
                        .map(formacaoAcademicaMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Define se faz parte de plano com base no planoId (regra de negócio)
        responseDTO.setFazParteDePlano(profissional.getPlanoId() != null); // Simplificado

        return responseDTO;
    }

    /**
     * Valida a existência de entidades de dados mestre.
     *
     * @param ids        Lista de UUIDs a serem validados.
     * @param finder     Função para encontrar a entidade por ID.
     * @param entityName Nome da entidade para mensagens de erro.
     * @param <T>        Tipo da entidade.
     */
    private <T> void validateMasterDataExistence(List<UUID> ids,
            java.util.function.Function<UUID, java.util.Optional<T>> finder, String entityName) {
        for (UUID id : ids) {
            if (finder.apply(id).isEmpty()) {
                throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        entityName + " com ID " + id + " não encontrado(a).");
            }
        }
    }

    public Map<String, List<String>> listarLocalizacoesDisponiveis() {
        List<Object[]> resultados = profissionalRepository.findDistinctEstadosAndCidades();
        Map<String, List<String>> localizacoes = new HashMap<>();

        for (Object[] row : resultados) {
            String estado = (String) row[0];
            String cidade = (String) row[1];
            localizacoes.computeIfAbsent(estado, k -> new ArrayList<>()).add(cidade);
        }
        return localizacoes;
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Tipos de Atendimento (dados mestre).
 */
@Service
public class TipoAtendimentoService {

    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public TipoAtendimentoService(TipoAtendimentoRepository tipoAtendimentoRepository,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Busca um Tipo de Atendimento pelo ID.
     *
     * @param id ID do Tipo de Atendimento.
     * @return DTO do Tipo de Atendimento.
     * @throws BusinessException se o Tipo de Atendimento não for encontrado.
     */
    public TipoAtendimentoResponseDTO findTipoAtendimentoById(UUID id) {
        TipoAtendimento tipoAtendimento = tipoAtendimentoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Tipo de Atendimento não encontrado."));
        return tipoAtendimentoMapper.toResponseDTO(tipoAtendimento);
    }

    /**
     * Lista todos os Tipos de Atendimento.
     *
     * @return Lista de DTOs de Tipos de Atendimento.
     */
    public List<TipoAtendimentoResponseDTO> findAllTiposAtendimento() {
        return tipoAtendimentoRepository.findAll().stream()
                .map(tipoAtendimentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.commom.dto.request; // Assumindo um pacote common.dto.request para entidades comuns

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private String id; // Pode ser UUID ou String, dependendo da BaseEntity

    @NotBlank(message = "O logradouro é obrigatório.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número é obrigatório.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro é obrigatório.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade é obrigatória.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado é obrigatório.")
    @Size(max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP é obrigatório.")
    @Size(max = 9, message = "O CEP deve ter no máximo 9 caracteres.") // Com ou sem máscara
    private String cep;

    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais; // Valor padrão "Brasil" pode ser setado no serviço

    @NotNull(message = "O tipo de endereço é obrigatório.")
    private TipoEndereco tipoEndereco; // Usando o enum da entidade
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * DTO para requisição de criação ou atualização de uma Pessoa.
 * Inclui campos de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // ID é opcional para atualização (usado em PUT/put para identificar a Pessoa)
    private UUID id;

    @Valid
    @NotNull(message = "As informações do usuário são obrigatórias.")
    private UserRequestDTO usuario; // Informações de login e contato do usuário

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpf;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimento;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefones;

    @Valid
    private List<EnderecoRequestDTO> enderecos; // Lista de endereços associados à pessoa
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    // @NotBlank(message = "A senha do usuário é obrigatória.") // Pode ser
    // @NotBlank apenas na criação
    private String senha; // Em requisições, a senha é enviada em texto limpo para ser hashed no backend

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 14, message = "O CPF deve ter no máximo 14 caracteres.")
    private String cpf; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response; // Assumindo um pacote common.dto.response para entidades comuns

import java.util.UUID;

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;

    private String logradouro;

    private String numero;

    private String complemento;

    private String bairro;

    private String cidade;

    private String estado;

    private String cep;

    private String pais;

    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de uma Pessoa.
 * Inclui informações de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PessoaResponseDTO {
    private UUID id;

    private UserResponseDTO usuario;

    private String nomeCompleto;

    private String cpf;

    private LocalDate dataNascimento;

    private List<String> telefones;

    private List<EnderecoResponseDTO> enderecos;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.commom.model.User.UserStatus; // Importar o enum UserStatus da entidade User
import br.com.legalconnect.commom.model.User.UserType; // Importar o enum UserType da entidade User
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
package br.com.legalconnect.commom.mapper;

import java.util.UUID;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.EnderecoRequestDTO;
import br.com.legalconnect.commom.dto.response.EnderecoResponseDTO;
import br.com.legalconnect.commom.model.Endereco;

/**
 * Mapper MapStruct para a entidade Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {
    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * Mapeia um EnderecoRequestDTO para uma entidade Endereco.
     * Os campos 'pessoa' e 'empresa' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Endereco correspondente.
     */
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true) // Descomente se Empresa for
    // relevante e existir
    @Mapping(target = "id", source = "id", qualifiedByName = "mapStringToUuid")
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * Mapeia uma entidade Endereco para um EnderecoResponseDTO.
     *
     * @param entity A entidade Endereco.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id", qualifiedByName = "mapUuidToString")
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * Atualiza uma entidade Endereco existente com os dados de um
     * EnderecoRequestDTO.
     * O campo 'pessoa' e 'empresa' não são atualizados via DTO. O ID não deve ser
     * atualizado.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Endereco a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true)
    void updateEntityFromDto(EnderecoRequestDTO dto, @MappingTarget Endereco entity);

    /**
     * Converte uma String (ID do DTO) para um UUID (ID da Entidade).
     * 
     * @param id A string representando o UUID.
     * @return O objeto UUID.
     */
    @Named("mapStringToUuid")
    default UUID mapStringToUuid(UUID id) {
        return id != null ? (id) : null;
    }

    /**
     * Converte um UUID (ID da Entidade) para uma String (ID do DTO).
     * 
     * @param id O objeto UUID.
     * @return A string representando o UUID.
     */
    @Named("mapUuidToString")
    default String mapUuidToString(UUID id) {
        return id != null ? id.toString() : null;
    }
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.model.Pessoa;

/**
 * Mapper MapStruct para a entidade Pessoa e seus DTOs.
 * Utiliza UserMapper e EnderecoMapper para mapeamentos aninhados.
 */
@Mapper(componentModel = "spring", uses = { UserMapper.class, EnderecoMapper.class })
public interface PessoaMapper {
    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * Mapeia um PessoaRequestDTO para uma entidade Pessoa.
     * Os campos 'usuario' e 'enderecos' serão mapeados pelos mappers especificados
     * em 'uses'.
     * A conversão de List para Set para 'telefones' é feita automaticamente pelo
     * MapStruct.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Pessoa correspondente.
     */
    // @Mapping(target = "id", ignore = true) // ID da Pessoa será gerado na criação
    // Pessoa toEntity(PessoaRequestDTO dto);

    /**
     * Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     *
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta correspondente.
     */
    PessoaResponseDTO toResponseDTO(Pessoa entity);

    /**
     * Atualiza uma entidade Pessoa existente com os dados de um PessoaRequestDTO.
     * O 'id' da Pessoa não deve ser atualizado.
     * A atualização de 'usuario' e 'enderecos' deve ser orquestrada no serviço,
     * pois o MapStruct pode não ter o contexto para atualizar entidades aninhadas
     * existentes.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Pessoa a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "usuario", ignore = true) // O serviço deve gerenciar a atualização do User associado
    @Mapping(target = "enderecos", ignore = true) // O serviço deve gerenciar a atualização dos Enderecos associados
    @Mapping(source = "telefones", target = "telefones") // Converte List<String> para Set<String>
    void updateEntityFromDto(PessoaRequestDTO dto, @MappingTarget Pessoa entity);
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.UserResponseDTO;
import br.com.legalconnect.commom.model.User;

/**
 * Mapper MapStruct para a entidade User e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * Mapeia um UserRequestDTO para uma entidade User.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' são definidos pela lógica de negócio e ignorados
     * aqui.
     *
     * @param dto O DTO de requisição.
     * @return A entidade User correspondente.
     */
    @Mapping(source = "senha", target = "senhaHash") // Mapeia a senha do DTO para senhaHash na entidade
    // @Mapping(target = "userType", ignore = true) // Definido pela lógica de
    // negócio
    // @Mapping(target = "userStatus", ignore = true) // Definido pela lógica de
    // negócio
    User toEntity(UserRequestDTO dto);

    /**
     * Mapeia uma entidade User para um UserResponseDTO.
     * 'senhaHash' é ignorado na resposta por segurança.
     *
     * @param entity A entidade User.
     * @return O DTO de resposta correspondente.
     */
    // @Mapping(target = "senha", ignore = true) // 'senhaHash' é um campo interno
    // da entidade, não deve ser exposto no DTO de resposta
    UserResponseDTO toResponseDTO(User entity);

    /**
     * Atualiza uma entidade User existente com os dados de um UserRequestDTO.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade User a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(source = "senha", target = "senhaHash")
    // @Mapping(target = "userType", ignore = true)
    // @Mapping(target = "userStatus", ignore = true)
    void updateEntityFromDto(UserRequestDTO dto, @MappingTarget User entity);
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "empresa_id")
    // private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.commom.model;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.Pessoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Pessoa}.
 * Gerencia operações de persistência para informações de pessoas no sistema.
 */
@Repository
public interface PessoaRepository extends JpaRepository<Pessoa, UUID> {

    /**
     * Verifica se existe uma Pessoa com o CPF fornecido.
     * Regra de Negócio: Garante a unicidade do CPF no sistema.
     *
     * @param cpf O CPF a ser verificado.
     * @return true se uma Pessoa com o CPF já existe, false caso contrário.
     */
    boolean existsByCpf(String cpf);

    /**
     * Busca uma Pessoa pelo ID do usuário associado.
     *
     * @param userId O ID do usuário.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByUsuarioId(UUID userId);

    /**
     * Busca uma Pessoa pelo CPF.
     *
     * @param cpf O CPF da Pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu endereço de e-mail.
     * Regra de Negócio: O e-mail é único para cada usuário dentro de um tenant.
     *
     * @param email O endereço de e-mail do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * Verifica se um usuário com o endereço de e-mail fornecido já existe.
     * Regra de Negócio: Garante a unicidade do e-mail no sistema.
     *
     * @param email O endereço de e-mail a ser verificado.
     * @return true se um usuário com o e-mail já existe, false caso contrário.
     */
    boolean existsByEmail(String email);
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço simulado para envio de e-mails.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com um provedor de e-mails
 * como SendGrid, Amazon SES, ou o serviço de e-mail do Spring Boot.
 */
@Service
public class EmailService {

    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    /**
     * Simula o envio de um e-mail de ativação de conta.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param activationLink O link de ativação da conta.
     */
    public void sendActivationEmail(String toEmail, String activationLink) {
        log.info("Simulando envio de e-mail de ativação para: {}", toEmail);
        log.info("Link de Ativação: {}", activationLink);
        // Lógica real de envio de e-mail seria aqui, por exemplo:
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(toEmail);
        // helper.setSubject("Ative sua conta na LegalConnect!");
        // helper.setText("Olá! Clique no link para ativar sua conta: " + activationLink, true);
        // mailSender.send(message);
        log.info("E-mail de ativação simulado enviado com sucesso.");
    }

    /**
     * Simula o envio de um e-mail de confirmação de agendamento.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param details Detalhes do agendamento.
     */
    public void sendAppointmentConfirmationEmail(String toEmail, String details) {
        log.info("Simulando envio de e-mail de confirmação de agendamento para: {}", toEmail);
        log.info("Detalhes do Agendamento: {}", details);
        log.info("E-mail de confirmação de agendamento simulado enviado com sucesso.");
    }

    // Outros métodos de envio de e-mail podem ser adicionados conforme a necessidade
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;
import br.com.legalconnect.commom.mapper.UserMapper;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.model.User;
import br.com.legalconnect.commom.repository.PessoaRepository; // Assumindo a existência de PessoaRepository
import br.com.legalconnect.commom.repository.UserRepository; // Assumindo a existência de UserRepository
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das entidades Pessoa e User.
 * Centraliza a lógica de negócio para criação, atualização e busca de Pessoas
 * e seus usuários associados, incluindo validações de unicidade e criptografia
 * de senha.
 */
@Service
public class PessoaService {

    private final PessoaRepository pessoaRepository;
    private final UserRepository userRepository;
    private final PessoaMapper pessoaMapper;
    private final UserMapper userMapper;
    // Assumindo um EnderecoMapper se EnderecoRequestDTO for mapeado para Endereco
    // aqui
    // private final EnderecoMapper enderecoMapper;

    @Autowired
    public PessoaService(PessoaRepository pessoaRepository, UserRepository userRepository,
            PessoaMapper pessoaMapper, UserMapper userMapper) {
        this.pessoaRepository = pessoaRepository;
        this.userRepository = userRepository;
        this.pessoaMapper = pessoaMapper;
        this.userMapper = userMapper;
    }

    /**
     * Cria uma nova Pessoa e seu User associado.
     * Regras de Negócio:
     * - Garante que o CPF e o e-mail do usuário sejam únicos no sistema.
     * - Criptografa a senha antes de salvar.
     * - Define o status inicial do usuário como PENDING para aguardar ativação.
     *
     * @param pessoaRequestDTO DTO com os dados da Pessoa e do User.
     * @return DTO da Pessoa criada.
     * @throws BusinessException se o CPF ou e-mail já estiverem cadastrados.
     */
    @Transactional
    public Pessoa createPessoa(PessoaRequestDTO pessoaRequestDTO) {
        // Regra de Negócio: Validar unicidade de CPF
        if (pessoaRepository.existsByCpf(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, pessoaRequestDTO.getCpf());
        }

        // Regra de Negócio: Validar unicidade de e-mail para o usuário
        if (userRepository.existsByEmail(pessoaRequestDTO.getUsuario().getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    pessoaRequestDTO.getUsuario().getEmail());
        }

        // Cria e criptografa o usuário

        // Persiste o usuário
        var newUser = new User();
        newUser.setId((pessoaRequestDTO.getUsuario().getId()));

        // Cria a Pessoa e associa o usuário
        Pessoa newPessoa = Pessoa.builder()
                .usuario(newUser)
                .nomeCompleto(pessoaRequestDTO.getNomeCompleto())
                .cpf(pessoaRequestDTO.getCpf())
                .dataNascimento(pessoaRequestDTO.getDataNascimento())
                .telefones(new HashSet<>(pessoaRequestDTO.getTelefones()))
                .build();

        // Adiciona endereços
        if (pessoaRequestDTO.getEnderecos() != null && !pessoaRequestDTO.getEnderecos().isEmpty()) {
            Set<Endereco> enderecos = pessoaRequestDTO.getEnderecos().stream()
                    .map(dto -> {
                        Endereco endereco = new Endereco(); // Ou use enderecoMapper.toEntity(dto) se existir
                        endereco.setLogradouro(dto.getLogradouro());
                        endereco.setNumero(dto.getNumero());
                        endereco.setComplemento(dto.getComplemento());
                        endereco.setBairro(dto.getBairro());
                        endereco.setCidade(dto.getCidade());
                        endereco.setEstado(dto.getEstado());
                        endereco.setCep(dto.getCep());
                        endereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil"); // Define país padrão
                        endereco.setTipoEndereco(dto.getTipoEndereco());
                        endereco.setPessoa(newPessoa); // Associa o endereço à Pessoa
                        return endereco;
                    }).collect(Collectors.toSet());
            newPessoa.setEnderecos(enderecos);
        }
        // Reassigning to make it effectively final
        return (pessoaRepository.save(newPessoa));
    }

    /**
     * Busca uma Pessoa pelo ID.
     *
     * @param id ID da Pessoa.
     * @return DTO da Pessoa encontrada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    public PessoaResponseDTO findPessoaById(UUID id) {
        Pessoa pessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * Atualiza os dados de uma Pessoa existente.
     * Regras de Negócio:
     * - Permite a atualização de informações da Pessoa e do User associado.
     * - Valida a unicidade do e-mail se for alterado.
     * - Não permite a alteração do CPF.
     *
     * @param id               ID da Pessoa a ser atualizada.
     * @param pessoaRequestDTO DTO com os dados para atualização.
     * @return DTO da Pessoa atualizada.
     * @throws BusinessException se a Pessoa não for encontrada, ou se o e-mail já
     *                           estiver cadastrado.
     */
    @Transactional
    public PessoaResponseDTO updatePessoa(UUID id, PessoaRequestDTO pessoaRequestDTO) {
        Pessoa existingPessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada para atualização."));

        // Não permitir alteração de CPF (Regra de Negócio)
        if (!existingPessoa.getCpf().equals(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "Não é permitido alterar o CPF de uma pessoa existente.");
        }

        // Atualiza o User associado
        User existingUser = existingPessoa.getUsuario();
        UserRequestDTO userRequestDTO = pessoaRequestDTO.getUsuario();

        // Valida unicidade de e-mail se o e-mail for alterado
        if (!existingUser.getEmail().equals(userRequestDTO.getEmail())
                && userRepository.existsByEmail(userRequestDTO.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT, userRequestDTO.getEmail());
        }

        userMapper.updateEntityFromDto(userRequestDTO, existingUser);
        userRepository.save(existingUser); // Salva as alterações no User

        // Atualiza os dados da Pessoa (exceto usuário e endereços que são gerenciados
        // separadamente)
        pessoaMapper.updateEntityFromDto(pessoaRequestDTO, existingPessoa);

        // Lógica para gerenciar Endereços: Adicionar, Atualizar, Remover
        // Isso pode ser complexo e requer lógica manual, pois EndereçoRequestDTO tem ID
        // opcional
        // Para simplificar, vou redefinir os endereços ou adicionar lógica de
        // diferenciação.
        // Uma abordagem mais robusta seria comparar listas e fazer operações de CRUD
        // individualmente.
        if (pessoaRequestDTO.getEnderecos() != null) {
            // Removendo endereços que não estão no DTO
            existingPessoa.getEnderecos().removeIf(existingEndereco -> pessoaRequestDTO.getEnderecos().stream()
                    .noneMatch(dto -> dto.getId() != null && dto.getId().equals(existingEndereco.getId().toString())));

            // Adicionando ou atualizando endereços
            for (br.com.legalconnect.commom.dto.request.EnderecoRequestDTO dto : pessoaRequestDTO.getEnderecos()) {
                if (dto.getId() == null) {
                    // Novo endereço
                    Endereco newEndereco = new Endereco();
                    newEndereco.setLogradouro(dto.getLogradouro());
                    newEndereco.setNumero(dto.getNumero());
                    newEndereco.setComplemento(dto.getComplemento());
                    newEndereco.setBairro(dto.getBairro());
                    newEndereco.setCidade(dto.getCidade());
                    newEndereco.setEstado(dto.getEstado());
                    newEndereco.setCep(dto.getCep());
                    newEndereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                    newEndereco.setTipoEndereco(dto.getTipoEndereco());
                    newEndereco.setPessoa(existingPessoa);
                    existingPessoa.getEnderecos().add(newEndereco);
                } else {
                    // Atualizar endereço existente
                    existingPessoa.getEnderecos().stream()
                            .filter(e -> e.getId().toString().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> {
                                e.setLogradouro(dto.getLogradouro());
                                e.setNumero(dto.getNumero());
                                e.setComplemento(dto.getComplemento());
                                e.setBairro(dto.getBairro());
                                e.setCidade(dto.getCidade());
                                e.setEstado(dto.getEstado());
                                e.setCep(dto.getCep());
                                e.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                                e.setTipoEndereco(dto.getTipoEndereco());
                            });
                }
            }
        }

        existingPessoa = pessoaRepository.save(existingPessoa);
        return pessoaMapper.toResponseDTO(existingPessoa);
    }

    /**
     * Deleta uma Pessoa pelo ID.
     * Regras de Negócio:
     * - Também deleta o User associado devido ao CascadeType.ALL na Pessoa.
     *
     * @param id ID da Pessoa a ser deletada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    @Transactional
    public void deletePessoa(UUID id) {
        if (!pessoaRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                    "Pessoa não encontrada para deleção.");
        }
        pessoaRepository.deleteById(id);
    }

    public Optional<LocalAtuacao> findPessoaByCpf(String cpf) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByCpf'");
    }

    public Optional<LocalAtuacao> findPessoaByEmail(String email) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByEmail'");
    }
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço de integração simulada com AWS S3 para upload e deleção de arquivos.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a AWS
 * SDK.
 */
@Service
public class S3Service {

    private static final Logger log = LoggerFactory.getLogger(S3Service.class);
    private static final String MOCK_S3_BASE_URL = "https://mock-s3-bucket.s3.amazonaws.com/";

    /**
     * Simula o upload de um arquivo para o S3.
     *
     * @param fileBytes Os bytes do arquivo.
     * @param key       A chave/caminho do arquivo no bucket S3.
     * @param mimeType  O tipo MIME do arquivo.
     * @return A URL pública do arquivo no S3.
     * @throws BusinessException se ocorrer um erro durante o "upload" simulado.
     */
    public String uploadFile(byte[] fileBytes, String key, String mimeType) {
        if (fileBytes == null || fileBytes.length == 0) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "O conteúdo do arquivo não pode ser vazio.");
        }
        if (key == null || key.isEmpty()) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "A chave do S3 não pode ser vazia.");
        }

        // Simulação de upload: Loga a operação e retorna uma URL mock
        log.info("Simulando upload para S3. Chave: {}, Tamanho: {} bytes, Tipo: {}", key, fileBytes.length, mimeType);
        String fileUrl = MOCK_S3_BASE_URL + key;
        log.info("Upload simulado concluído. URL: {}", fileUrl);
        return fileUrl;
    }

    /**
     * Simula a deleção de um arquivo do S3.
     *
     * @param fileUrl A URL pública do arquivo a ser deletado.
     * @throws BusinessException se ocorrer um erro durante a "deleção" simulada.
     */
    public void deleteFile(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "URL do arquivo não pode ser vazia para deleção.");
        }

        // Simulação de deleção: Loga a operação
        log.info("Simulando deleção de S3. URL: {}", fileUrl);
        // Em um ambiente real, aqui estaria a chamada para o AWS S3 SDK para deletar o
        // objeto.
        // Por exemplo: s3Client.deleteObject(bucketName, key);
        log.info("Deleção simulada concluída para URL: {}", fileUrl);
    }
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.UUID;

/**
 * Utilitário para gerenciar o ID do Tenant no contexto da thread atual.
 * Usado em arquiteturas multitenant para garantir que as operações de banco de dados
 * sejam filtradas pelo tenant correto.
 */
public class TenantContext {

    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();

    /**
     * Define o ID do Tenant para a thread atual.
     *
     * @param tenantId O ID do Tenant.
     */
    public static void setCurrentTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }

    /**
     * Retorna o ID do Tenant da thread atual.
     *
     * @return O ID do Tenant.
     * @throws IllegalStateException se o Tenant ID não estiver definido no contexto.
     */
    public static UUID getCurrentTenantId() {
        UUID tenantId = currentTenant.get();
        if (tenantId == null) {
            // Em um ambiente real, você pode lançar uma exceção ou retornar um tenant padrão
            // dependendo da lógica de segurança e acesso.
            // Por simplicidade para este exercício, lançaremos uma exceção.
            throw new IllegalStateException("Tenant ID não está definido no contexto da requisição. Verifique o filtro de segurança.");
        }
        return tenantId;
    }

    /**
     * Limpa o ID do Tenant da thread atual.
     * Deve ser chamado ao final da requisição para evitar vazamentos de contexto.
     */
    public static void clear() {
        currentTenant.remove();
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-advogados
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

 
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
package br.com.legalconnect.legal_usuario;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LegalUsuarioApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(basePackages = {
		"br.com.legalconnect.advogado.repository",
		"br.com.legalconnect.commom.repository" })
@EntityScan(basePackages = {
		"br.com.legalconnect.commom.model",
		"br.com.legalconnect.advogado.domain" })
@EnableDiscoveryClient
@SpringBootApplication
public class LegalUsuarioApplication {
	// @Value("${application.tenant.default-id}")
	// private String defaultTenantId;

	// @Autowired
	// private TenantMigrationService tenantMigrationService;

	public static void main(String[] args) {
		SpringApplication.run(LegalUsuarioApplication.class, args);
	}
}
// @Bean
// boolean inicio() {
// tenantMigrationService.migrateTenant(defaultTenantId);
// return true;
// }
// }

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.ERRO;
import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.service.AgendamentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.NotNull;

/**
 * Controller para o módulo de Agendamento de Consultas.
 * Gerencia as operações relacionadas ao agendamento e avaliação de consultas
 * entre clientes e profissionais.
 */
@RestController
@RequestMapping("/api/v1/advogados/agendamentos")
@Tag(name = "Agendamentos", description = "Gerenciamento de agendamentos de consultas e avaliações")
public class AgendamentoController {

        private final AgendamentoService agendamentoService;

        @Autowired
        public AgendamentoController(AgendamentoService agendamentoService) {
                this.agendamentoService = agendamentoService;
        }

        /**
         * Realiza o agendamento de uma consulta.
         * Funcionalidade Completa: Cenário 1 (Cliente busca e agenda) e Cenário 2
         * (Advogado recebe e confirma).
         * Regras de Negócio: Verifica disponibilidade do profissional, profissional
         * deve estar ativo e usar marketplace, integração com Google Calendar, envio de
         * e-mails.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta (formato ISO).
         * @param tipoServico        Tipo de serviço agendado.
         * @return ResponseEntity indicando o sucesso do agendamento.
         */
        @Operation(summary = "Agenda uma nova consulta", description = "Permite a um cliente agendar uma consulta com um profissional, verificando disponibilidade e enviando notificações.", responses = {
                        @ApiResponse(responseCode = "201", description = "Consulta agendada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: horário indisponível)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de agendamento (horário já ocupado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/agendar")
        public ResponseEntity<BaseResponse<Boolean>> agendarConsulta(
                        @Parameter(description = "ID do profissional para o agendamento") @RequestParam @NotNull UUID profissionalId,
                        @Parameter(description = "ID do cliente que está agendando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Horário desejado para a consulta (formato ISO 8601, ex: 2024-07-25T10:00:00)") @RequestParam @NotNull @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime horarioAgendamento,
                        @Parameter(description = "Tipo de serviço a ser agendado (ex: 'Consulta Online', 'Reunião Presencial')") @RequestParam @NotNull String tipoServico) {

                boolean sucesso = agendamentoService.agendarConsulta(profissionalId, clienteId, horarioAgendamento,
                                tipoServico);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Boolean>builder()
                                                .status(SUCESSO)
                                                .message("Consulta agendada com sucesso.")
                                                .data(sucesso)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Permite ao cliente avaliar uma consulta.
         * Funcionalidade Completa: Cenário 3 (Cliente avalia e influencia ranking).
         * Regras de Negócio: Associa avaliação ao agendamento e profissional, atualiza
         * média de avaliação.
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return ResponseEntity indicando o sucesso da avaliação.
         */
        @Operation(summary = "Avalia uma consulta", description = "Permite a um cliente fornecer uma nota e um comentário para uma consulta já realizada.", responses = {
                        @ApiResponse(responseCode = "200", description = "Consulta avaliada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: nota fora do intervalo)"),
                        @ApiResponse(responseCode = "404", description = "Agendamento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/avaliar")
        public ResponseEntity<BaseResponse<Boolean>> avaliarConsulta(
                        @Parameter(description = "ID do agendamento a ser avaliado") @RequestParam @NotNull UUID agendamentoId,
                        @Parameter(description = "ID do cliente que está avaliando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Nota da avaliação (1 a 5)") @RequestParam @NotNull int rating,
                        @Parameter(description = "Comentário opcional sobre a avaliação") @RequestParam(required = false) String comentario) {

                // Regra de Negócio: Rating deve estar entre 1 e 5
                if (rating < 1 || rating > 5) {
                        return ResponseEntity.badRequest().body(BaseResponse.<Boolean>builder()
                                        .status(ERRO)
                                        .message("A nota da avaliação deve ser entre 1 e 5.")
                                        .data(false)
                                        .timestamp(java.time.LocalDateTime.now())
                                        .build());
                }

                boolean sucesso = agendamentoService.avaliarConsulta(agendamentoId, clienteId, rating, comentario);
                return ResponseEntity.ok(BaseResponse.<Boolean>builder()
                                .status(SUCESSO)
                                .message("Consulta avaliada com sucesso.")
                                .data(sucesso)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Áreas de Atuação (dados mestre).
 * Oferece endpoints para consultar as áreas de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/areas-atuacao")
@Tag(name = "Áreas de Atuação", description = "Gerenciamento de dados mestre de Áreas de Atuação")
public class AreaAtuacaoController {

        private final AreaAtuacaoService areaAtuacaoService;

        @Autowired
        public AreaAtuacaoController(AreaAtuacaoService areaAtuacaoService) {
                this.areaAtuacaoService = areaAtuacaoService;
        }

        /**
         * Busca uma Área de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID da Área de Atuação.
         * @return ResponseEntity com o DTO da Área de Atuação.
         */
        @Operation(summary = "Busca uma área de atuação pelo ID", description = "Retorna os detalhes de uma área de atuação específica.", responses = {
                        @ApiResponse(responseCode = "200", description = "Área de Atuação encontrada com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Área de Atuação não encontrada"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<AreaAtuacaoResponseDTO>> getAreaAtuacaoById(
                        @Parameter(description = "ID da Área de Atuação") @PathVariable UUID id) {
                AreaAtuacaoResponseDTO response = areaAtuacaoService.findAreaAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<AreaAtuacaoResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Área de Atuação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.service.IdiomaService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Idiomas (dados mestre).
 * Oferece endpoints para consultar os idiomas disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/idiomas")
@Tag(name = "Idiomas", description = "Gerenciamento de dados mestre de Idiomas")
public class IdiomaController {

        private final IdiomaService idiomaService;

        @Autowired
        public IdiomaController(IdiomaService idiomaService) {
                this.idiomaService = idiomaService;
        }

        /**
         * Busca um Idioma pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Idioma.
         * @return ResponseEntity com o DTO do Idioma.
         */
        @Operation(summary = "Busca um idioma pelo ID", description = "Retorna os detalhes de um idioma específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idioma encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Idioma não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<IdiomaResponseDTO>> getIdiomaById(
                        @Parameter(description = "ID do idioma") @PathVariable UUID id) {
                IdiomaResponseDTO response = idiomaService.findIdiomaById(id);
                return ResponseEntity.ok(BaseResponse.<IdiomaResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idioma encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Idiomas.
         * Funcionalidade Completa: Listagem de todos os idiomas disponíveis para
         * seleção pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Idiomas.
         */
        @Operation(summary = "Lista todos os idiomas", description = "Retorna uma lista de todos os idiomas cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idiomas listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<IdiomaResponseDTO>>> getAllIdiomas() {
                List<IdiomaResponseDTO> response = idiomaService.findAllIdiomas();
                return ResponseEntity.ok(BaseResponse.<List<IdiomaResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idiomas listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.LocalAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Locais de Atuação (dados mestre).
 * Oferece endpoints para consultar os locais de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/locais-atuacao")
@Tag(name = "Locais de Atuação", description = "Gerenciamento de dados mestre de Locais de Atuação")
public class LocalAtuacaoController {

        private final LocalAtuacaoService localAtuacaoService;

        @Autowired
        public LocalAtuacaoController(LocalAtuacaoService localAtuacaoService) {
                this.localAtuacaoService = localAtuacaoService;
        }

        /**
         * Busca um Local de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Local de Atuação.
         * @return ResponseEntity com o DTO do Local de Atuação.
         */
        @Operation(summary = "Busca um local de atuação pelo ID", description = "Retorna os detalhes de um local de atuação específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Local de Atuação encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Local de Atuação não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<LocalAtuacaoResponseDTO>> getLocalAtuacaoById(
                        @Parameter(description = "ID do Local de Atuação") @PathVariable UUID id) {
                LocalAtuacaoResponseDTO response = localAtuacaoService.findLocalAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<LocalAtuacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Local de Atuação encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Locais de Atuação.
         * Funcionalidade Completa: Listagem de todos os locais disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Locais de Atuação.
         */
        @Operation(summary = "Lista todos os locais de atuação", description = "Retorna uma lista de todos os locais de atuação cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Locais de Atuação listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<LocalAtuacaoResponseDTO>>> getAllLocaisAtuacao() {
                List<LocalAtuacaoResponseDTO> response = localAtuacaoService.findAllLocaisAtuacao();
                return ResponseEntity.ok(BaseResponse.<List<LocalAtuacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Locais de Atuação listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.service.CertificacaoService;
import br.com.legalconnect.advogado.service.DocumentoService;
import br.com.legalconnect.advogado.service.ExperienciaProfissionalService;
import br.com.legalconnect.advogado.service.FormacaoAcademicaService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * Controller para o módulo de Profissionais (Advogados).
 * Gerencia as operações REST para perfis de advogados,
 * incluindo suas certificações, experiências, formações e documentos.
 */
@RestController
@RequestMapping("/api/v1/advogados/profissionais")
@Tag(name = "Profissionais", description = "Gerenciamento de perfis de Advogados")
public class ProfissionalController {

        private final ProfissionalService profissionalService;
        private final CertificacaoService certificacaoService;
        private final ExperienciaProfissionalService experienciaProfissionalService;
        private final FormacaoAcademicaService formacaoAcademicaService;
        private final DocumentoService documentoService;

        @Autowired
        public ProfissionalController(ProfissionalService profissionalService,
                        CertificacaoService certificacaoService,
                        ExperienciaProfissionalService experienciaProfissionalService,
                        FormacaoAcademicaService formacaoAcademicaService,
                        DocumentoService documentoService) {
                this.profissionalService = profissionalService;
                this.certificacaoService = certificacaoService;
                this.experienciaProfissionalService = experienciaProfissionalService;
                this.formacaoAcademicaService = formacaoAcademicaService;
                this.documentoService = documentoService;
        }

        // ***************************************

        /**
         * Lista todas as localizações (estados e cidades) onde há profissionais.
         * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
         * cidades.
         *
         * @return ResponseEntity com o mapa de localizações.
         */
        @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/localizacoes")
        public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
                Map<String, List<String>> response = profissionalService.listarLocalizacoesDisponiveis();

                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Map<String, List<String>>>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        // ************************************************ */
        /**
         * Cria um novo profissional (advogado) no sistema.
         * Funcionalidade Completa: Cadastro de Advogado com dados aninhados.
         * Regras de Negócio: Validação de unicidade de OAB, CPF e Email. Associação a
         * um tenant.
         *
         * @param request      DTO com os dados do profissional a ser criado.
         * @param userIdHeader Opcional. ID do usuário logado/solicitante, vindo do
         *                     cabeçalho X-Correlation-Id.
         * @return ResponseEntity com o DTO do profissional criado.
         */
        @Operation(summary = "Cria um novo profissional", description = "Registra um novo advogado com seus dados pessoais e informações profissionais.", responses = {
                        @ApiResponse(responseCode = "201", description = "Profissional criado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "409", description = "OAB, CPF ou Email já cadastrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> createProfissional(
                        @Valid @RequestBody ProfissionalCreateRequest request,
                        @RequestHeader(value = "X-Correlation-Id", required = false) String userIdHeader) {
                if (userIdHeader != null && !userIdHeader.trim().isEmpty()) {
                        try {
                                UUID userUuid = UUID.fromString(userIdHeader); // Validar se é um UUID válido

                                if (request.getUsuario() == null) {
                                        // Se o DTO de usuário não foi fornecido no corpo, cria um com o ID do header
                                        request.setUsuario(UserRequestDTO.builder().id(userUuid).build());
                                } else if (request.getUsuario().getId() == null) {
                                        // Se o DTO de usuário foi fornecido, mas sem ID, usa o do header
                                        request.getUsuario().setId(userUuid);
                                }
                        } catch (IllegalArgumentException e) {
                                // Logar ou tratar erro se userIdHeader não for um UUID válido
                                // Para este caso, vamos apenas logar e ignorar o userIdHeader inválido.
                                System.err.println("X-Correlation-Id inválido: " + userIdHeader
                                                + ". Ignorando ID do cabeçalho.");
                        }
                }

                ProfissionalResponseDTO response = profissionalService.createProfissional(request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza um profissional existente.
         * Funcionalidade Completa: Atualização de perfil de advogado, incluindo dados
         * da Pessoa e coleções aninhadas.
         * Regras de Negócio: Acesso restrito ao próprio tenant, validação de
         * existência.
         *
         * @param id      ID do profissional a ser atualizado.
         * @param request DTO com os dados de atualização.
         * @return ResponseEntity com o DTO do profissional atualizado.
         */
        @Operation(summary = "Atualiza um profissional existente", description = "Atualiza os dados de um advogado, incluindo informações pessoais e coleções relacionadas.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional atualizado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: email duplicado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> updateProfissional(
                        @Parameter(description = "ID do profissional a ser atualizado") @PathVariable UUID id,
                        @Valid @RequestBody ProfissionalUpdateRequest request) {
                ProfissionalResponseDTO response = profissionalService.updateProfissional(id, request);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional atualizado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca um profissional pelo ID.
         * Funcionalidade Completa: Exibição detalhada do perfil de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param id ID do profissional.
         * @return ResponseEntity com o DTO do profissional.
         */
        @Operation(summary = "Busca um profissional pelo ID", description = "Retorna os detalhes completos de um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> getProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID id) {
                ProfissionalResponseDTO response = profissionalService.findProfissionalById(id);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os profissionais do tenant atual com paginação.
         * Funcionalidade Completa: Listagem paginada de advogados para o marketplace ou
         * para gestão interna do tenant.
         * Regras de Negócio: Filtro automático por tenant_id.
         *
         * @param page Número da página (0-indexed).
         * @param size Tamanho da página.
         * @param sort Critério de ordenação (ex: campo,asc ou campo,desc).
         * @return ResponseEntity com a página de DTOs de profissionais.
         */
        @Operation(summary = "Lista todos os profissionais com paginação", description = "Retorna uma lista paginada de todos os advogados associados ao tenant atual.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissionais listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> getAllProfissionais(
                        @Parameter(description = "Número da página (0-indexed)", example = "0") @RequestParam(defaultValue = "0") int page,
                        @Parameter(description = "Tamanho da página", example = "10") @RequestParam(defaultValue = "10") int size,
                        @Parameter(description = "Critério de ordenação (ex: nomeCompleto,asc ou numeroOab,desc)", example = "nomeCompleto,asc") @RequestParam(defaultValue = "nomeCompleto,asc") String[] sort) {

                Sort sortCriteria = Sort.by(Sort.Direction.fromString(sort[1]), sort[0]);
                PageRequest pageable = PageRequest.of(page, size, sortCriteria);

                Page<ProfissionalResponseDTO> response = profissionalService.findAllProfissionais(pageable);
                return ResponseEntity.ok(BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Profissionais listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um profissional pelo ID.
         * Funcionalidade Completa: Remoção completa do perfil do advogado e dados
         * associados.
         * Regras de Negócio: Acesso restrito ao próprio tenant. Deleção em cascata
         * (certificações, experiências, documentos, formação, pessoa).
         *
         * @param id ID do profissional a ser deletado.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um profissional pelo ID", description = "Remove um advogado e todos os seus dados associados do sistema.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deleteProfissional(
                        @Parameter(description = "ID do profissional a ser deletado") @PathVariable UUID id) {
                profissionalService.deleteProfissional(id);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Profissional deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Certificações ---

        /**
         * Adiciona uma certificação a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de certificações.
         * Regras de Negócio: Certificação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da certificação.
         * @return ResponseEntity com a certificação criada.
         */
        @Operation(summary = "Adiciona uma certificação a um profissional", description = "Adiciona uma nova certificação ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Certificação adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> addCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.createCertificacao(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<CertificacaoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Certificação adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma certificação de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma certificação
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a certificação atualizada.
         */
        @Operation(summary = "Atualiza uma certificação de um profissional", description = "Atualiza os detalhes de uma certificação existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> updateCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser atualizada") @PathVariable UUID certificacaoId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.updateCertificacao(profissionalId,
                                certificacaoId,
                                requestDTO);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma certificação específica de um profissional.
         * Funcionalidade Completa: Consulta individual de certificação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity com a certificação encontrada.
         */
        @Operation(summary = "Busca uma certificação específica de um profissional", description = "Retorna os detalhes de uma certificação específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> getCertificacaoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação") @PathVariable UUID certificacaoId) {
                CertificacaoResponseDTO response = certificacaoService.findCertificacaoById(profissionalId,
                                certificacaoId);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as certificações de um profissional.
         * Funcionalidade Completa: Visualização de todas as certificações de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de certificações.
         */
        @Operation(summary = "Lista todas as certificações de um profissional", description = "Retorna uma lista de todas as certificações associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificações listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<List<CertificacaoResponseDTO>>> getAllCertificacoes(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<CertificacaoResponseDTO> response = certificacaoService
                                .findAllCertificacoesByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<CertificacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Certificações listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma certificação de um profissional.
         * Funcionalidade Completa: Remoção de uma certificação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma certificação de um profissional", description = "Remove uma certificação específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser deletada") @PathVariable UUID certificacaoId) {
                certificacaoService.deleteCertificacao(profissionalId, certificacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Certificação deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Experiências Profissionais ---

        /**
         * Adiciona uma experiência profissional a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de experiências.
         * Regras de Negócio: Experiência associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da experiência.
         * @return ResponseEntity com a experiência criada.
         */
        @Operation(summary = "Adiciona uma experiência profissional a um profissional", description = "Adiciona uma nova experiência profissional ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Experiência profissional adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> addExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .createExperienciaProfissional(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Experiência profissional adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma experiência profissional de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma experiência
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a experiência atualizada.
         */
        @Operation(summary = "Atualiza uma experiência profissional de um profissional", description = "Atualiza os detalhes de uma experiência profissional existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> updateExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser atualizada") @PathVariable UUID experienciaId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .updateExperienciaProfissional(profissionalId, experienciaId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma experiência profissional específica de um profissional.
         * Funcionalidade Completa: Consulta individual de experiência.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity com a experiência encontrada.
         */
        @Operation(summary = "Busca uma experiência profissional específica de um profissional", description = "Retorna os detalhes de uma experiência profissional específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> getExperienciaProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência") @PathVariable UUID experienciaId) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .findExperienciaProfissionalById(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         * Funcionalidade Completa: Visualização de todas as experiências de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de experiências.
         */
        @Operation(summary = "Lista todas as experiências profissionais de um profissional", description = "Retorna uma lista de todas as experiências profissionais associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiências profissionais listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<List<ExperienciaProfissionalResponseDTO>>> getAllExperienciasProfissionais(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<ExperienciaProfissionalResponseDTO> response = experienciaProfissionalService
                                .findAllExperienciasProfissionaisByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<ExperienciaProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Experiências profissionais listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         * Funcionalidade Completa: Remoção de uma experiência específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma experiência profissional de um profissional", description = "Remove uma experiência profissional específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<Void>> deleteExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser deletada") @PathVariable UUID experienciaId) {
                experienciaProfissionalService.deleteExperienciaProfissional(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Formações Acadêmicas ---

        /**
         * Adiciona uma formação acadêmica a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de formações.
         * Regras de Negócio: Formação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da formação.
         * @return ResponseEntity com a formação criada.
         */
        @Operation(summary = "Adiciona uma formação acadêmica a um profissional", description = "Adiciona uma nova formação acadêmica ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Formação acadêmica adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> addFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.createFormacaoAcademica(profissionalId,
                                requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Formação acadêmica adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma formação existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a formação atualizada.
         */
        @Operation(summary = "Atualiza uma formação acadêmica de um profissional", description = "Atualiza os detalhes de uma formação acadêmica existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> updateFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser atualizada") @PathVariable UUID formacaoId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.updateFormacaoAcademica(profissionalId,
                                formacaoId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma formação acadêmica específica de um profissional.
         * Funcionalidade Completa: Consulta individual de formação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity com a formação encontrada.
         */
        @Operation(summary = "Busca uma formação acadêmica específica de um profissional", description = "Retorna os detalhes de uma formação acadêmica específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> getFormacaoAcademicaById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação") @PathVariable UUID formacaoId) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.findFormacaoAcademicaById(
                                profissionalId,
                                formacaoId);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         * Funcionalidade Completa: Visualização de todas as formações de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de formações.
         */
        @Operation(summary = "Lista todas as formações acadêmicas de um profissional", description = "Retorna uma lista de todas as formações acadêmicas associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formações acadêmicas listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<List<FormacaoAcademicaResponseDTO>>> getAllFormacoesAcademicas(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<FormacaoAcademicaResponseDTO> response = formacaoAcademicaService
                                .findAllFormacoesAcademicasByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<FormacaoAcademicaResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Formações acadêmicas listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Remoção de uma formação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma formação acadêmica de um profissional", description = "Remove uma formação acadêmica específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser deletada") @PathVariable UUID formacaoId) {
                formacaoAcademicaService.deleteFormacaoAcademica(profissionalId, formacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Documentos ---

        /**
         * Realiza o upload de um documento para um profissional.
         * Funcionalidade Completa: Armazenamento de documentos no S3 e metadados no DB.
         * Regras de Negócio: Associação ao profissional e tenant, validação de formato
         * Base64.
         *
         * @param profissionalId ID do profissional.
         * @param request        DTO com os dados do documento e o arquivo em Base64.
         * @return ResponseEntity com o DTO do documento criado.
         */
        @Operation(summary = "Realiza o upload de um documento para um profissional", description = "Faz o upload de um documento para o S3 e persiste seus metadados para um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Documento enviado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: Base64 inválido)"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Falha ao fazer upload do documento ou erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/documentos/upload")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> uploadDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody DocumentoUploadRequest request) {
                DocumentoResponseDTO response = documentoService.uploadDocumento(profissionalId, request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<DocumentoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Documento enviado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Busca um documento específico de um profissional.
         * Funcionalidade Completa: Consulta individual de documento.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity com o DTO do documento encontrado.
         */
        @Operation(summary = "Busca um documento específico de um profissional", description = "Retorna os detalhes de um documento específico de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> getDocumentoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento") @PathVariable UUID documentoId) {
                DocumentoResponseDTO response = documentoService.findDocumentoById(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<DocumentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Documento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os documentos de um profissional.
         * Funcionalidade Completa: Visualização de todos os documentos de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de documentos.
         */
        @Operation(summary = "Lista todos os documentos de um profissional", description = "Retorna uma lista de todos os documentos associados a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documentos listados com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos")
        public ResponseEntity<BaseResponse<List<DocumentoResponseDTO>>> getAllDocumentos(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<DocumentoResponseDTO> response = documentoService
                                .findAllDocumentosByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<DocumentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Documentos listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um documento de um profissional.
         * Funcionalidade Completa: Remoção do documento do S3 e do banco de dados.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um documento de um profissional", description = "Remove um documento específico do perfil de um advogado, incluindo a remoção do S3.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para deleção"),
                        @ApiResponse(responseCode = "500", description = "Falha ao deletar o documento do S3 ou erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<Void>> deleteDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento a ser deletado") @PathVariable UUID documentoId) {
                documentoService.deleteDocumento(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Documento deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

/**
 * Controller para dados mestre de Localizações.
 * Oferece endpoints para consultar estados e cidades disponíveis.
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/advogados/profissionais") // Caminho da requisição ajustado
@Tag(name = "Localizações", description = "Gerenciamento de dados mestre de Localizações (Estados e Cidades)")
public class ProfissionalPublicoController {

    private final ProfissionalService pessoaService;

    private final AreaAtuacaoService areaAtuacaoService;

    /**
     * Lista todas as localizações (estados e cidades) onde há profissionais.
     * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
     * cidades.
     *
     * @return ResponseEntity com o mapa de localizações.
     */
    @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
            @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/localizacoes")
    public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
        Map<String, List<String>> response = pessoaService.listarLocalizacoesDisponiveis();
        return ResponseEntity.ok(BaseResponse.<Map<String, List<String>>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Localizações listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }

    /**
     * Lista todas as Áreas de Atuação.
     * Funcionalidade Completa: Listagem de todas as áreas disponíveis para seleção
     * pelos advogados.
     * Regras de Negócio: N/A (apenas listagem).
     *
     * @return ResponseEntity com a lista de DTOs de Áreas de Atuação.
     */
    @Operation(summary = "Lista todas as áreas de atuação", description = "Retorna uma lista de todas as áreas de atuação cadastradas.", responses = {
            @ApiResponse(responseCode = "200", description = "Áreas de Atuação listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/areas-atuacao")
    public ResponseEntity<BaseResponse<List<AreaAtuacaoResponseDTO>>> getAllAreasAtuacao() {
        List<AreaAtuacaoResponseDTO> response = areaAtuacaoService.findAllAreasAtuacao();
        return ResponseEntity.ok(BaseResponse.<List<AreaAtuacaoResponseDTO>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Áreas de Atuação listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }
}

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.service.TipoAtendimentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Tipos de Atendimento (dados mestre).
 * Oferece endpoints para consultar os tipos de atendimento disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/tipos-atendimento")
@Tag(name = "Tipos de Atendimento", description = "Gerenciamento de dados mestre de Tipos de Atendimento")
public class TipoAtendimentoController {

        private final TipoAtendimentoService tipoAtendimentoService;

        @Autowired
        public TipoAtendimentoController(TipoAtendimentoService tipoAtendimentoService) {
                this.tipoAtendimentoService = tipoAtendimentoService;
        }

        /**
         * Busca um Tipo de Atendimento pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Tipo de Atendimento.
         * @return ResponseEntity com o DTO do Tipo de Atendimento.
         */
        @Operation(summary = "Busca um tipo de atendimento pelo ID", description = "Retorna os detalhes de um tipo de atendimento específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipo de Atendimento encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Tipo de Atendimento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<TipoAtendimentoResponseDTO>> getTipoAtendimentoById(
                        @Parameter(description = "ID do Tipo de Atendimento") @PathVariable UUID id) {
                TipoAtendimentoResponseDTO response = tipoAtendimentoService.findTipoAtendimentoById(id);
                return ResponseEntity.ok(BaseResponse.<TipoAtendimentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Tipo de Atendimento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Tipos de Atendimento.
         * Funcionalidade Completa: Listagem de todos os tipos disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Tipos de Atendimento.
         */
        @Operation(summary = "Lista todos os tipos de atendimento", description = "Retorna uma lista de todos os tipos de atendimento cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipos de Atendimento listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<TipoAtendimentoResponseDTO>>> getAllTiposAtendimento() {
                List<TipoAtendimentoResponseDTO> response = tipoAtendimentoService.findAllTiposAtendimento();
                return ResponseEntity.ok(BaseResponse.<List<TipoAtendimentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Tipos de Atendimento listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Certificacao extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Documento extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissional extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademica extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Idioma extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.commom.model.Pessoa;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId;

    @Column(name = "empresa_id")
    private UUID empresaId;
    @Column(name = "plano_id", nullable = false)
    private UUID planoId;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Certificacao> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Documento> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissional> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademica> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissional> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissional extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimento extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.enums;

/**
 * Enumeração para os tipos de documentos de um Profissional (Advogado).
 * 
 */
public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CertificacaoRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de upload de documento.
 * O campo 'tipoDocumento' foi alterado de String para o enum DocumentoTipo
 * para garantir tipagem segura e validação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    // Alterado de String para o enum DocumentoTipo para tipagem segura
    @NotNull(message = "O tipo do documento é obrigatório.")
    private DocumentoTipo tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim; // Pode ser nulo se for a experiência atual

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para criação de um novo Profissional.
 * Este DTO agora compõe um PessoaRequestDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ProfissionalCreateRequest extends PessoaRequestDTO {

    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;

    // Relacionamentos para dados mestres que podem ser definidos na criação
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // DTOs para certificações, experiências e formações na criação (opcional)
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para atualização de um Profissional.
 * Permite a atualização dos dados da Pessoa associada e dos campos específicos
 * de Profissional,
 * bem como de listas aninhadas.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalUpdateRequest {
    @NotNull(message = "O ID do profissional é obrigatório para atualização.")
    private UUID id;

    @Valid
    // A PessoaRequestDTO interna deve ter seu próprio ID se for uma atualização de
    // pessoa existente
    private PessoaRequestDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId; // Pode ser nulo se não houver empresa associada ou se for desvinculada

    private UUID planoId; // Pode ser nulo se o plano não for alterado

    // Listas de UUIDs para dados mestres
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // Listas de DTOs aninhados para certificações, experiências, formações
    // O ID em cada DTO aninhado indicará se é uma criação, atualização ou remoção.
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Área de Atuação.
 * Usado para retornar detalhes completos da Área de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AreaAtuacaoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Documento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Idioma.
 * Usado para retornar detalhes completos do Idioma.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdiomaResponseDTO {
    private UUID id;
    private String nome;
    private String codigo;
    private String nivel;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Local de Atuação.
 * Usado para retornar detalhes completos do Local de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LocalAtuacaoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.response.PessoaResponseDTO; // Importar PessoaResponseDTO
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta detalhada para um Profissional.
 * Agora compõe um PessoaResponseDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalResponseDTO {
    private UUID id; // ID do Profissional

    private PessoaResponseDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;

    // IDs de entidades relacionadas
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    // Listas de DTOs aninhados
    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    // Listas de DTOs de dados mestres (detalhados)
    private List<LocalAtuacaoResponseDTO> locaisAtuacao;
    private List<AreaAtuacaoResponseDTO> areasAtuacao;
    private List<IdiomaResponseDTO> idiomas;
    private List<TipoAtendimentoResponseDTO> tiposAtendimento;
    private List<RoleProfissionalResponseDTO> rolesProfissional; // DTO para Role do Profissional
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Role de Profissional.
 * Usado para retornar detalhes completos da Role.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleProfissionalResponseDTO {
    private UUID id;
    private String name;
    // O tenantId pode ser incluído se for relevante para o frontend
    // private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Tipo de Atendimento.
 * Usado para retornar detalhes completos do Tipo de Atendimento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TipoAtendimentoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade AreaAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface AreaAtuacaoMapper {
    AreaAtuacaoMapper INSTANCE = Mappers.getMapper(AreaAtuacaoMapper.class);

    /**
     * Mapeia uma entidade AreaAtuacao para um AreaAtuacaoResponseDTO.
     * 
     * @param entity A entidade AreaAtuacao.
     * @return O DTO de resposta correspondente.
     */
    AreaAtuacaoResponseDTO toResponseDTO(AreaAtuacao entity);

    /**
     * Mapeia um AreaAtuacaoResponseDTO para uma entidade AreaAtuacao.
     * Útil para cenários de re-conversão ou testes, embora a criação normalmente
     * venha de um RequestDTO.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade AreaAtuacao correspondente.
     */
    AreaAtuacao toEntity(AreaAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade Certificacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface CertificacaoMapper {
    CertificacaoMapper INSTANCE = Mappers.getMapper(CertificacaoMapper.class);

    /**
     * Mapeia um CertificacaoRequestDTO para uma entidade Certificacao.
     * O campo 'profissional' e 'tenantId' na entidade devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Certificacao correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    Certificacao toEntity(CertificacaoRequestDTO dto);

    /**
     * Mapeia uma entidade Certificacao para um CertificacaoResponseDTO.
     *
     * @param entity A entidade Certificacao.
     * @return O DTO de resposta correspondente.
     */
    CertificacaoResponseDTO toResponseDTO(Certificacao entity);

    /**
     * Atualiza uma entidade Certificacao existente com os dados de um
     * CertificacaoRequestDTO.
     * O campo 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Certificacao a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(CertificacaoRequestDTO dto, @MappingTarget Certificacao entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;

/**
 * Mapper MapStruct para a entidade Documento e seus DTOs.
 * Gerencia a conversão entre DocumentoUploadRequest, Documento e
 * DocumentoResponseDTO.
 */
@Mapper(componentModel = "spring")
public interface DocumentoMapper {
    DocumentoMapper INSTANCE = Mappers.getMapper(DocumentoMapper.class);

    /**
     * Mapeia um DocumentoUploadRequest para uma entidade Documento.
     * Ignora 'arquivoBase64' e 'mimeType' (dados para upload, não persistentes na
     * entidade).
     * 'urlS3', 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição para upload de documento.
     * @return A entidade Documento correspondente.
     */
    @Mapping(target = "urlS3", ignore = true) // Preenchido após o upload bem-sucedido
    @Mapping(target = "profissional", ignore = true) // Relacionamento com Profissional, preenchido no serviço
    @Mapping(target = "tenantId", ignore = true) // TenantId, preenchido no serviço
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    Documento toEntity(DocumentoUploadRequest dto);

    /**
     * Mapeia uma entidade Documento para um DocumentoResponseDTO.
     *
     * @param entity A entidade Documento.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "tipoDocumento", target = "tipoDocumento") // Mapeamento direto de String para String
    DocumentoResponseDTO toResponseDTO(Documento entity);

    /**
     * Atualiza uma entidade Documento existente com os dados de um
     * DocumentoUploadRequest.
     * Campos ignorados: 'id', 'urlS3', 'profissional', 'tenantId'.
     *
     * @param dto    O DTO de requisição.
     * @param entity A entidade Documento a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "urlS3", ignore = true)
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    void updateEntityFromDto(DocumentoUploadRequest dto, @MappingTarget Documento entity);

    /**
     * Converte um enum DocumentoTipo para sua representação em String.
     * Usado para mapear de DTO (enum) para Entidade (String).
     *
     * @param tipo O enum DocumentoTipo.
     * @return A representação em String do enum.
     */
    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipo) {
        return tipo != null ? tipo.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade ExperienciaProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface ExperienciaProfissionalMapper {
    ExperienciaProfissionalMapper INSTANCE = Mappers.getMapper(ExperienciaProfissionalMapper.class);

    /**
     * Mapeia um ExperienciaProfissionalRequestDTO para uma entidade
     * ExperienciaProfissional.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade ExperienciaProfissional correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    ExperienciaProfissional toEntity(ExperienciaProfissionalRequestDTO dto);

    /**
     * Mapeia uma entidade ExperienciaProfissional para um
     * ExperienciaProfissionalResponseDTO.
     *
     * @param entity A entidade ExperienciaProfissional.
     * @return O DTO de resposta correspondente.
     */
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissional entity);

    /**
     * Atualiza uma entidade ExperienciaProfissional existente com os dados de um
     * ExperienciaProfissionalRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade ExperienciaProfissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(ExperienciaProfissionalRequestDTO dto, @MappingTarget ExperienciaProfissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;

/**
 * Mapper MapStruct para a entidade FormacaoAcademica e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface FormacaoAcademicaMapper {
    FormacaoAcademicaMapper INSTANCE = Mappers.getMapper(FormacaoAcademicaMapper.class);

    /**
     * Mapeia um FormacaoAcademicaRequestDTO para uma entidade FormacaoAcademica.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade FormacaoAcademica correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    FormacaoAcademica toEntity(FormacaoAcademicaRequestDTO dto);

    /**
     * Mapeia uma entidade FormacaoAcademica para um FormacaoAcademicaResponseDTO.
     *
     * @param entity A entidade FormacaoAcademica.
     * @return O DTO de resposta correspondente.
     */
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademica entity);

    /**
     * Atualiza uma entidade FormacaoAcademica existente com os dados de um
     * FormacaoAcademicaRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade FormacaoAcademica a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademica entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;

/**
 * Mapper MapStruct para a entidade Idioma e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface IdiomaMapper {
    IdiomaMapper INSTANCE = Mappers.getMapper(IdiomaMapper.class);

    /**
     * Mapeia uma entidade Idioma para um IdiomaResponseDTO.
     * 
     * @param entity A entidade Idioma.
     * @return O DTO de resposta correspondente.
     */
    IdiomaResponseDTO toResponseDTO(Idioma entity);

    /**
     * Mapeia um IdiomaResponseDTO para uma entidade Idioma.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade Idioma correspondente.
     */
    Idioma toEntity(IdiomaResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade LocalAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface LocalAtuacaoMapper {
    LocalAtuacaoMapper INSTANCE = Mappers.getMapper(LocalAtuacaoMapper.class);

    /**
     * Mapeia uma entidade LocalAtuacao para um LocalAtuacaoResponseDTO.
     * 
     * @param entity A entidade LocalAtuacao.
     * @return O DTO de resposta correspondente.
     */
    LocalAtuacaoResponseDTO toResponseDTO(LocalAtuacao entity);

    /**
     * Mapeia um LocalAtuacaoResponseDTO para uma entidade LocalAtuacao.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade LocalAtuacao correspondente.
     */
    LocalAtuacao toEntity(LocalAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;

/**
 * Mapper MapStruct para a entidade Profissional e seus DTOs de requisição e
 * resposta.
 * Lida com mapeamentos complexos e aninhados, delegando para outros mappers
 * quando necessário.
 */
@Mapper(componentModel = "spring", uses = {
        PessoaMapper.class,
        CertificacaoMapper.class,
        DocumentoMapper.class,
        ExperienciaProfissionalMapper.class,
        FormacaoAcademicaMapper.class,
        RoleProfissionalMapper.class
        // Mappers para AreaAtuacao, Idioma, LocalAtuacao, TipoAtendimento NÃO são
        // usados diretamente aqui
        // para mapear UUIDs para DTOs completos, pois isso é responsabilidade do
        // serviço.
})
public interface ProfissionalMapper {
    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * Mapeia um ProfissionalCreateRequest para uma nova entidade Profissional.
     *
     * @param dto O DTO de requisição para criação.
     * @return A nova entidade Profissional.
     */
    // @Mapping(source = "pessoa.user", target = "usuario") // Mapeia o
    // PessoaRequestDTO (que é 'pessoa') para a superclasse 'usuario'
    @Mapping(target = "id", ignore = true) // ID do Profissional será gerado
    @Mapping(target = "pessoaId", ignore = true) // Será preenchido no serviço após a persistência da Pessoa
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "documentos", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "experiencias", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "formacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    Profissional toEntity(ProfissionalCreateRequest dto);

    /**
     * Atualiza uma entidade Profissional existente com os dados de um
     * ProfissionalUpdateRequest.
     *
     * @param dto    O DTO de requisição para atualização.
     * @param entity A entidade Profissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID da entidade não deve ser alterado pelo DTO
    @Mapping(source = "pessoa.usuario", target = "usuario") // Mapeia o DTO 'pessoa.usuario' para a superclasse
                                                            // 'usuario'
    @Mapping(target = "pessoaId", ignore = true) // Gerenciado pelo sistema
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Gerenciado pelo serviço (criação/atualização/remoção)
    @Mapping(target = "documentos", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "experiencias", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "formacoes", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Gerenciado pelo serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    void updateEntityFromDto(ProfissionalUpdateRequest dto, @MappingTarget Profissional entity);

    /**
     * Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * Campos de dados mestres (locaisAtuacao, areasAtuacao, idiomas,
     * tiposAtendimento)
     * são ignorados aqui e devem ser populados pela camada de serviço,
     * pois a entidade Profissional armazena apenas os IDs dessas relações.
     *
     * @param entity A entidade Profissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "usuario", target = "pessoa") // Mapeia a superclasse 'usuario' para 'pessoa' no DTO
    @Mapping(target = "locaisAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "areasAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "idiomas", ignore = true) // Populado pelo serviço
    @Mapping(target = "tiposAtendimento", ignore = true) // Populado pelo serviço
    @Mapping(source = "roleProfissionals", target = "rolesProfissional") // Mapeia Set<RoleProfissional> para
                                                                         // List<RoleProfissionalResponseDTO>
    ProfissionalResponseDTO toResponseDTO(Profissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.RoleProfissional;
import br.com.legalconnect.advogado.dto.response.RoleProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade RoleProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface RoleProfissionalMapper {
    RoleProfissionalMapper INSTANCE = Mappers.getMapper(RoleProfissionalMapper.class);

    /**
     * Mapeia uma entidade RoleProfissional para um RoleProfissionalResponseDTO.
     * Ignora 'tenantId' na resposta se não for relevante para o frontend.
     *
     * @param entity A entidade RoleProfissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    RoleProfissionalResponseDTO toResponseDTO(RoleProfissional entity);

    /**
     * Mapeia um RoleProfissionalResponseDTO para uma entidade RoleProfissional.
     * 'tenantId' deve ser definido pelo serviço.
     *
     * @param dto O DTO de resposta.
     * @return A entidade RoleProfissional correspondente.
     */
    @Mapping(target = "tenantId", ignore = true)
    RoleProfissional toEntity(RoleProfissionalResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;

/**
 * Mapper MapStruct para a entidade TipoAtendimento e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface TipoAtendimentoMapper {
    TipoAtendimentoMapper INSTANCE = Mappers.getMapper(TipoAtendimentoMapper.class);

    /**
     * Mapeia uma entidade TipoAtendimento para um TipoAtendimentoResponseDTO.
     * 
     * @param entity A entidade TipoAtendimento.
     * @return O DTO de resposta correspondente.
     */
    TipoAtendimentoResponseDTO toResponseDTO(TipoAtendimento entity);

    /**
     * Mapeia um TipoAtendimentoResponseDTO para uma entidade TipoAtendimento.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade TipoAtendimento correspondente.
     */
    TipoAtendimento toEntity(TipoAtendimentoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.AreaAtuacao;

@Repository
public interface AreaAtuacaoRepository extends JpaRepository<AreaAtuacao, UUID> {

    /**
     * Busca uma Área de Atuação pelo nome.
     *
     * @param nome O nome da área de atuação.
     * @return Um Optional contendo a Área de Atuação, se encontrada.
     */
    Optional<AreaAtuacao> findByNome(String nome);

    /**
     * 
     * Busca todas as Áreas de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs das áreas de atuação.
     * 
     * @return Uma lista de Áreas de Atuação.
     */
    List<AreaAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Certificacao;

/**
 * Repositório para a entidade {@link Certificacao}.
 * Gerencia operações de persistência para as certificações de um profissional.
 */
@Repository
public interface CertificacaoRepository extends JpaRepository<Certificacao, UUID> {

    /**
     * Busca uma Certificação pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Certificação, se encontrada.
     */
    Optional<Certificacao> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Certificações de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Certificações.
     */
    List<Certificacao> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Documento;

/**
 * Repositório para a entidade {@link Documento}.
 * Gerencia operações de persistência para os documentos de um profissional.
 */
@Repository
public interface DocumentoRepository extends JpaRepository<Documento, UUID> {

    /**
     * Busca um Documento pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo o Documento, se encontrado.
     */
    Optional<Documento> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todos os Documentos de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Documentos.
     */
    List<Documento> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta um Documento pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

/**
 * Repositório para a entidade {@link ExperienciaProfissional}.
 * Gerencia operações de persistência para as experiências profissionais de um
 * profissional.
 * O método 'save' é automaticamente fornecido por JpaRepository, não deve ser
 * declarado explicitamente aqui com parâmetros extras.
 */
@Repository
public interface ExperienciaProfissionalRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    /**
     * Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional
     * associado.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Experiência Profissional, se encontrada.
     */
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Experiências Profissionais de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Experiências Profissionais.
     */
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);

    // IMPORTANTE: NÃO HÁ MÉTODO 'save' EXPLICITAMENTE DECLARADO AQUI.
    // Ele é herdado de JpaRepository e tem a assinatura: S save(S entity);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

@Repository
public interface ExperienciaRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

/**
 * Repositório para a entidade {@link FormacaoAcademica}.
 * Gerencia operações de persistência para as formações acadêmicas de um
 * profissional.
 */
@Repository
public interface FormacaoAcademicaRepository extends JpaRepository<FormacaoAcademica, UUID> {

    /**
     * Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Formação Acadêmica, se encontrada.
     */
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Formações Acadêmicas de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Formações Acadêmicas.
     */
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

@Repository
public interface FormacaoRepository extends JpaRepository<FormacaoAcademica, UUID> {

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Idioma;

/**
 * Repositório para a entidade {@link Idioma}.
 * Gerencia operações de persistência para os idiomas disponíveis.
 */
@Repository
public interface IdiomaRepository extends JpaRepository<Idioma, UUID> {

    /**
     * Busca um Idioma pelo nome.
     *
     * @param nome O nome do idioma.
     * @return Um Optional contendo o Idioma, se encontrado.
     */
    Optional<Idioma> findByNome(String nome);

    /**
     * Busca todos os Idiomas por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos idiomas.
     * @return Uma lista de Idiomas.
     */
    List<Idioma> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.LocalAtuacao;

/**
 * Repositório para a entidade {@link LocalAtuacao}.
 * Gerencia operações de persistência para os locais de atuação dos
 * profissionais.
 */
@Repository
public interface LocalAtuacaoRepository extends JpaRepository<LocalAtuacao, UUID> {

    /**
     * Busca um Local de Atuação pelo nome.
     *
     * @param nome O nome do local de atuação.
     * @return Um Optional contendo o Local de Atuação, se encontrado.
     */
    Optional<LocalAtuacao> findByNome(String nome);

    /**
     * Busca todos os Locais de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos locais de atuação.
     * @return Uma lista de Locais de Atuação.
     */
    List<LocalAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Profissional;

/**
 * Repositório para a entidade {@link Profissional}.
 * Gerencia operações de persistência para os profissionais (advogados).
 */
@Repository
public interface ProfissionalRepository extends JpaRepository<Profissional, UUID> {

    /**
     * Busca um Profissional pelo número da OAB.
     *
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * Busca todos os Profissionais associados a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de Profissionais.
     */
    Page<Profissional> findAllByTenantId(UUID tenantId, Pageable pageable);

    /**
     * Verifica se um Profissional existe pelo número da OAB.
     * Regra de Negócio: Garante a unicidade do número da OAB.
     *
     * @param numeroOab O número da OAB a ser verificado.
     * @return true se um Profissional com a OAB já existe, false caso contrário.
     */
    boolean existsByNumeroOab(String numeroOab);

    /**
     * Verifica se um Profissional existe pelo ID da pessoa associada.
     *
     * @param pessoaId O ID da pessoa.
     * @return true se um Profissional com o ID da pessoa existe, false caso
     *         contrário.
     */
    boolean existsByPessoaId(UUID pessoaId);

    /**
     * NOVO MÉTODO: Busca todos os estados e cidades (municípios) distintos
     * de todas as Pessoas cadastradas.
     * Retorna uma lista de arrays de objetos, onde cada array contém [estado,
     * cidade].
     *
     * @return Uma lista de Object[] contendo pares [estado, cidade].
     */
    @Query(value = "SELECT DISTINCT e.estado, e.cidade FROM tb_endereco e WHERE e.estado IS NOT NULL AND e.cidade IS NOT NULL ORDER BY e.estado, e.cidade", nativeQuery = true)
    List<Object[]> findDistinctEstadosAndCidades();
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.RoleProfissional;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link RoleProfissional}.
 * Gerencia operações de persistência para os papéis (roles) dos profissionais.
 */
@Repository
public interface RoleProfissionalRepository extends JpaRepository<RoleProfissional, UUID> {

    /**
     * Busca uma Role de Profissional pelo nome.
     *
     * @param name O nome da role.
     * @return Um Optional contendo a RoleProfissional, se encontrada.
     */
    Optional<RoleProfissional> findByName(String name);

    /**
     * Busca todas as Roles de Profissional associadas a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de RoleProfissional.
     */
    List<RoleProfissional> findAllByTenantId(UUID tenantId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.TipoAtendimento;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link TipoAtendimento}.
 * Gerencia operações de persistência para os tipos de atendimento disponíveis.
 */
@Repository
public interface TipoAtendimentoRepository extends JpaRepository<TipoAtendimento, UUID> {

    /**
     * Busca um Tipo de Atendimento pelo nome.
     *
     * @param nome O nome do tipo de atendimento.
     * @return Um Optional contendo o TipoAtendimento, se encontrado.
     */
    Optional<TipoAtendimento> findByNome(String nome);

    /**
     * Busca todos os Tipos de Atendimento por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos tipos de atendimento.
     * @return Uma lista de Tipos de Atendimento.
     */
    List<TipoAtendimento> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.EmailService; // Para enviar e-mails de confirmação
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço responsável pela lógica de agendamento de consultas no Marketplace.
 */
@Slf4j
@Service
public class AgendamentoService {

        private final ProfissionalRepository profissionalRepository;
        private final GoogleCalendarService googleCalendarService;
        private final EmailService emailService;
        // Repositório de agendamentos (assumindo a entidade Agendamento)
        // private final AgendamentoRepository agendamentoRepository;

        @Autowired
        public AgendamentoService(ProfissionalRepository profissionalRepository,
                        GoogleCalendarService googleCalendarService,
                        EmailService emailService) {
                this.profissionalRepository = profissionalRepository;
                this.googleCalendarService = googleCalendarService;
                this.emailService = emailService;
                // this.agendamentoRepository = agendamentoRepository;
        }

        /**
         * Realiza o agendamento de uma consulta entre um cliente e um profissional.
         * Regras de Negócio:
         * - Verifica a disponibilidade do profissional na data/hora solicitada.
         * - Garante que o profissional existe e está ativo no marketplace.
         * - Integra com Google Calendar para adicionar o evento na agenda do
         * profissional.
         * - Envia e-mails de confirmação para cliente e profissional.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta.
         * @param tipoServico        Tipo de serviço agendado.
         * @return Sucesso do agendamento.
         * @throws BusinessException se o profissional não estiver disponível ou outras
         *                           regras de negócio forem violadas.
         */
        @Transactional
        public boolean agendarConsulta(UUID profissionalId, UUID clienteId, LocalDateTime horarioAgendamento,
                        String tipoServico) {
                UUID tenantId = TenantContext.getCurrentTenantId(); // O agendamento ocorre dentro do contexto de um
                                                                    // tenant

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                // Regra de Negócio: Profissional deve estar ativo e usar marketplace
                if (!profissional.getUsaMarketplace() || !profissional.getStatusProfissional().equals("ACTIVE")) { // Assuming
                                                                                                                   // "ACTIVE"
                                                                                                                   // status
                        throw new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE, HttpStatus.BAD_REQUEST,
                                        "Profissional não disponível para agendamento.");
                }

                // Regra de Negócio: Verificar disponibilidade real do profissional (com Google
                // Calendar)
                boolean isAvailable = googleCalendarService.checkAvailability(profissional.getUsuario().getEmail(),
                                horarioAgendamento);
                if (!isAvailable) {
                        throw new BusinessException(ErrorCode.APPOINTMENT_CONFLICT, HttpStatus.CONFLICT,
                                        "Horário indisponível para o profissional.");
                }

                // Regra de Negócio: Criar o registro de agendamento no banco de dados (se
                // houver entidade Agendamento)
                // Agendamento newAppointment = Agendamento.builder()
                // .profissional(profissional)
                // .clienteId(clienteId)
                // .horario(horarioAgendamento)
                // .tipoServico(tipoServico)
                // .tenantId(tenantId)
                // .build();
                // agendamentoRepository.save(newAppointment);

                // Funcionalidade Completa: Adicionar evento ao Google Calendar do profissional
                googleCalendarService.addEvent(
                                profissional.getUsuario().getEmail(),
                                "Consulta: " + tipoServico + " com Cliente " + clienteId, // Supondo que você pode obter
                                                                                          // o nome do
                                                                                          // cliente
                                horarioAgendamento,
                                horarioAgendamento.plusHours(1) // Consulta de 1 hora
                );

                // Funcionalidade Completa: Enviar e-mails de confirmação
                emailService.sendAppointmentConfirmationEmail(
                                profissional.getUsuario().getEmail(),
                                "Você tem uma nova consulta agendada com o cliente " + clienteId + " para "
                                                + horarioAgendamento);
                // emailService.sendAppointmentConfirmationEmail(
                // clienteService.findById(clienteId).getEmail(), // Supondo um clienteService
                // "Sua consulta com " + profissional.getNomeCompleto() + " foi confirmada para
                // " + horarioAgendamento
                // );

                return true;
        }

        /**
         * Simula a avaliação de uma consulta pelo cliente.
         * Regras de Negócio:
         * - Associa a avaliação ao agendamento e ao profissional.
         * - Atualiza a média de avaliação do profissional (lógica simplificada).
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return Sucesso da avaliação.
         */
        @Transactional
        public boolean avaliarConsulta(UUID agendamentoId, UUID clienteId, int rating, String comentario) {
                // Lógica para encontrar o agendamento e associar a avaliação.
                // Agendamento agendamento =
                // agendamentoRepository.findById(agendamentoId).orElseThrow(...)
                // Criar uma entidade Avaliacao.
                // Atualizar a média de avaliação do Profissional.

                // Simulação: Apenas loga a avaliação
                log.info("Cliente {} avaliou agendamento {} com nota {} e comentário: {}", clienteId, agendamentoId,
                                rating,
                                comentario);

                // Para fins de demonstração, vamos considerar um sucesso
                return true;
        }

        // Outras funcionalidades como reagendamento, cancelamento, busca de
        // agendamentos
        // seriam implementadas aqui.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Áreas de Atuação (dados mestre).
 * Essas entidades são consideradas globais ou de um tenant específico da
 * plataforma,
 * mas para este módulo, o acesso é simplificado como dados mestre.
 */
@Service
public class AreaAtuacaoService {

    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;

    @Autowired
    public AreaAtuacaoService(AreaAtuacaoRepository areaAtuacaoRepository, AreaAtuacaoMapper areaAtuacaoMapper) {
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
    }

    /**
     * Busca uma Área de Atuação pelo ID.
     *
     * @param id ID da Área de Atuação.
     * @return DTO da Área de Atuação.
     * @throws BusinessException se a Área de Atuação não for encontrada.
     */
    public AreaAtuacaoResponseDTO findAreaAtuacaoById(UUID id) {
        AreaAtuacao areaAtuacao = areaAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Área de Atuação não encontrada."));
        return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
    }

    /**
     * Lista todas as Áreas de Atuação.
     *
     * @return Lista de DTOs de Áreas de Atuação.
     */
    public List<AreaAtuacaoResponseDTO> findAllAreasAtuacao() {
        return areaAtuacaoRepository.findAll().stream()
                .map(areaAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para criar, atualizar e deletar podem ser adicionados
    // se essas entidades mestre forem gerenciáveis via API
    // Por exemplo, por um ADMIN da plataforma.
    // Ex:
    /*
     * @Transactional
     * public AreaAtuacaoResponseDTO createAreaAtuacao(AreaAtuacaoRequestDTO
     * requestDTO) {
     * if (areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * AreaAtuacao areaAtuacao = areaAtuacaoMapper.toEntity(requestDTO);
     * areaAtuacao = areaAtuacaoRepository.save(areaAtuacao);
     * return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
     * }
     * 
     * @Transactional
     * public AreaAtuacaoResponseDTO updateAreaAtuacao(UUID id,
     * AreaAtuacaoRequestDTO requestDTO) {
     * AreaAtuacao existing = areaAtuacaoRepository.findById(id)
     * .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada."));
     * if (!existing.getNome().equalsIgnoreCase(requestDTO.getNome()) &&
     * areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * areaAtuacaoMapper.updateEntityFromDto(requestDTO, existing); // Supondo um
     * updateEntityFromDto no mapper
     * existing = areaAtuacaoRepository.save(existing);
     * return areaAtuacaoMapper.toResponseDTO(existing);
     * }
     * 
     * @Transactional
     * public void deleteAreaAtuacao(UUID id) {
     * if (!areaAtuacaoRepository.existsById(id)) {
     * throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada para deleção.");
     * }
     * // Regra de Negócio: Verificar se está em uso por algum Profissional antes de
     * deletar
     * // if (profissionalRepository.existsByAreaAtuacaoId(id)) { ... }
     * areaAtuacaoRepository.deleteById(id);
     * }
     */
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das certificações de um Profissional.
 * Este serviço é granular e pode ser usado para operações diretas em
 * certificações,
 * embora o ProfissionalService orquestre a maioria.
 */
@Service
public class CertificacaoService {

    private final CertificacaoRepository certificacaoRepository;
    private final CertificacaoMapper certificacaoMapper;
    private final ProfissionalRepository profissionalRepository;

    @Autowired
    public CertificacaoService(CertificacaoRepository certificacaoRepository,
            CertificacaoMapper certificacaoMapper,
            ProfissionalRepository profissionalRepository) {
        this.certificacaoRepository = certificacaoRepository;
        this.certificacaoMapper = certificacaoMapper;
        this.profissionalRepository = profissionalRepository;
    }

    /**
     * Cria uma nova certificação para um profissional específico.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - A certificação é associada ao profissional e ao tenant.
     *
     * @param profissionalId ID do profissional.
     * @param requestDTO     DTO com os dados da certificação.
     * @return DTO da certificação criada.
     */
    @Transactional
    public CertificacaoResponseDTO createCertificacao(UUID profissionalId, CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        Certificacao certificacao = certificacaoMapper.toEntity(requestDTO);
        certificacao.setProfissional(profissional);
        certificacao.setTenantId(tenantId);

        certificacao = certificacaoRepository.save(certificacao); // profissionalId é passado para o
                                                                  // save no repositório customizado
        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Atualiza uma certificação existente de um profissional.
     * Regras de Negócio:
     * - A certificação deve existir e pertencer ao profissional e tenant corretos.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @param requestDTO     DTO com os dados para atualização.
     * @return DTO da certificação atualizada.
     */
    @Transactional
    public CertificacaoResponseDTO updateCertificacao(UUID profissionalId, UUID certificacaoId,
            CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant ou profissional.");
        }

        certificacaoMapper.updateEntityFromDto(requestDTO, existingCertificacao);
        existingCertificacao = certificacaoRepository.save(existingCertificacao);
        return certificacaoMapper.toResponseDTO(existingCertificacao);
    }

    /**
     * Busca uma certificação pelo ID do profissional e da certificação.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @return DTO da certificação.
     */
    public CertificacaoResponseDTO findCertificacaoById(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao certificacao = certificacaoRepository.findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!certificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Lista todas as certificações de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de certificações.
     */
    public List<CertificacaoResponseDTO> findAllCertificacoesByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se o profissional existe e pertence ao tenant
        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return certificacaoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(certificacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta uma certificação de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação a ser deletada.
     */
    @Transactional
    public void deleteCertificacao(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se a certificação existe e pertence ao profissional e tenant
        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para deleção."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        certificacaoRepository.deleteByIdAndProfissionalId(certificacaoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.Base64; // Para decodificar Base64
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.S3Service;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão de documentos de um Profissional.
 * Inclui o upload de arquivos para o S3 e o armazenamento dos metadados no
 * banco de dados.
 */
@Service
public class DocumentoService {

    private final DocumentoRepository documentoRepository;
    private final DocumentoMapper documentoMapper;
    private final ProfissionalRepository profissionalRepository;
    private final S3Service s3Service; // Serviço para integração com S3

    @Autowired
    public DocumentoService(DocumentoRepository documentoRepository,
            DocumentoMapper documentoMapper,
            ProfissionalRepository profissionalRepository,
            S3Service s3Service) {
        this.documentoRepository = documentoRepository;
        this.documentoMapper = documentoMapper;
        this.profissionalRepository = profissionalRepository;
        this.s3Service = s3Service;
    }

    /**
     * Realiza o upload de um documento para o S3 e persiste seus metadados.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - O conteúdo do arquivo em Base64 é decodificado e enviado ao S3.
     * - A URL do S3 é armazenada no banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param request        DTO com os dados do documento e o arquivo em Base64.
     * @return DTO do documento criado.
     * @throws BusinessException em caso de falha no upload ou se o profissional não
     *                           for encontrado.
     */
    @Transactional
    public DocumentoResponseDTO uploadDocumento(UUID profissionalId, DocumentoUploadRequest request) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para upload de documento."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Decodificar Base64 e fazer upload para S3
        byte[] fileBytes;
        try {
            fileBytes = Base64.getDecoder().decode(request.getArquivoBase64());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.INVALID_DOCUMENT_FORMAT, HttpStatus.BAD_REQUEST,
                    "Conteúdo do arquivo em Base64 inválido.");
        }

        String s3Key = "profissionais/" + profissionalId + "/documentos/" + UUID.randomUUID() + "/"
                + request.getNomeArquivo();
        String fileUrl = s3Service.uploadFile(fileBytes, s3Key, request.getMimeType());

        if (fileUrl == null) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao fazer upload do documento para o S3.");
        }

        Documento documento = documentoMapper.toEntity(request);
        documento.setUrlS3(fileUrl);
        documento.setProfissional(profissional);
        documento.setTenantId(tenantId);

        documento = documentoRepository.save(documento);
        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Busca um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento deve pertencer ao profissional e ao tenant correto.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento.
     * @return DTO do documento encontrado.
     * @throws BusinessException se o documento não for encontrado.
     */
    public DocumentoResponseDTO findDocumentoById(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento documento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para este profissional."));

        if (!documento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant ou profissional.");
        }

        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Lista todos os documentos de um profissional.
     * Regras de Negócio:
     * - Apenas documentos do tenant atual são retornados.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de documentos.
     */
    public List<DocumentoResponseDTO> findAllDocumentosByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return documentoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(documentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento é removido do S3 antes de ser deletado do banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento a ser deletado.
     * @throws BusinessException se o documento não for encontrado ou falha na
     *                           deleção do S3.
     */
    @Transactional
    public void deleteDocumento(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento existingDocumento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para deleção."));

        if (!existingDocumento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant.");
        }

        // Deletar do S3 primeiro
        try {
            s3Service.deleteFile(existingDocumento.getUrlS3());
        } catch (Exception e) {
            throw new BusinessException(ErrorCode.ERRO_INTERNO_SERVIDOR, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao deletar o documento do S3: " + e.getMessage());
        }

        documentoRepository.deleteByIdAndProfissionalId(documentoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das experiências profissionais de um
 * Profissional.
 */
@Service
public class ExperienciaProfissionalService {

        private final ExperienciaRepository experienciaRepository;
        private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public ExperienciaProfissionalService(ExperienciaRepository experienciaRepository,
                        ExperienciaProfissionalMapper experienciaProfissionalMapper,
                        ProfissionalRepository profissionalRepository) {
                this.experienciaRepository = experienciaRepository;
                this.experienciaProfissionalMapper = experienciaProfissionalMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova experiência profissional para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A experiência é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da experiência.
         * @return DTO da experiência criada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO createExperienciaProfissional(UUID profissionalId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                ExperienciaProfissional experiencia = experienciaProfissionalMapper.toEntity(requestDTO);
                experiencia.setProfissional(profissional);
                experiencia.setTenantId(tenantId);

                experiencia = experienciaRepository.save(experiencia);
                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Atualiza uma experiência profissional existente de um profissional.
         * Regras de Negócio:
         * - A experiência deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da experiência atualizada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO updateExperienciaProfissional(UUID profissionalId, UUID experienciaId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant ou profissional.");
                }

                experienciaProfissionalMapper.updateEntityFromDto(requestDTO, existingExperiencia);
                existingExperiencia = experienciaRepository.save(existingExperiencia);
                return experienciaProfissionalMapper.toResponseDTO(existingExperiencia);
        }

        /**
         * Busca uma experiência profissional pelo ID do profissional e da experiência.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return DTO da experiência.
         */
        public ExperienciaProfissionalResponseDTO findExperienciaProfissionalById(UUID profissionalId,
                        UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional experiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!experiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de experiências.
         */
        public List<ExperienciaProfissionalResponseDTO> findAllExperienciasProfissionaisByProfissionalId(
                        UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return experienciaRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(experienciaProfissionalMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência a ser deletada.
         */
        @Transactional
        public void deleteExperienciaProfissional(UUID profissionalId, UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para deleção."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                experienciaRepository.deleteByIdAndProfissionalId(experienciaId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das formações acadêmicas de um Profissional.
 */
@Service
public class FormacaoAcademicaService {

        private final FormacaoRepository formacaoRepository;
        private final FormacaoAcademicaMapper formacaoAcademicaMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public FormacaoAcademicaService(FormacaoRepository formacaoRepository,
                        FormacaoAcademicaMapper formacaoAcademicaMapper,
                        ProfissionalRepository profissionalRepository) {
                this.formacaoRepository = formacaoRepository;
                this.formacaoAcademicaMapper = formacaoAcademicaMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova formação acadêmica para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A formação é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da formação.
         * @return DTO da formação criada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO createFormacaoAcademica(UUID profissionalId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                FormacaoAcademica formacao = formacaoAcademicaMapper.toEntity(requestDTO);
                formacao.setProfissional(profissional);
                formacao.setTenantId(tenantId);

                formacao = formacaoRepository.save(formacao);
                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Atualiza uma formação acadêmica existente de um profissional.
         * Regras de Negócio:
         * - A formação deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da formação atualizada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO updateFormacaoAcademica(UUID profissionalId, UUID formacaoId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant ou profissional.");
                }

                formacaoAcademicaMapper.updateEntityFromDto(requestDTO, existingFormacao);
                existingFormacao = formacaoRepository.save(existingFormacao);
                return formacaoAcademicaMapper.toResponseDTO(existingFormacao);
        }

        /**
         * Busca uma formação acadêmica pelo ID do profissional e da formação.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return DTO da formação.
         */
        public FormacaoAcademicaResponseDTO findFormacaoAcademicaById(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica formacao = formacaoRepository.findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!formacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de formações.
         */
        public List<FormacaoAcademicaResponseDTO> findAllFormacoesAcademicasByProfissionalId(UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return formacaoRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(formacaoAcademicaMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação a ser deletada.
         */
        @Transactional
        public void deleteFormacaoAcademica(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para deleção."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                formacaoRepository.deleteByIdAndProfissionalId(formacaoId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço de integração simulada com a Google Calendar API.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a
 * Google Calendar API
 * utilizando as credenciais OAuth2 do aplicativo.
 */
@Service
public class GoogleCalendarService {

    private static final Logger log = LoggerFactory.getLogger(GoogleCalendarService.class);

    /**
     * Simula a adição de um evento à agenda do Google Calendar de um usuário.
     *
     * @param userEmail    O e-mail do usuário cuja agenda será atualizada.
     * @param eventSummary O título do evento.
     * @param startTime    A data e hora de início do evento.
     * @param endTime      A data e hora de fim do evento.
     * @return true se o evento foi "adicionado" com sucesso, false caso contrário.
     */
    public boolean addEvent(String userEmail, String eventSummary, LocalDateTime startTime, LocalDateTime endTime) {
        log.info("Simulando adição de evento ao Google Calendar para {}:", userEmail);
        log.info("  Sumário: {}", eventSummary);
        log.info("  Início: {}", startTime);
        log.info("  Fim: {}", endTime);
        // Lógica real de integração com Google Calendar API seria aqui, por exemplo:
        // Event event = new Event()
        // .setSummary(eventSummary)
        // .setDescription("Agendamento via LegalConnect");
        // DateTime startDateTime = new DateTime(startTime.toString());
        // EventDateTime start = new
        // EventDateTime().setDateTime(startDateTime).setTimeZone("America/Sao_Paulo");
        // event.setStart(start);
        // ...
        // Calendar service = new Calendar.Builder(...).build();
        // service.events().insert(userEmail, event).execute();
        log.info("Evento simulado adicionado com sucesso ao Google Calendar.");
        return true;
    }

    /**
     * Simula a verificação de disponibilidade na agenda do Google Calendar de um
     * usuário.
     *
     * @param userEmail    O e-mail do usuário.
     * @param proposedTime O horário a ser verificado.
     * @return true se o horário estiver disponível, false caso contrário.
     */
    public boolean checkAvailability(String userEmail, LocalDateTime proposedTime) {
        log.info("Simulando verificação de disponibilidade para {} no horário {}", userEmail, proposedTime);
        // Em um cenário real, você consultaria a API do Google Calendar para Free/Busy
        // Por simplicidade, vamos simular que o horário está sempre disponível, a menos
        // que seja um horário "proibido"
        if (proposedTime.getHour() == 13) { // Exemplo de regra de negócio: almoço indisponível
            log.info("Horário indisponível (simulado).");
            return false;
        }
        log.info("Horário disponível (simulado).");
        return true;
    }

    // Outros métodos como updateEvent, deleteEvent, listEvents podem ser
    // adicionados.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Idiomas (dados mestre).
 */
@Service
public class IdiomaService {

    private final IdiomaRepository idiomaRepository;
    private final IdiomaMapper idiomaMapper;

    @Autowired
    public IdiomaService(IdiomaRepository idiomaRepository, IdiomaMapper idiomaMapper) {
        this.idiomaRepository = idiomaRepository;
        this.idiomaMapper = idiomaMapper;
    }

    /**
     * Busca um Idioma pelo ID.
     *
     * @param id ID do Idioma.
     * @return DTO do Idioma.
     * @throws BusinessException se o Idioma não for encontrado.
     */
    public IdiomaResponseDTO findIdiomaById(UUID id) {
        Idioma idioma = idiomaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Idioma não encontrado."));
        return idiomaMapper.toResponseDTO(idioma);
    }

    /**
     * Lista todos os Idiomas.
     *
     * @return Lista de DTOs de Idiomas.
     */
    public List<IdiomaResponseDTO> findAllIdiomas() {
        return idiomaRepository.findAll().stream()
                .map(idiomaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Locais de Atuação (dados mestre).
 */
@Service
public class LocalAtuacaoService {

    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final LocalAtuacaoMapper localAtuacaoMapper;

    @Autowired
    public LocalAtuacaoService(LocalAtuacaoRepository localAtuacaoRepository, LocalAtuacaoMapper localAtuacaoMapper) {
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.localAtuacaoMapper = localAtuacaoMapper;
    }

    /**
     * Busca um Local de Atuação pelo ID.
     *
     * @param id ID do Local de Atuação.
     * @return DTO do Local de Atuação.
     * @throws BusinessException se o Local de Atuação não for encontrado.
     */
    public LocalAtuacaoResponseDTO findLocalAtuacaoById(UUID id) {
        LocalAtuacao localAtuacao = localAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Local de Atuação não encontrado."));
        return localAtuacaoMapper.toResponseDTO(localAtuacao);
    }

    /**
     * Lista todos os Locais de Atuação.
     *
     * @return Lista de DTOs de Locais de Atuação.
     */
    public List<LocalAtuacaoResponseDTO> findAllLocaisAtuacao() {
        return localAtuacaoRepository.findAll().stream()
                .map(localAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import org.springframework.stereotype.Service;

// Assumindo a existência dessas classes de DTO, Entidade e Repositório
// import br.com.legalconnect.office.application.dto.request.ProcessoRequestDTO;
// import br.com.legalconnect.office.application.dto.response.ProcessoResponseDTO;
// import br.com.legalconnect.office.domain.modal.entity.Processo;
// import br.com.legalconnect.office.domain.repository.ProcessoRepository;
// import br.com.legalconnect.office.application.mapper.ProcessoMapper;

/**
 * Serviço responsável pela gestão de Processos Judiciais e Administrativos no
 * módulo de Gestão de Escritório.
 */
@Service
public class ProcessoService {

    // private final ProcessoRepository processoRepository;
    // private final ProcessoMapper processoMapper;
    // private final AIService aiService; // Para geração de petições com IA
    // private final S3Service s3Service; // Para anexos de documentos

    // @Autowired
    // public ProcessoService(ProcessoRepository processoRepository,
    // ProcessoMapper processoMapper,
    // AIService aiService,
    // S3Service s3Service) {
    // this.processoRepository = processoRepository;
    // this.processoMapper = processoMapper;
    // this.aiService = aiService;
    // this.s3Service = s3Service;
    // }

    /**
     * Cria um novo processo judicial ou administrativo.
     * Regras de Negócio:
     * - Associa o processo ao tenant atual.
     * - Define o status inicial do processo.
     *
     * @param requestDTO DTO com os dados do processo.
     * @return DTO do processo criado.
     */
    // @Transactional
    // public ProcessoResponseDTO createProcesso(ProcessoRequestDTO requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoMapper.toEntity(requestDTO);
    // processo.setTenantId(tenantId);
    // processo.setStatus("INICIADO"); // Regra de Negócio: Status inicial
    //
    // processo = processoRepository.save(processo);
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Atualiza um processo existente.
     * Regras de Negócio:
     * - O processo deve existir e pertencer ao tenant atual.
     *
     * @param id         ID do processo.
     * @param requestDTO DTO com os dados para atualização.
     * @return DTO do processo atualizado.
     */
    // @Transactional
    // public ProcessoResponseDTO updateProcesso(UUID id, ProcessoRequestDTO
    // requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // processoMapper.updateEntityFromDto(requestDTO, existingProcesso);
    // existingProcesso = processoRepository.save(existingProcesso);
    // return processoMapper.toResponseDTO(existingProcesso);
    // }

    /**
     * Busca um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo.
     * @return DTO do processo.
     */
    // public ProcessoResponseDTO findProcessoById(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Lista todos os processos de um tenant.
     *
     * @return Lista de DTOs de processos.
     */
    // public List<ProcessoResponseDTO> findAllProcessos() {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // return processoRepository.findAllByTenantId(tenantId).stream()
    // .map(processoMapper::toResponseDTO)
    // .collect(Collectors.toList());
    // }

    /**
     * Deleta um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo a ser deletado.
     */
    // @Transactional
    // public void deleteProcesso(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para deleção."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Regra de Negócio: Verificar se o processo pode ser deletado (ex: não tem
    // atividades pendentes)
    // // if (hasPendingActivities(existingProcesso)) {
    // // throw new BusinessException(ErrorCode.RECURSO_EM_USO, HttpStatus.CONFLICT,
    // "Processo possui atividades pendentes e não pode ser deletado.");
    // // }
    //
    // processoRepository.deleteById(id);
    // }

    /**
     * Gera um rascunho de petição utilizando IA (OpenAI GPT).
     * Regras de Negócio:
     * - O profissional deve ter permissão e estar em um plano que suporte IA.
     * - A IA gera um texto baseado nas informações do processo.
     *
     * @param processoId ID do processo para o qual a petição será gerada.
     * @param prompt     Instruções adicionais para a IA.
     * @return O rascunho da petição gerado pela IA.
     */
    // public String generatePeticaoWithAI(UUID processoId, String prompt) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    // // Verifica se o usuário logado tem permissão e plano para usar IA
    // // Profissional profissional =
    // profissionalService.findProfissionalById(userIdFromSecurityContext);
    // // if (!profissional.getPlano().supportsAI()) { ... }
    //
    // Processo processo = processoRepository.findById(processoId)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para geração de petição."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Montar o prompt completo para a IA com base nos dados do processo
    // String fullPrompt = String.format("Crie um rascunho de petição para o
    // processo '%s' (Tipo: %s, Partes: %s). Contexto: %s. %s",
    // processo.getNumero(), processo.getTipo(), processo.getPartes(),
    // processo.getDescricao(), prompt);
    //
    // // Chamada ao serviço de IA
    // String generatedText = aiService.generateText(fullPrompt);
    //
    // return generatedText;
    // }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.ProfissionalMapper;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.service.PessoaService;
import br.com.legalconnect.commom.service.S3Service; // Assumindo S3Service para upload de documentos
import br.com.legalconnect.commom.service.TenantContext; // Assumindo TenantContext para multitenancy
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão completa do Profissional (Advogado).
 * Inclui operações de CRUD, validações de negócio e orquestração com serviços
 * de entidades aninhadas
 * e dados mestre. Gerencia também o upload de documentos e a associação com o
 * tenant.
 */
@Service
public class ProfissionalService {

    private final ProfissionalRepository profissionalRepository;
    private final ProfissionalMapper profissionalMapper;
    private final PessoaService pessoaService; // Para gerenciar a entidade Pessoa
    private final CertificacaoMapper certificacaoMapper;
    private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
    private final FormacaoAcademicaMapper formacaoAcademicaMapper;
    private final DocumentoMapper documentoMapper;
    private final CertificacaoRepository certificacaoRepository;
    private final ExperienciaRepository experienciaRepository;
    private final FormacaoRepository formacaoRepository;
    private final DocumentoRepository documentoRepository;
    private final S3Service s3Service; // Serviço para integração com S3
    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final IdiomaRepository idiomaRepository;
    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;
    private final IdiomaMapper idiomaMapper;
    private final LocalAtuacaoMapper localAtuacaoMapper;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public ProfissionalService(ProfissionalRepository profissionalRepository,
            ProfissionalMapper profissionalMapper,
            PessoaService pessoaService,
            CertificacaoMapper certificacaoMapper,
            ExperienciaProfissionalMapper experienciaProfissionalMapper,
            FormacaoAcademicaMapper formacaoAcademicaMapper,
            DocumentoMapper documentoMapper,
            CertificacaoRepository certificacaoRepository,
            ExperienciaRepository experienciaRepository,
            FormacaoRepository formacaoRepository,
            DocumentoRepository documentoRepository,
            S3Service s3Service,
            AreaAtuacaoRepository areaAtuacaoRepository,
            IdiomaRepository idiomaRepository,
            LocalAtuacaoRepository localAtuacaoRepository,
            TipoAtendimentoRepository tipoAtendimentoRepository,
            AreaAtuacaoMapper areaAtuacaoMapper,
            IdiomaMapper idiomaMapper,
            LocalAtuacaoMapper localAtuacaoMapper,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.profissionalRepository = profissionalRepository;
        this.profissionalMapper = profissionalMapper;
        this.pessoaService = pessoaService;
        this.certificacaoMapper = certificacaoMapper;
        this.experienciaProfissionalMapper = experienciaProfissionalMapper;
        this.formacaoAcademicaMapper = formacaoAcademicaMapper;
        this.documentoMapper = documentoMapper;
        this.certificacaoRepository = certificacaoRepository;
        this.experienciaRepository = experienciaRepository;
        this.formacaoRepository = formacaoRepository;
        this.documentoRepository = documentoRepository;
        this.s3Service = s3Service;
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.idiomaRepository = idiomaRepository;
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
        this.idiomaMapper = idiomaMapper;
        this.localAtuacaoMapper = localAtuacaoMapper;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Cria um novo Profissional no sistema.
     * Regras de Negócio:
     * - Valida a unicidade do número da OAB.
     * - Associa o Profissional a um Tenant (obtido do contexto de segurança).
     * - Cria a entidade Pessoa associada através do PessoaService.
     * - Gerencia a criação de certificações, experiências e formações aninhadas.
     * - Define o status inicial do profissional.
     * - Valida a existência do plano.
     *
     * @param createRequest DTO com os dados para criação do Profissional.
     * @return DTO do Profissional criado.
     * @throws BusinessException se a OAB já estiver cadastrada, ou se o
     *                           plano/tenant não existirem.
     */
    @Transactional
    public ProfissionalResponseDTO createProfissional(ProfissionalCreateRequest createRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo que o tenantId vem do contexto de segurança

        // Regra de Negócio: Validar unicidade da OAB
        if (profissionalRepository.existsByNumeroOab(createRequest.getNumeroOab())) {
            throw new BusinessException(ErrorCode.OAB_DUPLICADA, HttpStatus.CONFLICT, createRequest.getNumeroOab());
        }

        // Regra de Negócio: Validar unicidade da Pessoa (CPF/Email) antes de criar o
        // Profissional
        if (pessoaService.findPessoaByCpf(createRequest.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, createRequest.getCpf());
        }
        if (pessoaService.findPessoaByEmail(createRequest.getUsuario().getEmail()).isPresent()) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    createRequest.getUsuario().getEmail());
        }

        // Criar a Pessoa associada primeiro, pois Profissional estende Pessoa
        PessoaRequestDTO pessoaRequestDTO = new PessoaRequestDTO();
        pessoaRequestDTO.setUsuario(createRequest.getUsuario());
        pessoaRequestDTO.setNomeCompleto(createRequest.getNomeCompleto());
        pessoaRequestDTO.setCpf(createRequest.getCpf());
        pessoaRequestDTO.setDataNascimento(createRequest.getDataNascimento());
        pessoaRequestDTO.setTelefones(createRequest.getTelefones());
        pessoaRequestDTO.setEnderecos(createRequest.getEnderecos());

        Pessoa newPessoa = pessoaService.createPessoa(pessoaRequestDTO);

        // Regra de Negócio: Validar que o planoId existe (assumindo um PlanoService ou
        // repositório de Plano)
        // if (!planoService.existsById(createRequest.getPlanoId())) {
        // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
        // HttpStatus.NOT_FOUND);
        // }

        Profissional profissional = profissionalMapper.toEntity(createRequest);
        profissional.setPessoaId(newPessoa.getId()); // Associa o ID da Pessoa recém-criada
        profissional.setUsuario(newPessoa.getUsuario()); // Garante que o usuário de Pessoa esteja associado
        profissional.setTenantId(tenantId); // Regra de Negócio: Define o tenant do profissional
        profissional.setStatusProfissional("PENDING_APPROVAL"); // Regra de Negócio: Status inicial

        // Relacionamentos muitos-para-muitos (apenas IDs aqui)
        if (createRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            profissional.setLocaisAtuacaoIds(createRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            profissional.setAreaAtuacaoIds(createRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(createRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            profissional.setIdiomaIds(createRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(createRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            profissional
                    .setTipoAtendimentoIds(createRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        profissional = profissionalRepository.save(profissional);

        // Gerenciar certificações, experiências e formações
        manageNestedEntities(profissional, createRequest);

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Atualiza um Profissional existente.
     * Regras de Negócio:
     * - Valida a existência do Profissional e do Tenant.
     * - Permite a atualização de dados da Pessoa associada.
     * - Gerencia a adição, atualização e remoção de certificações, experiências e
     * formações.
     * - Atualiza relacionamentos com dados mestre.
     *
     * @param id            ID do Profissional a ser atualizado.
     * @param updateRequest DTO com os dados para atualização.
     * @return DTO do Profissional atualizado.
     * @throws BusinessException se o Profissional não for encontrado, ou por outras
     *                           violações de negócio.
     */
    @Transactional
    public ProfissionalResponseDTO updateProfissional(UUID id, ProfissionalUpdateRequest updateRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo tenantId do contexto de segurança

        Profissional existingProfissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para atualização."));

        // Regra de Negócio: O profissional só pode ser atualizado pelo seu próprio
        // tenant
        if (!existingProfissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Atualiza os dados da Pessoa associada (se fornecidos)
        if (updateRequest.getPessoa() != null) {
            pessoaService.updatePessoa(existingProfissional.getPessoaId(), updateRequest.getPessoa());
        }

        // Mapeia os campos atualizáveis para a entidade Profissional
        profissionalMapper.updateEntityFromDto(updateRequest, existingProfissional);

        // Regra de Negócio: Validar que o planoId existe se for alterado
        if (updateRequest.getPlanoId() != null
                && !existingProfissional.getPlanoId().equals(updateRequest.getPlanoId())) {
            // if (!planoService.existsById(updateRequest.getPlanoId())) {
            // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
            // HttpStatus.NOT_FOUND);
            // }
            existingProfissional.setPlanoId(updateRequest.getPlanoId());
        }

        // Atualiza relacionamentos muitos-para-muitos
        if (updateRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            existingProfissional
                    .setLocaisAtuacaoIds(updateRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            existingProfissional
                    .setAreaAtuacaoIds(updateRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(updateRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            existingProfissional.setIdiomaIds(updateRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(updateRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            existingProfissional
                    .setTipoAtendimentoIds(updateRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        // Gerenciar coleções aninhadas (certificações, experiências, formações)
        manageNestedEntities(existingProfissional, updateRequest);

        existingProfissional = profissionalRepository.save(existingProfissional);
        return mapToResponseDTOWithDetails(existingProfissional);
    }

    /**
     * Busca um Profissional pelo ID.
     * Regras de Negócio:
     * - Garante que o Profissional pertence ao Tenant do contexto de segurança.
     * - Popula os dados mestre relacionados.
     *
     * @param id ID do Profissional.
     * @return DTO do Profissional com detalhes.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    public ProfissionalResponseDTO findProfissionalById(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Busca todos os Profissionais de um determinado Tenant com paginação.
     *
     * @param pageable Objeto Pageable contendo informações de paginação e
     *                 ordenação.
     * @return Página de DTOs de Profissionais.
     */
    public Page<ProfissionalResponseDTO> findAllProfissionais(Pageable pageable) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Filtra por tenant

        Page<Profissional> profissionaisPage = profissionalRepository.findAllByTenantId(tenantId, pageable);
        return profissionaisPage.map(this::mapToResponseDTOWithDetails);
    }

    /**
     * Deleta um Profissional pelo ID.
     * Regras de Negócio:
     * - Apenas o proprietário do tenant pode deletar.
     * - Orquestra a deleção de entidades aninhadas (Certificações, Experiências,
     * Formações, Documentos).
     * - Deleção da Pessoa associada.
     *
     * @param id ID do Profissional a ser deletado.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    @Transactional
    public void deleteProfissional(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para deleção."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Deleta entidades aninhadas (cascade pode fazer isso, mas explicitar é bom
        // para clareza)
        certificacaoRepository.findAllByProfissionalId(id)
                .forEach(c -> certificacaoRepository.deleteByIdAndProfissionalId(c.getId(), id));
        experienciaRepository.findAllByProfissionalId(id)
                .forEach(e -> experienciaRepository.deleteByIdAndProfissionalId(e.getId(), id));
        formacaoRepository.findAllByProfissionalId(id)
                .forEach(f -> formacaoRepository.deleteByIdAndProfissionalId(f.getId(), id));
        documentoRepository.findAllByProfissionalId(id).forEach(d -> {
            s3Service.deleteFile(d.getUrlS3()); // Deleta arquivo do S3
            documentoRepository.deleteByIdAndProfissionalId(d.getId(), id);
        });

        // Deleta o profissional
        profissionalRepository.deleteById(id);

        // Deleta a pessoa associada
        pessoaService.deletePessoa(profissional.getPessoaId());
    }

    /**
     * Método auxiliar para gerenciar a adição, atualização e remoção de entidades
     * aninhadas
     * (certificações, experiências, formações) para um Profissional.
     *
     * @param profissional O Profissional pai.
     * @param request      O DTO de requisição (Create ou Update) contendo as listas
     *                     aninhadas.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalCreateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Remover certificações que não estão mais no DTO
            profissional.getCertificacoes().removeIf(existingCert -> request.getCertificacoes().stream()
                    .noneMatch(dto -> existingCert.getId().equals(dto.getId())));
            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        }

        // Experiências Profissionais
        if (request.getExperiencias() != null) {
            profissional.getExperiencias().removeIf(existingExp -> request.getExperiencias().stream()
                    .noneMatch(dto -> existingExp.getId().equals(dto.getId())));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) { // Nova experiência
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else { // Atualizar experiência existente
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        }

        // Formações Acadêmicas
        if (request.getFormacoes() != null) {
            profissional.getFormacoes().removeIf(existingForm -> request.getFormacoes().stream()
                    .noneMatch(dto -> existingForm.getId().equals(dto.getId())));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova formação
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else { // Atualizar formação existente
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        }
    }

    /**
     * Sobrecarga para o método de gerenciamento de entidades aninhadas para
     * ProfissionalUpdateRequest.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalUpdateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Coleta IDs das certificações no DTO para identificar as que serão removidas
            Set<UUID> dtoCertIds = request.getCertificacoes().stream()
                    .map(c -> c.getId())
                    .collect(Collectors.toSet());

            // Remove certificações que existem na entidade mas não no DTO (deleção)
            profissional.getCertificacoes().removeIf(
                    existingCert -> existingCert.getId() != null && !dtoCertIds.contains(existingCert.getId()));

            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação (ID nulo indica novo)
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId() != null && c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        } else {
            // Se a lista no DTO for nula, assume-se que todas as certificações devem ser
            // removidas
            profissional.getCertificacoes().clear();
        }

        // Experiências Profissionais (lógica similar às certificações)
        if (request.getExperiencias() != null) {
            Set<UUID> dtoExpIds = request.getExperiencias().stream()
                    .map(e -> e.getId())
                    .collect(Collectors.toSet());
            profissional.getExperiencias()
                    .removeIf(existingExp -> existingExp.getId() != null && !dtoExpIds.contains(existingExp.getId()));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) {
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else {
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId() != null && e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        } else {
            profissional.getExperiencias().clear();
        }

        // Formações Acadêmicas (lógica similar às certificações)
        if (request.getFormacoes() != null) {
            Set<UUID> dtoFormIds = request.getFormacoes().stream()
                    .map(f -> f.getId())
                    .collect(Collectors.toSet());
            profissional.getFormacoes().removeIf(
                    existingForm -> existingForm.getId() != null && !dtoFormIds.contains(existingForm.getId()));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) {
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else {
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId() != null && f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        } else {
            profissional.getFormacoes().clear();
        }
    }

    /**
     * Mapeia um Profissional para ProfissionalResponseDTO e popula os dados mestre
     * relacionados.
     * Esta é uma funcionalidade completa para apresentar o perfil do advogado.
     *
     * @param profissional A entidade Profissional.
     * @return O DTO de resposta detalhado.
     */
    private ProfissionalResponseDTO mapToResponseDTOWithDetails(Profissional profissional) {
        ProfissionalResponseDTO responseDTO = profissionalMapper.toResponseDTO(profissional);

        // Popula listas de DTOs de dados mestre
        responseDTO.setLocaisAtuacao(
                localAtuacaoRepository.findAllById(profissional.getLocaisAtuacaoIds())
                        .stream()
                        .map(localAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setAreasAtuacao(
                areaAtuacaoRepository.findAllById(profissional.getAreaAtuacaoIds())
                        .stream()
                        .map(areaAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setIdiomas(
                idiomaRepository.findAllById(profissional.getIdiomaIds())
                        .stream()
                        .map(idiomaMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setTiposAtendimento(
                tipoAtendimentoRepository.findAllById(profissional.getTipoAtendimentoIds())
                        .stream()
                        .map(tipoAtendimentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Popula as coleções aninhadas
        responseDTO.setCertificacoes(
                profissional.getCertificacoes().stream()
                        .map(certificacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setDocumentos(
                profissional.getDocumentos().stream()
                        .map(documentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setExperiencias(
                profissional.getExperiencias().stream()
                        .map(experienciaProfissionalMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setFormacoes(
                profissional.getFormacoes().stream()
                        .map(formacaoAcademicaMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Define se faz parte de plano com base no planoId (regra de negócio)
        responseDTO.setFazParteDePlano(profissional.getPlanoId() != null); // Simplificado

        return responseDTO;
    }

    /**
     * Valida a existência de entidades de dados mestre.
     *
     * @param ids        Lista de UUIDs a serem validados.
     * @param finder     Função para encontrar a entidade por ID.
     * @param entityName Nome da entidade para mensagens de erro.
     * @param <T>        Tipo da entidade.
     */
    private <T> void validateMasterDataExistence(List<UUID> ids,
            java.util.function.Function<UUID, java.util.Optional<T>> finder, String entityName) {
        for (UUID id : ids) {
            if (finder.apply(id).isEmpty()) {
                throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        entityName + " com ID " + id + " não encontrado(a).");
            }
        }
    }

    public Map<String, List<String>> listarLocalizacoesDisponiveis() {
        List<Object[]> resultados = profissionalRepository.findDistinctEstadosAndCidades();
        Map<String, List<String>> localizacoes = new HashMap<>();

        for (Object[] row : resultados) {
            String estado = (String) row[0];
            String cidade = (String) row[1];
            localizacoes.computeIfAbsent(estado, k -> new ArrayList<>()).add(cidade);
        }
        return localizacoes;
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Tipos de Atendimento (dados mestre).
 */
@Service
public class TipoAtendimentoService {

    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public TipoAtendimentoService(TipoAtendimentoRepository tipoAtendimentoRepository,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Busca um Tipo de Atendimento pelo ID.
     *
     * @param id ID do Tipo de Atendimento.
     * @return DTO do Tipo de Atendimento.
     * @throws BusinessException se o Tipo de Atendimento não for encontrado.
     */
    public TipoAtendimentoResponseDTO findTipoAtendimentoById(UUID id) {
        TipoAtendimento tipoAtendimento = tipoAtendimentoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Tipo de Atendimento não encontrado."));
        return tipoAtendimentoMapper.toResponseDTO(tipoAtendimento);
    }

    /**
     * Lista todos os Tipos de Atendimento.
     *
     * @return Lista de DTOs de Tipos de Atendimento.
     */
    public List<TipoAtendimentoResponseDTO> findAllTiposAtendimento() {
        return tipoAtendimentoRepository.findAll().stream()
                .map(tipoAtendimentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.commom.dto.request; // Assumindo um pacote common.dto.request para entidades comuns

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private String id; // Pode ser UUID ou String, dependendo da BaseEntity

    @NotBlank(message = "O logradouro é obrigatório.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número é obrigatório.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro é obrigatório.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade é obrigatória.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado é obrigatório.")
    @Size(max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP é obrigatório.")
    @Size(max = 9, message = "O CEP deve ter no máximo 9 caracteres.") // Com ou sem máscara
    private String cep;

    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais; // Valor padrão "Brasil" pode ser setado no serviço

    @NotNull(message = "O tipo de endereço é obrigatório.")
    private TipoEndereco tipoEndereco; // Usando o enum da entidade
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * DTO para requisição de criação ou atualização de uma Pessoa.
 * Inclui campos de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // ID é opcional para atualização (usado em PUT/put para identificar a Pessoa)
    private UUID id;

    @Valid
    @NotNull(message = "As informações do usuário são obrigatórias.")
    private UserRequestDTO usuario; // Informações de login e contato do usuário

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpf;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimento;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefones;

    @Valid
    private List<EnderecoRequestDTO> enderecos; // Lista de endereços associados à pessoa
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    // @NotBlank(message = "A senha do usuário é obrigatória.") // Pode ser
    // @NotBlank apenas na criação
    private String senha; // Em requisições, a senha é enviada em texto limpo para ser hashed no backend

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 14, message = "O CPF deve ter no máximo 14 caracteres.")
    private String cpf; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response; // Assumindo um pacote common.dto.response para entidades comuns

import java.util.UUID;

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;

    private String logradouro;

    private String numero;

    private String complemento;

    private String bairro;

    private String cidade;

    private String estado;

    private String cep;

    private String pais;

    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de uma Pessoa.
 * Inclui informações de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PessoaResponseDTO {
    private UUID id;

    private UserResponseDTO usuario;

    private String nomeCompleto;

    private String cpf;

    private LocalDate dataNascimento;

    private List<String> telefones;

    private List<EnderecoResponseDTO> enderecos;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.commom.model.User.UserStatus; // Importar o enum UserStatus da entidade User
import br.com.legalconnect.commom.model.User.UserType; // Importar o enum UserType da entidade User
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
package br.com.legalconnect.commom.mapper;

import java.util.UUID;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.EnderecoRequestDTO;
import br.com.legalconnect.commom.dto.response.EnderecoResponseDTO;
import br.com.legalconnect.commom.model.Endereco;

/**
 * Mapper MapStruct para a entidade Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {
    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * Mapeia um EnderecoRequestDTO para uma entidade Endereco.
     * Os campos 'pessoa' e 'empresa' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Endereco correspondente.
     */
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true) // Descomente se Empresa for
    // relevante e existir
    @Mapping(target = "id", source = "id", qualifiedByName = "mapStringToUuid")
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * Mapeia uma entidade Endereco para um EnderecoResponseDTO.
     *
     * @param entity A entidade Endereco.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id", qualifiedByName = "mapUuidToString")
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * Atualiza uma entidade Endereco existente com os dados de um
     * EnderecoRequestDTO.
     * O campo 'pessoa' e 'empresa' não são atualizados via DTO. O ID não deve ser
     * atualizado.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Endereco a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true)
    void updateEntityFromDto(EnderecoRequestDTO dto, @MappingTarget Endereco entity);

    /**
     * Converte uma String (ID do DTO) para um UUID (ID da Entidade).
     * 
     * @param id A string representando o UUID.
     * @return O objeto UUID.
     */
    @Named("mapStringToUuid")
    default UUID mapStringToUuid(UUID id) {
        return id != null ? (id) : null;
    }

    /**
     * Converte um UUID (ID da Entidade) para uma String (ID do DTO).
     * 
     * @param id O objeto UUID.
     * @return A string representando o UUID.
     */
    @Named("mapUuidToString")
    default String mapUuidToString(UUID id) {
        return id != null ? id.toString() : null;
    }
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.model.Pessoa;

/**
 * Mapper MapStruct para a entidade Pessoa e seus DTOs.
 * Utiliza UserMapper e EnderecoMapper para mapeamentos aninhados.
 */
@Mapper(componentModel = "spring", uses = { UserMapper.class, EnderecoMapper.class })
public interface PessoaMapper {
    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * Mapeia um PessoaRequestDTO para uma entidade Pessoa.
     * Os campos 'usuario' e 'enderecos' serão mapeados pelos mappers especificados
     * em 'uses'.
     * A conversão de List para Set para 'telefones' é feita automaticamente pelo
     * MapStruct.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Pessoa correspondente.
     */
    // @Mapping(target = "id", ignore = true) // ID da Pessoa será gerado na criação
    // Pessoa toEntity(PessoaRequestDTO dto);

    /**
     * Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     *
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta correspondente.
     */
    PessoaResponseDTO toResponseDTO(Pessoa entity);

    /**
     * Atualiza uma entidade Pessoa existente com os dados de um PessoaRequestDTO.
     * O 'id' da Pessoa não deve ser atualizado.
     * A atualização de 'usuario' e 'enderecos' deve ser orquestrada no serviço,
     * pois o MapStruct pode não ter o contexto para atualizar entidades aninhadas
     * existentes.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Pessoa a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "usuario", ignore = true) // O serviço deve gerenciar a atualização do User associado
    @Mapping(target = "enderecos", ignore = true) // O serviço deve gerenciar a atualização dos Enderecos associados
    @Mapping(source = "telefones", target = "telefones") // Converte List<String> para Set<String>
    void updateEntityFromDto(PessoaRequestDTO dto, @MappingTarget Pessoa entity);
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.UserResponseDTO;
import br.com.legalconnect.commom.model.User;

/**
 * Mapper MapStruct para a entidade User e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * Mapeia um UserRequestDTO para uma entidade User.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' são definidos pela lógica de negócio e ignorados
     * aqui.
     *
     * @param dto O DTO de requisição.
     * @return A entidade User correspondente.
     */
    @Mapping(source = "senha", target = "senhaHash") // Mapeia a senha do DTO para senhaHash na entidade
    // @Mapping(target = "userType", ignore = true) // Definido pela lógica de
    // negócio
    // @Mapping(target = "userStatus", ignore = true) // Definido pela lógica de
    // negócio
    User toEntity(UserRequestDTO dto);

    /**
     * Mapeia uma entidade User para um UserResponseDTO.
     * 'senhaHash' é ignorado na resposta por segurança.
     *
     * @param entity A entidade User.
     * @return O DTO de resposta correspondente.
     */
    // @Mapping(target = "senha", ignore = true) // 'senhaHash' é um campo interno
    // da entidade, não deve ser exposto no DTO de resposta
    UserResponseDTO toResponseDTO(User entity);

    /**
     * Atualiza uma entidade User existente com os dados de um UserRequestDTO.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade User a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(source = "senha", target = "senhaHash")
    // @Mapping(target = "userType", ignore = true)
    // @Mapping(target = "userStatus", ignore = true)
    void updateEntityFromDto(UserRequestDTO dto, @MappingTarget User entity);
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "empresa_id")
    // private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.commom.model;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.Pessoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Pessoa}.
 * Gerencia operações de persistência para informações de pessoas no sistema.
 */
@Repository
public interface PessoaRepository extends JpaRepository<Pessoa, UUID> {

    /**
     * Verifica se existe uma Pessoa com o CPF fornecido.
     * Regra de Negócio: Garante a unicidade do CPF no sistema.
     *
     * @param cpf O CPF a ser verificado.
     * @return true se uma Pessoa com o CPF já existe, false caso contrário.
     */
    boolean existsByCpf(String cpf);

    /**
     * Busca uma Pessoa pelo ID do usuário associado.
     *
     * @param userId O ID do usuário.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByUsuarioId(UUID userId);

    /**
     * Busca uma Pessoa pelo CPF.
     *
     * @param cpf O CPF da Pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu endereço de e-mail.
     * Regra de Negócio: O e-mail é único para cada usuário dentro de um tenant.
     *
     * @param email O endereço de e-mail do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * Verifica se um usuário com o endereço de e-mail fornecido já existe.
     * Regra de Negócio: Garante a unicidade do e-mail no sistema.
     *
     * @param email O endereço de e-mail a ser verificado.
     * @return true se um usuário com o e-mail já existe, false caso contrário.
     */
    boolean existsByEmail(String email);
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço simulado para envio de e-mails.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com um provedor de e-mails
 * como SendGrid, Amazon SES, ou o serviço de e-mail do Spring Boot.
 */
@Service
public class EmailService {

    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    /**
     * Simula o envio de um e-mail de ativação de conta.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param activationLink O link de ativação da conta.
     */
    public void sendActivationEmail(String toEmail, String activationLink) {
        log.info("Simulando envio de e-mail de ativação para: {}", toEmail);
        log.info("Link de Ativação: {}", activationLink);
        // Lógica real de envio de e-mail seria aqui, por exemplo:
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(toEmail);
        // helper.setSubject("Ative sua conta na LegalConnect!");
        // helper.setText("Olá! Clique no link para ativar sua conta: " + activationLink, true);
        // mailSender.send(message);
        log.info("E-mail de ativação simulado enviado com sucesso.");
    }

    /**
     * Simula o envio de um e-mail de confirmação de agendamento.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param details Detalhes do agendamento.
     */
    public void sendAppointmentConfirmationEmail(String toEmail, String details) {
        log.info("Simulando envio de e-mail de confirmação de agendamento para: {}", toEmail);
        log.info("Detalhes do Agendamento: {}", details);
        log.info("E-mail de confirmação de agendamento simulado enviado com sucesso.");
    }

    // Outros métodos de envio de e-mail podem ser adicionados conforme a necessidade
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;
import br.com.legalconnect.commom.mapper.UserMapper;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.model.User;
import br.com.legalconnect.commom.repository.PessoaRepository; // Assumindo a existência de PessoaRepository
import br.com.legalconnect.commom.repository.UserRepository; // Assumindo a existência de UserRepository
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das entidades Pessoa e User.
 * Centraliza a lógica de negócio para criação, atualização e busca de Pessoas
 * e seus usuários associados, incluindo validações de unicidade e criptografia
 * de senha.
 */
@Service
public class PessoaService {

    private final PessoaRepository pessoaRepository;
    private final UserRepository userRepository;
    private final PessoaMapper pessoaMapper;
    private final UserMapper userMapper;
    // Assumindo um EnderecoMapper se EnderecoRequestDTO for mapeado para Endereco
    // aqui
    // private final EnderecoMapper enderecoMapper;

    @Autowired
    public PessoaService(PessoaRepository pessoaRepository, UserRepository userRepository,
            PessoaMapper pessoaMapper, UserMapper userMapper) {
        this.pessoaRepository = pessoaRepository;
        this.userRepository = userRepository;
        this.pessoaMapper = pessoaMapper;
        this.userMapper = userMapper;
    }

    /**
     * Cria uma nova Pessoa e seu User associado.
     * Regras de Negócio:
     * - Garante que o CPF e o e-mail do usuário sejam únicos no sistema.
     * - Criptografa a senha antes de salvar.
     * - Define o status inicial do usuário como PENDING para aguardar ativação.
     *
     * @param pessoaRequestDTO DTO com os dados da Pessoa e do User.
     * @return DTO da Pessoa criada.
     * @throws BusinessException se o CPF ou e-mail já estiverem cadastrados.
     */
    @Transactional
    public Pessoa createPessoa(PessoaRequestDTO pessoaRequestDTO) {
        // Regra de Negócio: Validar unicidade de CPF
        if (pessoaRepository.existsByCpf(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, pessoaRequestDTO.getCpf());
        }

        // Regra de Negócio: Validar unicidade de e-mail para o usuário
        if (userRepository.existsByEmail(pessoaRequestDTO.getUsuario().getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    pessoaRequestDTO.getUsuario().getEmail());
        }

        // Cria e criptografa o usuário

        // Persiste o usuário
        var newUser = new User();
        newUser.setId((pessoaRequestDTO.getUsuario().getId()));

        // Cria a Pessoa e associa o usuário
        Pessoa newPessoa = Pessoa.builder()
                .usuario(newUser)
                .nomeCompleto(pessoaRequestDTO.getNomeCompleto())
                .cpf(pessoaRequestDTO.getCpf())
                .dataNascimento(pessoaRequestDTO.getDataNascimento())
                .telefones(new HashSet<>(pessoaRequestDTO.getTelefones()))
                .build();

        // Adiciona endereços
        if (pessoaRequestDTO.getEnderecos() != null && !pessoaRequestDTO.getEnderecos().isEmpty()) {
            Set<Endereco> enderecos = pessoaRequestDTO.getEnderecos().stream()
                    .map(dto -> {
                        Endereco endereco = new Endereco(); // Ou use enderecoMapper.toEntity(dto) se existir
                        endereco.setLogradouro(dto.getLogradouro());
                        endereco.setNumero(dto.getNumero());
                        endereco.setComplemento(dto.getComplemento());
                        endereco.setBairro(dto.getBairro());
                        endereco.setCidade(dto.getCidade());
                        endereco.setEstado(dto.getEstado());
                        endereco.setCep(dto.getCep());
                        endereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil"); // Define país padrão
                        endereco.setTipoEndereco(dto.getTipoEndereco());
                        endereco.setPessoa(newPessoa); // Associa o endereço à Pessoa
                        return endereco;
                    }).collect(Collectors.toSet());
            newPessoa.setEnderecos(enderecos);
        }
        // Reassigning to make it effectively final
        return (pessoaRepository.save(newPessoa));
    }

    /**
     * Busca uma Pessoa pelo ID.
     *
     * @param id ID da Pessoa.
     * @return DTO da Pessoa encontrada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    public PessoaResponseDTO findPessoaById(UUID id) {
        Pessoa pessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * Atualiza os dados de uma Pessoa existente.
     * Regras de Negócio:
     * - Permite a atualização de informações da Pessoa e do User associado.
     * - Valida a unicidade do e-mail se for alterado.
     * - Não permite a alteração do CPF.
     *
     * @param id               ID da Pessoa a ser atualizada.
     * @param pessoaRequestDTO DTO com os dados para atualização.
     * @return DTO da Pessoa atualizada.
     * @throws BusinessException se a Pessoa não for encontrada, ou se o e-mail já
     *                           estiver cadastrado.
     */
    @Transactional
    public PessoaResponseDTO updatePessoa(UUID id, PessoaRequestDTO pessoaRequestDTO) {
        Pessoa existingPessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada para atualização."));

        // Não permitir alteração de CPF (Regra de Negócio)
        if (!existingPessoa.getCpf().equals(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "Não é permitido alterar o CPF de uma pessoa existente.");
        }

        // Atualiza o User associado
        User existingUser = existingPessoa.getUsuario();
        UserRequestDTO userRequestDTO = pessoaRequestDTO.getUsuario();

        // Valida unicidade de e-mail se o e-mail for alterado
        if (!existingUser.getEmail().equals(userRequestDTO.getEmail())
                && userRepository.existsByEmail(userRequestDTO.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT, userRequestDTO.getEmail());
        }

        userMapper.updateEntityFromDto(userRequestDTO, existingUser);
        userRepository.save(existingUser); // Salva as alterações no User

        // Atualiza os dados da Pessoa (exceto usuário e endereços que são gerenciados
        // separadamente)
        pessoaMapper.updateEntityFromDto(pessoaRequestDTO, existingPessoa);

        // Lógica para gerenciar Endereços: Adicionar, Atualizar, Remover
        // Isso pode ser complexo e requer lógica manual, pois EndereçoRequestDTO tem ID
        // opcional
        // Para simplificar, vou redefinir os endereços ou adicionar lógica de
        // diferenciação.
        // Uma abordagem mais robusta seria comparar listas e fazer operações de CRUD
        // individualmente.
        if (pessoaRequestDTO.getEnderecos() != null) {
            // Removendo endereços que não estão no DTO
            existingPessoa.getEnderecos().removeIf(existingEndereco -> pessoaRequestDTO.getEnderecos().stream()
                    .noneMatch(dto -> dto.getId() != null && dto.getId().equals(existingEndereco.getId().toString())));

            // Adicionando ou atualizando endereços
            for (br.com.legalconnect.commom.dto.request.EnderecoRequestDTO dto : pessoaRequestDTO.getEnderecos()) {
                if (dto.getId() == null) {
                    // Novo endereço
                    Endereco newEndereco = new Endereco();
                    newEndereco.setLogradouro(dto.getLogradouro());
                    newEndereco.setNumero(dto.getNumero());
                    newEndereco.setComplemento(dto.getComplemento());
                    newEndereco.setBairro(dto.getBairro());
                    newEndereco.setCidade(dto.getCidade());
                    newEndereco.setEstado(dto.getEstado());
                    newEndereco.setCep(dto.getCep());
                    newEndereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                    newEndereco.setTipoEndereco(dto.getTipoEndereco());
                    newEndereco.setPessoa(existingPessoa);
                    existingPessoa.getEnderecos().add(newEndereco);
                } else {
                    // Atualizar endereço existente
                    existingPessoa.getEnderecos().stream()
                            .filter(e -> e.getId().toString().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> {
                                e.setLogradouro(dto.getLogradouro());
                                e.setNumero(dto.getNumero());
                                e.setComplemento(dto.getComplemento());
                                e.setBairro(dto.getBairro());
                                e.setCidade(dto.getCidade());
                                e.setEstado(dto.getEstado());
                                e.setCep(dto.getCep());
                                e.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                                e.setTipoEndereco(dto.getTipoEndereco());
                            });
                }
            }
        }

        existingPessoa = pessoaRepository.save(existingPessoa);
        return pessoaMapper.toResponseDTO(existingPessoa);
    }

    /**
     * Deleta uma Pessoa pelo ID.
     * Regras de Negócio:
     * - Também deleta o User associado devido ao CascadeType.ALL na Pessoa.
     *
     * @param id ID da Pessoa a ser deletada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    @Transactional
    public void deletePessoa(UUID id) {
        if (!pessoaRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                    "Pessoa não encontrada para deleção.");
        }
        pessoaRepository.deleteById(id);
    }

    public Optional<LocalAtuacao> findPessoaByCpf(String cpf) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByCpf'");
    }

    public Optional<LocalAtuacao> findPessoaByEmail(String email) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByEmail'");
    }
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço de integração simulada com AWS S3 para upload e deleção de arquivos.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a AWS
 * SDK.
 */
@Service
public class S3Service {

    private static final Logger log = LoggerFactory.getLogger(S3Service.class);
    private static final String MOCK_S3_BASE_URL = "https://mock-s3-bucket.s3.amazonaws.com/";

    /**
     * Simula o upload de um arquivo para o S3.
     *
     * @param fileBytes Os bytes do arquivo.
     * @param key       A chave/caminho do arquivo no bucket S3.
     * @param mimeType  O tipo MIME do arquivo.
     * @return A URL pública do arquivo no S3.
     * @throws BusinessException se ocorrer um erro durante o "upload" simulado.
     */
    public String uploadFile(byte[] fileBytes, String key, String mimeType) {
        if (fileBytes == null || fileBytes.length == 0) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "O conteúdo do arquivo não pode ser vazio.");
        }
        if (key == null || key.isEmpty()) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "A chave do S3 não pode ser vazia.");
        }

        // Simulação de upload: Loga a operação e retorna uma URL mock
        log.info("Simulando upload para S3. Chave: {}, Tamanho: {} bytes, Tipo: {}", key, fileBytes.length, mimeType);
        String fileUrl = MOCK_S3_BASE_URL + key;
        log.info("Upload simulado concluído. URL: {}", fileUrl);
        return fileUrl;
    }

    /**
     * Simula a deleção de um arquivo do S3.
     *
     * @param fileUrl A URL pública do arquivo a ser deletado.
     * @throws BusinessException se ocorrer um erro durante a "deleção" simulada.
     */
    public void deleteFile(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "URL do arquivo não pode ser vazia para deleção.");
        }

        // Simulação de deleção: Loga a operação
        log.info("Simulando deleção de S3. URL: {}", fileUrl);
        // Em um ambiente real, aqui estaria a chamada para o AWS S3 SDK para deletar o
        // objeto.
        // Por exemplo: s3Client.deleteObject(bucketName, key);
        log.info("Deleção simulada concluída para URL: {}", fileUrl);
    }
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.UUID;

/**
 * Utilitário para gerenciar o ID do Tenant no contexto da thread atual.
 * Usado em arquiteturas multitenant para garantir que as operações de banco de dados
 * sejam filtradas pelo tenant correto.
 */
public class TenantContext {

    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();

    /**
     * Define o ID do Tenant para a thread atual.
     *
     * @param tenantId O ID do Tenant.
     */
    public static void setCurrentTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }

    /**
     * Retorna o ID do Tenant da thread atual.
     *
     * @return O ID do Tenant.
     * @throws IllegalStateException se o Tenant ID não estiver definido no contexto.
     */
    public static UUID getCurrentTenantId() {
        UUID tenantId = currentTenant.get();
        if (tenantId == null) {
            // Em um ambiente real, você pode lançar uma exceção ou retornar um tenant padrão
            // dependendo da lógica de segurança e acesso.
            // Por simplicidade para este exercício, lançaremos uma exceção.
            throw new IllegalStateException("Tenant ID não está definido no contexto da requisição. Verifique o filtro de segurança.");
        }
        return tenantId;
    }

    /**
     * Limpa o ID do Tenant da thread atual.
     * Deve ser chamado ao final da requisição para evitar vazamentos de contexto.
     */
    public static void clear() {
        currentTenant.remove();
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-advogados
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

 
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
package br.com.legalconnect.legal_usuario;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LegalUsuarioApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(basePackages = {
		"br.com.legalconnect.advogado.repository",
		"br.com.legalconnect.commom.repository" })
@EntityScan(basePackages = {
		"br.com.legalconnect.commom.model",
		"br.com.legalconnect.advogado.domain" })
@EnableDiscoveryClient
@SpringBootApplication
public class LegalUsuarioApplication {
	// @Value("${application.tenant.default-id}")
	// private String defaultTenantId;

	// @Autowired
	// private TenantMigrationService tenantMigrationService;

	public static void main(String[] args) {
		SpringApplication.run(LegalUsuarioApplication.class, args);
	}
}
// @Bean
// boolean inicio() {
// tenantMigrationService.migrateTenant(defaultTenantId);
// return true;
// }
// }

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.ERRO;
import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.service.AgendamentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.NotNull;

/**
 * Controller para o módulo de Agendamento de Consultas.
 * Gerencia as operações relacionadas ao agendamento e avaliação de consultas
 * entre clientes e profissionais.
 */
@RestController
@RequestMapping("/api/v1/advogados/agendamentos")
@Tag(name = "Agendamentos", description = "Gerenciamento de agendamentos de consultas e avaliações")
public class AgendamentoController {

        private final AgendamentoService agendamentoService;

        @Autowired
        public AgendamentoController(AgendamentoService agendamentoService) {
                this.agendamentoService = agendamentoService;
        }

        /**
         * Realiza o agendamento de uma consulta.
         * Funcionalidade Completa: Cenário 1 (Cliente busca e agenda) e Cenário 2
         * (Advogado recebe e confirma).
         * Regras de Negócio: Verifica disponibilidade do profissional, profissional
         * deve estar ativo e usar marketplace, integração com Google Calendar, envio de
         * e-mails.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta (formato ISO).
         * @param tipoServico        Tipo de serviço agendado.
         * @return ResponseEntity indicando o sucesso do agendamento.
         */
        @Operation(summary = "Agenda uma nova consulta", description = "Permite a um cliente agendar uma consulta com um profissional, verificando disponibilidade e enviando notificações.", responses = {
                        @ApiResponse(responseCode = "201", description = "Consulta agendada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: horário indisponível)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de agendamento (horário já ocupado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/agendar")
        public ResponseEntity<BaseResponse<Boolean>> agendarConsulta(
                        @Parameter(description = "ID do profissional para o agendamento") @RequestParam @NotNull UUID profissionalId,
                        @Parameter(description = "ID do cliente que está agendando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Horário desejado para a consulta (formato ISO 8601, ex: 2024-07-25T10:00:00)") @RequestParam @NotNull @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime horarioAgendamento,
                        @Parameter(description = "Tipo de serviço a ser agendado (ex: 'Consulta Online', 'Reunião Presencial')") @RequestParam @NotNull String tipoServico) {

                boolean sucesso = agendamentoService.agendarConsulta(profissionalId, clienteId, horarioAgendamento,
                                tipoServico);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Boolean>builder()
                                                .status(SUCESSO)
                                                .message("Consulta agendada com sucesso.")
                                                .data(sucesso)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Permite ao cliente avaliar uma consulta.
         * Funcionalidade Completa: Cenário 3 (Cliente avalia e influencia ranking).
         * Regras de Negócio: Associa avaliação ao agendamento e profissional, atualiza
         * média de avaliação.
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return ResponseEntity indicando o sucesso da avaliação.
         */
        @Operation(summary = "Avalia uma consulta", description = "Permite a um cliente fornecer uma nota e um comentário para uma consulta já realizada.", responses = {
                        @ApiResponse(responseCode = "200", description = "Consulta avaliada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: nota fora do intervalo)"),
                        @ApiResponse(responseCode = "404", description = "Agendamento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/avaliar")
        public ResponseEntity<BaseResponse<Boolean>> avaliarConsulta(
                        @Parameter(description = "ID do agendamento a ser avaliado") @RequestParam @NotNull UUID agendamentoId,
                        @Parameter(description = "ID do cliente que está avaliando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Nota da avaliação (1 a 5)") @RequestParam @NotNull int rating,
                        @Parameter(description = "Comentário opcional sobre a avaliação") @RequestParam(required = false) String comentario) {

                // Regra de Negócio: Rating deve estar entre 1 e 5
                if (rating < 1 || rating > 5) {
                        return ResponseEntity.badRequest().body(BaseResponse.<Boolean>builder()
                                        .status(ERRO)
                                        .message("A nota da avaliação deve ser entre 1 e 5.")
                                        .data(false)
                                        .timestamp(java.time.LocalDateTime.now())
                                        .build());
                }

                boolean sucesso = agendamentoService.avaliarConsulta(agendamentoId, clienteId, rating, comentario);
                return ResponseEntity.ok(BaseResponse.<Boolean>builder()
                                .status(SUCESSO)
                                .message("Consulta avaliada com sucesso.")
                                .data(sucesso)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Áreas de Atuação (dados mestre).
 * Oferece endpoints para consultar as áreas de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/areas-atuacao")
@Tag(name = "Áreas de Atuação", description = "Gerenciamento de dados mestre de Áreas de Atuação")
public class AreaAtuacaoController {

        private final AreaAtuacaoService areaAtuacaoService;

        @Autowired
        public AreaAtuacaoController(AreaAtuacaoService areaAtuacaoService) {
                this.areaAtuacaoService = areaAtuacaoService;
        }

        /**
         * Busca uma Área de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID da Área de Atuação.
         * @return ResponseEntity com o DTO da Área de Atuação.
         */
        @Operation(summary = "Busca uma área de atuação pelo ID", description = "Retorna os detalhes de uma área de atuação específica.", responses = {
                        @ApiResponse(responseCode = "200", description = "Área de Atuação encontrada com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Área de Atuação não encontrada"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<AreaAtuacaoResponseDTO>> getAreaAtuacaoById(
                        @Parameter(description = "ID da Área de Atuação") @PathVariable UUID id) {
                AreaAtuacaoResponseDTO response = areaAtuacaoService.findAreaAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<AreaAtuacaoResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Área de Atuação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.service.IdiomaService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Idiomas (dados mestre).
 * Oferece endpoints para consultar os idiomas disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/idiomas")
@Tag(name = "Idiomas", description = "Gerenciamento de dados mestre de Idiomas")
public class IdiomaController {

        private final IdiomaService idiomaService;

        @Autowired
        public IdiomaController(IdiomaService idiomaService) {
                this.idiomaService = idiomaService;
        }

        /**
         * Busca um Idioma pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Idioma.
         * @return ResponseEntity com o DTO do Idioma.
         */
        @Operation(summary = "Busca um idioma pelo ID", description = "Retorna os detalhes de um idioma específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idioma encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Idioma não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<IdiomaResponseDTO>> getIdiomaById(
                        @Parameter(description = "ID do idioma") @PathVariable UUID id) {
                IdiomaResponseDTO response = idiomaService.findIdiomaById(id);
                return ResponseEntity.ok(BaseResponse.<IdiomaResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idioma encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Idiomas.
         * Funcionalidade Completa: Listagem de todos os idiomas disponíveis para
         * seleção pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Idiomas.
         */
        @Operation(summary = "Lista todos os idiomas", description = "Retorna uma lista de todos os idiomas cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idiomas listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<IdiomaResponseDTO>>> getAllIdiomas() {
                List<IdiomaResponseDTO> response = idiomaService.findAllIdiomas();
                return ResponseEntity.ok(BaseResponse.<List<IdiomaResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idiomas listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.LocalAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Locais de Atuação (dados mestre).
 * Oferece endpoints para consultar os locais de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/locais-atuacao")
@Tag(name = "Locais de Atuação", description = "Gerenciamento de dados mestre de Locais de Atuação")
public class LocalAtuacaoController {

        private final LocalAtuacaoService localAtuacaoService;

        @Autowired
        public LocalAtuacaoController(LocalAtuacaoService localAtuacaoService) {
                this.localAtuacaoService = localAtuacaoService;
        }

        /**
         * Busca um Local de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Local de Atuação.
         * @return ResponseEntity com o DTO do Local de Atuação.
         */
        @Operation(summary = "Busca um local de atuação pelo ID", description = "Retorna os detalhes de um local de atuação específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Local de Atuação encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Local de Atuação não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<LocalAtuacaoResponseDTO>> getLocalAtuacaoById(
                        @Parameter(description = "ID do Local de Atuação") @PathVariable UUID id) {
                LocalAtuacaoResponseDTO response = localAtuacaoService.findLocalAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<LocalAtuacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Local de Atuação encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Locais de Atuação.
         * Funcionalidade Completa: Listagem de todos os locais disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Locais de Atuação.
         */
        @Operation(summary = "Lista todos os locais de atuação", description = "Retorna uma lista de todos os locais de atuação cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Locais de Atuação listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<LocalAtuacaoResponseDTO>>> getAllLocaisAtuacao() {
                List<LocalAtuacaoResponseDTO> response = localAtuacaoService.findAllLocaisAtuacao();
                return ResponseEntity.ok(BaseResponse.<List<LocalAtuacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Locais de Atuação listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.service.CertificacaoService;
import br.com.legalconnect.advogado.service.DocumentoService;
import br.com.legalconnect.advogado.service.ExperienciaProfissionalService;
import br.com.legalconnect.advogado.service.FormacaoAcademicaService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * Controller para o módulo de Profissionais (Advogados).
 * Gerencia as operações REST para perfis de advogados,
 * incluindo suas certificações, experiências, formações e documentos.
 */
@RestController
@RequestMapping("/api/v1/advogados/profissionais")
@Tag(name = "Profissionais", description = "Gerenciamento de perfis de Advogados")
public class ProfissionalController {

        private final ProfissionalService profissionalService;
        private final CertificacaoService certificacaoService;
        private final ExperienciaProfissionalService experienciaProfissionalService;
        private final FormacaoAcademicaService formacaoAcademicaService;
        private final DocumentoService documentoService;

        @Autowired
        public ProfissionalController(ProfissionalService profissionalService,
                        CertificacaoService certificacaoService,
                        ExperienciaProfissionalService experienciaProfissionalService,
                        FormacaoAcademicaService formacaoAcademicaService,
                        DocumentoService documentoService) {
                this.profissionalService = profissionalService;
                this.certificacaoService = certificacaoService;
                this.experienciaProfissionalService = experienciaProfissionalService;
                this.formacaoAcademicaService = formacaoAcademicaService;
                this.documentoService = documentoService;
        }

        // ***************************************

        /**
         * Lista todas as localizações (estados e cidades) onde há profissionais.
         * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
         * cidades.
         *
         * @return ResponseEntity com o mapa de localizações.
         */
        @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/localizacoes")
        public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
                Map<String, List<String>> response = profissionalService.listarLocalizacoesDisponiveis();

                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Map<String, List<String>>>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        // ************************************************ */
        /**
         * Cria um novo profissional (advogado) no sistema.
         * Funcionalidade Completa: Cadastro de Advogado com dados aninhados.
         * Regras de Negócio: Validação de unicidade de OAB, CPF e Email. Associação a
         * um tenant.
         *
         * @param request      DTO com os dados do profissional a ser criado.
         * @param userIdHeader Opcional. ID do usuário logado/solicitante, vindo do
         *                     cabeçalho X-Correlation-Id.
         * @return ResponseEntity com o DTO do profissional criado.
         */
        @Operation(summary = "Cria um novo profissional", description = "Registra um novo advogado com seus dados pessoais e informações profissionais.", responses = {
                        @ApiResponse(responseCode = "201", description = "Profissional criado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "409", description = "OAB, CPF ou Email já cadastrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> createProfissional(
                        @Valid @RequestBody ProfissionalCreateRequest request,
                        @RequestHeader(value = "X-Correlation-Id", required = false) String userIdHeader) {
                if (userIdHeader != null && !userIdHeader.trim().isEmpty()) {
                        try {
                                UUID userUuid = UUID.fromString(userIdHeader); // Validar se é um UUID válido

                                if (request.getUsuario() == null) {
                                        // Se o DTO de usuário não foi fornecido no corpo, cria um com o ID do header
                                        request.setUsuario(UserRequestDTO.builder().id(userUuid).build());
                                } else if (request.getUsuario().getId() == null) {
                                        // Se o DTO de usuário foi fornecido, mas sem ID, usa o do header
                                        request.getUsuario().setId(userUuid);
                                }
                        } catch (IllegalArgumentException e) {
                                // Logar ou tratar erro se userIdHeader não for um UUID válido
                                // Para este caso, vamos apenas logar e ignorar o userIdHeader inválido.
                                System.err.println("X-Correlation-Id inválido: " + userIdHeader
                                                + ". Ignorando ID do cabeçalho.");
                        }
                }

                ProfissionalResponseDTO response = profissionalService.createProfissional(request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza um profissional existente.
         * Funcionalidade Completa: Atualização de perfil de advogado, incluindo dados
         * da Pessoa e coleções aninhadas.
         * Regras de Negócio: Acesso restrito ao próprio tenant, validação de
         * existência.
         *
         * @param id      ID do profissional a ser atualizado.
         * @param request DTO com os dados de atualização.
         * @return ResponseEntity com o DTO do profissional atualizado.
         */
        @Operation(summary = "Atualiza um profissional existente", description = "Atualiza os dados de um advogado, incluindo informações pessoais e coleções relacionadas.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional atualizado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: email duplicado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> updateProfissional(
                        @Parameter(description = "ID do profissional a ser atualizado") @PathVariable UUID id,
                        @Valid @RequestBody ProfissionalUpdateRequest request) {
                ProfissionalResponseDTO response = profissionalService.updateProfissional(id, request);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional atualizado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca um profissional pelo ID.
         * Funcionalidade Completa: Exibição detalhada do perfil de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param id ID do profissional.
         * @return ResponseEntity com o DTO do profissional.
         */
        @Operation(summary = "Busca um profissional pelo ID", description = "Retorna os detalhes completos de um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> getProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID id) {
                ProfissionalResponseDTO response = profissionalService.findProfissionalById(id);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os profissionais do tenant atual com paginação.
         * Funcionalidade Completa: Listagem paginada de advogados para o marketplace ou
         * para gestão interna do tenant.
         * Regras de Negócio: Filtro automático por tenant_id.
         *
         * @param page Número da página (0-indexed).
         * @param size Tamanho da página.
         * @param sort Critério de ordenação (ex: campo,asc ou campo,desc).
         * @return ResponseEntity com a página de DTOs de profissionais.
         */
        @Operation(summary = "Lista todos os profissionais com paginação", description = "Retorna uma lista paginada de todos os advogados associados ao tenant atual.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissionais listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> getAllProfissionais(
                        @Parameter(description = "Número da página (0-indexed)", example = "0") @RequestParam(defaultValue = "0") int page,
                        @Parameter(description = "Tamanho da página", example = "10") @RequestParam(defaultValue = "10") int size,
                        @Parameter(description = "Critério de ordenação (ex: nomeCompleto,asc ou numeroOab,desc)", example = "nomeCompleto,asc") @RequestParam(defaultValue = "nomeCompleto,asc") String[] sort) {

                Sort sortCriteria = Sort.by(Sort.Direction.fromString(sort[1]), sort[0]);
                PageRequest pageable = PageRequest.of(page, size, sortCriteria);

                Page<ProfissionalResponseDTO> response = profissionalService.findAllProfissionais(pageable);
                return ResponseEntity.ok(BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Profissionais listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um profissional pelo ID.
         * Funcionalidade Completa: Remoção completa do perfil do advogado e dados
         * associados.
         * Regras de Negócio: Acesso restrito ao próprio tenant. Deleção em cascata
         * (certificações, experiências, documentos, formação, pessoa).
         *
         * @param id ID do profissional a ser deletado.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um profissional pelo ID", description = "Remove um advogado e todos os seus dados associados do sistema.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deleteProfissional(
                        @Parameter(description = "ID do profissional a ser deletado") @PathVariable UUID id) {
                profissionalService.deleteProfissional(id);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Profissional deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Certificações ---

        /**
         * Adiciona uma certificação a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de certificações.
         * Regras de Negócio: Certificação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da certificação.
         * @return ResponseEntity com a certificação criada.
         */
        @Operation(summary = "Adiciona uma certificação a um profissional", description = "Adiciona uma nova certificação ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Certificação adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> addCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.createCertificacao(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<CertificacaoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Certificação adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma certificação de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma certificação
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a certificação atualizada.
         */
        @Operation(summary = "Atualiza uma certificação de um profissional", description = "Atualiza os detalhes de uma certificação existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> updateCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser atualizada") @PathVariable UUID certificacaoId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.updateCertificacao(profissionalId,
                                certificacaoId,
                                requestDTO);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma certificação específica de um profissional.
         * Funcionalidade Completa: Consulta individual de certificação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity com a certificação encontrada.
         */
        @Operation(summary = "Busca uma certificação específica de um profissional", description = "Retorna os detalhes de uma certificação específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> getCertificacaoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação") @PathVariable UUID certificacaoId) {
                CertificacaoResponseDTO response = certificacaoService.findCertificacaoById(profissionalId,
                                certificacaoId);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as certificações de um profissional.
         * Funcionalidade Completa: Visualização de todas as certificações de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de certificações.
         */
        @Operation(summary = "Lista todas as certificações de um profissional", description = "Retorna uma lista de todas as certificações associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificações listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<List<CertificacaoResponseDTO>>> getAllCertificacoes(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<CertificacaoResponseDTO> response = certificacaoService
                                .findAllCertificacoesByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<CertificacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Certificações listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma certificação de um profissional.
         * Funcionalidade Completa: Remoção de uma certificação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma certificação de um profissional", description = "Remove uma certificação específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser deletada") @PathVariable UUID certificacaoId) {
                certificacaoService.deleteCertificacao(profissionalId, certificacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Certificação deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Experiências Profissionais ---

        /**
         * Adiciona uma experiência profissional a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de experiências.
         * Regras de Negócio: Experiência associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da experiência.
         * @return ResponseEntity com a experiência criada.
         */
        @Operation(summary = "Adiciona uma experiência profissional a um profissional", description = "Adiciona uma nova experiência profissional ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Experiência profissional adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> addExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .createExperienciaProfissional(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Experiência profissional adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma experiência profissional de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma experiência
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a experiência atualizada.
         */
        @Operation(summary = "Atualiza uma experiência profissional de um profissional", description = "Atualiza os detalhes de uma experiência profissional existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> updateExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser atualizada") @PathVariable UUID experienciaId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .updateExperienciaProfissional(profissionalId, experienciaId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma experiência profissional específica de um profissional.
         * Funcionalidade Completa: Consulta individual de experiência.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity com a experiência encontrada.
         */
        @Operation(summary = "Busca uma experiência profissional específica de um profissional", description = "Retorna os detalhes de uma experiência profissional específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> getExperienciaProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência") @PathVariable UUID experienciaId) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .findExperienciaProfissionalById(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         * Funcionalidade Completa: Visualização de todas as experiências de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de experiências.
         */
        @Operation(summary = "Lista todas as experiências profissionais de um profissional", description = "Retorna uma lista de todas as experiências profissionais associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiências profissionais listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<List<ExperienciaProfissionalResponseDTO>>> getAllExperienciasProfissionais(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<ExperienciaProfissionalResponseDTO> response = experienciaProfissionalService
                                .findAllExperienciasProfissionaisByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<ExperienciaProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Experiências profissionais listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         * Funcionalidade Completa: Remoção de uma experiência específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma experiência profissional de um profissional", description = "Remove uma experiência profissional específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<Void>> deleteExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser deletada") @PathVariable UUID experienciaId) {
                experienciaProfissionalService.deleteExperienciaProfissional(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Formações Acadêmicas ---

        /**
         * Adiciona uma formação acadêmica a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de formações.
         * Regras de Negócio: Formação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da formação.
         * @return ResponseEntity com a formação criada.
         */
        @Operation(summary = "Adiciona uma formação acadêmica a um profissional", description = "Adiciona uma nova formação acadêmica ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Formação acadêmica adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> addFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.createFormacaoAcademica(profissionalId,
                                requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Formação acadêmica adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma formação existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a formação atualizada.
         */
        @Operation(summary = "Atualiza uma formação acadêmica de um profissional", description = "Atualiza os detalhes de uma formação acadêmica existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> updateFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser atualizada") @PathVariable UUID formacaoId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.updateFormacaoAcademica(profissionalId,
                                formacaoId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma formação acadêmica específica de um profissional.
         * Funcionalidade Completa: Consulta individual de formação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity com a formação encontrada.
         */
        @Operation(summary = "Busca uma formação acadêmica específica de um profissional", description = "Retorna os detalhes de uma formação acadêmica específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> getFormacaoAcademicaById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação") @PathVariable UUID formacaoId) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.findFormacaoAcademicaById(
                                profissionalId,
                                formacaoId);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         * Funcionalidade Completa: Visualização de todas as formações de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de formações.
         */
        @Operation(summary = "Lista todas as formações acadêmicas de um profissional", description = "Retorna uma lista de todas as formações acadêmicas associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formações acadêmicas listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<List<FormacaoAcademicaResponseDTO>>> getAllFormacoesAcademicas(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<FormacaoAcademicaResponseDTO> response = formacaoAcademicaService
                                .findAllFormacoesAcademicasByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<FormacaoAcademicaResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Formações acadêmicas listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Remoção de uma formação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma formação acadêmica de um profissional", description = "Remove uma formação acadêmica específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser deletada") @PathVariable UUID formacaoId) {
                formacaoAcademicaService.deleteFormacaoAcademica(profissionalId, formacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Documentos ---

        /**
         * Realiza o upload de um documento para um profissional.
         * Funcionalidade Completa: Armazenamento de documentos no S3 e metadados no DB.
         * Regras de Negócio: Associação ao profissional e tenant, validação de formato
         * Base64.
         *
         * @param profissionalId ID do profissional.
         * @param request        DTO com os dados do documento e o arquivo em Base64.
         * @return ResponseEntity com o DTO do documento criado.
         */
        @Operation(summary = "Realiza o upload de um documento para um profissional", description = "Faz o upload de um documento para o S3 e persiste seus metadados para um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Documento enviado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: Base64 inválido)"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Falha ao fazer upload do documento ou erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/documentos/upload")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> uploadDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody DocumentoUploadRequest request) {
                DocumentoResponseDTO response = documentoService.uploadDocumento(profissionalId, request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<DocumentoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Documento enviado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Busca um documento específico de um profissional.
         * Funcionalidade Completa: Consulta individual de documento.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity com o DTO do documento encontrado.
         */
        @Operation(summary = "Busca um documento específico de um profissional", description = "Retorna os detalhes de um documento específico de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> getDocumentoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento") @PathVariable UUID documentoId) {
                DocumentoResponseDTO response = documentoService.findDocumentoById(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<DocumentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Documento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os documentos de um profissional.
         * Funcionalidade Completa: Visualização de todos os documentos de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de documentos.
         */
        @Operation(summary = "Lista todos os documentos de um profissional", description = "Retorna uma lista de todos os documentos associados a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documentos listados com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos")
        public ResponseEntity<BaseResponse<List<DocumentoResponseDTO>>> getAllDocumentos(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<DocumentoResponseDTO> response = documentoService
                                .findAllDocumentosByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<DocumentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Documentos listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um documento de um profissional.
         * Funcionalidade Completa: Remoção do documento do S3 e do banco de dados.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um documento de um profissional", description = "Remove um documento específico do perfil de um advogado, incluindo a remoção do S3.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para deleção"),
                        @ApiResponse(responseCode = "500", description = "Falha ao deletar o documento do S3 ou erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<Void>> deleteDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento a ser deletado") @PathVariable UUID documentoId) {
                documentoService.deleteDocumento(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Documento deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

/**
 * Controller para dados mestre de Localizações.
 * Oferece endpoints para consultar estados e cidades disponíveis.
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/advogados/profissionais") // Caminho da requisição ajustado
@Tag(name = "Localizações", description = "Gerenciamento de dados mestre de Localizações (Estados e Cidades)")
public class ProfissionalPublicoController {

    private final ProfissionalService pessoaService;

    private final AreaAtuacaoService areaAtuacaoService;

    /**
     * Lista todas as localizações (estados e cidades) onde há profissionais.
     * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
     * cidades.
     *
     * @return ResponseEntity com o mapa de localizações.
     */
    @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
            @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/localizacoes")
    public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
        Map<String, List<String>> response = pessoaService.listarLocalizacoesDisponiveis();
        return ResponseEntity.ok(BaseResponse.<Map<String, List<String>>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Localizações listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }

    /**
     * Lista todas as Áreas de Atuação.
     * Funcionalidade Completa: Listagem de todas as áreas disponíveis para seleção
     * pelos advogados.
     * Regras de Negócio: N/A (apenas listagem).
     *
     * @return ResponseEntity com a lista de DTOs de Áreas de Atuação.
     */
    @Operation(summary = "Lista todas as áreas de atuação", description = "Retorna uma lista de todas as áreas de atuação cadastradas.", responses = {
            @ApiResponse(responseCode = "200", description = "Áreas de Atuação listadas com sucesso"),
            @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
    })
    @GetMapping("/areas-atuacao")
    public ResponseEntity<BaseResponse<List<AreaAtuacaoResponseDTO>>> getAllAreasAtuacao() {
        List<AreaAtuacaoResponseDTO> response = areaAtuacaoService.findAllAreasAtuacao();
        return ResponseEntity.ok(BaseResponse.<List<AreaAtuacaoResponseDTO>>builder()
                .status(StatusResponse.SUCESSO)
                .message("Áreas de Atuação listadas com sucesso.")
                .data(response)
                .timestamp(java.time.LocalDateTime.now())
                .build());
    }
}

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.service.TipoAtendimentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Tipos de Atendimento (dados mestre).
 * Oferece endpoints para consultar os tipos de atendimento disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/tipos-atendimento")
@Tag(name = "Tipos de Atendimento", description = "Gerenciamento de dados mestre de Tipos de Atendimento")
public class TipoAtendimentoController {

        private final TipoAtendimentoService tipoAtendimentoService;

        @Autowired
        public TipoAtendimentoController(TipoAtendimentoService tipoAtendimentoService) {
                this.tipoAtendimentoService = tipoAtendimentoService;
        }

        /**
         * Busca um Tipo de Atendimento pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Tipo de Atendimento.
         * @return ResponseEntity com o DTO do Tipo de Atendimento.
         */
        @Operation(summary = "Busca um tipo de atendimento pelo ID", description = "Retorna os detalhes de um tipo de atendimento específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipo de Atendimento encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Tipo de Atendimento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<TipoAtendimentoResponseDTO>> getTipoAtendimentoById(
                        @Parameter(description = "ID do Tipo de Atendimento") @PathVariable UUID id) {
                TipoAtendimentoResponseDTO response = tipoAtendimentoService.findTipoAtendimentoById(id);
                return ResponseEntity.ok(BaseResponse.<TipoAtendimentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Tipo de Atendimento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Tipos de Atendimento.
         * Funcionalidade Completa: Listagem de todos os tipos disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Tipos de Atendimento.
         */
        @Operation(summary = "Lista todos os tipos de atendimento", description = "Retorna uma lista de todos os tipos de atendimento cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipos de Atendimento listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<TipoAtendimentoResponseDTO>>> getAllTiposAtendimento() {
                List<TipoAtendimentoResponseDTO> response = tipoAtendimentoService.findAllTiposAtendimento();
                return ResponseEntity.ok(BaseResponse.<List<TipoAtendimentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Tipos de Atendimento listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Certificacao extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Documento extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissional extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademica extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Idioma extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.commom.model.Pessoa;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId;

    @Column(name = "empresa_id")
    private UUID empresaId;
    @Column(name = "plano_id", nullable = false)
    private UUID planoId;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Certificacao> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Documento> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissional> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademica> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissional> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissional extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimento extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.enums;

/**
 * Enumeração para os tipos de documentos de um Profissional (Advogado).
 * 
 */
public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CertificacaoRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de upload de documento.
 * O campo 'tipoDocumento' foi alterado de String para o enum DocumentoTipo
 * para garantir tipagem segura e validação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    // Alterado de String para o enum DocumentoTipo para tipagem segura
    @NotNull(message = "O tipo do documento é obrigatório.")
    private DocumentoTipo tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim; // Pode ser nulo se for a experiência atual

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para criação de um novo Profissional.
 * Este DTO agora compõe um PessoaRequestDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ProfissionalCreateRequest extends PessoaRequestDTO {

    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;

    // Relacionamentos para dados mestres que podem ser definidos na criação
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // DTOs para certificações, experiências e formações na criação (opcional)
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para atualização de um Profissional.
 * Permite a atualização dos dados da Pessoa associada e dos campos específicos
 * de Profissional,
 * bem como de listas aninhadas.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalUpdateRequest {
    @NotNull(message = "O ID do profissional é obrigatório para atualização.")
    private UUID id;

    @Valid
    // A PessoaRequestDTO interna deve ter seu próprio ID se for uma atualização de
    // pessoa existente
    private PessoaRequestDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId; // Pode ser nulo se não houver empresa associada ou se for desvinculada

    private UUID planoId; // Pode ser nulo se o plano não for alterado

    // Listas de UUIDs para dados mestres
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // Listas de DTOs aninhados para certificações, experiências, formações
    // O ID em cada DTO aninhado indicará se é uma criação, atualização ou remoção.
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Área de Atuação.
 * Usado para retornar detalhes completos da Área de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AreaAtuacaoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Documento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Idioma.
 * Usado para retornar detalhes completos do Idioma.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdiomaResponseDTO {
    private UUID id;
    private String nome;
    private String codigo;
    private String nivel;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Local de Atuação.
 * Usado para retornar detalhes completos do Local de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LocalAtuacaoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.response.PessoaResponseDTO; // Importar PessoaResponseDTO
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta detalhada para um Profissional.
 * Agora compõe um PessoaResponseDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalResponseDTO {
    private UUID id; // ID do Profissional

    private PessoaResponseDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;

    // IDs de entidades relacionadas
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    // Listas de DTOs aninhados
    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    // Listas de DTOs de dados mestres (detalhados)
    private List<LocalAtuacaoResponseDTO> locaisAtuacao;
    private List<AreaAtuacaoResponseDTO> areasAtuacao;
    private List<IdiomaResponseDTO> idiomas;
    private List<TipoAtendimentoResponseDTO> tiposAtendimento;
    private List<RoleProfissionalResponseDTO> rolesProfissional; // DTO para Role do Profissional
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Role de Profissional.
 * Usado para retornar detalhes completos da Role.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleProfissionalResponseDTO {
    private UUID id;
    private String name;
    // O tenantId pode ser incluído se for relevante para o frontend
    // private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Tipo de Atendimento.
 * Usado para retornar detalhes completos do Tipo de Atendimento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TipoAtendimentoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade AreaAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface AreaAtuacaoMapper {
    AreaAtuacaoMapper INSTANCE = Mappers.getMapper(AreaAtuacaoMapper.class);

    /**
     * Mapeia uma entidade AreaAtuacao para um AreaAtuacaoResponseDTO.
     * 
     * @param entity A entidade AreaAtuacao.
     * @return O DTO de resposta correspondente.
     */
    AreaAtuacaoResponseDTO toResponseDTO(AreaAtuacao entity);

    /**
     * Mapeia um AreaAtuacaoResponseDTO para uma entidade AreaAtuacao.
     * Útil para cenários de re-conversão ou testes, embora a criação normalmente
     * venha de um RequestDTO.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade AreaAtuacao correspondente.
     */
    AreaAtuacao toEntity(AreaAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade Certificacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface CertificacaoMapper {
    CertificacaoMapper INSTANCE = Mappers.getMapper(CertificacaoMapper.class);

    /**
     * Mapeia um CertificacaoRequestDTO para uma entidade Certificacao.
     * O campo 'profissional' e 'tenantId' na entidade devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Certificacao correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    Certificacao toEntity(CertificacaoRequestDTO dto);

    /**
     * Mapeia uma entidade Certificacao para um CertificacaoResponseDTO.
     *
     * @param entity A entidade Certificacao.
     * @return O DTO de resposta correspondente.
     */
    CertificacaoResponseDTO toResponseDTO(Certificacao entity);

    /**
     * Atualiza uma entidade Certificacao existente com os dados de um
     * CertificacaoRequestDTO.
     * O campo 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Certificacao a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(CertificacaoRequestDTO dto, @MappingTarget Certificacao entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;

/**
 * Mapper MapStruct para a entidade Documento e seus DTOs.
 * Gerencia a conversão entre DocumentoUploadRequest, Documento e
 * DocumentoResponseDTO.
 */
@Mapper(componentModel = "spring")
public interface DocumentoMapper {
    DocumentoMapper INSTANCE = Mappers.getMapper(DocumentoMapper.class);

    /**
     * Mapeia um DocumentoUploadRequest para uma entidade Documento.
     * Ignora 'arquivoBase64' e 'mimeType' (dados para upload, não persistentes na
     * entidade).
     * 'urlS3', 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição para upload de documento.
     * @return A entidade Documento correspondente.
     */
    @Mapping(target = "urlS3", ignore = true) // Preenchido após o upload bem-sucedido
    @Mapping(target = "profissional", ignore = true) // Relacionamento com Profissional, preenchido no serviço
    @Mapping(target = "tenantId", ignore = true) // TenantId, preenchido no serviço
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    Documento toEntity(DocumentoUploadRequest dto);

    /**
     * Mapeia uma entidade Documento para um DocumentoResponseDTO.
     *
     * @param entity A entidade Documento.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "tipoDocumento", target = "tipoDocumento") // Mapeamento direto de String para String
    DocumentoResponseDTO toResponseDTO(Documento entity);

    /**
     * Atualiza uma entidade Documento existente com os dados de um
     * DocumentoUploadRequest.
     * Campos ignorados: 'id', 'urlS3', 'profissional', 'tenantId'.
     *
     * @param dto    O DTO de requisição.
     * @param entity A entidade Documento a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "urlS3", ignore = true)
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    void updateEntityFromDto(DocumentoUploadRequest dto, @MappingTarget Documento entity);

    /**
     * Converte um enum DocumentoTipo para sua representação em String.
     * Usado para mapear de DTO (enum) para Entidade (String).
     *
     * @param tipo O enum DocumentoTipo.
     * @return A representação em String do enum.
     */
    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipo) {
        return tipo != null ? tipo.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade ExperienciaProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface ExperienciaProfissionalMapper {
    ExperienciaProfissionalMapper INSTANCE = Mappers.getMapper(ExperienciaProfissionalMapper.class);

    /**
     * Mapeia um ExperienciaProfissionalRequestDTO para uma entidade
     * ExperienciaProfissional.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade ExperienciaProfissional correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    ExperienciaProfissional toEntity(ExperienciaProfissionalRequestDTO dto);

    /**
     * Mapeia uma entidade ExperienciaProfissional para um
     * ExperienciaProfissionalResponseDTO.
     *
     * @param entity A entidade ExperienciaProfissional.
     * @return O DTO de resposta correspondente.
     */
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissional entity);

    /**
     * Atualiza uma entidade ExperienciaProfissional existente com os dados de um
     * ExperienciaProfissionalRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade ExperienciaProfissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(ExperienciaProfissionalRequestDTO dto, @MappingTarget ExperienciaProfissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;

/**
 * Mapper MapStruct para a entidade FormacaoAcademica e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface FormacaoAcademicaMapper {
    FormacaoAcademicaMapper INSTANCE = Mappers.getMapper(FormacaoAcademicaMapper.class);

    /**
     * Mapeia um FormacaoAcademicaRequestDTO para uma entidade FormacaoAcademica.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade FormacaoAcademica correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    FormacaoAcademica toEntity(FormacaoAcademicaRequestDTO dto);

    /**
     * Mapeia uma entidade FormacaoAcademica para um FormacaoAcademicaResponseDTO.
     *
     * @param entity A entidade FormacaoAcademica.
     * @return O DTO de resposta correspondente.
     */
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademica entity);

    /**
     * Atualiza uma entidade FormacaoAcademica existente com os dados de um
     * FormacaoAcademicaRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade FormacaoAcademica a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademica entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;

/**
 * Mapper MapStruct para a entidade Idioma e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface IdiomaMapper {
    IdiomaMapper INSTANCE = Mappers.getMapper(IdiomaMapper.class);

    /**
     * Mapeia uma entidade Idioma para um IdiomaResponseDTO.
     * 
     * @param entity A entidade Idioma.
     * @return O DTO de resposta correspondente.
     */
    IdiomaResponseDTO toResponseDTO(Idioma entity);

    /**
     * Mapeia um IdiomaResponseDTO para uma entidade Idioma.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade Idioma correspondente.
     */
    Idioma toEntity(IdiomaResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade LocalAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface LocalAtuacaoMapper {
    LocalAtuacaoMapper INSTANCE = Mappers.getMapper(LocalAtuacaoMapper.class);

    /**
     * Mapeia uma entidade LocalAtuacao para um LocalAtuacaoResponseDTO.
     * 
     * @param entity A entidade LocalAtuacao.
     * @return O DTO de resposta correspondente.
     */
    LocalAtuacaoResponseDTO toResponseDTO(LocalAtuacao entity);

    /**
     * Mapeia um LocalAtuacaoResponseDTO para uma entidade LocalAtuacao.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade LocalAtuacao correspondente.
     */
    LocalAtuacao toEntity(LocalAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;

/**
 * Mapper MapStruct para a entidade Profissional e seus DTOs de requisição e
 * resposta.
 * Lida com mapeamentos complexos e aninhados, delegando para outros mappers
 * quando necessário.
 */
@Mapper(componentModel = "spring", uses = {
        PessoaMapper.class,
        CertificacaoMapper.class,
        DocumentoMapper.class,
        ExperienciaProfissionalMapper.class,
        FormacaoAcademicaMapper.class,
        RoleProfissionalMapper.class
        // Mappers para AreaAtuacao, Idioma, LocalAtuacao, TipoAtendimento NÃO são
        // usados diretamente aqui
        // para mapear UUIDs para DTOs completos, pois isso é responsabilidade do
        // serviço.
})
public interface ProfissionalMapper {
    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * Mapeia um ProfissionalCreateRequest para uma nova entidade Profissional.
     *
     * @param dto O DTO de requisição para criação.
     * @return A nova entidade Profissional.
     */
    // @Mapping(source = "pessoa.user", target = "usuario") // Mapeia o
    // PessoaRequestDTO (que é 'pessoa') para a superclasse 'usuario'
    @Mapping(target = "id", ignore = true) // ID do Profissional será gerado
    @Mapping(target = "pessoaId", ignore = true) // Será preenchido no serviço após a persistência da Pessoa
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "documentos", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "experiencias", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "formacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    Profissional toEntity(ProfissionalCreateRequest dto);

    /**
     * Atualiza uma entidade Profissional existente com os dados de um
     * ProfissionalUpdateRequest.
     *
     * @param dto    O DTO de requisição para atualização.
     * @param entity A entidade Profissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID da entidade não deve ser alterado pelo DTO
    @Mapping(source = "pessoa.usuario", target = "usuario") // Mapeia o DTO 'pessoa.usuario' para a superclasse
                                                            // 'usuario'
    @Mapping(target = "pessoaId", ignore = true) // Gerenciado pelo sistema
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Gerenciado pelo serviço (criação/atualização/remoção)
    @Mapping(target = "documentos", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "experiencias", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "formacoes", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Gerenciado pelo serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    void updateEntityFromDto(ProfissionalUpdateRequest dto, @MappingTarget Profissional entity);

    /**
     * Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * Campos de dados mestres (locaisAtuacao, areasAtuacao, idiomas,
     * tiposAtendimento)
     * são ignorados aqui e devem ser populados pela camada de serviço,
     * pois a entidade Profissional armazena apenas os IDs dessas relações.
     *
     * @param entity A entidade Profissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "usuario", target = "pessoa") // Mapeia a superclasse 'usuario' para 'pessoa' no DTO
    @Mapping(target = "locaisAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "areasAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "idiomas", ignore = true) // Populado pelo serviço
    @Mapping(target = "tiposAtendimento", ignore = true) // Populado pelo serviço
    @Mapping(source = "roleProfissionals", target = "rolesProfissional") // Mapeia Set<RoleProfissional> para
                                                                         // List<RoleProfissionalResponseDTO>
    ProfissionalResponseDTO toResponseDTO(Profissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.RoleProfissional;
import br.com.legalconnect.advogado.dto.response.RoleProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade RoleProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface RoleProfissionalMapper {
    RoleProfissionalMapper INSTANCE = Mappers.getMapper(RoleProfissionalMapper.class);

    /**
     * Mapeia uma entidade RoleProfissional para um RoleProfissionalResponseDTO.
     * Ignora 'tenantId' na resposta se não for relevante para o frontend.
     *
     * @param entity A entidade RoleProfissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    RoleProfissionalResponseDTO toResponseDTO(RoleProfissional entity);

    /**
     * Mapeia um RoleProfissionalResponseDTO para uma entidade RoleProfissional.
     * 'tenantId' deve ser definido pelo serviço.
     *
     * @param dto O DTO de resposta.
     * @return A entidade RoleProfissional correspondente.
     */
    @Mapping(target = "tenantId", ignore = true)
    RoleProfissional toEntity(RoleProfissionalResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;

/**
 * Mapper MapStruct para a entidade TipoAtendimento e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface TipoAtendimentoMapper {
    TipoAtendimentoMapper INSTANCE = Mappers.getMapper(TipoAtendimentoMapper.class);

    /**
     * Mapeia uma entidade TipoAtendimento para um TipoAtendimentoResponseDTO.
     * 
     * @param entity A entidade TipoAtendimento.
     * @return O DTO de resposta correspondente.
     */
    TipoAtendimentoResponseDTO toResponseDTO(TipoAtendimento entity);

    /**
     * Mapeia um TipoAtendimentoResponseDTO para uma entidade TipoAtendimento.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade TipoAtendimento correspondente.
     */
    TipoAtendimento toEntity(TipoAtendimentoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.AreaAtuacao;

@Repository
public interface AreaAtuacaoRepository extends JpaRepository<AreaAtuacao, UUID> {

    /**
     * Busca uma Área de Atuação pelo nome.
     *
     * @param nome O nome da área de atuação.
     * @return Um Optional contendo a Área de Atuação, se encontrada.
     */
    Optional<AreaAtuacao> findByNome(String nome);

    /**
     * 
     * Busca todas as Áreas de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs das áreas de atuação.
     * 
     * @return Uma lista de Áreas de Atuação.
     */
    List<AreaAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Certificacao;

/**
 * Repositório para a entidade {@link Certificacao}.
 * Gerencia operações de persistência para as certificações de um profissional.
 */
@Repository
public interface CertificacaoRepository extends JpaRepository<Certificacao, UUID> {

    /**
     * Busca uma Certificação pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Certificação, se encontrada.
     */
    Optional<Certificacao> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Certificações de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Certificações.
     */
    List<Certificacao> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Documento;

/**
 * Repositório para a entidade {@link Documento}.
 * Gerencia operações de persistência para os documentos de um profissional.
 */
@Repository
public interface DocumentoRepository extends JpaRepository<Documento, UUID> {

    /**
     * Busca um Documento pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo o Documento, se encontrado.
     */
    Optional<Documento> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todos os Documentos de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Documentos.
     */
    List<Documento> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta um Documento pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

/**
 * Repositório para a entidade {@link ExperienciaProfissional}.
 * Gerencia operações de persistência para as experiências profissionais de um
 * profissional.
 * O método 'save' é automaticamente fornecido por JpaRepository, não deve ser
 * declarado explicitamente aqui com parâmetros extras.
 */
@Repository
public interface ExperienciaProfissionalRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    /**
     * Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional
     * associado.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Experiência Profissional, se encontrada.
     */
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Experiências Profissionais de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Experiências Profissionais.
     */
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);

    // IMPORTANTE: NÃO HÁ MÉTODO 'save' EXPLICITAMENTE DECLARADO AQUI.
    // Ele é herdado de JpaRepository e tem a assinatura: S save(S entity);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

@Repository
public interface ExperienciaRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

/**
 * Repositório para a entidade {@link FormacaoAcademica}.
 * Gerencia operações de persistência para as formações acadêmicas de um
 * profissional.
 */
@Repository
public interface FormacaoAcademicaRepository extends JpaRepository<FormacaoAcademica, UUID> {

    /**
     * Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Formação Acadêmica, se encontrada.
     */
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Formações Acadêmicas de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Formações Acadêmicas.
     */
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

@Repository
public interface FormacaoRepository extends JpaRepository<FormacaoAcademica, UUID> {

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Idioma;

/**
 * Repositório para a entidade {@link Idioma}.
 * Gerencia operações de persistência para os idiomas disponíveis.
 */
@Repository
public interface IdiomaRepository extends JpaRepository<Idioma, UUID> {

    /**
     * Busca um Idioma pelo nome.
     *
     * @param nome O nome do idioma.
     * @return Um Optional contendo o Idioma, se encontrado.
     */
    Optional<Idioma> findByNome(String nome);

    /**
     * Busca todos os Idiomas por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos idiomas.
     * @return Uma lista de Idiomas.
     */
    List<Idioma> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.LocalAtuacao;

/**
 * Repositório para a entidade {@link LocalAtuacao}.
 * Gerencia operações de persistência para os locais de atuação dos
 * profissionais.
 */
@Repository
public interface LocalAtuacaoRepository extends JpaRepository<LocalAtuacao, UUID> {

    /**
     * Busca um Local de Atuação pelo nome.
     *
     * @param nome O nome do local de atuação.
     * @return Um Optional contendo o Local de Atuação, se encontrado.
     */
    Optional<LocalAtuacao> findByNome(String nome);

    /**
     * Busca todos os Locais de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos locais de atuação.
     * @return Uma lista de Locais de Atuação.
     */
    List<LocalAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Profissional;

/**
 * Repositório para a entidade {@link Profissional}.
 * Gerencia operações de persistência para os profissionais (advogados).
 */
@Repository
public interface ProfissionalRepository extends JpaRepository<Profissional, UUID> {

    /**
     * Busca um Profissional pelo número da OAB.
     *
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * Busca todos os Profissionais associados a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de Profissionais.
     */
    Page<Profissional> findAllByTenantId(UUID tenantId, Pageable pageable);

    /**
     * Verifica se um Profissional existe pelo número da OAB.
     * Regra de Negócio: Garante a unicidade do número da OAB.
     *
     * @param numeroOab O número da OAB a ser verificado.
     * @return true se um Profissional com a OAB já existe, false caso contrário.
     */
    boolean existsByNumeroOab(String numeroOab);

    /**
     * Verifica se um Profissional existe pelo ID da pessoa associada.
     *
     * @param pessoaId O ID da pessoa.
     * @return true se um Profissional com o ID da pessoa existe, false caso
     *         contrário.
     */
    boolean existsByPessoaId(UUID pessoaId);

    /**
     * NOVO MÉTODO: Busca todos os estados e cidades (municípios) distintos
     * de todas as Pessoas cadastradas.
     * Retorna uma lista de arrays de objetos, onde cada array contém [estado,
     * cidade].
     *
     * @return Uma lista de Object[] contendo pares [estado, cidade].
     */
    @Query(value = "SELECT DISTINCT e.estado, e.cidade FROM tb_endereco e WHERE e.estado IS NOT NULL AND e.cidade IS NOT NULL ORDER BY e.estado, e.cidade", nativeQuery = true)
    List<Object[]> findDistinctEstadosAndCidades();
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.RoleProfissional;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link RoleProfissional}.
 * Gerencia operações de persistência para os papéis (roles) dos profissionais.
 */
@Repository
public interface RoleProfissionalRepository extends JpaRepository<RoleProfissional, UUID> {

    /**
     * Busca uma Role de Profissional pelo nome.
     *
     * @param name O nome da role.
     * @return Um Optional contendo a RoleProfissional, se encontrada.
     */
    Optional<RoleProfissional> findByName(String name);

    /**
     * Busca todas as Roles de Profissional associadas a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de RoleProfissional.
     */
    List<RoleProfissional> findAllByTenantId(UUID tenantId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.TipoAtendimento;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link TipoAtendimento}.
 * Gerencia operações de persistência para os tipos de atendimento disponíveis.
 */
@Repository
public interface TipoAtendimentoRepository extends JpaRepository<TipoAtendimento, UUID> {

    /**
     * Busca um Tipo de Atendimento pelo nome.
     *
     * @param nome O nome do tipo de atendimento.
     * @return Um Optional contendo o TipoAtendimento, se encontrado.
     */
    Optional<TipoAtendimento> findByNome(String nome);

    /**
     * Busca todos os Tipos de Atendimento por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos tipos de atendimento.
     * @return Uma lista de Tipos de Atendimento.
     */
    List<TipoAtendimento> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.EmailService; // Para enviar e-mails de confirmação
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço responsável pela lógica de agendamento de consultas no Marketplace.
 */
@Slf4j
@Service
public class AgendamentoService {

        private final ProfissionalRepository profissionalRepository;
        private final GoogleCalendarService googleCalendarService;
        private final EmailService emailService;
        // Repositório de agendamentos (assumindo a entidade Agendamento)
        // private final AgendamentoRepository agendamentoRepository;

        @Autowired
        public AgendamentoService(ProfissionalRepository profissionalRepository,
                        GoogleCalendarService googleCalendarService,
                        EmailService emailService) {
                this.profissionalRepository = profissionalRepository;
                this.googleCalendarService = googleCalendarService;
                this.emailService = emailService;
                // this.agendamentoRepository = agendamentoRepository;
        }

        /**
         * Realiza o agendamento de uma consulta entre um cliente e um profissional.
         * Regras de Negócio:
         * - Verifica a disponibilidade do profissional na data/hora solicitada.
         * - Garante que o profissional existe e está ativo no marketplace.
         * - Integra com Google Calendar para adicionar o evento na agenda do
         * profissional.
         * - Envia e-mails de confirmação para cliente e profissional.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta.
         * @param tipoServico        Tipo de serviço agendado.
         * @return Sucesso do agendamento.
         * @throws BusinessException se o profissional não estiver disponível ou outras
         *                           regras de negócio forem violadas.
         */
        @Transactional
        public boolean agendarConsulta(UUID profissionalId, UUID clienteId, LocalDateTime horarioAgendamento,
                        String tipoServico) {
                UUID tenantId = TenantContext.getCurrentTenantId(); // O agendamento ocorre dentro do contexto de um
                                                                    // tenant

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                // Regra de Negócio: Profissional deve estar ativo e usar marketplace
                if (!profissional.getUsaMarketplace() || !profissional.getStatusProfissional().equals("ACTIVE")) { // Assuming
                                                                                                                   // "ACTIVE"
                                                                                                                   // status
                        throw new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE, HttpStatus.BAD_REQUEST,
                                        "Profissional não disponível para agendamento.");
                }

                // Regra de Negócio: Verificar disponibilidade real do profissional (com Google
                // Calendar)
                boolean isAvailable = googleCalendarService.checkAvailability(profissional.getUsuario().getEmail(),
                                horarioAgendamento);
                if (!isAvailable) {
                        throw new BusinessException(ErrorCode.APPOINTMENT_CONFLICT, HttpStatus.CONFLICT,
                                        "Horário indisponível para o profissional.");
                }

                // Regra de Negócio: Criar o registro de agendamento no banco de dados (se
                // houver entidade Agendamento)
                // Agendamento newAppointment = Agendamento.builder()
                // .profissional(profissional)
                // .clienteId(clienteId)
                // .horario(horarioAgendamento)
                // .tipoServico(tipoServico)
                // .tenantId(tenantId)
                // .build();
                // agendamentoRepository.save(newAppointment);

                // Funcionalidade Completa: Adicionar evento ao Google Calendar do profissional
                googleCalendarService.addEvent(
                                profissional.getUsuario().getEmail(),
                                "Consulta: " + tipoServico + " com Cliente " + clienteId, // Supondo que você pode obter
                                                                                          // o nome do
                                                                                          // cliente
                                horarioAgendamento,
                                horarioAgendamento.plusHours(1) // Consulta de 1 hora
                );

                // Funcionalidade Completa: Enviar e-mails de confirmação
                emailService.sendAppointmentConfirmationEmail(
                                profissional.getUsuario().getEmail(),
                                "Você tem uma nova consulta agendada com o cliente " + clienteId + " para "
                                                + horarioAgendamento);
                // emailService.sendAppointmentConfirmationEmail(
                // clienteService.findById(clienteId).getEmail(), // Supondo um clienteService
                // "Sua consulta com " + profissional.getNomeCompleto() + " foi confirmada para
                // " + horarioAgendamento
                // );

                return true;
        }

        /**
         * Simula a avaliação de uma consulta pelo cliente.
         * Regras de Negócio:
         * - Associa a avaliação ao agendamento e ao profissional.
         * - Atualiza a média de avaliação do profissional (lógica simplificada).
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return Sucesso da avaliação.
         */
        @Transactional
        public boolean avaliarConsulta(UUID agendamentoId, UUID clienteId, int rating, String comentario) {
                // Lógica para encontrar o agendamento e associar a avaliação.
                // Agendamento agendamento =
                // agendamentoRepository.findById(agendamentoId).orElseThrow(...)
                // Criar uma entidade Avaliacao.
                // Atualizar a média de avaliação do Profissional.

                // Simulação: Apenas loga a avaliação
                log.info("Cliente {} avaliou agendamento {} com nota {} e comentário: {}", clienteId, agendamentoId,
                                rating,
                                comentario);

                // Para fins de demonstração, vamos considerar um sucesso
                return true;
        }

        // Outras funcionalidades como reagendamento, cancelamento, busca de
        // agendamentos
        // seriam implementadas aqui.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Áreas de Atuação (dados mestre).
 * Essas entidades são consideradas globais ou de um tenant específico da
 * plataforma,
 * mas para este módulo, o acesso é simplificado como dados mestre.
 */
@Service
public class AreaAtuacaoService {

    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;

    @Autowired
    public AreaAtuacaoService(AreaAtuacaoRepository areaAtuacaoRepository, AreaAtuacaoMapper areaAtuacaoMapper) {
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
    }

    /**
     * Busca uma Área de Atuação pelo ID.
     *
     * @param id ID da Área de Atuação.
     * @return DTO da Área de Atuação.
     * @throws BusinessException se a Área de Atuação não for encontrada.
     */
    public AreaAtuacaoResponseDTO findAreaAtuacaoById(UUID id) {
        AreaAtuacao areaAtuacao = areaAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Área de Atuação não encontrada."));
        return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
    }

    /**
     * Lista todas as Áreas de Atuação.
     *
     * @return Lista de DTOs de Áreas de Atuação.
     */
    public List<AreaAtuacaoResponseDTO> findAllAreasAtuacao() {
        return areaAtuacaoRepository.findAll().stream()
                .map(areaAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para criar, atualizar e deletar podem ser adicionados
    // se essas entidades mestre forem gerenciáveis via API
    // Por exemplo, por um ADMIN da plataforma.
    // Ex:
    /*
     * @Transactional
     * public AreaAtuacaoResponseDTO createAreaAtuacao(AreaAtuacaoRequestDTO
     * requestDTO) {
     * if (areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * AreaAtuacao areaAtuacao = areaAtuacaoMapper.toEntity(requestDTO);
     * areaAtuacao = areaAtuacaoRepository.save(areaAtuacao);
     * return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
     * }
     * 
     * @Transactional
     * public AreaAtuacaoResponseDTO updateAreaAtuacao(UUID id,
     * AreaAtuacaoRequestDTO requestDTO) {
     * AreaAtuacao existing = areaAtuacaoRepository.findById(id)
     * .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada."));
     * if (!existing.getNome().equalsIgnoreCase(requestDTO.getNome()) &&
     * areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * areaAtuacaoMapper.updateEntityFromDto(requestDTO, existing); // Supondo um
     * updateEntityFromDto no mapper
     * existing = areaAtuacaoRepository.save(existing);
     * return areaAtuacaoMapper.toResponseDTO(existing);
     * }
     * 
     * @Transactional
     * public void deleteAreaAtuacao(UUID id) {
     * if (!areaAtuacaoRepository.existsById(id)) {
     * throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada para deleção.");
     * }
     * // Regra de Negócio: Verificar se está em uso por algum Profissional antes de
     * deletar
     * // if (profissionalRepository.existsByAreaAtuacaoId(id)) { ... }
     * areaAtuacaoRepository.deleteById(id);
     * }
     */
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das certificações de um Profissional.
 * Este serviço é granular e pode ser usado para operações diretas em
 * certificações,
 * embora o ProfissionalService orquestre a maioria.
 */
@Service
public class CertificacaoService {

    private final CertificacaoRepository certificacaoRepository;
    private final CertificacaoMapper certificacaoMapper;
    private final ProfissionalRepository profissionalRepository;

    @Autowired
    public CertificacaoService(CertificacaoRepository certificacaoRepository,
            CertificacaoMapper certificacaoMapper,
            ProfissionalRepository profissionalRepository) {
        this.certificacaoRepository = certificacaoRepository;
        this.certificacaoMapper = certificacaoMapper;
        this.profissionalRepository = profissionalRepository;
    }

    /**
     * Cria uma nova certificação para um profissional específico.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - A certificação é associada ao profissional e ao tenant.
     *
     * @param profissionalId ID do profissional.
     * @param requestDTO     DTO com os dados da certificação.
     * @return DTO da certificação criada.
     */
    @Transactional
    public CertificacaoResponseDTO createCertificacao(UUID profissionalId, CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        Certificacao certificacao = certificacaoMapper.toEntity(requestDTO);
        certificacao.setProfissional(profissional);
        certificacao.setTenantId(tenantId);

        certificacao = certificacaoRepository.save(certificacao); // profissionalId é passado para o
                                                                  // save no repositório customizado
        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Atualiza uma certificação existente de um profissional.
     * Regras de Negócio:
     * - A certificação deve existir e pertencer ao profissional e tenant corretos.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @param requestDTO     DTO com os dados para atualização.
     * @return DTO da certificação atualizada.
     */
    @Transactional
    public CertificacaoResponseDTO updateCertificacao(UUID profissionalId, UUID certificacaoId,
            CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant ou profissional.");
        }

        certificacaoMapper.updateEntityFromDto(requestDTO, existingCertificacao);
        existingCertificacao = certificacaoRepository.save(existingCertificacao);
        return certificacaoMapper.toResponseDTO(existingCertificacao);
    }

    /**
     * Busca uma certificação pelo ID do profissional e da certificação.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @return DTO da certificação.
     */
    public CertificacaoResponseDTO findCertificacaoById(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao certificacao = certificacaoRepository.findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!certificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Lista todas as certificações de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de certificações.
     */
    public List<CertificacaoResponseDTO> findAllCertificacoesByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se o profissional existe e pertence ao tenant
        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return certificacaoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(certificacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta uma certificação de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação a ser deletada.
     */
    @Transactional
    public void deleteCertificacao(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se a certificação existe e pertence ao profissional e tenant
        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para deleção."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        certificacaoRepository.deleteByIdAndProfissionalId(certificacaoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.Base64; // Para decodificar Base64
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.S3Service;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão de documentos de um Profissional.
 * Inclui o upload de arquivos para o S3 e o armazenamento dos metadados no
 * banco de dados.
 */
@Service
public class DocumentoService {

    private final DocumentoRepository documentoRepository;
    private final DocumentoMapper documentoMapper;
    private final ProfissionalRepository profissionalRepository;
    private final S3Service s3Service; // Serviço para integração com S3

    @Autowired
    public DocumentoService(DocumentoRepository documentoRepository,
            DocumentoMapper documentoMapper,
            ProfissionalRepository profissionalRepository,
            S3Service s3Service) {
        this.documentoRepository = documentoRepository;
        this.documentoMapper = documentoMapper;
        this.profissionalRepository = profissionalRepository;
        this.s3Service = s3Service;
    }

    /**
     * Realiza o upload de um documento para o S3 e persiste seus metadados.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - O conteúdo do arquivo em Base64 é decodificado e enviado ao S3.
     * - A URL do S3 é armazenada no banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param request        DTO com os dados do documento e o arquivo em Base64.
     * @return DTO do documento criado.
     * @throws BusinessException em caso de falha no upload ou se o profissional não
     *                           for encontrado.
     */
    @Transactional
    public DocumentoResponseDTO uploadDocumento(UUID profissionalId, DocumentoUploadRequest request) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para upload de documento."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Decodificar Base64 e fazer upload para S3
        byte[] fileBytes;
        try {
            fileBytes = Base64.getDecoder().decode(request.getArquivoBase64());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.INVALID_DOCUMENT_FORMAT, HttpStatus.BAD_REQUEST,
                    "Conteúdo do arquivo em Base64 inválido.");
        }

        String s3Key = "profissionais/" + profissionalId + "/documentos/" + UUID.randomUUID() + "/"
                + request.getNomeArquivo();
        String fileUrl = s3Service.uploadFile(fileBytes, s3Key, request.getMimeType());

        if (fileUrl == null) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao fazer upload do documento para o S3.");
        }

        Documento documento = documentoMapper.toEntity(request);
        documento.setUrlS3(fileUrl);
        documento.setProfissional(profissional);
        documento.setTenantId(tenantId);

        documento = documentoRepository.save(documento);
        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Busca um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento deve pertencer ao profissional e ao tenant correto.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento.
     * @return DTO do documento encontrado.
     * @throws BusinessException se o documento não for encontrado.
     */
    public DocumentoResponseDTO findDocumentoById(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento documento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para este profissional."));

        if (!documento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant ou profissional.");
        }

        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Lista todos os documentos de um profissional.
     * Regras de Negócio:
     * - Apenas documentos do tenant atual são retornados.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de documentos.
     */
    public List<DocumentoResponseDTO> findAllDocumentosByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return documentoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(documentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento é removido do S3 antes de ser deletado do banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento a ser deletado.
     * @throws BusinessException se o documento não for encontrado ou falha na
     *                           deleção do S3.
     */
    @Transactional
    public void deleteDocumento(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento existingDocumento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para deleção."));

        if (!existingDocumento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant.");
        }

        // Deletar do S3 primeiro
        try {
            s3Service.deleteFile(existingDocumento.getUrlS3());
        } catch (Exception e) {
            throw new BusinessException(ErrorCode.ERRO_INTERNO_SERVIDOR, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao deletar o documento do S3: " + e.getMessage());
        }

        documentoRepository.deleteByIdAndProfissionalId(documentoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das experiências profissionais de um
 * Profissional.
 */
@Service
public class ExperienciaProfissionalService {

        private final ExperienciaRepository experienciaRepository;
        private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public ExperienciaProfissionalService(ExperienciaRepository experienciaRepository,
                        ExperienciaProfissionalMapper experienciaProfissionalMapper,
                        ProfissionalRepository profissionalRepository) {
                this.experienciaRepository = experienciaRepository;
                this.experienciaProfissionalMapper = experienciaProfissionalMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova experiência profissional para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A experiência é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da experiência.
         * @return DTO da experiência criada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO createExperienciaProfissional(UUID profissionalId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                ExperienciaProfissional experiencia = experienciaProfissionalMapper.toEntity(requestDTO);
                experiencia.setProfissional(profissional);
                experiencia.setTenantId(tenantId);

                experiencia = experienciaRepository.save(experiencia);
                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Atualiza uma experiência profissional existente de um profissional.
         * Regras de Negócio:
         * - A experiência deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da experiência atualizada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO updateExperienciaProfissional(UUID profissionalId, UUID experienciaId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant ou profissional.");
                }

                experienciaProfissionalMapper.updateEntityFromDto(requestDTO, existingExperiencia);
                existingExperiencia = experienciaRepository.save(existingExperiencia);
                return experienciaProfissionalMapper.toResponseDTO(existingExperiencia);
        }

        /**
         * Busca uma experiência profissional pelo ID do profissional e da experiência.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return DTO da experiência.
         */
        public ExperienciaProfissionalResponseDTO findExperienciaProfissionalById(UUID profissionalId,
                        UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional experiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!experiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de experiências.
         */
        public List<ExperienciaProfissionalResponseDTO> findAllExperienciasProfissionaisByProfissionalId(
                        UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return experienciaRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(experienciaProfissionalMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência a ser deletada.
         */
        @Transactional
        public void deleteExperienciaProfissional(UUID profissionalId, UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para deleção."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                experienciaRepository.deleteByIdAndProfissionalId(experienciaId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das formações acadêmicas de um Profissional.
 */
@Service
public class FormacaoAcademicaService {

        private final FormacaoRepository formacaoRepository;
        private final FormacaoAcademicaMapper formacaoAcademicaMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public FormacaoAcademicaService(FormacaoRepository formacaoRepository,
                        FormacaoAcademicaMapper formacaoAcademicaMapper,
                        ProfissionalRepository profissionalRepository) {
                this.formacaoRepository = formacaoRepository;
                this.formacaoAcademicaMapper = formacaoAcademicaMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova formação acadêmica para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A formação é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da formação.
         * @return DTO da formação criada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO createFormacaoAcademica(UUID profissionalId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                FormacaoAcademica formacao = formacaoAcademicaMapper.toEntity(requestDTO);
                formacao.setProfissional(profissional);
                formacao.setTenantId(tenantId);

                formacao = formacaoRepository.save(formacao);
                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Atualiza uma formação acadêmica existente de um profissional.
         * Regras de Negócio:
         * - A formação deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da formação atualizada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO updateFormacaoAcademica(UUID profissionalId, UUID formacaoId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant ou profissional.");
                }

                formacaoAcademicaMapper.updateEntityFromDto(requestDTO, existingFormacao);
                existingFormacao = formacaoRepository.save(existingFormacao);
                return formacaoAcademicaMapper.toResponseDTO(existingFormacao);
        }

        /**
         * Busca uma formação acadêmica pelo ID do profissional e da formação.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return DTO da formação.
         */
        public FormacaoAcademicaResponseDTO findFormacaoAcademicaById(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica formacao = formacaoRepository.findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!formacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de formações.
         */
        public List<FormacaoAcademicaResponseDTO> findAllFormacoesAcademicasByProfissionalId(UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return formacaoRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(formacaoAcademicaMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação a ser deletada.
         */
        @Transactional
        public void deleteFormacaoAcademica(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para deleção."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                formacaoRepository.deleteByIdAndProfissionalId(formacaoId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço de integração simulada com a Google Calendar API.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a
 * Google Calendar API
 * utilizando as credenciais OAuth2 do aplicativo.
 */
@Service
public class GoogleCalendarService {

    private static final Logger log = LoggerFactory.getLogger(GoogleCalendarService.class);

    /**
     * Simula a adição de um evento à agenda do Google Calendar de um usuário.
     *
     * @param userEmail    O e-mail do usuário cuja agenda será atualizada.
     * @param eventSummary O título do evento.
     * @param startTime    A data e hora de início do evento.
     * @param endTime      A data e hora de fim do evento.
     * @return true se o evento foi "adicionado" com sucesso, false caso contrário.
     */
    public boolean addEvent(String userEmail, String eventSummary, LocalDateTime startTime, LocalDateTime endTime) {
        log.info("Simulando adição de evento ao Google Calendar para {}:", userEmail);
        log.info("  Sumário: {}", eventSummary);
        log.info("  Início: {}", startTime);
        log.info("  Fim: {}", endTime);
        // Lógica real de integração com Google Calendar API seria aqui, por exemplo:
        // Event event = new Event()
        // .setSummary(eventSummary)
        // .setDescription("Agendamento via LegalConnect");
        // DateTime startDateTime = new DateTime(startTime.toString());
        // EventDateTime start = new
        // EventDateTime().setDateTime(startDateTime).setTimeZone("America/Sao_Paulo");
        // event.setStart(start);
        // ...
        // Calendar service = new Calendar.Builder(...).build();
        // service.events().insert(userEmail, event).execute();
        log.info("Evento simulado adicionado com sucesso ao Google Calendar.");
        return true;
    }

    /**
     * Simula a verificação de disponibilidade na agenda do Google Calendar de um
     * usuário.
     *
     * @param userEmail    O e-mail do usuário.
     * @param proposedTime O horário a ser verificado.
     * @return true se o horário estiver disponível, false caso contrário.
     */
    public boolean checkAvailability(String userEmail, LocalDateTime proposedTime) {
        log.info("Simulando verificação de disponibilidade para {} no horário {}", userEmail, proposedTime);
        // Em um cenário real, você consultaria a API do Google Calendar para Free/Busy
        // Por simplicidade, vamos simular que o horário está sempre disponível, a menos
        // que seja um horário "proibido"
        if (proposedTime.getHour() == 13) { // Exemplo de regra de negócio: almoço indisponível
            log.info("Horário indisponível (simulado).");
            return false;
        }
        log.info("Horário disponível (simulado).");
        return true;
    }

    // Outros métodos como updateEvent, deleteEvent, listEvents podem ser
    // adicionados.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Idiomas (dados mestre).
 */
@Service
public class IdiomaService {

    private final IdiomaRepository idiomaRepository;
    private final IdiomaMapper idiomaMapper;

    @Autowired
    public IdiomaService(IdiomaRepository idiomaRepository, IdiomaMapper idiomaMapper) {
        this.idiomaRepository = idiomaRepository;
        this.idiomaMapper = idiomaMapper;
    }

    /**
     * Busca um Idioma pelo ID.
     *
     * @param id ID do Idioma.
     * @return DTO do Idioma.
     * @throws BusinessException se o Idioma não for encontrado.
     */
    public IdiomaResponseDTO findIdiomaById(UUID id) {
        Idioma idioma = idiomaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Idioma não encontrado."));
        return idiomaMapper.toResponseDTO(idioma);
    }

    /**
     * Lista todos os Idiomas.
     *
     * @return Lista de DTOs de Idiomas.
     */
    public List<IdiomaResponseDTO> findAllIdiomas() {
        return idiomaRepository.findAll().stream()
                .map(idiomaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Locais de Atuação (dados mestre).
 */
@Service
public class LocalAtuacaoService {

    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final LocalAtuacaoMapper localAtuacaoMapper;

    @Autowired
    public LocalAtuacaoService(LocalAtuacaoRepository localAtuacaoRepository, LocalAtuacaoMapper localAtuacaoMapper) {
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.localAtuacaoMapper = localAtuacaoMapper;
    }

    /**
     * Busca um Local de Atuação pelo ID.
     *
     * @param id ID do Local de Atuação.
     * @return DTO do Local de Atuação.
     * @throws BusinessException se o Local de Atuação não for encontrado.
     */
    public LocalAtuacaoResponseDTO findLocalAtuacaoById(UUID id) {
        LocalAtuacao localAtuacao = localAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Local de Atuação não encontrado."));
        return localAtuacaoMapper.toResponseDTO(localAtuacao);
    }

    /**
     * Lista todos os Locais de Atuação.
     *
     * @return Lista de DTOs de Locais de Atuação.
     */
    public List<LocalAtuacaoResponseDTO> findAllLocaisAtuacao() {
        return localAtuacaoRepository.findAll().stream()
                .map(localAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import org.springframework.stereotype.Service;

// Assumindo a existência dessas classes de DTO, Entidade e Repositório
// import br.com.legalconnect.office.application.dto.request.ProcessoRequestDTO;
// import br.com.legalconnect.office.application.dto.response.ProcessoResponseDTO;
// import br.com.legalconnect.office.domain.modal.entity.Processo;
// import br.com.legalconnect.office.domain.repository.ProcessoRepository;
// import br.com.legalconnect.office.application.mapper.ProcessoMapper;

/**
 * Serviço responsável pela gestão de Processos Judiciais e Administrativos no
 * módulo de Gestão de Escritório.
 */
@Service
public class ProcessoService {

    // private final ProcessoRepository processoRepository;
    // private final ProcessoMapper processoMapper;
    // private final AIService aiService; // Para geração de petições com IA
    // private final S3Service s3Service; // Para anexos de documentos

    // @Autowired
    // public ProcessoService(ProcessoRepository processoRepository,
    // ProcessoMapper processoMapper,
    // AIService aiService,
    // S3Service s3Service) {
    // this.processoRepository = processoRepository;
    // this.processoMapper = processoMapper;
    // this.aiService = aiService;
    // this.s3Service = s3Service;
    // }

    /**
     * Cria um novo processo judicial ou administrativo.
     * Regras de Negócio:
     * - Associa o processo ao tenant atual.
     * - Define o status inicial do processo.
     *
     * @param requestDTO DTO com os dados do processo.
     * @return DTO do processo criado.
     */
    // @Transactional
    // public ProcessoResponseDTO createProcesso(ProcessoRequestDTO requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoMapper.toEntity(requestDTO);
    // processo.setTenantId(tenantId);
    // processo.setStatus("INICIADO"); // Regra de Negócio: Status inicial
    //
    // processo = processoRepository.save(processo);
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Atualiza um processo existente.
     * Regras de Negócio:
     * - O processo deve existir e pertencer ao tenant atual.
     *
     * @param id         ID do processo.
     * @param requestDTO DTO com os dados para atualização.
     * @return DTO do processo atualizado.
     */
    // @Transactional
    // public ProcessoResponseDTO updateProcesso(UUID id, ProcessoRequestDTO
    // requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // processoMapper.updateEntityFromDto(requestDTO, existingProcesso);
    // existingProcesso = processoRepository.save(existingProcesso);
    // return processoMapper.toResponseDTO(existingProcesso);
    // }

    /**
     * Busca um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo.
     * @return DTO do processo.
     */
    // public ProcessoResponseDTO findProcessoById(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Lista todos os processos de um tenant.
     *
     * @return Lista de DTOs de processos.
     */
    // public List<ProcessoResponseDTO> findAllProcessos() {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // return processoRepository.findAllByTenantId(tenantId).stream()
    // .map(processoMapper::toResponseDTO)
    // .collect(Collectors.toList());
    // }

    /**
     * Deleta um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo a ser deletado.
     */
    // @Transactional
    // public void deleteProcesso(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para deleção."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Regra de Negócio: Verificar se o processo pode ser deletado (ex: não tem
    // atividades pendentes)
    // // if (hasPendingActivities(existingProcesso)) {
    // // throw new BusinessException(ErrorCode.RECURSO_EM_USO, HttpStatus.CONFLICT,
    // "Processo possui atividades pendentes e não pode ser deletado.");
    // // }
    //
    // processoRepository.deleteById(id);
    // }

    /**
     * Gera um rascunho de petição utilizando IA (OpenAI GPT).
     * Regras de Negócio:
     * - O profissional deve ter permissão e estar em um plano que suporte IA.
     * - A IA gera um texto baseado nas informações do processo.
     *
     * @param processoId ID do processo para o qual a petição será gerada.
     * @param prompt     Instruções adicionais para a IA.
     * @return O rascunho da petição gerado pela IA.
     */
    // public String generatePeticaoWithAI(UUID processoId, String prompt) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    // // Verifica se o usuário logado tem permissão e plano para usar IA
    // // Profissional profissional =
    // profissionalService.findProfissionalById(userIdFromSecurityContext);
    // // if (!profissional.getPlano().supportsAI()) { ... }
    //
    // Processo processo = processoRepository.findById(processoId)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para geração de petição."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Montar o prompt completo para a IA com base nos dados do processo
    // String fullPrompt = String.format("Crie um rascunho de petição para o
    // processo '%s' (Tipo: %s, Partes: %s). Contexto: %s. %s",
    // processo.getNumero(), processo.getTipo(), processo.getPartes(),
    // processo.getDescricao(), prompt);
    //
    // // Chamada ao serviço de IA
    // String generatedText = aiService.generateText(fullPrompt);
    //
    // return generatedText;
    // }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable; // Importar Pageable
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.ProfissionalMapper;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.service.PessoaService;
import br.com.legalconnect.commom.service.S3Service; // Assumindo S3Service para upload de documentos
import br.com.legalconnect.commom.service.TenantContext; // Assumindo TenantContext para multitenancy
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão completa do Profissional (Advogado).
 * Inclui operações de CRUD, validações de negócio e orquestração com serviços
 * de entidades aninhadas
 * e dados mestre. Gerencia também o upload de documentos e a associação com o
 * tenant.
 */
@Service
public class ProfissionalService {

    private final ProfissionalRepository profissionalRepository;
    private final ProfissionalMapper profissionalMapper;
    private final PessoaService pessoaService; // Para gerenciar a entidade Pessoa
    private final CertificacaoMapper certificacaoMapper;
    private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
    private final FormacaoAcademicaMapper formacaoAcademicaMapper;
    private final DocumentoMapper documentoMapper;
    private final CertificacaoRepository certificacaoRepository;
    private final ExperienciaRepository experienciaRepository;
    private final FormacaoRepository formacaoRepository;
    private final DocumentoRepository documentoRepository;
    private final S3Service s3Service; // Serviço para integração com S3
    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final IdiomaRepository idiomaRepository;
    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;
    private final IdiomaMapper idiomaMapper;
    private final LocalAtuacaoMapper localAtuacaoMapper;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public ProfissionalService(ProfissionalRepository profissionalRepository,
            ProfissionalMapper profissionalMapper,
            PessoaService pessoaService,
            CertificacaoMapper certificacaoMapper,
            ExperienciaProfissionalMapper experienciaProfissionalMapper,
            FormacaoAcademicaMapper formacaoAcademicaMapper,
            DocumentoMapper documentoMapper,
            CertificacaoRepository certificacaoRepository,
            ExperienciaRepository experienciaRepository,
            FormacaoRepository formacaoRepository,
            DocumentoRepository documentoRepository,
            S3Service s3Service,
            AreaAtuacaoRepository areaAtuacaoRepository,
            IdiomaRepository idiomaRepository,
            LocalAtuacaoRepository localAtuacaoRepository,
            TipoAtendimentoRepository tipoAtendimentoRepository,
            AreaAtuacaoMapper areaAtuacaoMapper,
            IdiomaMapper idiomaMapper,
            LocalAtuacaoMapper localAtuacaoMapper,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.profissionalRepository = profissionalRepository;
        this.profissionalMapper = profissionalMapper;
        this.pessoaService = pessoaService;
        this.certificacaoMapper = certificacaoMapper;
        this.experienciaProfissionalMapper = experienciaProfissionalMapper;
        this.formacaoAcademicaMapper = formacaoAcademicaMapper;
        this.documentoMapper = documentoMapper;
        this.certificacaoRepository = certificacaoRepository;
        this.experienciaRepository = experienciaRepository;
        this.formacaoRepository = formacaoRepository;
        this.documentoRepository = documentoRepository;
        this.s3Service = s3Service;
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.idiomaRepository = idiomaRepository;
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
        this.idiomaMapper = idiomaMapper;
        this.localAtuacaoMapper = localAtuacaoMapper;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Cria um novo Profissional no sistema.
     * Regras de Negócio:
     * - Valida a unicidade do número da OAB.
     * - Associa o Profissional a um Tenant (obtido do contexto de segurança).
     * - Cria a entidade Pessoa associada através do PessoaService.
     * - Gerencia a criação de certificações, experiências e formações aninhadas.
     * - Define o status inicial do profissional.
     * - Valida a existência do plano.
     *
     * @param createRequest DTO com os dados para criação do Profissional.
     * @return DTO do Profissional criado.
     * @throws BusinessException se a OAB já estiver cadastrada, ou se o
     *                           plano/tenant não existirem.
     */
    @Transactional
    public ProfissionalResponseDTO createProfissional(ProfissionalCreateRequest createRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo que o tenantId vem do contexto de segurança

        // Regra de Negócio: Validar unicidade da OAB
        if (profissionalRepository.existsByNumeroOab(createRequest.getNumeroOab())) {
            throw new BusinessException(ErrorCode.OAB_DUPLICADA, HttpStatus.CONFLICT, createRequest.getNumeroOab());
        }

        // Regra de Negócio: Validar unicidade da Pessoa (CPF/Email) antes de criar o
        // Profissional
        if (pessoaService.findPessoaByCpf(createRequest.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, createRequest.getCpf());
        }
        if (pessoaService.findPessoaByEmail(createRequest.getUsuario().getEmail()).isPresent()) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    createRequest.getUsuario().getEmail());
        }

        // Criar a Pessoa associada primeiro, pois Profissional estende Pessoa
        PessoaRequestDTO pessoaRequestDTO = new PessoaRequestDTO();
        pessoaRequestDTO.setUsuario(createRequest.getUsuario());
        pessoaRequestDTO.setNomeCompleto(createRequest.getNomeCompleto());
        pessoaRequestDTO.setCpf(createRequest.getCpf());
        pessoaRequestDTO.setDataNascimento(createRequest.getDataNascimento());
        pessoaRequestDTO.setTelefones(createRequest.getTelefones());
        pessoaRequestDTO.setEnderecos(createRequest.getEnderecos());

        Pessoa newPessoa = pessoaService.createPessoa(pessoaRequestDTO);

        // Regra de Negócio: Validar que o planoId existe (assumindo um PlanoService ou
        // repositório de Plano)
        // if (!planoService.existsById(createRequest.getPlanoId())) {
        // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
        // HttpStatus.NOT_FOUND);
        // }

        Profissional profissional = profissionalMapper.toEntity(createRequest);
        profissional.setPessoaId(newPessoa.getId()); // Associa o ID da Pessoa recém-criada
        profissional.setUsuario(newPessoa.getUsuario()); // Garante que o usuário de Pessoa esteja associado
        profissional.setTenantId(tenantId); // Regra de Negócio: Define o tenant do profissional
        profissional.setStatusProfissional("PENDING_APPROVAL"); // Regra de Negócio: Status inicial

        // Relacionamentos muitos-para-muitos (apenas IDs aqui)
        if (createRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            profissional.setLocaisAtuacaoIds(createRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            profissional.setAreaAtuacaoIds(createRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(createRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            profissional.setIdiomaIds(createRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(createRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            profissional
                    .setTipoAtendimentoIds(createRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        profissional = profissionalRepository.save(profissional);

        // Gerenciar certificações, experiências e formações
        manageNestedEntities(profissional, createRequest);

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Atualiza um Profissional existente.
     * Regras de Negócio:
     * - Valida a existência do Profissional e do Tenant.
     * - Permite a atualização de dados da Pessoa associada.
     * - Gerencia a adição, atualização e remoção de certificações, experiências e
     * formações.
     * - Atualiza relacionamentos com dados mestre.
     *
     * @param id            ID do Profissional a ser atualizado.
     * @param updateRequest DTO com os dados para atualização.
     * @return DTO do Profissional atualizado.
     * @throws BusinessException se o Profissional não for encontrado, ou por outras
     *                           violações de negócio.
     */
    @Transactional
    public ProfissionalResponseDTO updateProfissional(UUID id, ProfissionalUpdateRequest updateRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo tenantId do contexto de segurança

        Profissional existingProfissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para atualização."));

        // Regra de Negócio: O profissional só pode ser atualizado pelo seu próprio
        // tenant
        if (!existingProfissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Atualiza os dados da Pessoa associada (se fornecidos)
        if (updateRequest.getPessoa() != null) {
            pessoaService.updatePessoa(existingProfissional.getPessoaId(), updateRequest.getPessoa());
        }

        // Mapeia os campos atualizáveis para a entidade Profissional
        profissionalMapper.updateEntityFromDto(updateRequest, existingProfissional);

        // Regra de Negócio: Validar que o planoId existe se for alterado
        if (updateRequest.getPlanoId() != null
                && !existingProfissional.getPlanoId().equals(updateRequest.getPlanoId())) {
            // if (!planoService.existsById(updateRequest.getPlanoId())) {
            // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
            // HttpStatus.NOT_FOUND);
            // }
            existingProfissional.setPlanoId(updateRequest.getPlanoId());
        }

        // Atualiza relacionamentos muitos-para-muitos
        if (updateRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            existingProfissional
                    .setLocaisAtuacaoIds(updateRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            existingProfissional
                    .setAreaAtuacaoIds(updateRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(updateRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            existingProfissional.setIdiomaIds(updateRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(updateRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            existingProfissional
                    .setTipoAtendimentoIds(updateRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        // Gerenciar coleções aninhadas (certificações, experiências, formações)
        manageNestedEntities(existingProfissional, updateRequest);

        existingProfissional = profissionalRepository.save(existingProfissional);
        return mapToResponseDTOWithDetails(existingProfissional);
    }

    /**
     * Busca um Profissional pelo ID.
     * Regras de Negócio:
     * - Garante que o Profissional pertence ao Tenant do contexto de segurança.
     * - Popula os dados mestre relacionados.
     *
     * @param id ID do Profissional.
     * @return DTO do Profissional com detalhes.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    public ProfissionalResponseDTO findProfissionalById(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Busca todos os Profissionais de um determinado Tenant com paginação.
     *
     * @param pageable Objeto Pageable contendo informações de paginação e
     *                 ordenação.
     * @return Página de DTOs de Profissionais.
     */
    public Page<ProfissionalResponseDTO> findAllProfissionais(Pageable pageable) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Filtra por tenant

        Page<Profissional> profissionaisPage = profissionalRepository.findAllByTenantId(tenantId, pageable);
        return profissionaisPage.map(this::mapToResponseDTOWithDetails);
    }

    /**
     * Deleta um Profissional pelo ID.
     * Regras de Negócio:
     * - Apenas o proprietário do tenant pode deletar.
     * - Orquestra a deleção de entidades aninhadas (Certificações, Experiências,
     * Formações, Documentos).
     * - Deleção da Pessoa associada.
     *
     * @param id ID do Profissional a ser deletado.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    @Transactional
    public void deleteProfissional(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para deleção."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Deleta entidades aninhadas (cascade pode fazer isso, mas explicitar é bom
        // para clareza)
        certificacaoRepository.findAllByProfissionalId(id)
                .forEach(c -> certificacaoRepository.deleteByIdAndProfissionalId(c.getId(), id));
        experienciaRepository.findAllByProfissionalId(id)
                .forEach(e -> experienciaRepository.deleteByIdAndProfissionalId(e.getId(), id));
        formacaoRepository.findAllByProfissionalId(id)
                .forEach(f -> formacaoRepository.deleteByIdAndProfissionalId(f.getId(), id));
        documentoRepository.findAllByProfissionalId(id).forEach(d -> {
            s3Service.deleteFile(d.getUrlS3()); // Deleta arquivo do S3
            documentoRepository.deleteByIdAndProfissionalId(d.getId(), id);
        });

        // Deleta o profissional
        profissionalRepository.deleteById(id);

        // Deleta a pessoa associada
        pessoaService.deletePessoa(profissional.getPessoaId());
    }

    /**
     * Método auxiliar para gerenciar a adição, atualização e remoção de entidades
     * aninhadas
     * (certificações, experiências, formações) para um Profissional.
     *
     * @param profissional O Profissional pai.
     * @param request      O DTO de requisição (Create ou Update) contendo as listas
     *                     aninhadas.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalCreateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Remover certificações que não estão mais no DTO
            profissional.getCertificacoes().removeIf(existingCert -> request.getCertificacoes().stream()
                    .noneMatch(dto -> existingCert.getId().equals(dto.getId())));
            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        }

        // Experiências Profissionais
        if (request.getExperiencias() != null) {
            profissional.getExperiencias().removeIf(existingExp -> request.getExperiencias().stream()
                    .noneMatch(dto -> existingExp.getId().equals(dto.getId())));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) { // Nova experiência
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else { // Atualizar experiência existente
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        }

        // Formações Acadêmicas
        if (request.getFormacoes() != null) {
            profissional.getFormacoes().removeIf(existingForm -> request.getFormacoes().stream()
                    .noneMatch(dto -> existingForm.getId().equals(dto.getId())));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova formação
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else { // Atualizar formação existente
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        }
    }

    /**
     * Sobrecarga para o método de gerenciamento de entidades aninhadas para
     * ProfissionalUpdateRequest.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalUpdateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Coleta IDs das certificações no DTO para identificar as que serão removidas
            Set<UUID> dtoCertIds = request.getCertificacoes().stream()
                    .map(c -> c.getId())
                    .collect(Collectors.toSet());

            // Remove certificações que existem na entidade mas não no DTO (deleção)
            profissional.getCertificacoes().removeIf(
                    existingCert -> existingCert.getId() != null && !dtoCertIds.contains(existingCert.getId()));

            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação (ID nulo indica novo)
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId() != null && c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        } else {
            // Se a lista no DTO for nula, assume-se que todas as certificações devem ser
            // removidas
            profissional.getCertificacoes().clear();
        }

        // Experiências Profissionais (lógica similar às certificações)
        if (request.getExperiencias() != null) {
            Set<UUID> dtoExpIds = request.getExperiencias().stream()
                    .map(e -> e.getId())
                    .collect(Collectors.toSet());
            profissional.getExperiencias()
                    .removeIf(existingExp -> existingExp.getId() != null && !dtoExpIds.contains(existingExp.getId()));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) {
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else {
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId() != null && e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        } else {
            profissional.getExperiencias().clear();
        }

        // Formações Acadêmicas (lógica similar às certificações)
        if (request.getFormacoes() != null) {
            Set<UUID> dtoFormIds = request.getFormacoes().stream()
                    .map(f -> f.getId())
                    .collect(Collectors.toSet());
            profissional.getFormacoes().removeIf(
                    existingForm -> existingForm.getId() != null && !dtoFormIds.contains(existingForm.getId()));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) {
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else {
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId() != null && f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        } else {
            profissional.getFormacoes().clear();
        }
    }

    /**
     * Mapeia um Profissional para ProfissionalResponseDTO e popula os dados mestre
     * relacionados.
     * Esta é uma funcionalidade completa para apresentar o perfil do advogado.
     *
     * @param profissional A entidade Profissional.
     * @return O DTO de resposta detalhado.
     */
    private ProfissionalResponseDTO mapToResponseDTOWithDetails(Profissional profissional) {
        ProfissionalResponseDTO responseDTO = profissionalMapper.toResponseDTO(profissional);

        // Popula listas de DTOs de dados mestre
        responseDTO.setLocaisAtuacao(
                localAtuacaoRepository.findAllById(profissional.getLocaisAtuacaoIds())
                        .stream()
                        .map(localAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setAreasAtuacao(
                areaAtuacaoRepository.findAllById(profissional.getAreaAtuacaoIds())
                        .stream()
                        .map(areaAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setIdiomas(
                idiomaRepository.findAllById(profissional.getIdiomaIds())
                        .stream()
                        .map(idiomaMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setTiposAtendimento(
                tipoAtendimentoRepository.findAllById(profissional.getTipoAtendimentoIds())
                        .stream()
                        .map(tipoAtendimentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Popula as coleções aninhadas
        responseDTO.setCertificacoes(
                profissional.getCertificacoes().stream()
                        .map(certificacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setDocumentos(
                profissional.getDocumentos().stream()
                        .map(documentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setExperiencias(
                profissional.getExperiencias().stream()
                        .map(experienciaProfissionalMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setFormacoes(
                profissional.getFormacoes().stream()
                        .map(formacaoAcademicaMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Define se faz parte de plano com base no planoId (regra de negócio)
        responseDTO.setFazParteDePlano(profissional.getPlanoId() != null); // Simplificado

        return responseDTO;
    }

    /**
     * Valida a existência de entidades de dados mestre.
     *
     * @param ids        Lista de UUIDs a serem validados.
     * @param finder     Função para encontrar a entidade por ID.
     * @param entityName Nome da entidade para mensagens de erro.
     * @param <T>        Tipo da entidade.
     */
    private <T> void validateMasterDataExistence(List<UUID> ids,
            java.util.function.Function<UUID, java.util.Optional<T>> finder, String entityName) {
        for (UUID id : ids) {
            if (finder.apply(id).isEmpty()) {
                throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        entityName + " com ID " + id + " não encontrado(a).");
            }
        }
    }

    public Map<String, List<String>> listarLocalizacoesDisponiveis() {
        List<Object[]> resultados = profissionalRepository.findDistinctEstadosAndCidades();
        Map<String, List<String>> localizacoes = new HashMap<>();

        for (Object[] row : resultados) {
            String estado = (String) row[0];
            String cidade = (String) row[1];
            localizacoes.computeIfAbsent(estado, k -> new ArrayList<>()).add(cidade);
        }
        return localizacoes;
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Tipos de Atendimento (dados mestre).
 */
@Service
public class TipoAtendimentoService {

    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public TipoAtendimentoService(TipoAtendimentoRepository tipoAtendimentoRepository,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Busca um Tipo de Atendimento pelo ID.
     *
     * @param id ID do Tipo de Atendimento.
     * @return DTO do Tipo de Atendimento.
     * @throws BusinessException se o Tipo de Atendimento não for encontrado.
     */
    public TipoAtendimentoResponseDTO findTipoAtendimentoById(UUID id) {
        TipoAtendimento tipoAtendimento = tipoAtendimentoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Tipo de Atendimento não encontrado."));
        return tipoAtendimentoMapper.toResponseDTO(tipoAtendimento);
    }

    /**
     * Lista todos os Tipos de Atendimento.
     *
     * @return Lista de DTOs de Tipos de Atendimento.
     */
    public List<TipoAtendimentoResponseDTO> findAllTiposAtendimento() {
        return tipoAtendimentoRepository.findAll().stream()
                .map(tipoAtendimentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.commom.dto.request; // Assumindo um pacote common.dto.request para entidades comuns

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private String id; // Pode ser UUID ou String, dependendo da BaseEntity

    @NotBlank(message = "O logradouro é obrigatório.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número é obrigatório.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro é obrigatório.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade é obrigatória.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado é obrigatório.")
    @Size(max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP é obrigatório.")
    @Size(max = 9, message = "O CEP deve ter no máximo 9 caracteres.") // Com ou sem máscara
    private String cep;

    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais; // Valor padrão "Brasil" pode ser setado no serviço

    @NotNull(message = "O tipo de endereço é obrigatório.")
    private TipoEndereco tipoEndereco; // Usando o enum da entidade
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * DTO para requisição de criação ou atualização de uma Pessoa.
 * Inclui campos de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // ID é opcional para atualização (usado em PUT/put para identificar a Pessoa)
    private UUID id;

    @Valid
    @NotNull(message = "As informações do usuário são obrigatórias.")
    private UserRequestDTO usuario; // Informações de login e contato do usuário

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpf;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimento;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefones;

    @Valid
    private List<EnderecoRequestDTO> enderecos; // Lista de endereços associados à pessoa
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    // @NotBlank(message = "A senha do usuário é obrigatória.") // Pode ser
    // @NotBlank apenas na criação
    private String senha; // Em requisições, a senha é enviada em texto limpo para ser hashed no backend

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 14, message = "O CPF deve ter no máximo 14 caracteres.")
    private String cpf; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response; // Assumindo um pacote common.dto.response para entidades comuns

import java.util.UUID;

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;

    private String logradouro;

    private String numero;

    private String complemento;

    private String bairro;

    private String cidade;

    private String estado;

    private String cep;

    private String pais;

    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de uma Pessoa.
 * Inclui informações de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PessoaResponseDTO {
    private UUID id;

    private UserResponseDTO usuario;

    private String nomeCompleto;

    private String cpf;

    private LocalDate dataNascimento;

    private List<String> telefones;

    private List<EnderecoResponseDTO> enderecos;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.commom.model.User.UserStatus; // Importar o enum UserStatus da entidade User
import br.com.legalconnect.commom.model.User.UserType; // Importar o enum UserType da entidade User
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
package br.com.legalconnect.commom.mapper;

import java.util.UUID;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.EnderecoRequestDTO;
import br.com.legalconnect.commom.dto.response.EnderecoResponseDTO;
import br.com.legalconnect.commom.model.Endereco;

/**
 * Mapper MapStruct para a entidade Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {
    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * Mapeia um EnderecoRequestDTO para uma entidade Endereco.
     * Os campos 'pessoa' e 'empresa' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Endereco correspondente.
     */
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true) // Descomente se Empresa for
    // relevante e existir
    @Mapping(target = "id", source = "id", qualifiedByName = "mapStringToUuid")
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * Mapeia uma entidade Endereco para um EnderecoResponseDTO.
     *
     * @param entity A entidade Endereco.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id", qualifiedByName = "mapUuidToString")
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * Atualiza uma entidade Endereco existente com os dados de um
     * EnderecoRequestDTO.
     * O campo 'pessoa' e 'empresa' não são atualizados via DTO. O ID não deve ser
     * atualizado.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Endereco a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true)
    void updateEntityFromDto(EnderecoRequestDTO dto, @MappingTarget Endereco entity);

    /**
     * Converte uma String (ID do DTO) para um UUID (ID da Entidade).
     * 
     * @param id A string representando o UUID.
     * @return O objeto UUID.
     */
    @Named("mapStringToUuid")
    default UUID mapStringToUuid(UUID id) {
        return id != null ? (id) : null;
    }

    /**
     * Converte um UUID (ID da Entidade) para uma String (ID do DTO).
     * 
     * @param id O objeto UUID.
     * @return A string representando o UUID.
     */
    @Named("mapUuidToString")
    default String mapUuidToString(UUID id) {
        return id != null ? id.toString() : null;
    }
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.model.Pessoa;

/**
 * Mapper MapStruct para a entidade Pessoa e seus DTOs.
 * Utiliza UserMapper e EnderecoMapper para mapeamentos aninhados.
 */
@Mapper(componentModel = "spring", uses = { UserMapper.class, EnderecoMapper.class })
public interface PessoaMapper {
    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * Mapeia um PessoaRequestDTO para uma entidade Pessoa.
     * Os campos 'usuario' e 'enderecos' serão mapeados pelos mappers especificados
     * em 'uses'.
     * A conversão de List para Set para 'telefones' é feita automaticamente pelo
     * MapStruct.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Pessoa correspondente.
     */
    // @Mapping(target = "id", ignore = true) // ID da Pessoa será gerado na criação
    // Pessoa toEntity(PessoaRequestDTO dto);

    /**
     * Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     *
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta correspondente.
     */
    PessoaResponseDTO toResponseDTO(Pessoa entity);

    /**
     * Atualiza uma entidade Pessoa existente com os dados de um PessoaRequestDTO.
     * O 'id' da Pessoa não deve ser atualizado.
     * A atualização de 'usuario' e 'enderecos' deve ser orquestrada no serviço,
     * pois o MapStruct pode não ter o contexto para atualizar entidades aninhadas
     * existentes.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Pessoa a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "usuario", ignore = true) // O serviço deve gerenciar a atualização do User associado
    @Mapping(target = "enderecos", ignore = true) // O serviço deve gerenciar a atualização dos Enderecos associados
    @Mapping(source = "telefones", target = "telefones") // Converte List<String> para Set<String>
    void updateEntityFromDto(PessoaRequestDTO dto, @MappingTarget Pessoa entity);
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.UserResponseDTO;
import br.com.legalconnect.commom.model.User;

/**
 * Mapper MapStruct para a entidade User e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * Mapeia um UserRequestDTO para uma entidade User.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' são definidos pela lógica de negócio e ignorados
     * aqui.
     *
     * @param dto O DTO de requisição.
     * @return A entidade User correspondente.
     */
    @Mapping(source = "senha", target = "senhaHash") // Mapeia a senha do DTO para senhaHash na entidade
    // @Mapping(target = "userType", ignore = true) // Definido pela lógica de
    // negócio
    // @Mapping(target = "userStatus", ignore = true) // Definido pela lógica de
    // negócio
    User toEntity(UserRequestDTO dto);

    /**
     * Mapeia uma entidade User para um UserResponseDTO.
     * 'senhaHash' é ignorado na resposta por segurança.
     *
     * @param entity A entidade User.
     * @return O DTO de resposta correspondente.
     */
    // @Mapping(target = "senha", ignore = true) // 'senhaHash' é um campo interno
    // da entidade, não deve ser exposto no DTO de resposta
    UserResponseDTO toResponseDTO(User entity);

    /**
     * Atualiza uma entidade User existente com os dados de um UserRequestDTO.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade User a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(source = "senha", target = "senhaHash")
    // @Mapping(target = "userType", ignore = true)
    // @Mapping(target = "userStatus", ignore = true)
    void updateEntityFromDto(UserRequestDTO dto, @MappingTarget User entity);
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "empresa_id")
    // private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.commom.model;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.Pessoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Pessoa}.
 * Gerencia operações de persistência para informações de pessoas no sistema.
 */
@Repository
public interface PessoaRepository extends JpaRepository<Pessoa, UUID> {

    /**
     * Verifica se existe uma Pessoa com o CPF fornecido.
     * Regra de Negócio: Garante a unicidade do CPF no sistema.
     *
     * @param cpf O CPF a ser verificado.
     * @return true se uma Pessoa com o CPF já existe, false caso contrário.
     */
    boolean existsByCpf(String cpf);

    /**
     * Busca uma Pessoa pelo ID do usuário associado.
     *
     * @param userId O ID do usuário.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByUsuarioId(UUID userId);

    /**
     * Busca uma Pessoa pelo CPF.
     *
     * @param cpf O CPF da Pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu endereço de e-mail.
     * Regra de Negócio: O e-mail é único para cada usuário dentro de um tenant.
     *
     * @param email O endereço de e-mail do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * Verifica se um usuário com o endereço de e-mail fornecido já existe.
     * Regra de Negócio: Garante a unicidade do e-mail no sistema.
     *
     * @param email O endereço de e-mail a ser verificado.
     * @return true se um usuário com o e-mail já existe, false caso contrário.
     */
    boolean existsByEmail(String email);
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço simulado para envio de e-mails.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com um provedor de e-mails
 * como SendGrid, Amazon SES, ou o serviço de e-mail do Spring Boot.
 */
@Service
public class EmailService {

    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    /**
     * Simula o envio de um e-mail de ativação de conta.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param activationLink O link de ativação da conta.
     */
    public void sendActivationEmail(String toEmail, String activationLink) {
        log.info("Simulando envio de e-mail de ativação para: {}", toEmail);
        log.info("Link de Ativação: {}", activationLink);
        // Lógica real de envio de e-mail seria aqui, por exemplo:
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(toEmail);
        // helper.setSubject("Ative sua conta na LegalConnect!");
        // helper.setText("Olá! Clique no link para ativar sua conta: " + activationLink, true);
        // mailSender.send(message);
        log.info("E-mail de ativação simulado enviado com sucesso.");
    }

    /**
     * Simula o envio de um e-mail de confirmação de agendamento.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param details Detalhes do agendamento.
     */
    public void sendAppointmentConfirmationEmail(String toEmail, String details) {
        log.info("Simulando envio de e-mail de confirmação de agendamento para: {}", toEmail);
        log.info("Detalhes do Agendamento: {}", details);
        log.info("E-mail de confirmação de agendamento simulado enviado com sucesso.");
    }

    // Outros métodos de envio de e-mail podem ser adicionados conforme a necessidade
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;
import br.com.legalconnect.commom.mapper.UserMapper;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.model.User;
import br.com.legalconnect.commom.repository.PessoaRepository; // Assumindo a existência de PessoaRepository
import br.com.legalconnect.commom.repository.UserRepository; // Assumindo a existência de UserRepository
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das entidades Pessoa e User.
 * Centraliza a lógica de negócio para criação, atualização e busca de Pessoas
 * e seus usuários associados, incluindo validações de unicidade e criptografia
 * de senha.
 */
@Service
public class PessoaService {

    private final PessoaRepository pessoaRepository;
    private final UserRepository userRepository;
    private final PessoaMapper pessoaMapper;
    private final UserMapper userMapper;
    // Assumindo um EnderecoMapper se EnderecoRequestDTO for mapeado para Endereco
    // aqui
    // private final EnderecoMapper enderecoMapper;

    @Autowired
    public PessoaService(PessoaRepository pessoaRepository, UserRepository userRepository,
            PessoaMapper pessoaMapper, UserMapper userMapper) {
        this.pessoaRepository = pessoaRepository;
        this.userRepository = userRepository;
        this.pessoaMapper = pessoaMapper;
        this.userMapper = userMapper;
    }

    /**
     * Cria uma nova Pessoa e seu User associado.
     * Regras de Negócio:
     * - Garante que o CPF e o e-mail do usuário sejam únicos no sistema.
     * - Criptografa a senha antes de salvar.
     * - Define o status inicial do usuário como PENDING para aguardar ativação.
     *
     * @param pessoaRequestDTO DTO com os dados da Pessoa e do User.
     * @return DTO da Pessoa criada.
     * @throws BusinessException se o CPF ou e-mail já estiverem cadastrados.
     */
    @Transactional
    public Pessoa createPessoa(PessoaRequestDTO pessoaRequestDTO) {
        // Regra de Negócio: Validar unicidade de CPF
        if (pessoaRepository.existsByCpf(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, pessoaRequestDTO.getCpf());
        }

        // Regra de Negócio: Validar unicidade de e-mail para o usuário
        if (userRepository.existsByEmail(pessoaRequestDTO.getUsuario().getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    pessoaRequestDTO.getUsuario().getEmail());
        }

        // Cria e criptografa o usuário

        // Persiste o usuário
        var newUser = new User();
        newUser.setId((pessoaRequestDTO.getUsuario().getId()));

        // Cria a Pessoa e associa o usuário
        Pessoa newPessoa = Pessoa.builder()
                .usuario(newUser)
                .nomeCompleto(pessoaRequestDTO.getNomeCompleto())
                .cpf(pessoaRequestDTO.getCpf())
                .dataNascimento(pessoaRequestDTO.getDataNascimento())
                .telefones(new HashSet<>(pessoaRequestDTO.getTelefones()))
                .build();

        // Adiciona endereços
        if (pessoaRequestDTO.getEnderecos() != null && !pessoaRequestDTO.getEnderecos().isEmpty()) {
            Set<Endereco> enderecos = pessoaRequestDTO.getEnderecos().stream()
                    .map(dto -> {
                        Endereco endereco = new Endereco(); // Ou use enderecoMapper.toEntity(dto) se existir
                        endereco.setLogradouro(dto.getLogradouro());
                        endereco.setNumero(dto.getNumero());
                        endereco.setComplemento(dto.getComplemento());
                        endereco.setBairro(dto.getBairro());
                        endereco.setCidade(dto.getCidade());
                        endereco.setEstado(dto.getEstado());
                        endereco.setCep(dto.getCep());
                        endereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil"); // Define país padrão
                        endereco.setTipoEndereco(dto.getTipoEndereco());
                        endereco.setPessoa(newPessoa); // Associa o endereço à Pessoa
                        return endereco;
                    }).collect(Collectors.toSet());
            newPessoa.setEnderecos(enderecos);
        }
        // Reassigning to make it effectively final
        return (pessoaRepository.save(newPessoa));
    }

    /**
     * Busca uma Pessoa pelo ID.
     *
     * @param id ID da Pessoa.
     * @return DTO da Pessoa encontrada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    public PessoaResponseDTO findPessoaById(UUID id) {
        Pessoa pessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * Atualiza os dados de uma Pessoa existente.
     * Regras de Negócio:
     * - Permite a atualização de informações da Pessoa e do User associado.
     * - Valida a unicidade do e-mail se for alterado.
     * - Não permite a alteração do CPF.
     *
     * @param id               ID da Pessoa a ser atualizada.
     * @param pessoaRequestDTO DTO com os dados para atualização.
     * @return DTO da Pessoa atualizada.
     * @throws BusinessException se a Pessoa não for encontrada, ou se o e-mail já
     *                           estiver cadastrado.
     */
    @Transactional
    public PessoaResponseDTO updatePessoa(UUID id, PessoaRequestDTO pessoaRequestDTO) {
        Pessoa existingPessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada para atualização."));

        // Não permitir alteração de CPF (Regra de Negócio)
        if (!existingPessoa.getCpf().equals(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "Não é permitido alterar o CPF de uma pessoa existente.");
        }

        // Atualiza o User associado
        User existingUser = existingPessoa.getUsuario();
        UserRequestDTO userRequestDTO = pessoaRequestDTO.getUsuario();

        // Valida unicidade de e-mail se o e-mail for alterado
        if (!existingUser.getEmail().equals(userRequestDTO.getEmail())
                && userRepository.existsByEmail(userRequestDTO.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT, userRequestDTO.getEmail());
        }

        userMapper.updateEntityFromDto(userRequestDTO, existingUser);
        userRepository.save(existingUser); // Salva as alterações no User

        // Atualiza os dados da Pessoa (exceto usuário e endereços que são gerenciados
        // separadamente)
        pessoaMapper.updateEntityFromDto(pessoaRequestDTO, existingPessoa);

        // Lógica para gerenciar Endereços: Adicionar, Atualizar, Remover
        // Isso pode ser complexo e requer lógica manual, pois EndereçoRequestDTO tem ID
        // opcional
        // Para simplificar, vou redefinir os endereços ou adicionar lógica de
        // diferenciação.
        // Uma abordagem mais robusta seria comparar listas e fazer operações de CRUD
        // individualmente.
        if (pessoaRequestDTO.getEnderecos() != null) {
            // Removendo endereços que não estão no DTO
            existingPessoa.getEnderecos().removeIf(existingEndereco -> pessoaRequestDTO.getEnderecos().stream()
                    .noneMatch(dto -> dto.getId() != null && dto.getId().equals(existingEndereco.getId().toString())));

            // Adicionando ou atualizando endereços
            for (br.com.legalconnect.commom.dto.request.EnderecoRequestDTO dto : pessoaRequestDTO.getEnderecos()) {
                if (dto.getId() == null) {
                    // Novo endereço
                    Endereco newEndereco = new Endereco();
                    newEndereco.setLogradouro(dto.getLogradouro());
                    newEndereco.setNumero(dto.getNumero());
                    newEndereco.setComplemento(dto.getComplemento());
                    newEndereco.setBairro(dto.getBairro());
                    newEndereco.setCidade(dto.getCidade());
                    newEndereco.setEstado(dto.getEstado());
                    newEndereco.setCep(dto.getCep());
                    newEndereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                    newEndereco.setTipoEndereco(dto.getTipoEndereco());
                    newEndereco.setPessoa(existingPessoa);
                    existingPessoa.getEnderecos().add(newEndereco);
                } else {
                    // Atualizar endereço existente
                    existingPessoa.getEnderecos().stream()
                            .filter(e -> e.getId().toString().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> {
                                e.setLogradouro(dto.getLogradouro());
                                e.setNumero(dto.getNumero());
                                e.setComplemento(dto.getComplemento());
                                e.setBairro(dto.getBairro());
                                e.setCidade(dto.getCidade());
                                e.setEstado(dto.getEstado());
                                e.setCep(dto.getCep());
                                e.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                                e.setTipoEndereco(dto.getTipoEndereco());
                            });
                }
            }
        }

        existingPessoa = pessoaRepository.save(existingPessoa);
        return pessoaMapper.toResponseDTO(existingPessoa);
    }

    /**
     * Deleta uma Pessoa pelo ID.
     * Regras de Negócio:
     * - Também deleta o User associado devido ao CascadeType.ALL na Pessoa.
     *
     * @param id ID da Pessoa a ser deletada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    @Transactional
    public void deletePessoa(UUID id) {
        if (!pessoaRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                    "Pessoa não encontrada para deleção.");
        }
        pessoaRepository.deleteById(id);
    }

    public Optional<LocalAtuacao> findPessoaByCpf(String cpf) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByCpf'");
    }

    public Optional<LocalAtuacao> findPessoaByEmail(String email) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByEmail'");
    }
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço de integração simulada com AWS S3 para upload e deleção de arquivos.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a AWS
 * SDK.
 */
@Service
public class S3Service {

    private static final Logger log = LoggerFactory.getLogger(S3Service.class);
    private static final String MOCK_S3_BASE_URL = "https://mock-s3-bucket.s3.amazonaws.com/";

    /**
     * Simula o upload de um arquivo para o S3.
     *
     * @param fileBytes Os bytes do arquivo.
     * @param key       A chave/caminho do arquivo no bucket S3.
     * @param mimeType  O tipo MIME do arquivo.
     * @return A URL pública do arquivo no S3.
     * @throws BusinessException se ocorrer um erro durante o "upload" simulado.
     */
    public String uploadFile(byte[] fileBytes, String key, String mimeType) {
        if (fileBytes == null || fileBytes.length == 0) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "O conteúdo do arquivo não pode ser vazio.");
        }
        if (key == null || key.isEmpty()) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "A chave do S3 não pode ser vazia.");
        }

        // Simulação de upload: Loga a operação e retorna uma URL mock
        log.info("Simulando upload para S3. Chave: {}, Tamanho: {} bytes, Tipo: {}", key, fileBytes.length, mimeType);
        String fileUrl = MOCK_S3_BASE_URL + key;
        log.info("Upload simulado concluído. URL: {}", fileUrl);
        return fileUrl;
    }

    /**
     * Simula a deleção de um arquivo do S3.
     *
     * @param fileUrl A URL pública do arquivo a ser deletado.
     * @throws BusinessException se ocorrer um erro durante a "deleção" simulada.
     */
    public void deleteFile(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "URL do arquivo não pode ser vazia para deleção.");
        }

        // Simulação de deleção: Loga a operação
        log.info("Simulando deleção de S3. URL: {}", fileUrl);
        // Em um ambiente real, aqui estaria a chamada para o AWS S3 SDK para deletar o
        // objeto.
        // Por exemplo: s3Client.deleteObject(bucketName, key);
        log.info("Deleção simulada concluída para URL: {}", fileUrl);
    }
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.UUID;

/**
 * Utilitário para gerenciar o ID do Tenant no contexto da thread atual.
 * Usado em arquiteturas multitenant para garantir que as operações de banco de dados
 * sejam filtradas pelo tenant correto.
 */
public class TenantContext {

    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();

    /**
     * Define o ID do Tenant para a thread atual.
     *
     * @param tenantId O ID do Tenant.
     */
    public static void setCurrentTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }

    /**
     * Retorna o ID do Tenant da thread atual.
     *
     * @return O ID do Tenant.
     * @throws IllegalStateException se o Tenant ID não estiver definido no contexto.
     */
    public static UUID getCurrentTenantId() {
        UUID tenantId = currentTenant.get();
        if (tenantId == null) {
            // Em um ambiente real, você pode lançar uma exceção ou retornar um tenant padrão
            // dependendo da lógica de segurança e acesso.
            // Por simplicidade para este exercício, lançaremos uma exceção.
            throw new IllegalStateException("Tenant ID não está definido no contexto da requisição. Verifique o filtro de segurança.");
        }
        return tenantId;
    }

    /**
     * Limpa o ID do Tenant da thread atual.
     * Deve ser chamado ao final da requisição para evitar vazamentos de contexto.
     */
    public static void clear() {
        currentTenant.remove();
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-advogados
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

 
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
package br.com.legalconnect.legal_usuario;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LegalUsuarioApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories(basePackages = {
		"br.com.legalconnect.advogado.repository",
		"br.com.legalconnect.commom.repository" })
@EntityScan(basePackages = {
		"br.com.legalconnect.commom.model",
		"br.com.legalconnect.advogado.domain" })
@EnableDiscoveryClient
@SpringBootApplication
public class LegalUsuarioApplication {
	// @Value("${application.tenant.default-id}")
	// private String defaultTenantId;

	// @Autowired
	// private TenantMigrationService tenantMigrationService;

	public static void main(String[] args) {
		SpringApplication.run(LegalUsuarioApplication.class, args);
	}
}
// @Bean
// boolean inicio() {
// tenantMigrationService.migrateTenant(defaultTenantId);
// return true;
// }
// }

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.ERRO;
import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.service.AgendamentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.NotNull;

/**
 * Controller para o módulo de Agendamento de Consultas.
 * Gerencia as operações relacionadas ao agendamento e avaliação de consultas
 * entre clientes e profissionais.
 */
@RestController
@RequestMapping("/api/v1/advogados/agendamentos")
@Tag(name = "Agendamentos", description = "Gerenciamento de agendamentos de consultas e avaliações")
public class AgendamentoController {

        private final AgendamentoService agendamentoService;

        @Autowired
        public AgendamentoController(AgendamentoService agendamentoService) {
                this.agendamentoService = agendamentoService;
        }

        /**
         * Realiza o agendamento de uma consulta.
         * Funcionalidade Completa: Cenário 1 (Cliente busca e agenda) e Cenário 2
         * (Advogado recebe e confirma).
         * Regras de Negócio: Verifica disponibilidade do profissional, profissional
         * deve estar ativo e usar marketplace, integração com Google Calendar, envio de
         * e-mails.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta (formato ISO).
         * @param tipoServico        Tipo de serviço agendado.
         * @return ResponseEntity indicando o sucesso do agendamento.
         */
        @Operation(summary = "Agenda uma nova consulta", description = "Permite a um cliente agendar uma consulta com um profissional, verificando disponibilidade e enviando notificações.", responses = {
                        @ApiResponse(responseCode = "201", description = "Consulta agendada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: horário indisponível)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de agendamento (horário já ocupado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/agendar")
        public ResponseEntity<BaseResponse<Boolean>> agendarConsulta(
                        @Parameter(description = "ID do profissional para o agendamento") @RequestParam @NotNull UUID profissionalId,
                        @Parameter(description = "ID do cliente que está agendando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Horário desejado para a consulta (formato ISO 8601, ex: 2024-07-25T10:00:00)") @RequestParam @NotNull @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime horarioAgendamento,
                        @Parameter(description = "Tipo de serviço a ser agendado (ex: 'Consulta Online', 'Reunião Presencial')") @RequestParam @NotNull String tipoServico) {

                boolean sucesso = agendamentoService.agendarConsulta(profissionalId, clienteId, horarioAgendamento,
                                tipoServico);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Boolean>builder()
                                                .status(SUCESSO)
                                                .message("Consulta agendada com sucesso.")
                                                .data(sucesso)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Permite ao cliente avaliar uma consulta.
         * Funcionalidade Completa: Cenário 3 (Cliente avalia e influencia ranking).
         * Regras de Negócio: Associa avaliação ao agendamento e profissional, atualiza
         * média de avaliação.
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return ResponseEntity indicando o sucesso da avaliação.
         */
        @Operation(summary = "Avalia uma consulta", description = "Permite a um cliente fornecer uma nota e um comentário para uma consulta já realizada.", responses = {
                        @ApiResponse(responseCode = "200", description = "Consulta avaliada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: nota fora do intervalo)"),
                        @ApiResponse(responseCode = "404", description = "Agendamento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/avaliar")
        public ResponseEntity<BaseResponse<Boolean>> avaliarConsulta(
                        @Parameter(description = "ID do agendamento a ser avaliado") @RequestParam @NotNull UUID agendamentoId,
                        @Parameter(description = "ID do cliente que está avaliando") @RequestParam @NotNull UUID clienteId,
                        @Parameter(description = "Nota da avaliação (1 a 5)") @RequestParam @NotNull int rating,
                        @Parameter(description = "Comentário opcional sobre a avaliação") @RequestParam(required = false) String comentario) {

                // Regra de Negócio: Rating deve estar entre 1 e 5
                if (rating < 1 || rating > 5) {
                        return ResponseEntity.badRequest().body(BaseResponse.<Boolean>builder()
                                        .status(ERRO)
                                        .message("A nota da avaliação deve ser entre 1 e 5.")
                                        .data(false)
                                        .timestamp(java.time.LocalDateTime.now())
                                        .build());
                }

                boolean sucesso = agendamentoService.avaliarConsulta(agendamentoId, clienteId, rating, comentario);
                return ResponseEntity.ok(BaseResponse.<Boolean>builder()
                                .status(SUCESSO)
                                .message("Consulta avaliada com sucesso.")
                                .data(sucesso)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Áreas de Atuação (dados mestre).
 * Oferece endpoints para consultar as áreas de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/areas-atuacao")
@Tag(name = "Áreas de Atuação", description = "Gerenciamento de dados mestre de Áreas de Atuação")
public class AreaAtuacaoController {

        private final AreaAtuacaoService areaAtuacaoService;

        @Autowired
        public AreaAtuacaoController(AreaAtuacaoService areaAtuacaoService) {
                this.areaAtuacaoService = areaAtuacaoService;
        }

        /**
         * Busca uma Área de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID da Área de Atuação.
         * @return ResponseEntity com o DTO da Área de Atuação.
         */
        @Operation(summary = "Busca uma área de atuação pelo ID", description = "Retorna os detalhes de uma área de atuação específica.", responses = {
                        @ApiResponse(responseCode = "200", description = "Área de Atuação encontrada com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Área de Atuação não encontrada"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<AreaAtuacaoResponseDTO>> getAreaAtuacaoById(
                        @Parameter(description = "ID da Área de Atuação") @PathVariable UUID id) {
                AreaAtuacaoResponseDTO response = areaAtuacaoService.findAreaAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<AreaAtuacaoResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Área de Atuação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.service.IdiomaService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Idiomas (dados mestre).
 * Oferece endpoints para consultar os idiomas disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/idiomas")
@Tag(name = "Idiomas", description = "Gerenciamento de dados mestre de Idiomas")
public class IdiomaController {

        private final IdiomaService idiomaService;

        @Autowired
        public IdiomaController(IdiomaService idiomaService) {
                this.idiomaService = idiomaService;
        }

        /**
         * Busca um Idioma pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Idioma.
         * @return ResponseEntity com o DTO do Idioma.
         */
        @Operation(summary = "Busca um idioma pelo ID", description = "Retorna os detalhes de um idioma específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idioma encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Idioma não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<IdiomaResponseDTO>> getIdiomaById(
                        @Parameter(description = "ID do idioma") @PathVariable UUID id) {
                IdiomaResponseDTO response = idiomaService.findIdiomaById(id);
                return ResponseEntity.ok(BaseResponse.<IdiomaResponseDTO>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idioma encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Idiomas.
         * Funcionalidade Completa: Listagem de todos os idiomas disponíveis para
         * seleção pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Idiomas.
         */
        @Operation(summary = "Lista todos os idiomas", description = "Retorna uma lista de todos os idiomas cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Idiomas listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<IdiomaResponseDTO>>> getAllIdiomas() {
                List<IdiomaResponseDTO> response = idiomaService.findAllIdiomas();
                return ResponseEntity.ok(BaseResponse.<List<IdiomaResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Idiomas listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.LocalAtuacaoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Locais de Atuação (dados mestre).
 * Oferece endpoints para consultar os locais de atuação disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/locais-atuacao")
@Tag(name = "Locais de Atuação", description = "Gerenciamento de dados mestre de Locais de Atuação")
public class LocalAtuacaoController {

        private final LocalAtuacaoService localAtuacaoService;

        @Autowired
        public LocalAtuacaoController(LocalAtuacaoService localAtuacaoService) {
                this.localAtuacaoService = localAtuacaoService;
        }

        /**
         * Busca um Local de Atuação pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Local de Atuação.
         * @return ResponseEntity com o DTO do Local de Atuação.
         */
        @Operation(summary = "Busca um local de atuação pelo ID", description = "Retorna os detalhes de um local de atuação específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Local de Atuação encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Local de Atuação não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<LocalAtuacaoResponseDTO>> getLocalAtuacaoById(
                        @Parameter(description = "ID do Local de Atuação") @PathVariable UUID id) {
                LocalAtuacaoResponseDTO response = localAtuacaoService.findLocalAtuacaoById(id);
                return ResponseEntity.ok(BaseResponse.<LocalAtuacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Local de Atuação encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Locais de Atuação.
         * Funcionalidade Completa: Listagem de todos os locais disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Locais de Atuação.
         */
        @Operation(summary = "Lista todos os locais de atuação", description = "Retorna uma lista de todos os locais de atuação cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Locais de Atuação listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<LocalAtuacaoResponseDTO>>> getAllLocaisAtuacao() {
                List<LocalAtuacaoResponseDTO> response = localAtuacaoService.findAllLocaisAtuacao();
                return ResponseEntity.ok(BaseResponse.<List<LocalAtuacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Locais de Atuação listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.service.CertificacaoService;
import br.com.legalconnect.advogado.service.DocumentoService;
import br.com.legalconnect.advogado.service.ExperienciaProfissionalService;
import br.com.legalconnect.advogado.service.FormacaoAcademicaService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;

/**
 * Controller para o módulo de Profissionais (Advogados).
 * Gerencia as operações REST para perfis de advogados,
 * incluindo suas certificações, experiências, formações e documentos.
 */
@RestController
@RequestMapping("/api/v1/advogados/profissionais")
@Tag(name = "Profissionais", description = "Gerenciamento de perfis de Advogados")
public class ProfissionalController {

        private final ProfissionalService profissionalService;
        private final CertificacaoService certificacaoService;
        private final ExperienciaProfissionalService experienciaProfissionalService;
        private final FormacaoAcademicaService formacaoAcademicaService;
        private final DocumentoService documentoService;

        @Autowired
        public ProfissionalController(ProfissionalService profissionalService,
                        CertificacaoService certificacaoService,
                        ExperienciaProfissionalService experienciaProfissionalService,
                        FormacaoAcademicaService formacaoAcademicaService,
                        DocumentoService documentoService) {
                this.profissionalService = profissionalService;
                this.certificacaoService = certificacaoService;
                this.experienciaProfissionalService = experienciaProfissionalService;
                this.formacaoAcademicaService = formacaoAcademicaService;
                this.documentoService = documentoService;
        }

        // ***************************************

        /**
         * Lista todas as localizações (estados e cidades) onde há profissionais.
         * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
         * cidades.
         *
         * @return ResponseEntity com o mapa de localizações.
         */
        @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/localizacoes")
        public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
                Map<String, List<String>> response = profissionalService.listarLocalizacoesDisponiveis();

                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<Map<String, List<String>>>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        // ************************************************ */
        /**
         * Cria um novo profissional (advogado) no sistema.
         * Funcionalidade Completa: Cadastro de Advogado com dados aninhados.
         * Regras de Negócio: Validação de unicidade de OAB, CPF e Email. Associação a
         * um tenant.
         *
         * @param request      DTO com os dados do profissional a ser criado.
         * @param userIdHeader Opcional. ID do usuário logado/solicitante, vindo do
         *                     cabeçalho X-Correlation-Id.
         * @return ResponseEntity com o DTO do profissional criado.
         */
        @Operation(summary = "Cria um novo profissional", description = "Registra um novo advogado com seus dados pessoais e informações profissionais.", responses = {
                        @ApiResponse(responseCode = "201", description = "Profissional criado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "409", description = "OAB, CPF ou Email já cadastrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> createProfissional(
                        @Valid @RequestBody ProfissionalCreateRequest request,
                        @RequestHeader(value = "X-Correlation-Id", required = false) String userIdHeader) {
                if (userIdHeader != null && !userIdHeader.trim().isEmpty()) {
                        try {
                                UUID userUuid = UUID.fromString(userIdHeader); // Validar se é um UUID válido

                                if (request.getUsuario() == null) {
                                        // Se o DTO de usuário não foi fornecido no corpo, cria um com o ID do header
                                        request.setUsuario(UserRequestDTO.builder().id(userUuid).build());
                                } else if (request.getUsuario().getId() == null) {
                                        // Se o DTO de usuário foi fornecido, mas sem ID, usa o do header
                                        request.getUsuario().setId(userUuid);
                                }
                        } catch (IllegalArgumentException e) {
                                // Logar ou tratar erro se userIdHeader não for um UUID válido
                                // Para este caso, vamos apenas logar e ignorar o userIdHeader inválido.
                                System.err.println("X-Correlation-Id inválido: " + userIdHeader
                                                + ". Ignorando ID do cabeçalho.");
                        }
                }

                ProfissionalResponseDTO response = profissionalService.createProfissional(request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Profissional criado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza um profissional existente.
         * Funcionalidade Completa: Atualização de perfil de advogado, incluindo dados
         * da Pessoa e coleções aninhadas.
         * Regras de Negócio: Acesso restrito ao próprio tenant, validação de
         * existência.
         *
         * @param id      ID do profissional a ser atualizado.
         * @param request DTO com os dados de atualização.
         * @return ResponseEntity com o DTO do profissional atualizado.
         */
        @Operation(summary = "Atualiza um profissional existente", description = "Atualiza os dados de um advogado, incluindo informações pessoais e coleções relacionadas.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional atualizado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "409", description = "Conflito de dados (ex: email duplicado)"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> updateProfissional(
                        @Parameter(description = "ID do profissional a ser atualizado") @PathVariable UUID id,
                        @Valid @RequestBody ProfissionalUpdateRequest request) {
                ProfissionalResponseDTO response = profissionalService.updateProfissional(id, request);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional atualizado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca um profissional pelo ID.
         * Funcionalidade Completa: Exibição detalhada do perfil de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param id ID do profissional.
         * @return ResponseEntity com o DTO do profissional.
         */
        @Operation(summary = "Busca um profissional pelo ID", description = "Retorna os detalhes completos de um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> getProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID id) {
                ProfissionalResponseDTO response = profissionalService.findProfissionalById(id);
                return ResponseEntity.ok(BaseResponse.<ProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Profissional encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os profissionais do tenant atual com paginação.
         * Funcionalidade Completa: Listagem paginada de advogados para o marketplace ou
         * para gestão interna do tenant.
         * Regras de Negócio: Filtro automático por tenant_id.
         *
         * @param page Número da página (0-indexed).
         * @param size Tamanho da página.
         * @param sort Critério de ordenação (ex: campo,asc ou campo,desc).
         * @return ResponseEntity com a página de DTOs de profissionais.
         */
        @Operation(summary = "Lista todos os profissionais com paginação", description = "Retorna uma lista paginada de todos os advogados associados ao tenant atual.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissionais listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> getAllProfissionais(
                        @Parameter(description = "Número da página (0-indexed)", example = "0") @RequestParam(defaultValue = "0") int page,
                        @Parameter(description = "Tamanho da página", example = "10") @RequestParam(defaultValue = "10") int size,
                        @Parameter(description = "Critério de ordenação (ex: nomeCompleto,asc ou numeroOab,desc)", example = "nomeCompleto,asc") @RequestParam(defaultValue = "nomeCompleto,asc") String[] sort) {

                Sort sortCriteria = Sort.by(Sort.Direction.fromString(sort[1]), sort[0]);
                PageRequest pageable = PageRequest.of(page, size, sortCriteria);

                Page<ProfissionalResponseDTO> response = profissionalService.findAllProfissionais(pageable);
                return ResponseEntity.ok(BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Profissionais listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um profissional pelo ID.
         * Funcionalidade Completa: Remoção completa do perfil do advogado e dados
         * associados.
         * Regras de Negócio: Acesso restrito ao próprio tenant. Deleção em cascata
         * (certificações, experiências, documentos, formação, pessoa).
         *
         * @param id ID do profissional a ser deletado.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um profissional pelo ID", description = "Remove um advogado e todos os seus dados associados do sistema.", responses = {
                        @ApiResponse(responseCode = "200", description = "Profissional deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deleteProfissional(
                        @Parameter(description = "ID do profissional a ser deletado") @PathVariable UUID id) {
                profissionalService.deleteProfissional(id);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Profissional deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Certificações ---

        /**
         * Adiciona uma certificação a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de certificações.
         * Regras de Negócio: Certificação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da certificação.
         * @return ResponseEntity com a certificação criada.
         */
        @Operation(summary = "Adiciona uma certificação a um profissional", description = "Adiciona uma nova certificação ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Certificação adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> addCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.createCertificacao(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<CertificacaoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Certificação adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma certificação de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma certificação
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a certificação atualizada.
         */
        @Operation(summary = "Atualiza uma certificação de um profissional", description = "Atualiza os detalhes de uma certificação existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> updateCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser atualizada") @PathVariable UUID certificacaoId,
                        @Valid @RequestBody CertificacaoRequestDTO requestDTO) {
                CertificacaoResponseDTO response = certificacaoService.updateCertificacao(profissionalId,
                                certificacaoId,
                                requestDTO);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma certificação específica de um profissional.
         * Funcionalidade Completa: Consulta individual de certificação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity com a certificação encontrada.
         */
        @Operation(summary = "Busca uma certificação específica de um profissional", description = "Retorna os detalhes de uma certificação específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<CertificacaoResponseDTO>> getCertificacaoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação") @PathVariable UUID certificacaoId) {
                CertificacaoResponseDTO response = certificacaoService.findCertificacaoById(profissionalId,
                                certificacaoId);
                return ResponseEntity.ok(BaseResponse.<CertificacaoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Certificação encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as certificações de um profissional.
         * Funcionalidade Completa: Visualização de todas as certificações de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de certificações.
         */
        @Operation(summary = "Lista todas as certificações de um profissional", description = "Retorna uma lista de todas as certificações associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificações listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/certificacoes")
        public ResponseEntity<BaseResponse<List<CertificacaoResponseDTO>>> getAllCertificacoes(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<CertificacaoResponseDTO> response = certificacaoService
                                .findAllCertificacoesByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<CertificacaoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Certificações listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma certificação de um profissional.
         * Funcionalidade Completa: Remoção de uma certificação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param certificacaoId ID da certificação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma certificação de um profissional", description = "Remove uma certificação específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Certificação deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (certificação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Certificação não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/certificacoes/{certificacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteCertificacao(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da certificação a ser deletada") @PathVariable UUID certificacaoId) {
                certificacaoService.deleteCertificacao(profissionalId, certificacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Certificação deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Experiências Profissionais ---

        /**
         * Adiciona uma experiência profissional a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de experiências.
         * Regras de Negócio: Experiência associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da experiência.
         * @return ResponseEntity com a experiência criada.
         */
        @Operation(summary = "Adiciona uma experiência profissional a um profissional", description = "Adiciona uma nova experiência profissional ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Experiência profissional adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> addExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .createExperienciaProfissional(profissionalId, requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Experiência profissional adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma experiência profissional de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma experiência
         * existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a experiência atualizada.
         */
        @Operation(summary = "Atualiza uma experiência profissional de um profissional", description = "Atualiza os detalhes de uma experiência profissional existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> updateExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser atualizada") @PathVariable UUID experienciaId,
                        @Valid @RequestBody ExperienciaProfissionalRequestDTO requestDTO) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .updateExperienciaProfissional(profissionalId, experienciaId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma experiência profissional específica de um profissional.
         * Funcionalidade Completa: Consulta individual de experiência.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity com a experiência encontrada.
         */
        @Operation(summary = "Busca uma experiência profissional específica de um profissional", description = "Retorna os detalhes de uma experiência profissional específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<ExperienciaProfissionalResponseDTO>> getExperienciaProfissionalById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência") @PathVariable UUID experienciaId) {
                ExperienciaProfissionalResponseDTO response = experienciaProfissionalService
                                .findExperienciaProfissionalById(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<ExperienciaProfissionalResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         * Funcionalidade Completa: Visualização de todas as experiências de um
         * advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de experiências.
         */
        @Operation(summary = "Lista todas as experiências profissionais de um profissional", description = "Retorna uma lista de todas as experiências profissionais associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiências profissionais listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/experiencias")
        public ResponseEntity<BaseResponse<List<ExperienciaProfissionalResponseDTO>>> getAllExperienciasProfissionais(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<ExperienciaProfissionalResponseDTO> response = experienciaProfissionalService
                                .findAllExperienciasProfissionaisByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<ExperienciaProfissionalResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Experiências profissionais listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         * Funcionalidade Completa: Remoção de uma experiência específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma experiência profissional de um profissional", description = "Remove uma experiência profissional específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Experiência profissional deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (experiência pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Experiência profissional não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/experiencias/{experienciaId}")
        public ResponseEntity<BaseResponse<Void>> deleteExperienciaProfissional(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da experiência a ser deletada") @PathVariable UUID experienciaId) {
                experienciaProfissionalService.deleteExperienciaProfissional(profissionalId, experienciaId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Experiência profissional deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Formações Acadêmicas ---

        /**
         * Adiciona uma formação acadêmica a um profissional.
         * Funcionalidade Completa: Gerenciamento granular de formações.
         * Regras de Negócio: Formação associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO da formação.
         * @return ResponseEntity com a formação criada.
         */
        @Operation(summary = "Adiciona uma formação acadêmica a um profissional", description = "Adiciona uma nova formação acadêmica ao perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Formação acadêmica adicionada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> addFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.createFormacaoAcademica(profissionalId,
                                requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Formação acadêmica adicionada com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Atualiza uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Atualização de detalhes de uma formação existente.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados de atualização.
         * @return ResponseEntity com a formação atualizada.
         */
        @Operation(summary = "Atualiza uma formação acadêmica de um profissional", description = "Atualiza os detalhes de uma formação acadêmica existente associada a um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica atualizada com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @PutMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> updateFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser atualizada") @PathVariable UUID formacaoId,
                        @Valid @RequestBody FormacaoAcademicaRequestDTO requestDTO) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.updateFormacaoAcademica(profissionalId,
                                formacaoId, requestDTO);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica atualizada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Busca uma formação acadêmica específica de um profissional.
         * Funcionalidade Completa: Consulta individual de formação.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity com a formação encontrada.
         */
        @Operation(summary = "Busca uma formação acadêmica específica de um profissional", description = "Retorna os detalhes de uma formação acadêmica específica de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica encontrada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<FormacaoAcademicaResponseDTO>> getFormacaoAcademicaById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação") @PathVariable UUID formacaoId) {
                FormacaoAcademicaResponseDTO response = formacaoAcademicaService.findFormacaoAcademicaById(
                                profissionalId,
                                formacaoId);
                return ResponseEntity.ok(BaseResponse.<FormacaoAcademicaResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica encontrada com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         * Funcionalidade Completa: Visualização de todas as formações de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de formações.
         */
        @Operation(summary = "Lista todas as formações acadêmicas de um profissional", description = "Retorna uma lista de todas as formações acadêmicas associadas a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formações acadêmicas listadas com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/formacoes")
        public ResponseEntity<BaseResponse<List<FormacaoAcademicaResponseDTO>>> getAllFormacoesAcademicas(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<FormacaoAcademicaResponseDTO> response = formacaoAcademicaService
                                .findAllFormacoesAcademicasByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<FormacaoAcademicaResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Formações acadêmicas listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         * Funcionalidade Completa: Remoção de uma formação específica.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta uma formação acadêmica de um profissional", description = "Remove uma formação acadêmica específica do perfil de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Formação acadêmica deletada com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (formação pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Formação acadêmica não encontrada para deleção"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/formacoes/{formacaoId}")
        public ResponseEntity<BaseResponse<Void>> deleteFormacaoAcademica(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID da formação a ser deletada") @PathVariable UUID formacaoId) {
                formacaoAcademicaService.deleteFormacaoAcademica(profissionalId, formacaoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Formação acadêmica deletada com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        // --- Endpoints para Documentos ---

        /**
         * Realiza o upload de um documento para um profissional.
         * Funcionalidade Completa: Armazenamento de documentos no S3 e metadados no DB.
         * Regras de Negócio: Associação ao profissional e tenant, validação de formato
         * Base64.
         *
         * @param profissionalId ID do profissional.
         * @param request        DTO com os dados do documento e o arquivo em Base64.
         * @return ResponseEntity com o DTO do documento criado.
         */
        @Operation(summary = "Realiza o upload de um documento para um profissional", description = "Faz o upload de um documento para o S3 e persiste seus metadados para um advogado.", responses = {
                        @ApiResponse(responseCode = "201", description = "Documento enviado com sucesso"),
                        @ApiResponse(responseCode = "400", description = "Dados de requisição inválidos (ex: Base64 inválido)"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Falha ao fazer upload do documento ou erro interno do servidor")
        })
        @PostMapping("/{profissionalId}/documentos/upload")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> uploadDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Valid @RequestBody DocumentoUploadRequest request) {
                DocumentoResponseDTO response = documentoService.uploadDocumento(profissionalId, request);
                return ResponseEntity.status(HttpStatus.CREATED)
                                .body(BaseResponse.<DocumentoResponseDTO>builder()
                                                .status(SUCESSO)
                                                .message("Documento enviado com sucesso.")
                                                .data(response)
                                                .timestamp(java.time.LocalDateTime.now())
                                                .build());
        }

        /**
         * Busca um documento específico de um profissional.
         * Funcionalidade Completa: Consulta individual de documento.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity com o DTO do documento encontrado.
         */
        @Operation(summary = "Busca um documento específico de um profissional", description = "Retorna os detalhes de um documento específico de um advogado.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento encontrado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant ou profissional)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para este profissional"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<DocumentoResponseDTO>> getDocumentoById(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento") @PathVariable UUID documentoId) {
                DocumentoResponseDTO response = documentoService.findDocumentoById(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<DocumentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Documento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os documentos de um profissional.
         * Funcionalidade Completa: Visualização de todos os documentos de um advogado.
         * Regras de Negócio: Acesso restrito ao próprio tenant.
         *
         * @param profissionalId ID do profissional.
         * @return ResponseEntity com a lista de documentos.
         */
        @Operation(summary = "Lista todos os documentos de um profissional", description = "Retorna uma lista de todos os documentos associados a um advogado específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documentos listados com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (profissional pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Profissional não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{profissionalId}/documentos")
        public ResponseEntity<BaseResponse<List<DocumentoResponseDTO>>> getAllDocumentos(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId) {
                List<DocumentoResponseDTO> response = documentoService
                                .findAllDocumentosByProfissionalId(profissionalId);
                return ResponseEntity.ok(BaseResponse.<List<DocumentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Documentos listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Deleta um documento de um profissional.
         * Funcionalidade Completa: Remoção do documento do S3 e do banco de dados.
         * Regras de Negócio: Validação de pertencimento ao profissional e tenant.
         *
         * @param profissionalId ID do profissional.
         * @param documentoId    ID do documento.
         * @return ResponseEntity de sucesso sem conteúdo.
         */
        @Operation(summary = "Deleta um documento de um profissional", description = "Remove um documento específico do perfil de um advogado, incluindo a remoção do S3.", responses = {
                        @ApiResponse(responseCode = "200", description = "Documento deletado com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso negado (documento pertence a outro tenant)"),
                        @ApiResponse(responseCode = "404", description = "Documento não encontrado para deleção"),
                        @ApiResponse(responseCode = "500", description = "Falha ao deletar o documento do S3 ou erro interno do servidor")
        })
        @DeleteMapping("/{profissionalId}/documentos/{documentoId}")
        public ResponseEntity<BaseResponse<Void>> deleteDocumento(
                        @Parameter(description = "ID do profissional") @PathVariable UUID profissionalId,
                        @Parameter(description = "ID do documento a ser deletado") @PathVariable UUID documentoId) {
                documentoService.deleteDocumento(profissionalId, documentoId);
                return ResponseEntity.ok(BaseResponse.<Void>builder()
                                .status(SUCESSO)
                                .message("Documento deletado com sucesso.")
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.controller;

import java.util.List;
import java.util.Map;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.service.AreaAtuacaoService;
import br.com.legalconnect.advogado.service.ProfissionalService;
import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.perfilcardadvogado.dto.response.AdvogadoResponseDTO; // Import atualizado
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

/**
 * Controller para dados mestre de Localizações.
 * Oferece endpoints para consultar estados e cidades disponíveis.
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/advogados/profissionais") // Caminho da requisição ajustado
@Tag(name = "Localizações", description = "Gerenciamento de dados mestre de Localizações (Estados e Cidades)")
public class ProfissionalPublicoController {

        private final ProfissionalService pessoaService;

        private final AreaAtuacaoService areaAtuacaoService;

        /**
         * Lista todas as localizações (estados e cidades) onde há profissionais.
         * Retorna um mapa onde a chave é o estado (UF) e o valor é uma lista de
         * cidades.
         *
         * @return ResponseEntity com o mapa de localizações.
         */
        @Operation(summary = "Lista todas as localizações (estados e cidades)", description = "Retorna um mapa de estados e suas respectivas cidades onde há advogados cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Localizações listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/localizacoes")
        public ResponseEntity<BaseResponse<Map<String, List<String>>>> getAllLocalizacoes() {
                Map<String, List<String>> response = pessoaService.listarLocalizacoesDisponiveis();
                return ResponseEntity.ok(BaseResponse.<Map<String, List<String>>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Localizações listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todas as Áreas de Atuação.
         * Funcionalidade Completa: Listagem de todas as áreas disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Áreas de Atuação.
         */
        @Operation(summary = "Lista todas as áreas de atuação", description = "Retorna uma lista de todas as áreas de atuação cadastradas.", responses = {
                        @ApiResponse(responseCode = "200", description = "Áreas de Atuação listadas com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/areas-atuacao")
        public ResponseEntity<BaseResponse<List<AreaAtuacaoResponseDTO>>> getAllAreasAtuacao() {
                List<AreaAtuacaoResponseDTO> response = areaAtuacaoService.findAllAreasAtuacao();
                return ResponseEntity.ok(BaseResponse.<List<AreaAtuacaoResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Áreas de Atuação listadas com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os advogados do marketplace com paginação e ordenação.
         * A ordenação prioriza profissionais com planos de assinatura pagos.
         *
         * @param page Número da página (0-indexed).
         * @param size Tamanho da página.
         * @param sort Critério de ordenação (ex: planoId,desc;avaliacao,desc;nome,asc).
         * @return ResponseEntity com a página de DTOs de advogados.
         */
        @Operation(summary = "Lista todos os advogados do marketplace com paginação e ordenação", description = "Retorna uma lista paginada de todos os advogados do marketplace, com ordenação por plano de assinatura (pagos primeiro) e reputação.", responses = {
                        @ApiResponse(responseCode = "200", description = "Advogados listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<AdvogadoResponseDTO>>> getAllAdvogados() {
                List<AdvogadoResponseDTO> response = pessoaService.findAllAdvogadosPublico();

                return ResponseEntity.ok(BaseResponse.<List<AdvogadoResponseDTO>>builder()
                                .status(StatusResponse.SUCESSO)
                                .message("Advogados do marketplace listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}

```
```java
package br.com.legalconnect.advogado.controller;

import static br.com.legalconnect.enums.StatusResponse.SUCESSO;

import java.util.List;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.service.TipoAtendimentoService;
import br.com.legalconnect.common.dto.BaseResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;

/**
 * Controller para o módulo de Tipos de Atendimento (dados mestre).
 * Oferece endpoints para consultar os tipos de atendimento disponíveis.
 */
@RestController
@RequestMapping("/api/v1/advogados/tipos-atendimento")
@Tag(name = "Tipos de Atendimento", description = "Gerenciamento de dados mestre de Tipos de Atendimento")
public class TipoAtendimentoController {

        private final TipoAtendimentoService tipoAtendimentoService;

        @Autowired
        public TipoAtendimentoController(TipoAtendimentoService tipoAtendimentoService) {
                this.tipoAtendimentoService = tipoAtendimentoService;
        }

        /**
         * Busca um Tipo de Atendimento pelo ID.
         * Funcionalidade Completa: Consulta de um dado mestre específico.
         * Regras de Negócio: N/A (apenas busca por ID).
         *
         * @param id ID do Tipo de Atendimento.
         * @return ResponseEntity com o DTO do Tipo de Atendimento.
         */
        @Operation(summary = "Busca um tipo de atendimento pelo ID", description = "Retorna os detalhes de um tipo de atendimento específico.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipo de Atendimento encontrado com sucesso"),
                        @ApiResponse(responseCode = "404", description = "Tipo de Atendimento não encontrado"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<TipoAtendimentoResponseDTO>> getTipoAtendimentoById(
                        @Parameter(description = "ID do Tipo de Atendimento") @PathVariable UUID id) {
                TipoAtendimentoResponseDTO response = tipoAtendimentoService.findTipoAtendimentoById(id);
                return ResponseEntity.ok(BaseResponse.<TipoAtendimentoResponseDTO>builder()
                                .status(SUCESSO)
                                .message("Tipo de Atendimento encontrado com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }

        /**
         * Lista todos os Tipos de Atendimento.
         * Funcionalidade Completa: Listagem de todos os tipos disponíveis para seleção
         * pelos advogados.
         * Regras de Negócio: N/A (apenas listagem).
         *
         * @return ResponseEntity com a lista de DTOs de Tipos de Atendimento.
         */
        @Operation(summary = "Lista todos os tipos de atendimento", description = "Retorna uma lista de todos os tipos de atendimento cadastrados.", responses = {
                        @ApiResponse(responseCode = "200", description = "Tipos de Atendimento listados com sucesso"),
                        @ApiResponse(responseCode = "500", description = "Erro interno do servidor")
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<TipoAtendimentoResponseDTO>>> getAllTiposAtendimento() {
                List<TipoAtendimentoResponseDTO> response = tipoAtendimentoService.findAllTiposAtendimento();
                return ResponseEntity.ok(BaseResponse.<List<TipoAtendimentoResponseDTO>>builder()
                                .status(SUCESSO)
                                .message("Tipos de Atendimento listados com sucesso.")
                                .data(response)
                                .timestamp(java.time.LocalDateTime.now())
                                .build());
        }
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Certificacao extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Documento extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissional extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademica extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Idioma extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.math.BigDecimal;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder; // Adicionado para consistência com outras entidades

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 * plataforma.
 * Esta classe é um placeholder e deve ser definida em seu próprio
 * microsserviço (marketplace).
 * Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder // Adicionado para consistência
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault;

    // Mapeamento bidirecional, mas Profissional é o lado "dono" para plano_id
    // Se Plano for um microsserviço separado, essa relação pode ser apenas por ID.
    @OneToMany(mappedBy = "plano", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionals = new HashSet<>();

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     * plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        EXENCIAL,
        PREMIUM,
        GOLD
    }
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.commom.model.Pessoa;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne; // Import adicionado
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder; // Adicionado para consistência

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder // Adicionado para consistência
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId;

    @Column(name = "empresa_id")
    private UUID empresaId;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira
    private Plano plano; // Relacionamento com a entidade Plano

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Certificacao> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Documento> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissional> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademica> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissional> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain;

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissional extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

```
```java
package br.com.legalconnect.advogado.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimento extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.enums;

/**
 * Enumeração para os tipos de documentos de um Profissional (Advogado).
 * 
 */
public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CertificacaoRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de upload de documento.
 * O campo 'tipoDocumento' foi alterado de String para o enum DocumentoTipo
 * para garantir tipagem segura e validação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    // Alterado de String para o enum DocumentoTipo para tipagem segura
    @NotNull(message = "O tipo do documento é obrigatório.")
    private DocumentoTipo tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim; // Pode ser nulo se for a experiência atual

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para criação de um novo Profissional.
 * Este DTO agora compõe um PessoaRequestDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ProfissionalCreateRequest extends PessoaRequestDTO {

    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;

    // Relacionamentos para dados mestres que podem ser definidos na criação
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // DTOs para certificações, experiências e formações na criação (opcional)
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para atualização de um Profissional.
 * Permite a atualização dos dados da Pessoa associada e dos campos específicos
 * de Profissional,
 * bem como de listas aninhadas.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalUpdateRequest {
    @NotNull(message = "O ID do profissional é obrigatório para atualização.")
    private UUID id;

    @Valid
    // A PessoaRequestDTO interna deve ter seu próprio ID se for uma atualização de
    // pessoa existente
    private PessoaRequestDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId; // Pode ser nulo se não houver empresa associada ou se for desvinculada

    private UUID planoId; // Pode ser nulo se o plano não for alterado

    // Listas de UUIDs para dados mestres
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // Listas de DTOs aninhados para certificações, experiências, formações
    // O ID em cada DTO aninhado indicará se é uma criação, atualização ou remoção.
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Área de Atuação.
 * Usado para retornar detalhes completos da Área de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AreaAtuacaoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Documento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Idioma.
 * Usado para retornar detalhes completos do Idioma.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdiomaResponseDTO {
    private UUID id;
    private String nome;
    private String codigo;
    private String nivel;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Local de Atuação.
 * Usado para retornar detalhes completos do Local de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LocalAtuacaoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.response.PessoaResponseDTO; // Importar PessoaResponseDTO
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta detalhada para um Profissional.
 * Agora compõe um PessoaResponseDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalResponseDTO {
    private UUID id; // ID do Profissional

    private PessoaResponseDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;

    // IDs de entidades relacionadas
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    // Listas de DTOs aninhados
    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    // Listas de DTOs de dados mestres (detalhados)
    private List<LocalAtuacaoResponseDTO> locaisAtuacao;
    private List<AreaAtuacaoResponseDTO> areasAtuacao;
    private List<IdiomaResponseDTO> idiomas;
    private List<TipoAtendimentoResponseDTO> tiposAtendimento;
    private List<RoleProfissionalResponseDTO> rolesProfissional; // DTO para Role do Profissional
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Role de Profissional.
 * Usado para retornar detalhes completos da Role.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleProfissionalResponseDTO {
    private UUID id;
    private String name;
    // O tenantId pode ser incluído se for relevante para o frontend
    // private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Tipo de Atendimento.
 * Usado para retornar detalhes completos do Tipo de Atendimento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TipoAtendimentoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.mapper;

import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.Named;
import org.springframework.beans.factory.annotation.Autowired;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.perfilcardadvogado.dto.response.AdvogadoResponseDTO; // Import atualizado
import br.com.legalconnect.perfilcardadvogado.dto.response.AdvogadoResponseDTO.MetricasDTO; // Import atualizado
import br.com.legalconnect.perfilcardadvogado.dto.response.AdvogadoResponseDTO.ServicoDTO; // Import atualizado

/**
 * Mapper MapStruct para converter a entidade Profissional em
 * AdvogadoResponseDTO.
 * Lida com a agregação de dados de outras entidades para formar o DTO final.
 */
@Mapper(componentModel = "spring")
public abstract class AdvogadoMapper {

    @Autowired
    protected AreaAtuacaoRepository areaAtuacaoRepository;
    @Autowired
    protected LocalAtuacaoRepository localAtuacaoRepository;
    @Autowired
    protected TipoAtendimentoRepository tipoAtendimentoRepository;

    @Mapping(source = "id", target = "id")
    @Mapping(source = "numeroOab", target = "oab")
    @Mapping(source = "fazParteDePlano", target = "fazParteDePlano")
    @Mapping(source = "usuario.nomeCompleto", target = "nome")
    @Mapping(source = "usuario.fotoUrl", target = "fotoUrl")
    @Mapping(source = "plano.nome", target = "nomePlano") // Mapeia o nome do plano
    // Mapeamentos para campos que precisam de lógica customizada ou agregação
    @Mapping(target = "avaliacao", expression = "java(calcularMediaAvaliacao(profissional))")
    @Mapping(target = "numAvaliacoes", expression = "java(calcularNumAvaliacoes(profissional))")
    @Mapping(target = "bio", expression = "java(getBio(profissional))")
    @Mapping(target = "especialidades", expression = "java(mapAreaAtuacaoIdsToNomes(profissional.getAreaAtuacaoIds()))")
    @Mapping(target = "localizacao", expression = "java(mapLocalizacao(profissional))")
    @Mapping(target = "estado", expression = "java(mapEstado(profissional))")
    @Mapping(target = "municipio", expression = "java(mapMunicipio(profissional))")
    @Mapping(target = "verificadoOAB", expression = "java(isOABVerificada(profissional))")
    @Mapping(target = "nivel", expression = "java(getNivelProfissional(profissional))")
    @Mapping(target = "formacao", expression = "java(getUltimaFormacao(profissional))")
    @Mapping(target = "metricas", expression = "java(mapMetricas(profissional))")
    @Mapping(target = "servicos", expression = "java(mapServicos(profissional))")
    public abstract AdvogadoResponseDTO toAdvogadoResponseDTO(Profissional profissional);

    // Métodos de mapeamento customizados

    @Named("calcularMediaAvaliacao")
    protected Double calcularMediaAvaliacao(Profissional profissional) {
        // Lógica para calcular a média de avaliação.
        // Assumindo que a entidade Profissional não tem um campo de avaliação direta,
        // isso viria de um relacionamento com Avaliacoes.
        // Por simplicidade, retornamos um valor fixo ou aleatório.
        return 4.5; // Exemplo
    }

    @Named("calcularNumAvaliacoes")
    protected Integer calcularNumAvaliacoes(Profissional profissional) {
        // Lógica para obter o número de avaliações.
        return 120; // Exemplo
    }

    @Named("getBio")
    protected String getBio(Profissional profissional) {
        // Assumindo que a bio pode estar no campo 'descricao' da Pessoa ou em um campo
        // específico do Profissional.
        // Se não houver, pode ser uma string vazia ou null.
        return "Advogado com 10 anos de experiência em Direito de Família e Sucessões."; // Exemplo
    }

    @Named("mapAreaAtuacaoIdsToNomes")
    protected List<String> mapAreaAtuacaoIdsToNomes(Set<UUID> areaAtuacaoIds) {
        if (areaAtuacaoIds == null || areaAtuacaoIds.isEmpty()) {
            return List.of();
        }
        return areaAtuacaoRepository.findAllById(areaAtuacaoIds).stream()
                .map(area -> area.getNome())
                .collect(Collectors.toList());
    }

    @Named("mapLocalizacao")
    protected String mapLocalizacao(Profissional profissional) {
        // Retorna a primeira cidade/estado do endereço principal do profissional
        return profissional.getEnderecos().stream()
                .filter(e -> e.getTipoEndereco() == Endereco.TipoEndereco.ESCRITORIO
                        || e.getTipoEndereco() == Endereco.TipoEndereco.COMERCIAL)
                .findFirst()
                .map(e -> e.getCidade() + " - " + e.getEstado())
                .orElse("Não informada");
    }

    @Named("mapEstado")
    protected String mapEstado(Profissional profissional) {
        return profissional.getEnderecos().stream()
                .filter(e -> e.getTipoEndereco() == Endereco.TipoEndereco.ESCRITORIO
                        || e.getTipoEndereco() == Endereco.TipoEndereco.COMERCIAL)
                .findFirst()
                .map(e -> e.getEstado())
                .orElse(null);
    }

    @Named("mapMunicipio")
    protected String mapMunicipio(Profissional profissional) {
        return profissional.getEnderecos().stream()
                .filter(e -> e.getTipoEndereco() == Endereco.TipoEndereco.ESCRITORIO
                        || e.getTipoEndereco() == Endereco.TipoEndereco.COMERCIAL)
                .findFirst()
                .map(e -> e.getCidade())
                .orElse(null);
    }

    @Named("isOABVerificada")
    protected Boolean isOABVerificada(Profissional profissional) {
        // Simulação de verificação da OAB. Em um cenário real, isso envolveria
        // integração com um serviço externo ou um processo de validação interno.
        return true; // Exemplo: sempre true para advogados cadastrados
    }

    @Named("getNivelProfissional")
    protected String getNivelProfissional(Profissional profissional) {
        // Lógica para determinar o nível (Júnior, Pleno, Sênior) com base na
        // experiência,
        // tempo de OAB, ou algum campo específico na entidade Profissional.
        return "Sênior"; // Exemplo
    }

    @Named("getUltimaFormacao")
    protected String getUltimaFormacao(Profissional profissional) {
        // Retorna o curso da última formação acadêmica (mais recente)
        return profissional.getFormacoes().stream()
                .sorted((f1, f2) -> f2.getDataConclusao().compareTo(f1.getDataConclusao()))
                .findFirst()
                .map(f -> f.getCurso() + " em " + f.getInstituicao())
                .orElse("Não informada");
    }

    @Named("mapMetricas")
    protected MetricasDTO mapMetricas(Profissional profissional) {
        // Simulação de métricas. Em um cenário real, isso viria de dados de
        // performance.
        return MetricasDTO.builder()
                .satisfacao(0.95) // Exemplo: 95% de satisfação
                .casosConcluidos(50) // Exemplo: 50 casos concluídos
                .build();
    }

    @Named("mapServicos")
    protected List<ServicoDTO> mapServicos(Profissional profissional) {
        // Mapeia os tipos de atendimento para serviços.
        // Em um cenário real, haveria uma entidade 'Servico' com nome, descrição e
        // preço.
        return profissional.getTipoAtendimentoIds().stream()
                .map(id -> tipoAtendimentoRepository.findById(id).orElse(null))
                .filter(java.util.Objects::nonNull)
                .map(tipo -> ServicoDTO.builder()
                        .nome(tipo.getNome())
                        .descricao("Serviço de " + tipo.getNome().toLowerCase())
                        .preco("R$ 250,00") // Preço fixo para exemplo
                        .build())
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade AreaAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface AreaAtuacaoMapper {
    AreaAtuacaoMapper INSTANCE = Mappers.getMapper(AreaAtuacaoMapper.class);

    /**
     * Mapeia uma entidade AreaAtuacao para um AreaAtuacaoResponseDTO.
     * 
     * @param entity A entidade AreaAtuacao.
     * @return O DTO de resposta correspondente.
     */
    AreaAtuacaoResponseDTO toResponseDTO(AreaAtuacao entity);

    /**
     * Mapeia um AreaAtuacaoResponseDTO para uma entidade AreaAtuacao.
     * Útil para cenários de re-conversão ou testes, embora a criação normalmente
     * venha de um RequestDTO.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade AreaAtuacao correspondente.
     */
    AreaAtuacao toEntity(AreaAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade Certificacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface CertificacaoMapper {
    CertificacaoMapper INSTANCE = Mappers.getMapper(CertificacaoMapper.class);

    /**
     * Mapeia um CertificacaoRequestDTO para uma entidade Certificacao.
     * O campo 'profissional' e 'tenantId' na entidade devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Certificacao correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    Certificacao toEntity(CertificacaoRequestDTO dto);

    /**
     * Mapeia uma entidade Certificacao para um CertificacaoResponseDTO.
     *
     * @param entity A entidade Certificacao.
     * @return O DTO de resposta correspondente.
     */
    CertificacaoResponseDTO toResponseDTO(Certificacao entity);

    /**
     * Atualiza uma entidade Certificacao existente com os dados de um
     * CertificacaoRequestDTO.
     * O campo 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Certificacao a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(CertificacaoRequestDTO dto, @MappingTarget Certificacao entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;

/**
 * Mapper MapStruct para a entidade Documento e seus DTOs.
 * Gerencia a conversão entre DocumentoUploadRequest, Documento e
 * DocumentoResponseDTO.
 */
@Mapper(componentModel = "spring")
public interface DocumentoMapper {
    DocumentoMapper INSTANCE = Mappers.getMapper(DocumentoMapper.class);

    /**
     * Mapeia um DocumentoUploadRequest para uma entidade Documento.
     * Ignora 'arquivoBase64' e 'mimeType' (dados para upload, não persistentes na
     * entidade).
     * 'urlS3', 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição para upload de documento.
     * @return A entidade Documento correspondente.
     */
    @Mapping(target = "urlS3", ignore = true) // Preenchido após o upload bem-sucedido
    @Mapping(target = "profissional", ignore = true) // Relacionamento com Profissional, preenchido no serviço
    @Mapping(target = "tenantId", ignore = true) // TenantId, preenchido no serviço
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    Documento toEntity(DocumentoUploadRequest dto);

    /**
     * Mapeia uma entidade Documento para um DocumentoResponseDTO.
     *
     * @param entity A entidade Documento.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "tipoDocumento", target = "tipoDocumento") // Mapeamento direto de String para String
    DocumentoResponseDTO toResponseDTO(Documento entity);

    /**
     * Atualiza uma entidade Documento existente com os dados de um
     * DocumentoUploadRequest.
     * Campos ignorados: 'id', 'urlS3', 'profissional', 'tenantId'.
     *
     * @param dto    O DTO de requisição.
     * @param entity A entidade Documento a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "urlS3", ignore = true)
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    void updateEntityFromDto(DocumentoUploadRequest dto, @MappingTarget Documento entity);

    /**
     * Converte um enum DocumentoTipo para sua representação em String.
     * Usado para mapear de DTO (enum) para Entidade (String).
     *
     * @param tipo O enum DocumentoTipo.
     * @return A representação em String do enum.
     */
    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipo) {
        return tipo != null ? tipo.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade ExperienciaProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface ExperienciaProfissionalMapper {
    ExperienciaProfissionalMapper INSTANCE = Mappers.getMapper(ExperienciaProfissionalMapper.class);

    /**
     * Mapeia um ExperienciaProfissionalRequestDTO para uma entidade
     * ExperienciaProfissional.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade ExperienciaProfissional correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    ExperienciaProfissional toEntity(ExperienciaProfissionalRequestDTO dto);

    /**
     * Mapeia uma entidade ExperienciaProfissional para um
     * ExperienciaProfissionalResponseDTO.
     *
     * @param entity A entidade ExperienciaProfissional.
     * @return O DTO de resposta correspondente.
     */
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissional entity);

    /**
     * Atualiza uma entidade ExperienciaProfissional existente com os dados de um
     * ExperienciaProfissionalRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade ExperienciaProfissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(ExperienciaProfissionalRequestDTO dto, @MappingTarget ExperienciaProfissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;

/**
 * Mapper MapStruct para a entidade FormacaoAcademica e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface FormacaoAcademicaMapper {
    FormacaoAcademicaMapper INSTANCE = Mappers.getMapper(FormacaoAcademicaMapper.class);

    /**
     * Mapeia um FormacaoAcademicaRequestDTO para uma entidade FormacaoAcademica.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade FormacaoAcademica correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    FormacaoAcademica toEntity(FormacaoAcademicaRequestDTO dto);

    /**
     * Mapeia uma entidade FormacaoAcademica para um FormacaoAcademicaResponseDTO.
     *
     * @param entity A entidade FormacaoAcademica.
     * @return O DTO de resposta correspondente.
     */
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademica entity);

    /**
     * Atualiza uma entidade FormacaoAcademica existente com os dados de um
     * FormacaoAcademicaRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade FormacaoAcademica a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademica entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;

/**
 * Mapper MapStruct para a entidade Idioma e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface IdiomaMapper {
    IdiomaMapper INSTANCE = Mappers.getMapper(IdiomaMapper.class);

    /**
     * Mapeia uma entidade Idioma para um IdiomaResponseDTO.
     * 
     * @param entity A entidade Idioma.
     * @return O DTO de resposta correspondente.
     */
    IdiomaResponseDTO toResponseDTO(Idioma entity);

    /**
     * Mapeia um IdiomaResponseDTO para uma entidade Idioma.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade Idioma correspondente.
     */
    Idioma toEntity(IdiomaResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;

/**
 * Mapper MapStruct para a entidade LocalAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface LocalAtuacaoMapper {
    LocalAtuacaoMapper INSTANCE = Mappers.getMapper(LocalAtuacaoMapper.class);

    /**
     * Mapeia uma entidade LocalAtuacao para um LocalAtuacaoResponseDTO.
     * 
     * @param entity A entidade LocalAtuacao.
     * @return O DTO de resposta correspondente.
     */
    LocalAtuacaoResponseDTO toResponseDTO(LocalAtuacao entity);

    /**
     * Mapeia um LocalAtuacaoResponseDTO para uma entidade LocalAtuacao.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade LocalAtuacao correspondente.
     */
    LocalAtuacao toEntity(LocalAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;

/**
 * Mapper MapStruct para a entidade Profissional e seus DTOs de requisição e
 * resposta.
 * Lida com mapeamentos complexos e aninhados, delegando para outros mappers
 * quando necessário.
 */
@Mapper(componentModel = "spring", uses = {
        PessoaMapper.class,
        CertificacaoMapper.class,
        DocumentoMapper.class,
        ExperienciaProfissionalMapper.class,
        FormacaoAcademicaMapper.class,
        RoleProfissionalMapper.class
        // Mappers para AreaAtuacao, Idioma, LocalAtuacao, TipoAtendimento NÃO são
        // usados diretamente aqui
        // para mapear UUIDs para DTOs completos, pois isso é responsabilidade do
        // serviço.
})
public interface ProfissionalMapper {
    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * Mapeia um ProfissionalCreateRequest para uma nova entidade Profissional.
     *
     * @param dto O DTO de requisição para criação.
     * @return A nova entidade Profissional.
     */
    // @Mapping(source = "pessoa.user", target = "usuario") // Mapeia o
    // PessoaRequestDTO (que é 'pessoa') para a superclasse 'usuario'
    Profissional toEntity(ProfissionalCreateRequest dto);

    /**
     * Atualiza uma entidade Profissional existente com os dados de um
     * ProfissionalUpdateRequest.
     *
     * @param dto    O DTO de requisição para atualização.
     * @param entity A entidade Profissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID da entidade não deve ser alterado pelo DTO
    @Mapping(source = "pessoa.usuario", target = "usuario") // Mapeia o DTO 'pessoa.usuario' para a superclasse
                                                            // 'usuario'
    @Mapping(target = "pessoaId", ignore = true) // Gerenciado pelo sistema
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Gerenciado pelo serviço (criação/atualização/remoção)
    @Mapping(target = "documentos", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "experiencias", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "formacoes", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Gerenciado pelo serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    void updateEntityFromDto(ProfissionalUpdateRequest dto, @MappingTarget Profissional entity);

    /**
     * Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * Campos de dados mestres (locaisAtuacao, areasAtuacao, idiomas,
     * tiposAtendimento)
     * são ignorados aqui e devem ser populados pela camada de serviço,
     * pois a entidade Profissional armazena apenas os IDs dessas relações.
     *
     * @param entity A entidade Profissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "usuario", target = "pessoa") // Mapeia a superclasse 'usuario' para 'pessoa' no DTO
    @Mapping(target = "locaisAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "areasAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "idiomas", ignore = true) // Populado pelo serviço
    @Mapping(target = "tiposAtendimento", ignore = true) // Populado pelo serviço
    @Mapping(source = "roleProfissionals", target = "rolesProfissional") // Mapeia Set<RoleProfissional> para
                                                                         // List<RoleProfissionalResponseDTO>
    ProfissionalResponseDTO toResponseDTO(Profissional entity);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.RoleProfissional;
import br.com.legalconnect.advogado.dto.response.RoleProfissionalResponseDTO;

/**
 * Mapper MapStruct para a entidade RoleProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface RoleProfissionalMapper {
    RoleProfissionalMapper INSTANCE = Mappers.getMapper(RoleProfissionalMapper.class);

    /**
     * Mapeia uma entidade RoleProfissional para um RoleProfissionalResponseDTO.
     * Ignora 'tenantId' na resposta se não for relevante para o frontend.
     *
     * @param entity A entidade RoleProfissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    RoleProfissionalResponseDTO toResponseDTO(RoleProfissional entity);

    /**
     * Mapeia um RoleProfissionalResponseDTO para uma entidade RoleProfissional.
     * 'tenantId' deve ser definido pelo serviço.
     *
     * @param dto O DTO de resposta.
     * @return A entidade RoleProfissional correspondente.
     */
    @Mapping(target = "tenantId", ignore = true)
    RoleProfissional toEntity(RoleProfissionalResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;

/**
 * Mapper MapStruct para a entidade TipoAtendimento e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface TipoAtendimentoMapper {
    TipoAtendimentoMapper INSTANCE = Mappers.getMapper(TipoAtendimentoMapper.class);

    /**
     * Mapeia uma entidade TipoAtendimento para um TipoAtendimentoResponseDTO.
     * 
     * @param entity A entidade TipoAtendimento.
     * @return O DTO de resposta correspondente.
     */
    TipoAtendimentoResponseDTO toResponseDTO(TipoAtendimento entity);

    /**
     * Mapeia um TipoAtendimentoResponseDTO para uma entidade TipoAtendimento.
     * 
     * @param dto O DTO de resposta.
     * @return A entidade TipoAtendimento correspondente.
     */
    TipoAtendimento toEntity(TipoAtendimentoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.AreaAtuacao;

@Repository
public interface AreaAtuacaoRepository extends JpaRepository<AreaAtuacao, UUID> {

    /**
     * Busca uma Área de Atuação pelo nome.
     *
     * @param nome O nome da área de atuação.
     * @return Um Optional contendo a Área de Atuação, se encontrada.
     */
    Optional<AreaAtuacao> findByNome(String nome);

    /**
     * 
     * Busca todas as Áreas de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs das áreas de atuação.
     * 
     * @return Uma lista de Áreas de Atuação.
     */
    List<AreaAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Certificacao;

/**
 * Repositório para a entidade {@link Certificacao}.
 * Gerencia operações de persistência para as certificações de um profissional.
 */
@Repository
public interface CertificacaoRepository extends JpaRepository<Certificacao, UUID> {

    /**
     * Busca uma Certificação pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Certificação, se encontrada.
     */
    Optional<Certificacao> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Certificações de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Certificações.
     */
    List<Certificacao> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Documento;

/**
 * Repositório para a entidade {@link Documento}.
 * Gerencia operações de persistência para os documentos de um profissional.
 */
@Repository
public interface DocumentoRepository extends JpaRepository<Documento, UUID> {

    /**
     * Busca um Documento pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo o Documento, se encontrado.
     */
    Optional<Documento> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todos os Documentos de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Documentos.
     */
    List<Documento> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta um Documento pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID do documento.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

/**
 * Repositório para a entidade {@link ExperienciaProfissional}.
 * Gerencia operações de persistência para as experiências profissionais de um
 * profissional.
 * O método 'save' é automaticamente fornecido por JpaRepository, não deve ser
 * declarado explicitamente aqui com parâmetros extras.
 */
@Repository
public interface ExperienciaProfissionalRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    /**
     * Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional
     * associado.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Experiência Profissional, se encontrada.
     */
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Experiências Profissionais de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Experiências Profissionais.
     */
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);

    // IMPORTANTE: NÃO HÁ MÉTODO 'save' EXPLICITAMENTE DECLARADO AQUI.
    // Ele é herdado de JpaRepository e tem a assinatura: S save(S entity);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;

@Repository
public interface ExperienciaRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

/**
 * Repositório para a entidade {@link FormacaoAcademica}.
 * Gerencia operações de persistência para as formações acadêmicas de um
 * profissional.
 */
@Repository
public interface FormacaoAcademicaRepository extends JpaRepository<FormacaoAcademica, UUID> {

    /**
     * Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Formação Acadêmica, se encontrada.
     */
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Formações Acadêmicas de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Formações Acadêmicas.
     */
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;

@Repository
public interface FormacaoRepository extends JpaRepository<FormacaoAcademica, UUID> {

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Idioma;

/**
 * Repositório para a entidade {@link Idioma}.
 * Gerencia operações de persistência para os idiomas disponíveis.
 */
@Repository
public interface IdiomaRepository extends JpaRepository<Idioma, UUID> {

    /**
     * Busca um Idioma pelo nome.
     *
     * @param nome O nome do idioma.
     * @return Um Optional contendo o Idioma, se encontrado.
     */
    Optional<Idioma> findByNome(String nome);

    /**
     * Busca todos os Idiomas por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos idiomas.
     * @return Uma lista de Idiomas.
     */
    List<Idioma> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.LocalAtuacao;

/**
 * Repositório para a entidade {@link LocalAtuacao}.
 * Gerencia operações de persistência para os locais de atuação dos
 * profissionais.
 */
@Repository
public interface LocalAtuacaoRepository extends JpaRepository<LocalAtuacao, UUID> {

    /**
     * Busca um Local de Atuação pelo nome.
     *
     * @param nome O nome do local de atuação.
     * @return Um Optional contendo o Local de Atuação, se encontrado.
     */
    Optional<LocalAtuacao> findByNome(String nome);

    /**
     * Busca todos os Locais de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos locais de atuação.
     * @return Uma lista de Locais de Atuação.
     */
    List<LocalAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.repository;

import br.com.legalconnect.advogado.domain.Plano;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Plano}.
 * Gerencia operações de persistência para os planos de assinatura.
 */
@Repository
public interface PlanoRepository extends JpaRepository<Plano, UUID> {
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.advogado.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.Profissional;

/**
 * Repositório para a entidade {@link Profissional}.
 * Gerencia operações de persistência para os profissionais (advogados).
 */
@Repository
public interface ProfissionalRepository extends JpaRepository<Profissional, UUID> {

    /**
     * Busca um Profissional pelo número da OAB.
     *
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * Busca todos os Profissionais associados a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de Profissionais.
     */
    Page<Profissional> findAllByTenantId(UUID tenantId, Pageable pageable);

    /**
     * Verifica se um Profissional existe pelo número da OAB.
     * Regra de Negócio: Garante a unicidade do número da OAB.
     *
     * @param numeroOab O número da OAB a ser verificado.
     * @return true se um Profissional com a OAB já existe, false caso contrário.
     */
    boolean existsByNumeroOab(String numeroOab);

    /**
     * Verifica se um Profissional existe pelo ID da pessoa associada.
     *
     * @param pessoaId O ID da pessoa.
     * @return true se um Profissional com o ID da pessoa existe, false caso
     *         contrário.
     */
    boolean existsByPessoaId(UUID pessoaId);

    /**
     * Busca todos os estados e cidades (municípios) distintos
     * de todas as Pessoas cadastradas.
     * Retorna uma lista de arrays de objetos, onde cada array contém [estado,
     * cidade].
     *
     * @return Uma lista de Object[] contendo pares [estado, cidade].
     */
    @Query(value = "SELECT DISTINCT e.estado, e.cidade FROM tb_endereco e WHERE e.estado IS NOT NULL AND e.cidade IS NOT NULL ORDER BY e.estado, e.cidade", nativeQuery = true)
    List<Object[]> findDistinctEstadosAndCidades();

    /**
     * NOVO MÉTODO: Busca uma página de Profissionais ativos que usam o marketplace,
     * ordenando aleatoriamente para seleção inicial.
     *
     * @param pageable Objeto Pageable contendo informações de paginação (para
     *                 limitar o número de resultados aleatórios).
     * @return Uma página de Profissionais.
     */
    @Query(value = "SELECT p FROM Profissional p JOIN FETCH p.usuario u LEFT JOIN FETCH p.enderecos e LEFT JOIN FETCH p.plano pl "
            +
            "WHERE p.usaMarketplace = true AND p.statusProfissional = 'ATIVO' " +
            "ORDER BY RANDOM()") // Ordena aleatoriamente para pegar uma amostra
    Page<Profissional> findAllPublicMarketplaceProfissionais(Pageable pageable);
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.RoleProfissional;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link RoleProfissional}.
 * Gerencia operações de persistência para os papéis (roles) dos profissionais.
 */
@Repository
public interface RoleProfissionalRepository extends JpaRepository<RoleProfissional, UUID> {

    /**
     * Busca uma Role de Profissional pelo nome.
     *
     * @param name O nome da role.
     * @return Um Optional contendo a RoleProfissional, se encontrada.
     */
    Optional<RoleProfissional> findByName(String name);

    /**
     * Busca todas as Roles de Profissional associadas a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de RoleProfissional.
     */
    List<RoleProfissional> findAllByTenantId(UUID tenantId);
}
```
```java
package br.com.legalconnect.advogado.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.TipoAtendimento;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link TipoAtendimento}.
 * Gerencia operações de persistência para os tipos de atendimento disponíveis.
 */
@Repository
public interface TipoAtendimentoRepository extends JpaRepository<TipoAtendimento, UUID> {

    /**
     * Busca um Tipo de Atendimento pelo nome.
     *
     * @param nome O nome do tipo de atendimento.
     * @return Um Optional contendo o TipoAtendimento, se encontrado.
     */
    Optional<TipoAtendimento> findByNome(String nome);

    /**
     * Busca todos os Tipos de Atendimento por uma lista de IDs.
     * 
     * @param ids Lista de IDs dos tipos de atendimento.
     * @return Uma lista de Tipos de Atendimento.
     */
    List<TipoAtendimento> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.EmailService; // Para enviar e-mails de confirmação
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço responsável pela lógica de agendamento de consultas no Marketplace.
 */
@Slf4j
@Service
public class AgendamentoService {

        private final ProfissionalRepository profissionalRepository;
        private final GoogleCalendarService googleCalendarService;
        private final EmailService emailService;
        // Repositório de agendamentos (assumindo a entidade Agendamento)
        // private final AgendamentoRepository agendamentoRepository;

        @Autowired
        public AgendamentoService(ProfissionalRepository profissionalRepository,
                        GoogleCalendarService googleCalendarService,
                        EmailService emailService) {
                this.profissionalRepository = profissionalRepository;
                this.googleCalendarService = googleCalendarService;
                this.emailService = emailService;
                // this.agendamentoRepository = agendamentoRepository;
        }

        /**
         * Realiza o agendamento de uma consulta entre um cliente e um profissional.
         * Regras de Negócio:
         * - Verifica a disponibilidade do profissional na data/hora solicitada.
         * - Garante que o profissional existe e está ativo no marketplace.
         * - Integra com Google Calendar para adicionar o evento na agenda do
         * profissional.
         * - Envia e-mails de confirmação para cliente e profissional.
         *
         * @param profissionalId     ID do profissional.
         * @param clienteId          ID do cliente.
         * @param horarioAgendamento Horário da consulta.
         * @param tipoServico        Tipo de serviço agendado.
         * @return Sucesso do agendamento.
         * @throws BusinessException se o profissional não estiver disponível ou outras
         *                           regras de negócio forem violadas.
         */
        @Transactional
        public boolean agendarConsulta(UUID profissionalId, UUID clienteId, LocalDateTime horarioAgendamento,
                        String tipoServico) {
                UUID tenantId = TenantContext.getCurrentTenantId(); // O agendamento ocorre dentro do contexto de um
                                                                    // tenant

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                // Regra de Negócio: Profissional deve estar ativo e usar marketplace
                if (!profissional.getUsaMarketplace() || !profissional.getStatusProfissional().equals("ACTIVE")) { // Assuming
                                                                                                                   // "ACTIVE"
                                                                                                                   // status
                        throw new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE, HttpStatus.BAD_REQUEST,
                                        "Profissional não disponível para agendamento.");
                }

                // Regra de Negócio: Verificar disponibilidade real do profissional (com Google
                // Calendar)
                boolean isAvailable = googleCalendarService.checkAvailability(profissional.getUsuario().getEmail(),
                                horarioAgendamento);
                if (!isAvailable) {
                        throw new BusinessException(ErrorCode.APPOINTMENT_CONFLICT, HttpStatus.CONFLICT,
                                        "Horário indisponível para o profissional.");
                }

                // Regra de Negócio: Criar o registro de agendamento no banco de dados (se
                // houver entidade Agendamento)
                // Agendamento newAppointment = Agendamento.builder()
                // .profissional(profissional)
                // .clienteId(clienteId)
                // .horario(horarioAgendamento)
                // .tipoServico(tipoServico)
                // .tenantId(tenantId)
                // .build();
                // agendamentoRepository.save(newAppointment);

                // Funcionalidade Completa: Adicionar evento ao Google Calendar do profissional
                googleCalendarService.addEvent(
                                profissional.getUsuario().getEmail(),
                                "Consulta: " + tipoServico + " com Cliente " + clienteId, // Supondo que você pode obter
                                                                                          // o nome do
                                                                                          // cliente
                                horarioAgendamento,
                                horarioAgendamento.plusHours(1) // Consulta de 1 hora
                );

                // Funcionalidade Completa: Enviar e-mails de confirmação
                emailService.sendAppointmentConfirmationEmail(
                                profissional.getUsuario().getEmail(),
                                "Você tem uma nova consulta agendada com o cliente " + clienteId + " para "
                                                + horarioAgendamento);
                // emailService.sendAppointmentConfirmationEmail(
                // clienteService.findById(clienteId).getEmail(), // Supondo um clienteService
                // "Sua consulta com " + profissional.getNomeCompleto() + " foi confirmada para
                // " + horarioAgendamento
                // );

                return true;
        }

        /**
         * Simula a avaliação de uma consulta pelo cliente.
         * Regras de Negócio:
         * - Associa a avaliação ao agendamento e ao profissional.
         * - Atualiza a média de avaliação do profissional (lógica simplificada).
         *
         * @param agendamentoId ID do agendamento avaliado.
         * @param clienteId     ID do cliente que avaliou.
         * @param rating        Nota da avaliação (1-5).
         * @param comentario    Comentário opcional.
         * @return Sucesso da avaliação.
         */
        @Transactional
        public boolean avaliarConsulta(UUID agendamentoId, UUID clienteId, int rating, String comentario) {
                // Lógica para encontrar o agendamento e associar a avaliação.
                // Agendamento agendamento =
                // agendamentoRepository.findById(agendamentoId).orElseThrow(...)
                // Criar uma entidade Avaliacao.
                // Atualizar a média de avaliação do Profissional.

                // Simulação: Apenas loga a avaliação
                log.info("Cliente {} avaliou agendamento {} com nota {} e comentário: {}", clienteId, agendamentoId,
                                rating,
                                comentario);

                // Para fins de demonstração, vamos considerar um sucesso
                return true;
        }

        // Outras funcionalidades como reagendamento, cancelamento, busca de
        // agendamentos
        // seriam implementadas aqui.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.AreaAtuacao;
import br.com.legalconnect.advogado.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Áreas de Atuação (dados mestre).
 * Essas entidades são consideradas globais ou de um tenant específico da
 * plataforma,
 * mas para este módulo, o acesso é simplificado como dados mestre.
 */
@Service
public class AreaAtuacaoService {

    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;

    @Autowired
    public AreaAtuacaoService(AreaAtuacaoRepository areaAtuacaoRepository, AreaAtuacaoMapper areaAtuacaoMapper) {
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
    }

    /**
     * Busca uma Área de Atuação pelo ID.
     *
     * @param id ID da Área de Atuação.
     * @return DTO da Área de Atuação.
     * @throws BusinessException se a Área de Atuação não for encontrada.
     */
    public AreaAtuacaoResponseDTO findAreaAtuacaoById(UUID id) {
        AreaAtuacao areaAtuacao = areaAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Área de Atuação não encontrada."));
        return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
    }

    /**
     * Lista todas as Áreas de Atuação.
     *
     * @return Lista de DTOs de Áreas de Atuação.
     */
    public List<AreaAtuacaoResponseDTO> findAllAreasAtuacao() {
        return areaAtuacaoRepository.findAll().stream()
                .map(areaAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para criar, atualizar e deletar podem ser adicionados
    // se essas entidades mestre forem gerenciáveis via API
    // Por exemplo, por um ADMIN da plataforma.
    // Ex:
    /*
     * @Transactional
     * public AreaAtuacaoResponseDTO createAreaAtuacao(AreaAtuacaoRequestDTO
     * requestDTO) {
     * if (areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * AreaAtuacao areaAtuacao = areaAtuacaoMapper.toEntity(requestDTO);
     * areaAtuacao = areaAtuacaoRepository.save(areaAtuacao);
     * return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
     * }
     * 
     * @Transactional
     * public AreaAtuacaoResponseDTO updateAreaAtuacao(UUID id,
     * AreaAtuacaoRequestDTO requestDTO) {
     * AreaAtuacao existing = areaAtuacaoRepository.findById(id)
     * .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada."));
     * if (!existing.getNome().equalsIgnoreCase(requestDTO.getNome()) &&
     * areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * areaAtuacaoMapper.updateEntityFromDto(requestDTO, existing); // Supondo um
     * updateEntityFromDto no mapper
     * existing = areaAtuacaoRepository.save(existing);
     * return areaAtuacaoMapper.toResponseDTO(existing);
     * }
     * 
     * @Transactional
     * public void deleteAreaAtuacao(UUID id) {
     * if (!areaAtuacaoRepository.existsById(id)) {
     * throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada para deleção.");
     * }
     * // Regra de Negócio: Verificar se está em uso por algum Profissional antes de
     * deletar
     * // if (profissionalRepository.existsByAreaAtuacaoId(id)) { ... }
     * areaAtuacaoRepository.deleteById(id);
     * }
     */
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das certificações de um Profissional.
 * Este serviço é granular e pode ser usado para operações diretas em
 * certificações,
 * embora o ProfissionalService orquestre a maioria.
 */
@Service
public class CertificacaoService {

    private final CertificacaoRepository certificacaoRepository;
    private final CertificacaoMapper certificacaoMapper;
    private final ProfissionalRepository profissionalRepository;

    @Autowired
    public CertificacaoService(CertificacaoRepository certificacaoRepository,
            CertificacaoMapper certificacaoMapper,
            ProfissionalRepository profissionalRepository) {
        this.certificacaoRepository = certificacaoRepository;
        this.certificacaoMapper = certificacaoMapper;
        this.profissionalRepository = profissionalRepository;
    }

    /**
     * Cria uma nova certificação para um profissional específico.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - A certificação é associada ao profissional e ao tenant.
     *
     * @param profissionalId ID do profissional.
     * @param requestDTO     DTO com os dados da certificação.
     * @return DTO da certificação criada.
     */
    @Transactional
    public CertificacaoResponseDTO createCertificacao(UUID profissionalId, CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        Certificacao certificacao = certificacaoMapper.toEntity(requestDTO);
        certificacao.setProfissional(profissional);
        certificacao.setTenantId(tenantId);

        certificacao = certificacaoRepository.save(certificacao); // profissionalId é passado para o
                                                                  // save no repositório customizado
        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Atualiza uma certificação existente de um profissional.
     * Regras de Negócio:
     * - A certificação deve existir e pertencer ao profissional e tenant corretos.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @param requestDTO     DTO com os dados para atualização.
     * @return DTO da certificação atualizada.
     */
    @Transactional
    public CertificacaoResponseDTO updateCertificacao(UUID profissionalId, UUID certificacaoId,
            CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant ou profissional.");
        }

        certificacaoMapper.updateEntityFromDto(requestDTO, existingCertificacao);
        existingCertificacao = certificacaoRepository.save(existingCertificacao);
        return certificacaoMapper.toResponseDTO(existingCertificacao);
    }

    /**
     * Busca uma certificação pelo ID do profissional e da certificação.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @return DTO da certificação.
     */
    public CertificacaoResponseDTO findCertificacaoById(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao certificacao = certificacaoRepository.findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!certificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Lista todas as certificações de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de certificações.
     */
    public List<CertificacaoResponseDTO> findAllCertificacoesByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se o profissional existe e pertence ao tenant
        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return certificacaoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(certificacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta uma certificação de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação a ser deletada.
     */
    @Transactional
    public void deleteCertificacao(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se a certificação existe e pertence ao profissional e tenant
        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para deleção."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        certificacaoRepository.deleteByIdAndProfissionalId(certificacaoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.Base64; // Para decodificar Base64
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Documento;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.S3Service;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão de documentos de um Profissional.
 * Inclui o upload de arquivos para o S3 e o armazenamento dos metadados no
 * banco de dados.
 */
@Service
public class DocumentoService {

    private final DocumentoRepository documentoRepository;
    private final DocumentoMapper documentoMapper;
    private final ProfissionalRepository profissionalRepository;
    private final S3Service s3Service; // Serviço para integração com S3

    @Autowired
    public DocumentoService(DocumentoRepository documentoRepository,
            DocumentoMapper documentoMapper,
            ProfissionalRepository profissionalRepository,
            S3Service s3Service) {
        this.documentoRepository = documentoRepository;
        this.documentoMapper = documentoMapper;
        this.profissionalRepository = profissionalRepository;
        this.s3Service = s3Service;
    }

    /**
     * Realiza o upload de um documento para o S3 e persiste seus metadados.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - O conteúdo do arquivo em Base64 é decodificado e enviado ao S3.
     * - A URL do S3 é armazenada no banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param request        DTO com os dados do documento e o arquivo em Base64.
     * @return DTO do documento criado.
     * @throws BusinessException em caso de falha no upload ou se o profissional não
     *                           for encontrado.
     */
    @Transactional
    public DocumentoResponseDTO uploadDocumento(UUID profissionalId, DocumentoUploadRequest request) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para upload de documento."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Decodificar Base64 e fazer upload para S3
        byte[] fileBytes;
        try {
            fileBytes = Base64.getDecoder().decode(request.getArquivoBase64());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.INVALID_DOCUMENT_FORMAT, HttpStatus.BAD_REQUEST,
                    "Conteúdo do arquivo em Base64 inválido.");
        }

        String s3Key = "profissionais/" + profissionalId + "/documentos/" + UUID.randomUUID() + "/"
                + request.getNomeArquivo();
        String fileUrl = s3Service.uploadFile(fileBytes, s3Key, request.getMimeType());

        if (fileUrl == null) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao fazer upload do documento para o S3.");
        }

        Documento documento = documentoMapper.toEntity(request);
        documento.setUrlS3(fileUrl);
        documento.setProfissional(profissional);
        documento.setTenantId(tenantId);

        documento = documentoRepository.save(documento);
        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Busca um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento deve pertencer ao profissional e ao tenant correto.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento.
     * @return DTO do documento encontrado.
     * @throws BusinessException se o documento não for encontrado.
     */
    public DocumentoResponseDTO findDocumentoById(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento documento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para este profissional."));

        if (!documento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant ou profissional.");
        }

        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Lista todos os documentos de um profissional.
     * Regras de Negócio:
     * - Apenas documentos do tenant atual são retornados.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de documentos.
     */
    public List<DocumentoResponseDTO> findAllDocumentosByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return documentoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(documentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento é removido do S3 antes de ser deletado do banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento a ser deletado.
     * @throws BusinessException se o documento não for encontrado ou falha na
     *                           deleção do S3.
     */
    @Transactional
    public void deleteDocumento(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento existingDocumento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para deleção."));

        if (!existingDocumento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant.");
        }

        // Deletar do S3 primeiro
        try {
            s3Service.deleteFile(existingDocumento.getUrlS3());
        } catch (Exception e) {
            throw new BusinessException(ErrorCode.ERRO_INTERNO_SERVIDOR, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao deletar o documento do S3: " + e.getMessage());
        }

        documentoRepository.deleteByIdAndProfissionalId(documentoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das experiências profissionais de um
 * Profissional.
 */
@Service
public class ExperienciaProfissionalService {

        private final ExperienciaRepository experienciaRepository;
        private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public ExperienciaProfissionalService(ExperienciaRepository experienciaRepository,
                        ExperienciaProfissionalMapper experienciaProfissionalMapper,
                        ProfissionalRepository profissionalRepository) {
                this.experienciaRepository = experienciaRepository;
                this.experienciaProfissionalMapper = experienciaProfissionalMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova experiência profissional para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A experiência é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da experiência.
         * @return DTO da experiência criada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO createExperienciaProfissional(UUID profissionalId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                ExperienciaProfissional experiencia = experienciaProfissionalMapper.toEntity(requestDTO);
                experiencia.setProfissional(profissional);
                experiencia.setTenantId(tenantId);

                experiencia = experienciaRepository.save(experiencia);
                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Atualiza uma experiência profissional existente de um profissional.
         * Regras de Negócio:
         * - A experiência deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da experiência atualizada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO updateExperienciaProfissional(UUID profissionalId, UUID experienciaId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant ou profissional.");
                }

                experienciaProfissionalMapper.updateEntityFromDto(requestDTO, existingExperiencia);
                existingExperiencia = experienciaRepository.save(existingExperiencia);
                return experienciaProfissionalMapper.toResponseDTO(existingExperiencia);
        }

        /**
         * Busca uma experiência profissional pelo ID do profissional e da experiência.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return DTO da experiência.
         */
        public ExperienciaProfissionalResponseDTO findExperienciaProfissionalById(UUID profissionalId,
                        UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional experiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!experiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de experiências.
         */
        public List<ExperienciaProfissionalResponseDTO> findAllExperienciasProfissionaisByProfissionalId(
                        UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return experienciaRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(experienciaProfissionalMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência a ser deletada.
         */
        @Transactional
        public void deleteExperienciaProfissional(UUID profissionalId, UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para deleção."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                experienciaRepository.deleteByIdAndProfissionalId(experienciaId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das formações acadêmicas de um Profissional.
 */
@Service
public class FormacaoAcademicaService {

        private final FormacaoRepository formacaoRepository;
        private final FormacaoAcademicaMapper formacaoAcademicaMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public FormacaoAcademicaService(FormacaoRepository formacaoRepository,
                        FormacaoAcademicaMapper formacaoAcademicaMapper,
                        ProfissionalRepository profissionalRepository) {
                this.formacaoRepository = formacaoRepository;
                this.formacaoAcademicaMapper = formacaoAcademicaMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova formação acadêmica para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A formação é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da formação.
         * @return DTO da formação criada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO createFormacaoAcademica(UUID profissionalId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                FormacaoAcademica formacao = formacaoAcademicaMapper.toEntity(requestDTO);
                formacao.setProfissional(profissional);
                formacao.setTenantId(tenantId);

                formacao = formacaoRepository.save(formacao);
                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Atualiza uma formação acadêmica existente de um profissional.
         * Regras de Negócio:
         * - A formação deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da formação atualizada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO updateFormacaoAcademica(UUID profissionalId, UUID formacaoId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant ou profissional.");
                }

                formacaoAcademicaMapper.updateEntityFromDto(requestDTO, existingFormacao);
                existingFormacao = formacaoRepository.save(existingFormacao);
                return formacaoAcademicaMapper.toResponseDTO(existingFormacao);
        }

        /**
         * Busca uma formação acadêmica pelo ID do profissional e da formação.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return DTO da formação.
         */
        public FormacaoAcademicaResponseDTO findFormacaoAcademicaById(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica formacao = formacaoRepository.findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!formacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de formações.
         */
        public List<FormacaoAcademicaResponseDTO> findAllFormacoesAcademicasByProfissionalId(UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return formacaoRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(formacaoAcademicaMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação a ser deletada.
         */
        @Transactional
        public void deleteFormacaoAcademica(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para deleção."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                formacaoRepository.deleteByIdAndProfissionalId(formacaoId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço de integração simulada com a Google Calendar API.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a
 * Google Calendar API
 * utilizando as credenciais OAuth2 do aplicativo.
 */
@Service
public class GoogleCalendarService {

    private static final Logger log = LoggerFactory.getLogger(GoogleCalendarService.class);

    /**
     * Simula a adição de um evento à agenda do Google Calendar de um usuário.
     *
     * @param userEmail    O e-mail do usuário cuja agenda será atualizada.
     * @param eventSummary O título do evento.
     * @param startTime    A data e hora de início do evento.
     * @param endTime      A data e hora de fim do evento.
     * @return true se o evento foi "adicionado" com sucesso, false caso contrário.
     */
    public boolean addEvent(String userEmail, String eventSummary, LocalDateTime startTime, LocalDateTime endTime) {
        log.info("Simulando adição de evento ao Google Calendar para {}:", userEmail);
        log.info("  Sumário: {}", eventSummary);
        log.info("  Início: {}", startTime);
        log.info("  Fim: {}", endTime);
        // Lógica real de integração com Google Calendar API seria aqui, por exemplo:
        // Event event = new Event()
        // .setSummary(eventSummary)
        // .setDescription("Agendamento via LegalConnect");
        // DateTime startDateTime = new DateTime(startTime.toString());
        // EventDateTime start = new
        // EventDateTime().setDateTime(startDateTime).setTimeZone("America/Sao_Paulo");
        // event.setStart(start);
        // ...
        // Calendar service = new Calendar.Builder(...).build();
        // service.events().insert(userEmail, event).execute();
        log.info("Evento simulado adicionado com sucesso ao Google Calendar.");
        return true;
    }

    /**
     * Simula a verificação de disponibilidade na agenda do Google Calendar de um
     * usuário.
     *
     * @param userEmail    O e-mail do usuário.
     * @param proposedTime O horário a ser verificado.
     * @return true se o horário estiver disponível, false caso contrário.
     */
    public boolean checkAvailability(String userEmail, LocalDateTime proposedTime) {
        log.info("Simulando verificação de disponibilidade para {} no horário {}", userEmail, proposedTime);
        // Em um cenário real, você consultaria a API do Google Calendar para Free/Busy
        // Por simplicidade, vamos simular que o horário está sempre disponível, a menos
        // que seja um horário "proibido"
        if (proposedTime.getHour() == 13) { // Exemplo de regra de negócio: almoço indisponível
            log.info("Horário indisponível (simulado).");
            return false;
        }
        log.info("Horário disponível (simulado).");
        return true;
    }

    // Outros métodos como updateEvent, deleteEvent, listEvents podem ser
    // adicionados.
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Idioma;
import br.com.legalconnect.advogado.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Idiomas (dados mestre).
 */
@Service
public class IdiomaService {

    private final IdiomaRepository idiomaRepository;
    private final IdiomaMapper idiomaMapper;

    @Autowired
    public IdiomaService(IdiomaRepository idiomaRepository, IdiomaMapper idiomaMapper) {
        this.idiomaRepository = idiomaRepository;
        this.idiomaMapper = idiomaMapper;
    }

    /**
     * Busca um Idioma pelo ID.
     *
     * @param id ID do Idioma.
     * @return DTO do Idioma.
     * @throws BusinessException se o Idioma não for encontrado.
     */
    public IdiomaResponseDTO findIdiomaById(UUID id) {
        Idioma idioma = idiomaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Idioma não encontrado."));
        return idiomaMapper.toResponseDTO(idioma);
    }

    /**
     * Lista todos os Idiomas.
     *
     * @return Lista de DTOs de Idiomas.
     */
    public List<IdiomaResponseDTO> findAllIdiomas() {
        return idiomaRepository.findAll().stream()
                .map(idiomaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.advogado.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Locais de Atuação (dados mestre).
 */
@Service
public class LocalAtuacaoService {

    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final LocalAtuacaoMapper localAtuacaoMapper;

    @Autowired
    public LocalAtuacaoService(LocalAtuacaoRepository localAtuacaoRepository, LocalAtuacaoMapper localAtuacaoMapper) {
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.localAtuacaoMapper = localAtuacaoMapper;
    }

    /**
     * Busca um Local de Atuação pelo ID.
     *
     * @param id ID do Local de Atuação.
     * @return DTO do Local de Atuação.
     * @throws BusinessException se o Local de Atuação não for encontrado.
     */
    public LocalAtuacaoResponseDTO findLocalAtuacaoById(UUID id) {
        LocalAtuacao localAtuacao = localAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Local de Atuação não encontrado."));
        return localAtuacaoMapper.toResponseDTO(localAtuacao);
    }

    /**
     * Lista todos os Locais de Atuação.
     *
     * @return Lista de DTOs de Locais de Atuação.
     */
    public List<LocalAtuacaoResponseDTO> findAllLocaisAtuacao() {
        return localAtuacaoRepository.findAll().stream()
                .map(localAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import org.springframework.stereotype.Service;

// Assumindo a existência dessas classes de DTO, Entidade e Repositório
// import br.com.legalconnect.office.application.dto.request.ProcessoRequestDTO;
// import br.com.legalconnect.office.application.dto.response.ProcessoResponseDTO;
// import br.com.legalconnect.office.domain.modal.entity.Processo;
// import br.com.legalconnect.office.domain.repository.ProcessoRepository;
// import br.com.legalconnect.office.application.mapper.ProcessoMapper;

/**
 * Serviço responsável pela gestão de Processos Judiciais e Administrativos no
 * módulo de Gestão de Escritório.
 */
@Service
public class ProcessoService {

    // private final ProcessoRepository processoRepository;
    // private final ProcessoMapper processoMapper;
    // private final AIService aiService; // Para geração de petições com IA
    // private final S3Service s3Service; // Para anexos de documentos

    // @Autowired
    // public ProcessoService(ProcessoRepository processoRepository,
    // ProcessoMapper processoMapper,
    // AIService aiService,
    // S3Service s3Service) {
    // this.processoRepository = processoRepository;
    // this.processoMapper = processoMapper;
    // this.aiService = aiService;
    // this.s3Service = s3Service;
    // }

    /**
     * Cria um novo processo judicial ou administrativo.
     * Regras de Negócio:
     * - Associa o processo ao tenant atual.
     * - Define o status inicial do processo.
     *
     * @param requestDTO DTO com os dados do processo.
     * @return DTO do processo criado.
     */
    // @Transactional
    // public ProcessoResponseDTO createProcesso(ProcessoRequestDTO requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoMapper.toEntity(requestDTO);
    // processo.setTenantId(tenantId);
    // processo.setStatus("INICIADO"); // Regra de Negócio: Status inicial
    //
    // processo = processoRepository.save(processo);
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Atualiza um processo existente.
     * Regras de Negócio:
     * - O processo deve existir e pertencer ao tenant atual.
     *
     * @param id         ID do processo.
     * @param requestDTO DTO com os dados para atualização.
     * @return DTO do processo atualizado.
     */
    // @Transactional
    // public ProcessoResponseDTO updateProcesso(UUID id, ProcessoRequestDTO
    // requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // processoMapper.updateEntityFromDto(requestDTO, existingProcesso);
    // existingProcesso = processoRepository.save(existingProcesso);
    // return processoMapper.toResponseDTO(existingProcesso);
    // }

    /**
     * Busca um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo.
     * @return DTO do processo.
     */
    // public ProcessoResponseDTO findProcessoById(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Lista todos os processos de um tenant.
     *
     * @return Lista de DTOs de processos.
     */
    // public List<ProcessoResponseDTO> findAllProcessos() {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // return processoRepository.findAllByTenantId(tenantId).stream()
    // .map(processoMapper::toResponseDTO)
    // .collect(Collectors.toList());
    // }

    /**
     * Deleta um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo a ser deletado.
     */
    // @Transactional
    // public void deleteProcesso(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para deleção."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Regra de Negócio: Verificar se o processo pode ser deletado (ex: não tem
    // atividades pendentes)
    // // if (hasPendingActivities(existingProcesso)) {
    // // throw new BusinessException(ErrorCode.RECURSO_EM_USO, HttpStatus.CONFLICT,
    // "Processo possui atividades pendentes e não pode ser deletado.");
    // // }
    //
    // processoRepository.deleteById(id);
    // }

    /**
     * Gera um rascunho de petição utilizando IA (OpenAI GPT).
     * Regras de Negócio:
     * - O profissional deve ter permissão e estar em um plano que suporte IA.
     * - A IA gera um texto baseado nas informações do processo.
     *
     * @param processoId ID do processo para o qual a petição será gerada.
     * @param prompt     Instruções adicionais para a IA.
     * @return O rascunho da petição gerado pela IA.
     */
    // public String generatePeticaoWithAI(UUID processoId, String prompt) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    // // Verifica se o usuário logado tem permissão e plano para usar IA
    // // Profissional profissional =
    // profissionalService.findProfissionalById(userIdFromSecurityContext);
    // // if (!profissional.getPlano().supportsAI()) { ... }
    //
    // Processo processo = processoRepository.findById(processoId)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para geração de petição."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Montar o prompt completo para a IA com base nos dados do processo
    // String fullPrompt = String.format("Crie um rascunho de petição para o
    // processo '%s' (Tipo: %s, Partes: %s). Contexto: %s. %s",
    // processo.getNumero(), processo.getTipo(), processo.getPartes(),
    // processo.getDescricao(), prompt);
    //
    // // Chamada ao serviço de IA
    // String generatedText = aiService.generateText(fullPrompt);
    //
    // return generatedText;
    // }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.ArrayList;
import java.util.Comparator; // Import adicionado
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest; // Import adicionado
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.Certificacao;
import br.com.legalconnect.advogado.domain.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.Plano; // Import adicionado
import br.com.legalconnect.advogado.domain.Profissional;
import br.com.legalconnect.advogado.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.mapper.AdvogadoMapper; // Import atualizado
import br.com.legalconnect.advogado.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.mapper.ProfissionalMapper;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.repository.DocumentoRepository;
import br.com.legalconnect.advogado.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.repository.FormacaoRepository;
import br.com.legalconnect.advogado.repository.IdiomaRepository;
import br.com.legalconnect.advogado.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.repository.PlanoRepository; // Import adicionado
import br.com.legalconnect.advogado.repository.ProfissionalRepository;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.service.PessoaService;
import br.com.legalconnect.commom.service.S3Service; // Assumindo S3Service para upload de documentos
import br.com.legalconnect.commom.service.TenantContext; // Assumindo TenantContext para multitenancy
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.perfilcardadvogado.dto.response.AdvogadoResponseDTO; // Import atualizado
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor; // Import adicionado
import lombok.extern.slf4j.Slf4j; // Import adicionado

/**
 * Serviço responsável pela gestão completa do Profissional (Advogado).
 * Inclui operações de CRUD, validações de negócio e orquestração com serviços
 * de entidades aninhadas
 * e dados mestre. Gerencia também o upload de documentos e a associação com o
 * tenant.
 */
@Service
@RequiredArgsConstructor // Construtor gerado automaticamente para campos final
@Slf4j // Adiciona logger
public class ProfissionalService {

    private final ProfissionalRepository profissionalRepository;
    private final ProfissionalMapper profissionalMapper;
    private final AdvogadoMapper advogadoMapper;
    private final PessoaService pessoaService;
    private final CertificacaoMapper certificacaoMapper;
    private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
    private final FormacaoAcademicaMapper formacaoAcademicaMapper;
    private final DocumentoMapper documentoMapper;
    private final CertificacaoRepository certificacaoRepository;
    private final ExperienciaRepository experienciaRepository;
    private final FormacaoRepository formacaoRepository;
    private final DocumentoRepository documentoRepository;
    private final S3Service s3Service;
    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final IdiomaRepository idiomaRepository;
    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;
    private final IdiomaMapper idiomaMapper;
    private final LocalAtuacaoMapper localAtuacaoMapper;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;
    private final PlanoRepository planoRepository; // Novo repositório injetado

    /**
     * Cria um novo Profissional no sistema.
     * Regras de Negócio:
     * - Valida a unicidade do número da OAB.
     * - Associa o Profissional a um Tenant (obtido do contexto de segurança).
     * - Cria a entidade Pessoa associada através do PessoaService.
     * - Gerencia a criação de certificações, experiências e formações aninhadas.
     * - Define o status inicial do profissional.
     * - Valida a existência do plano.
     *
     * @param createRequest DTO com os dados para criação do Profissional.
     * @return DTO do Profissional criado.
     * @throws BusinessException se a OAB já estiver cadastrada, ou se o
     *                           plano/tenant não existirem.
     */
    @Transactional
    public ProfissionalResponseDTO createProfissional(ProfissionalCreateRequest createRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo que o tenantId vem do contexto de segurança

        // Regra de Negócio: Validar unicidade da OAB
        if (profissionalRepository.existsByNumeroOab(createRequest.getNumeroOab())) {
            throw new BusinessException(ErrorCode.OAB_DUPLICADA, HttpStatus.CONFLICT, createRequest.getNumeroOab());
        }

        // Regra de Negócio: Validar unicidade da Pessoa (CPF/Email) antes de criar o
        // Profissional
        if (pessoaService.findPessoaByCpf(createRequest.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, createRequest.getCpf());
        }
        if (pessoaService.findPessoaByEmail(createRequest.getUsuario().getEmail()).isPresent()) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    createRequest.getUsuario().getEmail());
        }

        // Criar a Pessoa associada primeiro, pois Profissional estende Pessoa
        PessoaRequestDTO pessoaRequestDTO = new PessoaRequestDTO();
        pessoaRequestDTO.setUsuario(createRequest.getUsuario());
        pessoaRequestDTO.setNomeCompleto(createRequest.getNomeCompleto());
        pessoaRequestDTO.setCpf(createRequest.getCpf());
        pessoaRequestDTO.setDataNascimento(createRequest.getDataNascimento());
        pessoaRequestDTO.setTelefones(createRequest.getTelefones());
        pessoaRequestDTO.setEnderecos(createRequest.getEnderecos());

        Pessoa newPessoa = pessoaService.createPessoa(pessoaRequestDTO);

        // Regra de Negócio: Validar que o planoId existe e associar o Plano
        Plano plano = planoRepository.findById(createRequest.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Plano com ID " + createRequest.getPlanoId() + " não encontrado."));

        Profissional profissional = profissionalMapper.toEntity(createRequest);
        profissional.setPessoaId(newPessoa.getId()); // Associa o ID da Pessoa recém-criada
        profissional.setUsuario(newPessoa.getUsuario()); // Garante que o usuário de Pessoa esteja associado
        profissional.setTenantId(tenantId); // Regra de Negócio: Define o tenant do profissional
        profissional.setStatusProfissional("PENDING_APPROVAL"); // Regra de Negócio: Status inicial
        profissional.setPlano(plano); // Associa o objeto Plano

        // Relacionamentos muitos-para-muitos (apenas IDs aqui)
        if (createRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            profissional.setLocaisAtuacaoIds(createRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            profissional.setAreaAtuacaoIds(createRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(createRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            profissional.setIdiomaIds(createRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(createRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            profissional
                    .setTipoAtendimentoIds(createRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        profissional = profissionalRepository.save(profissional);

        // Gerenciar certificações, experiências e formações
        manageNestedEntities(profissional, createRequest);

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Atualiza um Profissional existente.
     * Regras de Negócio:
     * - Valida a existência do Profissional e do Tenant.
     * - Permite a atualização de dados da Pessoa associada.
     * - Gerencia a adição, atualização e remoção de certificações, experiências e
     * formações.
     * - Atualiza relacionamentos com dados mestre.
     *
     * @param id            ID do Profissional a ser atualizado.
     * @param updateRequest DTO com os dados para atualização.
     * @return DTO do Profissional atualizado.
     * @throws BusinessException se o Profissional não for encontrado, ou por outras
     *                           violações de negócio.
     */
    @Transactional
    public ProfissionalResponseDTO updateProfissional(UUID id, ProfissionalUpdateRequest updateRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo tenantId do contexto de segurança

        Profissional existingProfissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para atualização."));

        // Regra de Negócio: O profissional só pode ser atualizado pelo seu próprio
        // tenant
        if (!existingProfissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Atualiza os dados da Pessoa associada (se fornecidos)
        if (updateRequest.getPessoa() != null) {
            pessoaService.updatePessoa(existingProfissional.getPessoaId(), updateRequest.getPessoa());
        }

        // Mapeia os campos atualizáveis para a entidade Profissional
        profissionalMapper.updateEntityFromDto(updateRequest, existingProfissional);

        // Regra de Negócio: Validar que o planoId existe se for alterado
        if (updateRequest.getPlanoId() != null
                && (existingProfissional.getPlano() == null
                        || !existingProfissional.getPlano().getId().equals(updateRequest.getPlanoId()))) {
            Plano novoPlano = planoRepository.findById(updateRequest.getPlanoId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                            "Plano com ID " + updateRequest.getPlanoId() + " não encontrado."));
            existingProfissional.setPlano(novoPlano);
        }

        // Atualiza relacionamentos muitos-para-muitos
        if (updateRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            existingProfissional
                    .setLocaisAtuacaoIds(updateRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            existingProfissional
                    .setAreaAtuacaoIds(updateRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(updateRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            existingProfissional.setIdiomaIds(updateRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(updateRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            existingProfissional
                    .setTipoAtendimentoIds(updateRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        // Gerenciar coleções aninhadas (certificações, experiências, formações)
        manageNestedEntities(existingProfissional, updateRequest);

        existingProfissional = profissionalRepository.save(existingProfissional);
        return mapToResponseDTOWithDetails(existingProfissional);
    }

    /**
     * Busca um Profissional pelo ID.
     * Regras de Negócio:
     * - Garante que o Profissional pertence ao Tenant do contexto de segurança.
     * - Popula os dados mestre relacionados.
     *
     * @param id ID do Profissional.
     * @return DTO do Profissional com detalhes.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    public ProfissionalResponseDTO findProfissionalById(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Busca todos os Profissionais de um determinado Tenant com paginação.
     *
     * @param pageable Objeto Pageable contendo informações de paginação e
     *                 ordenação.
     * @return Página de DTOs de Profissionais.
     */
    public Page<ProfissionalResponseDTO> findAllProfissionais(Pageable pageable) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Filtra por tenant

        Page<Profissional> profissionaisPage = profissionalRepository.findAllByTenantId(tenantId, pageable);
        return profissionaisPage.map(this::mapToResponseDTOWithDetails);
    }

    /**
     * NOVO MÉTODO: Busca 20 advogados aleatórios elegíveis para o marketplace
     * público
     * e os ordena pela visibilidade do plano.
     *
     * @return Uma lista de AdvogadoResponseDTO.
     */
    public List<AdvogadoResponseDTO> findAllAdvogadosPublico() {
        // Busca 20 profissionais aleatórios do repositório
        Page<Profissional> randomProfessionalsPage = profissionalRepository
                .findAllPublicMarketplaceProfissionais(PageRequest.of(0, 20));
        List<Profissional> randomProfessionals = randomProfessionalsPage.getContent();

        // Converte para DTOs
        List<AdvogadoResponseDTO> advogadoDTOs = randomProfessionals.stream()
                .map(advogadoMapper::toAdvogadoResponseDTO)
                .collect(Collectors.toList());

        // Aplica a ordenação customizada em memória
        advogadoDTOs.sort(Comparator.<AdvogadoResponseDTO, Integer>comparing(
                dto -> {
                    // Mapeia o nome do plano para um valor inteiro para ordenação
                    if (dto.getNomePlano() == null) {
                        return 5; // Planos nulos ou desconhecidos por último
                    }
                    switch (dto.getNomePlano().toUpperCase()) {
                        case "GOLD":
                            return 1;
                        case "PREMIUM":
                            return 2;
                        case "EXENCIAL":
                            return 3;
                        case "PADRAO":
                            return 4;
                        default:
                            return 5; // Outros planos por último
                    }
                })
                .thenComparing(AdvogadoResponseDTO::getAvaliacao, Comparator.nullsLast(Comparator.reverseOrder()))
                .thenComparing(AdvogadoResponseDTO::getNome, Comparator.nullsLast(String.CASE_INSENSITIVE_ORDER)));

        return advogadoDTOs;
    }

    /**
     * Deleta um Profissional pelo ID.
     * Regras de Negócio:
     * - Apenas o proprietário do tenant pode deletar.
     * - Orquestra a deleção de entidades aninhadas (Certificações, Experiências,
     * Formações, Documentos).
     * - Deleção da Pessoa associada.
     *
     * @param id ID do Profissional a ser deletado.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    @Transactional
    public void deleteProfissional(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para deleção."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Deleta entidades aninhadas (cascade pode fazer isso, mas explicitar é bom
        // para clareza)
        certificacaoRepository.findAllByProfissionalId(id)
                .forEach(c -> certificacaoRepository.deleteByIdAndProfissionalId(c.getId(), id));
        experienciaRepository.findAllByProfissionalId(id)
                .forEach(e -> experienciaRepository.deleteByIdAndProfissionalId(e.getId(), id));
        formacaoRepository.findAllByProfissionalId(id)
                .forEach(f -> formacaoRepository.deleteByIdAndProfissionalId(f.getId(), id));
        documentoRepository.findAllByProfissionalId(id).forEach(d -> {
            s3Service.deleteFile(d.getUrlS3()); // Deleta arquivo do S3
            documentoRepository.deleteByIdAndProfissionalId(d.getId(), id);
        });

        // Deleta o profissional
        profissionalRepository.deleteById(id);

        // Deleta a pessoa associada
        pessoaService.deletePessoa(profissional.getPessoaId());
    }

    /**
     * Método auxiliar para gerenciar a adição, atualização e remoção de entidades
     * aninhadas
     * (certificações, experiências, formações) para um Profissional.
     *
     * @param profissional O Profissional pai.
     * @param request      O DTO de requisição (Create ou Update) contendo as listas
     *                     aninhadas.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalCreateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Remover certificações que não estão mais no DTO
            profissional.getCertificacoes().removeIf(existingCert -> request.getCertificacoes().stream()
                    .noneMatch(dto -> existingCert.getId().equals(dto.getId())));
            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        }

        // Experiências Profissionais
        if (request.getExperiencias() != null) {
            profissional.getExperiencias().removeIf(existingExp -> request.getExperiencias().stream()
                    .noneMatch(dto -> existingExp.getId().equals(dto.getId())));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) { // Nova experiência
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else { // Atualizar experiência existente
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        }

        // Formações Acadêmicas
        if (request.getFormacoes() != null) {
            profissional.getFormacoes().removeIf(existingForm -> request.getFormacoes().stream()
                    .noneMatch(dto -> existingForm.getId().equals(dto.getId())));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova formação
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else { // Atualizar formação existente
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        }
    }

    /**
     * Sobrecarga para o método de gerenciamento de entidades aninhadas para
     * ProfissionalUpdateRequest.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalUpdateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Coleta IDs das certificações no DTO para identificar as que serão removidas
            Set<UUID> dtoCertIds = request.getCertificacoes().stream()
                    .map(c -> c.getId())
                    .collect(Collectors.toSet());

            // Remove certificações que existem na entidade but not in the DTO (deleção)
            profissional.getCertificacoes().removeIf(
                    existingCert -> existingCert.getId() != null && !dtoCertIds.contains(existingCert.getId()));

            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação (ID nulo indica novo)
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId() != null && c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        } else {
            // Se a lista no DTO for nula, assume-se que todas as certificações devem ser
            // removidas
            profissional.getCertificacoes().clear();
        }

        // Experiências Profissionais (lógica similar às certificações)
        if (request.getExperiencias() != null) {
            Set<UUID> dtoExpIds = request.getExperiencias().stream()
                    .map(e -> e.getId())
                    .collect(Collectors.toSet());
            profissional.getExperiencias()
                    .removeIf(existingExp -> existingExp.getId() != null && !dtoExpIds.contains(existingExp.getId()));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) {
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else {
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId() != null && e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        } else {
            profissional.getExperiencias().clear();
        }

        // Formações Acadêmicas (lógica similar às certificações)
        if (request.getFormacoes() != null) {
            Set<UUID> dtoFormIds = request.getFormacoes().stream()
                    .map(f -> f.getId())
                    .collect(Collectors.toSet());
            profissional.getFormacoes().removeIf(
                    existingForm -> existingForm.getId() != null && !dtoFormIds.contains(existingForm.getId()));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) {
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else {
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId() != null && f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        } else {
            profissional.getFormacoes().clear();
        }
    }

    /**
     * Mapeia um Profissional para ProfissionalResponseDTO e popula os dados mestre
     * relacionados.
     * Esta é uma funcionalidade completa para apresentar o perfil do advogado.
     *
     * @param profissional A entidade Profissional.
     * @return O DTO de resposta detalhado.
     */
    private ProfissionalResponseDTO mapToResponseDTOWithDetails(Profissional profissional) {
        ProfissionalResponseDTO responseDTO = profissionalMapper.toResponseDTO(profissional);

        // Popula listas de DTOs de dados mestre
        responseDTO.setLocaisAtuacao(
                localAtuacaoRepository.findAllById(profissional.getLocaisAtuacaoIds())
                        .stream()
                        .map(localAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setAreasAtuacao(
                areaAtuacaoRepository.findAllById(profissional.getAreaAtuacaoIds())
                        .stream()
                        .map(areaAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setIdiomas(
                idiomaRepository.findAllById(profissional.getIdiomaIds())
                        .stream()
                        .map(idiomaMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setTiposAtendimento(
                tipoAtendimentoRepository.findAllById(profissional.getTipoAtendimentoIds())
                        .stream()
                        .map(tipoAtendimentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Popula as coleções aninhadas
        responseDTO.setCertificacoes(
                profissional.getCertificacoes().stream()
                        .map(certificacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setDocumentos(
                profissional.getDocumentos().stream()
                        .map(documentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setExperiencias(
                profissional.getExperiencias().stream()
                        .map(experienciaProfissionalMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setFormacoes(
                profissional.getFormacoes().stream()
                        .map(formacaoAcademicaMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Define se faz parte de plano com base no planoId (regra de negócio)
        responseDTO.setFazParteDePlano(profissional.getPlano() != null); // Simplificado

        return responseDTO;
    }

    /**
     * Valida a existência de entidades de dados mestre.
     *
     * @param ids        Lista de UUIDs a serem validados.
     * @param finder     Função para encontrar a entidade por ID.
     * @param entityName Nome da entidade para mensagens de erro.
     * @param <T>        Tipo da entidade.
     */
    private <T> void validateMasterDataExistence(List<UUID> ids,
            java.util.function.Function<UUID, java.util.Optional<T>> finder, String entityName) {
        for (UUID id : ids) {
            if (finder.apply(id).isEmpty()) {
                throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        entityName + " com ID " + id + " não encontrado(a).");
            }
        }
    }

    public Map<String, List<String>> listarLocalizacoesDisponiveis() {
        List<Object[]> resultados = profissionalRepository.findDistinctEstadosAndCidades();
        Map<String, List<String>> localizacoes = new HashMap<>();

        for (Object[] row : resultados) {
            String estado = (String) row[0];
            String cidade = (String) row[1];
            localizacoes.computeIfAbsent(estado, k -> new ArrayList<>()).add(cidade);
        }
        return localizacoes;
    }
}
```
```java
package br.com.legalconnect.advogado.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.TipoAtendimento;
import br.com.legalconnect.advogado.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.repository.TipoAtendimentoRepository;
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço para gestão de Tipos de Atendimento (dados mestre).
 */
@Service
public class TipoAtendimentoService {

    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public TipoAtendimentoService(TipoAtendimentoRepository tipoAtendimentoRepository,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Busca um Tipo de Atendimento pelo ID.
     *
     * @param id ID do Tipo de Atendimento.
     * @return DTO do Tipo de Atendimento.
     * @throws BusinessException se o Tipo de Atendimento não for encontrado.
     */
    public TipoAtendimentoResponseDTO findTipoAtendimentoById(UUID id) {
        TipoAtendimento tipoAtendimento = tipoAtendimentoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Tipo de Atendimento não encontrado."));
        return tipoAtendimentoMapper.toResponseDTO(tipoAtendimento);
    }

    /**
     * Lista todos os Tipos de Atendimento.
     *
     * @return Lista de DTOs de Tipos de Atendimento.
     */
    public List<TipoAtendimentoResponseDTO> findAllTiposAtendimento() {
        return tipoAtendimentoRepository.findAll().stream()
                .map(tipoAtendimentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.commom.dto.request; // Assumindo um pacote common.dto.request para entidades comuns

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private String id; // Pode ser UUID ou String, dependendo da BaseEntity

    @NotBlank(message = "O logradouro é obrigatório.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número é obrigatório.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro é obrigatório.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade é obrigatória.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado é obrigatório.")
    @Size(max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP é obrigatório.")
    @Size(max = 9, message = "O CEP deve ter no máximo 9 caracteres.") // Com ou sem máscara
    private String cep;

    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais; // Valor padrão "Brasil" pode ser setado no serviço

    @NotNull(message = "O tipo de endereço é obrigatório.")
    private TipoEndereco tipoEndereco; // Usando o enum da entidade
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * DTO para requisição de criação ou atualização de uma Pessoa.
 * Inclui campos de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // ID é opcional para atualização (usado em PUT/put para identificar a Pessoa)
    private UUID id;

    @Valid
    @NotNull(message = "As informações do usuário são obrigatórias.")
    private UserRequestDTO usuario; // Informações de login e contato do usuário

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpf;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimento;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefones;

    @Valid
    private List<EnderecoRequestDTO> enderecos; // Lista de endereços associados à pessoa
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    // @NotBlank(message = "A senha do usuário é obrigatória.") // Pode ser
    // @NotBlank apenas na criação
    private String senha; // Em requisições, a senha é enviada em texto limpo para ser hashed no backend

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 14, message = "O CPF deve ter no máximo 14 caracteres.")
    private String cpf; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response; // Assumindo um pacote common.dto.response para entidades comuns

import java.util.UUID;

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;

    private String logradouro;

    private String numero;

    private String complemento;

    private String bairro;

    private String cidade;

    private String estado;

    private String cep;

    private String pais;

    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de uma Pessoa.
 * Inclui informações de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PessoaResponseDTO {
    private UUID id;

    private UserResponseDTO usuario;

    private String nomeCompleto;

    private String cpf;

    private LocalDate dataNascimento;

    private List<String> telefones;

    private List<EnderecoResponseDTO> enderecos;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.commom.model.User.UserStatus; // Importar o enum UserStatus da entidade User
import br.com.legalconnect.commom.model.User.UserType; // Importar o enum UserType da entidade User
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
package br.com.legalconnect.commom.mapper;

import java.util.UUID;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.EnderecoRequestDTO;
import br.com.legalconnect.commom.dto.response.EnderecoResponseDTO;
import br.com.legalconnect.commom.model.Endereco;

/**
 * Mapper MapStruct para a entidade Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {
    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * Mapeia um EnderecoRequestDTO para uma entidade Endereco.
     * Os campos 'pessoa' e 'empresa' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Endereco correspondente.
     */
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true) // Descomente se Empresa for
    // relevante e existir
    @Mapping(target = "id", source = "id", qualifiedByName = "mapStringToUuid")
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * Mapeia uma entidade Endereco para um EnderecoResponseDTO.
     *
     * @param entity A entidade Endereco.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id", qualifiedByName = "mapUuidToString")
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * Atualiza uma entidade Endereco existente com os dados de um
     * EnderecoRequestDTO.
     * O campo 'pessoa' e 'empresa' não são atualizados via DTO. O ID não deve ser
     * atualizado.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Endereco a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true)
    void updateEntityFromDto(EnderecoRequestDTO dto, @MappingTarget Endereco entity);

    /**
     * Converte uma String (ID do DTO) para um UUID (ID da Entidade).
     * 
     * @param id A string representando o UUID.
     * @return O objeto UUID.
     */
    @Named("mapStringToUuid")
    default UUID mapStringToUuid(UUID id) {
        return id != null ? (id) : null;
    }

    /**
     * Converte um UUID (ID da Entidade) para uma String (ID do DTO).
     * 
     * @param id O objeto UUID.
     * @return A string representando o UUID.
     */
    @Named("mapUuidToString")
    default String mapUuidToString(UUID id) {
        return id != null ? id.toString() : null;
    }
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.model.Pessoa;

/**
 * Mapper MapStruct para a entidade Pessoa e seus DTOs.
 * Utiliza UserMapper e EnderecoMapper para mapeamentos aninhados.
 */
@Mapper(componentModel = "spring", uses = { UserMapper.class, EnderecoMapper.class })
public interface PessoaMapper {
    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * Mapeia um PessoaRequestDTO para uma entidade Pessoa.
     * Os campos 'usuario' e 'enderecos' serão mapeados pelos mappers especificados
     * em 'uses'.
     * A conversão de List para Set para 'telefones' é feita automaticamente pelo
     * MapStruct.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Pessoa correspondente.
     */
    // @Mapping(target = "id", ignore = true) // ID da Pessoa será gerado na criação
    // Pessoa toEntity(PessoaRequestDTO dto);

    /**
     * Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     *
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta correspondente.
     */
    PessoaResponseDTO toResponseDTO(Pessoa entity);

    /**
     * Atualiza uma entidade Pessoa existente com os dados de um PessoaRequestDTO.
     * O 'id' da Pessoa não deve ser atualizado.
     * A atualização de 'usuario' e 'enderecos' deve ser orquestrada no serviço,
     * pois o MapStruct pode não ter o contexto para atualizar entidades aninhadas
     * existentes.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Pessoa a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "usuario", ignore = true) // O serviço deve gerenciar a atualização do User associado
    @Mapping(target = "enderecos", ignore = true) // O serviço deve gerenciar a atualização dos Enderecos associados
    @Mapping(source = "telefones", target = "telefones") // Converte List<String> para Set<String>
    void updateEntityFromDto(PessoaRequestDTO dto, @MappingTarget Pessoa entity);
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.UserResponseDTO;
import br.com.legalconnect.commom.model.User;

/**
 * Mapper MapStruct para a entidade User e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * Mapeia um UserRequestDTO para uma entidade User.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' são definidos pela lógica de negócio e ignorados
     * aqui.
     *
     * @param dto O DTO de requisição.
     * @return A entidade User correspondente.
     */
    @Mapping(source = "senha", target = "senhaHash") // Mapeia a senha do DTO para senhaHash na entidade
    // @Mapping(target = "userType", ignore = true) // Definido pela lógica de
    // negócio
    // @Mapping(target = "userStatus", ignore = true) // Definido pela lógica de
    // negócio
    User toEntity(UserRequestDTO dto);

    /**
     * Mapeia uma entidade User para um UserResponseDTO.
     * 'senhaHash' é ignorado na resposta por segurança.
     *
     * @param entity A entidade User.
     * @return O DTO de resposta correspondente.
     */
    // @Mapping(target = "senha", ignore = true) // 'senhaHash' é um campo interno
    // da entidade, não deve ser exposto no DTO de resposta
    UserResponseDTO toResponseDTO(User entity);

    /**
     * Atualiza uma entidade User existente com os dados de um UserRequestDTO.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade User a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(source = "senha", target = "senhaHash")
    // @Mapping(target = "userType", ignore = true)
    // @Mapping(target = "userStatus", ignore = true)
    void updateEntityFromDto(UserRequestDTO dto, @MappingTarget User entity);
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "empresa_id")
    // private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.commom.model;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.Pessoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Pessoa}.
 * Gerencia operações de persistência para informações de pessoas no sistema.
 */
@Repository
public interface PessoaRepository extends JpaRepository<Pessoa, UUID> {

    /**
     * Verifica se existe uma Pessoa com o CPF fornecido.
     * Regra de Negócio: Garante a unicidade do CPF no sistema.
     *
     * @param cpf O CPF a ser verificado.
     * @return true se uma Pessoa com o CPF já existe, false caso contrário.
     */
    boolean existsByCpf(String cpf);

    /**
     * Busca uma Pessoa pelo ID do usuário associado.
     *
     * @param userId O ID do usuário.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByUsuarioId(UUID userId);

    /**
     * Busca uma Pessoa pelo CPF.
     *
     * @param cpf O CPF da Pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu endereço de e-mail.
     * Regra de Negócio: O e-mail é único para cada usuário dentro de um tenant.
     *
     * @param email O endereço de e-mail do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * Verifica se um usuário com o endereço de e-mail fornecido já existe.
     * Regra de Negócio: Garante a unicidade do e-mail no sistema.
     *
     * @param email O endereço de e-mail a ser verificado.
     * @return true se um usuário com o e-mail já existe, false caso contrário.
     */
    boolean existsByEmail(String email);
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço simulado para envio de e-mails.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com um provedor de e-mails
 * como SendGrid, Amazon SES, ou o serviço de e-mail do Spring Boot.
 */
@Service
public class EmailService {

    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    /**
     * Simula o envio de um e-mail de ativação de conta.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param activationLink O link de ativação da conta.
     */
    public void sendActivationEmail(String toEmail, String activationLink) {
        log.info("Simulando envio de e-mail de ativação para: {}", toEmail);
        log.info("Link de Ativação: {}", activationLink);
        // Lógica real de envio de e-mail seria aqui, por exemplo:
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(toEmail);
        // helper.setSubject("Ative sua conta na LegalConnect!");
        // helper.setText("Olá! Clique no link para ativar sua conta: " + activationLink, true);
        // mailSender.send(message);
        log.info("E-mail de ativação simulado enviado com sucesso.");
    }

    /**
     * Simula o envio de um e-mail de confirmação de agendamento.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param details Detalhes do agendamento.
     */
    public void sendAppointmentConfirmationEmail(String toEmail, String details) {
        log.info("Simulando envio de e-mail de confirmação de agendamento para: {}", toEmail);
        log.info("Detalhes do Agendamento: {}", details);
        log.info("E-mail de confirmação de agendamento simulado enviado com sucesso.");
    }

    // Outros métodos de envio de e-mail podem ser adicionados conforme a necessidade
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.LocalAtuacao;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;
import br.com.legalconnect.commom.mapper.UserMapper;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.model.User;
import br.com.legalconnect.commom.repository.PessoaRepository; // Assumindo a existência de PessoaRepository
import br.com.legalconnect.commom.repository.UserRepository; // Assumindo a existência de UserRepository
import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das entidades Pessoa e User.
 * Centraliza a lógica de negócio para criação, atualização e busca de Pessoas
 * e seus usuários associados, incluindo validações de unicidade e criptografia
 * de senha.
 */
@Service
public class PessoaService {

    private final PessoaRepository pessoaRepository;
    private final UserRepository userRepository;
    private final PessoaMapper pessoaMapper;
    private final UserMapper userMapper;
    // Assumindo um EnderecoMapper se EnderecoRequestDTO for mapeado para Endereco
    // aqui
    // private final EnderecoMapper enderecoMapper;

    @Autowired
    public PessoaService(PessoaRepository pessoaRepository, UserRepository userRepository,
            PessoaMapper pessoaMapper, UserMapper userMapper) {
        this.pessoaRepository = pessoaRepository;
        this.userRepository = userRepository;
        this.pessoaMapper = pessoaMapper;
        this.userMapper = userMapper;
    }

    /**
     * Cria uma nova Pessoa e seu User associado.
     * Regras de Negócio:
     * - Garante que o CPF e o e-mail do usuário sejam únicos no sistema.
     * - Criptografa a senha antes de salvar.
     * - Define o status inicial do usuário como PENDING para aguardar ativação.
     *
     * @param pessoaRequestDTO DTO com os dados da Pessoa e do User.
     * @return DTO da Pessoa criada.
     * @throws BusinessException se o CPF ou e-mail já estiverem cadastrados.
     */
    @Transactional
    public Pessoa createPessoa(PessoaRequestDTO pessoaRequestDTO) {
        // Regra de Negócio: Validar unicidade de CPF
        if (pessoaRepository.existsByCpf(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, pessoaRequestDTO.getCpf());
        }

        // Regra de Negócio: Validar unicidade de e-mail para o usuário
        if (userRepository.existsByEmail(pessoaRequestDTO.getUsuario().getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    pessoaRequestDTO.getUsuario().getEmail());
        }

        // Cria e criptografa o usuário

        // Persiste o usuário
        var newUser = new User();
        newUser.setId((pessoaRequestDTO.getUsuario().getId()));

        // Cria a Pessoa e associa o usuário
        Pessoa newPessoa = Pessoa.builder()
                .usuario(newUser)
                .nomeCompleto(pessoaRequestDTO.getNomeCompleto())
                .cpf(pessoaRequestDTO.getCpf())
                .dataNascimento(pessoaRequestDTO.getDataNascimento())
                .telefones(new HashSet<>(pessoaRequestDTO.getTelefones()))
                .build();

        // Adiciona endereços
        if (pessoaRequestDTO.getEnderecos() != null && !pessoaRequestDTO.getEnderecos().isEmpty()) {
            Set<Endereco> enderecos = pessoaRequestDTO.getEnderecos().stream()
                    .map(dto -> {
                        Endereco endereco = new Endereco(); // Ou use enderecoMapper.toEntity(dto) se existir
                        endereco.setLogradouro(dto.getLogradouro());
                        endereco.setNumero(dto.getNumero());
                        endereco.setComplemento(dto.getComplemento());
                        endereco.setBairro(dto.getBairro());
                        endereco.setCidade(dto.getCidade());
                        endereco.setEstado(dto.getEstado());
                        endereco.setCep(dto.getCep());
                        endereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil"); // Define país padrão
                        endereco.setTipoEndereco(dto.getTipoEndereco());
                        endereco.setPessoa(newPessoa); // Associa o endereço à Pessoa
                        return endereco;
                    }).collect(Collectors.toSet());
            newPessoa.setEnderecos(enderecos);
        }
        // Reassigning to make it effectively final
        return (pessoaRepository.save(newPessoa));
    }

    /**
     * Busca uma Pessoa pelo ID.
     *
     * @param id ID da Pessoa.
     * @return DTO da Pessoa encontrada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    public PessoaResponseDTO findPessoaById(UUID id) {
        Pessoa pessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * Atualiza os dados de uma Pessoa existente.
     * Regras de Negócio:
     * - Permite a atualização de informações da Pessoa e do User associado.
     * - Valida a unicidade do e-mail se for alterado.
     * - Não permite a alteração do CPF.
     *
     * @param id               ID da Pessoa a ser atualizada.
     * @param pessoaRequestDTO DTO com os dados para atualização.
     * @return DTO da Pessoa atualizada.
     * @throws BusinessException se a Pessoa não for encontrada, ou se o e-mail já
     *                           estiver cadastrado.
     */
    @Transactional
    public PessoaResponseDTO updatePessoa(UUID id, PessoaRequestDTO pessoaRequestDTO) {
        Pessoa existingPessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada para atualização."));

        // Não permitir alteração de CPF (Regra de Negócio)
        if (!existingPessoa.getCpf().equals(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "Não é permitido alterar o CPF de uma pessoa existente.");
        }

        // Atualiza o User associado
        User existingUser = existingPessoa.getUsuario();
        UserRequestDTO userRequestDTO = pessoaRequestDTO.getUsuario();

        // Valida unicidade de e-mail se o e-mail for alterado
        if (!existingUser.getEmail().equals(userRequestDTO.getEmail())
                && userRepository.existsByEmail(userRequestDTO.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT, userRequestDTO.getEmail());
        }

        userMapper.updateEntityFromDto(userRequestDTO, existingUser);
        userRepository.save(existingUser); // Salva as alterações no User

        // Atualiza os dados da Pessoa (exceto usuário e endereços que são gerenciados
        // separadamente)
        pessoaMapper.updateEntityFromDto(pessoaRequestDTO, existingPessoa);

        // Lógica para gerenciar Endereços: Adicionar, Atualizar, Remover
        // Isso pode ser complexo e requer lógica manual, pois EndereçoRequestDTO tem ID
        // opcional
        // Para simplificar, vou redefinir os endereços ou adicionar lógica de
        // diferenciação.
        // Uma abordagem mais robusta seria comparar listas e fazer operações de CRUD
        // individualmente.
        if (pessoaRequestDTO.getEnderecos() != null) {
            // Removendo endereços que não estão no DTO
            existingPessoa.getEnderecos().removeIf(existingEndereco -> pessoaRequestDTO.getEnderecos().stream()
                    .noneMatch(dto -> dto.getId() != null && dto.getId().equals(existingEndereco.getId().toString())));

            // Adicionando ou atualizando endereços
            for (br.com.legalconnect.commom.dto.request.EnderecoRequestDTO dto : pessoaRequestDTO.getEnderecos()) {
                if (dto.getId() == null) {
                    // Novo endereço
                    Endereco newEndereco = new Endereco();
                    newEndereco.setLogradouro(dto.getLogradouro());
                    newEndereco.setNumero(dto.getNumero());
                    newEndereco.setComplemento(dto.getComplemento());
                    newEndereco.setBairro(dto.getBairro());
                    newEndereco.setCidade(dto.getCidade());
                    newEndereco.setEstado(dto.getEstado());
                    newEndereco.setCep(dto.getCep());
                    newEndereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                    newEndereco.setTipoEndereco(dto.getTipoEndereco());
                    newEndereco.setPessoa(existingPessoa);
                    existingPessoa.getEnderecos().add(newEndereco);
                } else {
                    // Atualizar endereço existente
                    existingPessoa.getEnderecos().stream()
                            .filter(e -> e.getId().toString().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> {
                                e.setLogradouro(dto.getLogradouro());
                                e.setNumero(dto.getNumero());
                                e.setComplemento(dto.getComplemento());
                                e.setBairro(dto.getBairro());
                                e.setCidade(dto.getCidade());
                                e.setEstado(dto.getEstado());
                                e.setCep(dto.getCep());
                                e.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                                e.setTipoEndereco(dto.getTipoEndereco());
                            });
                }
            }
        }

        existingPessoa = pessoaRepository.save(existingPessoa);
        return pessoaMapper.toResponseDTO(existingPessoa);
    }

    /**
     * Deleta uma Pessoa pelo ID.
     * Regras de Negócio:
     * - Também deleta o User associado devido ao CascadeType.ALL na Pessoa.
     *
     * @param id ID da Pessoa a ser deletada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    @Transactional
    public void deletePessoa(UUID id) {
        if (!pessoaRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                    "Pessoa não encontrada para deleção.");
        }
        pessoaRepository.deleteById(id);
    }

    public Optional<LocalAtuacao> findPessoaByCpf(String cpf) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByCpf'");
    }

    public Optional<LocalAtuacao> findPessoaByEmail(String email) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByEmail'");
    }
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;

/**
 * Serviço de integração simulada com AWS S3 para upload e deleção de arquivos.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a AWS
 * SDK.
 */
@Service
public class S3Service {

    private static final Logger log = LoggerFactory.getLogger(S3Service.class);
    private static final String MOCK_S3_BASE_URL = "https://mock-s3-bucket.s3.amazonaws.com/";

    /**
     * Simula o upload de um arquivo para o S3.
     *
     * @param fileBytes Os bytes do arquivo.
     * @param key       A chave/caminho do arquivo no bucket S3.
     * @param mimeType  O tipo MIME do arquivo.
     * @return A URL pública do arquivo no S3.
     * @throws BusinessException se ocorrer um erro durante o "upload" simulado.
     */
    public String uploadFile(byte[] fileBytes, String key, String mimeType) {
        if (fileBytes == null || fileBytes.length == 0) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "O conteúdo do arquivo não pode ser vazio.");
        }
        if (key == null || key.isEmpty()) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "A chave do S3 não pode ser vazia.");
        }

        // Simulação de upload: Loga a operação e retorna uma URL mock
        log.info("Simulando upload para S3. Chave: {}, Tamanho: {} bytes, Tipo: {}", key, fileBytes.length, mimeType);
        String fileUrl = MOCK_S3_BASE_URL + key;
        log.info("Upload simulado concluído. URL: {}", fileUrl);
        return fileUrl;
    }

    /**
     * Simula a deleção de um arquivo do S3.
     *
     * @param fileUrl A URL pública do arquivo a ser deletado.
     * @throws BusinessException se ocorrer um erro durante a "deleção" simulada.
     */
    public void deleteFile(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "URL do arquivo não pode ser vazia para deleção.");
        }

        // Simulação de deleção: Loga a operação
        log.info("Simulando deleção de S3. URL: {}", fileUrl);
        // Em um ambiente real, aqui estaria a chamada para o AWS S3 SDK para deletar o
        // objeto.
        // Por exemplo: s3Client.deleteObject(bucketName, key);
        log.info("Deleção simulada concluída para URL: {}", fileUrl);
    }
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.UUID;

/**
 * Utilitário para gerenciar o ID do Tenant no contexto da thread atual.
 * Usado em arquiteturas multitenant para garantir que as operações de banco de dados
 * sejam filtradas pelo tenant correto.
 */
public class TenantContext {

    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();

    /**
     * Define o ID do Tenant para a thread atual.
     *
     * @param tenantId O ID do Tenant.
     */
    public static void setCurrentTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }

    /**
     * Retorna o ID do Tenant da thread atual.
     *
     * @return O ID do Tenant.
     * @throws IllegalStateException se o Tenant ID não estiver definido no contexto.
     */
    public static UUID getCurrentTenantId() {
        UUID tenantId = currentTenant.get();
        if (tenantId == null) {
            // Em um ambiente real, você pode lançar uma exceção ou retornar um tenant padrão
            // dependendo da lógica de segurança e acesso.
            // Por simplicidade para este exercício, lançaremos uma exceção.
            throw new IllegalStateException("Tenant ID não está definido no contexto da requisição. Verifique o filtro de segurança.");
        }
        return tenantId;
    }

    /**
     * Limpa o ID do Tenant da thread atual.
     * Deve ser chamado ao final da requisição para evitar vazamentos de contexto.
     */
    public static void clear() {
        currentTenant.remove();
    }
}
```
```java
package br.com.legalconnect.perfilcardadvogado.dto.response; // Pacote atualizado

import java.util.List;
import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta para a listagem pública de advogados no marketplace.
 * Corresponde à interface Advogado solicitada pelo frontend.
 */
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AdvogadoResponseDTO {
    private UUID id;
    private String nome;
    private String oab;
    private String fotoUrl;
    private Double avaliacao; // Média de avaliação
    private Integer numAvaliacoes; // Número de avaliações
    private String bio;
    private List<String> especialidades;
    private String localizacao; // Cidade/Estado concatenado
    private String estado;
    private String municipio;
    private Boolean verificadoOAB; // Simulação de verificação da OAB
    private String nivel; // Nível do advogado (ex: Júnior, Pleno, Sênior)
    private String formacao; // Última formação acadêmica relevante
    private MetricasDTO metricas;
    private List<ServicoDTO> servicos;
    private Boolean fazParteDePlano; // Indica se o profissional tem um plano pago (para ordenação)
    private String nomePlano; // Novo campo para o nome do plano

    /**
     * DTO aninhado para métricas de desempenho do advogado.
     */
    @Getter
    @Setter
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class MetricasDTO {
        private Double satisfacao;
        private Integer casosConcluidos;
    }

    /**
     * DTO aninhado para serviços oferecidos pelo advogado.
     */
    @Getter
    @Setter
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class ServicoDTO {
        private String nome;
        private String descricao;
        private String preco;
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-advogados
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

 
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
package br.com.legalconnect.legal_usuario;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LegalUsuarioApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Estágio de Build
# Usamos uma imagem base que já inclui o Maven e o JDK 17.
FROM maven:3.9.6-eclipse-temurin-17-focal AS build

# Define o diretório de trabalho dentro do contêiner.
WORKDIR /app

# Copia o arquivo pom.xml para que as dependências sejam cacheadas.
COPY pom.xml .

# Copia o código-fonte da aplicação.
COPY src ./src

# Constrói a aplicação usando Maven.
# O build para o Gateway também pode pular os testes para agilizar.
RUN mvn clean install package -Dmaven.test.skip=true

# Estágio de Runtime
# Usamos uma imagem base com JRE (Runtime Environment) para rodar a aplicação.
FROM eclipse-temurin:17-jre-focal

# Define o diretório de trabalho dentro do contêiner.
WORKDIR /app

# Copia o JAR executável gerado no estágio de build para o estágio de runtime.
# O nome do JAR é baseado no artifactId e version do pom.xml do Gateway.
COPY --from=build /app/target/gateway-0.0.1-SNAPSHOT.jar legalconnect-gateway.jar

# Expõe a porta em que o Gateway será executado.
# Conforme o application.properties, a porta padrão é 8080.
EXPOSE 8080

# Define o comando de entrada que será executado quando o contêiner iniciar.
# Isso executa o JAR do Spring Boot.
ENTRYPOINT ["java", "-jar", "legalconnect-gateway.jar"]


```
```java
# Read Me First

The following was discovered as part of building this project:

- The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

- [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
- [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
- [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.

docker build -t legal-gateway:latest .

docker run --name legal-gateway -p 8080:8080 -d legal-gateway:latest

docker run -d --name legal-gateway --network legalconnect-network -p 8080:8080 legal-gateway:latest

docker run -d --name legalconnect-gateway-instance --network legalconnect-app-network -p 8080:8080 -e EUREKA_CLIENT_SERVICE_URL=http://eureka-server-instance:8761/eureka/ -e JWT_SECRET_KEY=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970 legal-gateway:latest

```
```java
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version> <!-- Usando 3.2.5, uma versão estável do Spring Boot 3 -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>gateway</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>legalconnect-gateway</name>
	<description>API Gateway for LegalConnect Microservices</description>

	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.3</spring-cloud.version>
	</properties>

	<dependencies>
		<!-- Spring Cloud Gateway -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway</artifactId>
		</dependency>

		<!-- Service Discovery (Eureka) -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

		<!-- Swagger para documentação do Gateway -->
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
			<version>2.0.2</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.6</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- common-lib (se aplicável, mantenha a versão correta) -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-openfeign</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.20</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-LegalconnectGatewayApplication<gateway>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.gateway.LegalconnectGatewayApplication",
      "projectName": "gateway",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
2025-07-19T00:04:15.152-03:00  INFO 15528 --- [api-gateway] [main] b.c.l.g.LegalconnectGatewayApplication   : Starting LegalconnectGatewayApplication using Java 17.0.14 with PID 15528 (E:\legalconnect\legalconnect\microservices\legal-gaateway\target\classes started by marce in E:\legalconnect\legalconnect\microservices\legal-gaateway)
2025-07-19T00:04:15.157-03:00  INFO 15528 --- [api-gateway] [main] b.c.l.g.LegalconnectGatewayApplication   : The following 1 profile is active: "prod"
2025-07-19T00:04:16.294-03:00  INFO 15528 --- [api-gateway] [main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=5f08001b-9a87-30ca-868e-5ada63b5f73e
2025-07-19T00:04:16.371-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration$DeferringLoadBalancerInterceptorConfig' of type [org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration$DeferringLoadBalancerInterceptorConfig] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). The currently created BeanPostProcessor [lbRestClientPostProcessor] is declared through a non-static factory method on that class; consider declaring it as static instead.
2025-07-19T00:04:16.375-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'deferringLoadBalancerInterceptor' of type [org.springframework.cloud.client.loadbalancer.DeferringLoadBalancerInterceptor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [lbRestClientPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:16.377-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration' of type [org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). The currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor] is declared through a non-static factory method on that class; consider declaring it as static instead.
2025-07-19T00:04:16.379-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration$ReactorDeferringLoadBalancerFilterConfig' of type [org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration$ReactorDeferringLoadBalancerFilterConfig] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:16.381-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'reactorDeferringLoadBalancerExchangeFilterFunction' of type [org.springframework.cloud.client.loadbalancer.reactive.DeferringLoadBalancerExchangeFilterFunction] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:17.438-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [After]
2025-07-19T00:04:17.439-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Before]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Between]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Cookie]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Header]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Host]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Method]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Path]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Query]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [ReadBody]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [RemoteAddr]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [XForwardedRemoteAddr]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Weight]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [CloudFoundryRouteService]
2025-07-19T00:04:17.939-03:00  INFO 15528 --- [api-gateway] [main] DiscoveryClientOptionalArgsConfiguration : Eureka HTTP Client uses RestTemplate.
2025-07-19T00:04:18.093-03:00  WARN 15528 --- [api-gateway] [main] iguration$LoadBalancerCaffeineWarnLogger : Spring Cloud LoadBalancer is currently working with the default cache. While this cache implementation is useful for development and tests, it's recommended to use Caffeine cache in production.You can switch to using Caffeine cache, by adding it and org.springframework.cache.caffeine.CaffeineCacheManager to the classpath.
2025-07-19T00:04:18.162-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING
2025-07-19T00:04:18.195-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka in region us-east-1
2025-07-19T00:04:18.200-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration
2025-07-19T00:04:18.224-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false
2025-07-19T00:04:18.226-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null
2025-07-19T00:04:18.226-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Application is null : false
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server
2025-07-19T00:04:18.629-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : The response status is 200
2025-07-19T00:04:18.632-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30
2025-07-19T00:04:18.634-03:00  INFO 15528 --- [api-gateway] [main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4
2025-07-19T00:04:18.642-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1752894258641 with initial instances count: 1
2025-07-19T00:04:18.644-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application API-GATEWAY with eureka with status UP
2025-07-19T00:04:18.646-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1752894258646, current=UP, previous=STARTING]
2025-07-19T00:04:18.649-03:00  INFO 15528 --- [api-gateway] [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080: registering service...
2025-07-19T00:04:18.701-03:00  INFO 15528 --- [api-gateway] [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080 - registration status: 204
2025-07-19T00:04:18.699-03:00 ERROR 15528 --- [api-gateway] [main] o.s.c.gateway.route.CachingRouteLocator  : Refresh routes error !!!

java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name name
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.loadGatewayFilters(RouteDefinitionRouteLocator.java:145) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.getFilters(RouteDefinitionRouteLocator.java:186) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.convertToRoute(RouteDefinitionRouteLocator.java:132) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:492) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:424) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.drain(FluxMergeSequential.java:439) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.innerComplete(FluxMergeSequential.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialInner.onSubscribe(FluxMergeSequential.java:559) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4568) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:4634) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4534) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4470) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4442) ~[reactor-core-3.6.5.jar:3.6.5]
	at org.springframework.cloud.gateway.route.CachingRouteLocator.onApplicationEvent(CachingRouteLocator.java:100) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.CachingRouteLocator.onApplicationEvent(CachingRouteLocator.java:42) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.reset(RouteRefreshListener.java:73) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.onApplicationEvent(RouteRefreshListener.java:54) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration.start(EurekaAutoServiceRegistration.java:91) ~[spring-cloud-netflix-eureka-client-4.1.1.jar:4.1.1]
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:288) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:471) ~[spring-context-6.1.6.jar:6.1.6]
	at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]
	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:260) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:205) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:981) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:627) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]

2025-07-19T00:04:18.715-03:00  WARN 15528 --- [api-gateway] [main] onfigReactiveWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Failed to start bean 'eurekaAutoServiceRegistration'
2025-07-19T00:04:18.723-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...
2025-07-19T00:04:21.733-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Unregistering ...
2025-07-19T00:04:21.742-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8761/eureka/} exception=Connection pool shut down stacktrace=java.lang.IllegalStateException: Connection pool shut down
	at org.apache.hc.core5.util.Asserts.check(Asserts.java:38)
	at org.apache.hc.core5.pool.StrictConnPool.lease(StrictConnPool.java:176)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.lease(PoolingHttpClientConnectionManager.java:298)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.acquireEndpoint(InternalExecRuntime.java:103)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:125)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:87)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.apache.hc.client5.http.classic.HttpClient.executeOpen(HttpClient.java:183)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:95)
	at org.springframework.http.client.AbstractStreamingClientHttpRequest.executeInternal(AbstractStreamingClientHttpRequest.java:70)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:112)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:88)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:72)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:889)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:790)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:672)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.cancel(RestTemplateEurekaHttpClient.java:87)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:91)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916)
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195)
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389)
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637)
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18)

2025-07-19T00:04:21.744-03:00  WARN 15528 --- [api-gateway] [main] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: Connection pool shut down
2025-07-19T00:04:21.749-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8761/eureka/}, exception=Connection pool shut down stacktrace=java.lang.IllegalStateException: Connection pool shut down
	at org.apache.hc.core5.util.Asserts.check(Asserts.java:38)
	at org.apache.hc.core5.pool.StrictConnPool.lease(StrictConnPool.java:176)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.lease(PoolingHttpClientConnectionManager.java:298)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.acquireEndpoint(InternalExecRuntime.java:103)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:125)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:87)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.apache.hc.client5.http.classic.HttpClient.executeOpen(HttpClient.java:183)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:95)
	at org.springframework.http.client.AbstractStreamingClientHttpRequest.executeInternal(AbstractStreamingClientHttpRequest.java:70)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:112)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:88)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:72)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:889)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:790)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:672)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.cancel(RestTemplateEurekaHttpClient.java:87)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916)
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195)
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389)
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637)
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18)

2025-07-19T00:04:21.749-03:00  WARN 15528 --- [api-gateway] [main] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: Connection pool shut down
2025-07-19T00:04:21.750-03:00 ERROR 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080 - de-registration failedCannot execute request on any known server

com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892) ~[eureka-client-2.0.2.jar:2.0.2]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:569) ~[na:na]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389) ~[spring-cloud-context-4.1.2.jar:4.1.2]
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136) ~[spring-cloud-context-4.1.2.jar:4.1.2]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]

2025-07-19T00:04:21.756-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient
2025-07-19T00:04:21.770-03:00  INFO 15528 --- [api-gateway] [main] .s.b.a.l.ConditionEvaluationReportLogger : 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-07-19T00:04:21.790-03:00 ERROR 15528 --- [api-gateway] [main] o.s.boot.SpringApplication               : Application run failed

org.springframework.context.ApplicationContextException: Failed to start bean 'eurekaAutoServiceRegistration'
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:291) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:471) ~[spring-context-6.1.6.jar:6.1.6]
	at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]
	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:260) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:205) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:981) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:627) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]
Caused by: java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name name
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.loadGatewayFilters(RouteDefinitionRouteLocator.java:145) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.getFilters(RouteDefinitionRouteLocator.java:186) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.convertToRoute(RouteDefinitionRouteLocator.java:132) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:492) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:424) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.drain(FluxMergeSequential.java:439) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.innerComplete(FluxMergeSequential.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialInner.onSubscribe(FluxMergeSequential.java:559) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.blockLast(Flux.java:2816) ~[reactor-core-3.6.5.jar:3.6.5]
	at org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter.lambda$onApplicationEvent$3(WeightCalculatorWebFilter.java:156) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider.ifAvailable(DefaultListableBeanFactory.java:2126) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter.onApplicationEvent(WeightCalculatorWebFilter.java:156) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.reset(RouteRefreshListener.java:73) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.onApplicationEvent(RouteRefreshListener.java:54) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration.start(EurekaAutoServiceRegistration.java:91) ~[spring-cloud-netflix-eureka-client-4.1.1.jar:4.1.1]
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:288) ~[spring-context-6.1.6.jar:6.1.6]
	... 13 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:104) ~[reactor-core-3.6.5.jar:3.6.5]
		at reactor.core.publisher.Flux.blockLast(Flux.java:2817) ~[reactor-core-3.6.5.jar:3.6.5]
		... 30 common frames omitted


```
```java
{
  "openapi": "3.0.1",
  "info": {
    "title": "LegalConnect Gateway API",
    "description": "API Gateway para o sistema LegalConnect",
    "version": "1.0"
  },
  "servers": [
    { "url": "http://192.168.1.4:54557", "description": "Generated server url" }
  ],
  "security": [{ "JWT": [] }],
  "paths": {
    "/api/v1/auth/socios/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerSocio",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/redefinir": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "resetPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ResetPasswordRequest" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/recuperar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "recoverPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecoverPasswordRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/refresh-token": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "refreshToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshTokenRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/login": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "authenticate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/LoginRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/clientes/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerClient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/advogados/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdvogado",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/administradores/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdmin",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "UserRegistrationRequest": {
        "required": ["cpf", "email", "nomeCompleto", "senha", "userType"],
        "type": "object",
        "properties": {
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "email": { "maxLength": 255, "minLength": 0, "type": "string" },
          "cpf": {
            "pattern": "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$",
            "type": "string"
          },
          "telefone": { "maxLength": 20, "minLength": 0, "type": "string" },
          "senha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          },
          "userType": { "type": "string" }
        }
      },
      "BaseResponseUserResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/UserResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "nomeCompleto": { "type": "string" },
          "email": { "type": "string" },
          "cpf": { "type": "string" },
          "telefone": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "status": { "type": "string" }
        }
      },
      "ResetPasswordRequest": {
        "required": ["novaSenha", "token"],
        "type": "object",
        "properties": {
          "token": { "type": "string" },
          "novaSenha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "RecoverPasswordRequest": {
        "required": ["email"],
        "type": "object",
        "properties": { "email": { "type": "string" } }
      },
      "RefreshTokenRequestDTO": {
        "required": ["refreshToken"],
        "type": "object",
        "properties": { "refreshToken": { "type": "string" } }
      },
      "AuthResponse": {
        "type": "object",
        "properties": {
          "accessToken": { "type": "string" },
          "refreshToken": { "type": "string" },
          "tokenType": { "type": "string" },
          "expiresIn": { "type": "integer", "format": "int64" }
        }
      },
      "BaseResponseAuthResponse": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AuthResponse" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "LoginRequestDTO": {
        "required": ["email", "senha"],
        "type": "object",
        "properties": {
          "email": { "type": "string" },
          "senha": { "type": "string" }
        }
      }
    },
    "securitySchemes": {
      "JWT": {
        "type": "http",
        "name": "JWT",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  }
}

```
```java
```java
package br.com.legalconnect.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class LegalconnectGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(LegalconnectGatewayApplication.class, args);
	}

}

```
```java
package br.com.legalconnect.gateway.config;

import java.net.URI;

import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    // Este bean é para permitir o roteamento dinâmico no application.yml
    // para o Swagger, onde precisamos pegar o URI de qualquer serviço.
    @Bean
    public CustomDiscoveryClientService customDiscoveryClientService(DiscoveryClient discoveryClient) {
        return new CustomDiscoveryClientService(discoveryClient);
    }

    public static class CustomDiscoveryClientService {
        private final DiscoveryClient discoveryClient;

        public CustomDiscoveryClientService(DiscoveryClient discoveryClient) {
            this.discoveryClient = discoveryClient;
        }

        public URI getServiceUri() {
            // Este método será usado no application.yml para resolver o URI dinamicamente.
            // Para o Swagger, precisamos de um URI genérico para que o Gateway possa
            // proxyar requisições para qualquer serviço.
            // Em um cenário real, você pode querer listar todos os serviços
            // e construir as rotas do Swagger dinamicamente em tempo de execução
            // ou ter um serviço de agregação de Swagger.
            // Aqui, apenas retornamos um URI base para o balanceador de carga.
            return URI.create("lb://");
        }
    }

}

```
```java
package br.com.legalconnect.gateway.config;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayRouteConfig {
        private final GatewayFilter jwtFilter;

        public GatewayRouteConfig(GatewayFilter jwtFilter) {
                this.jwtFilter = jwtFilter;
        }
        // @Bean
        // public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        // return builder.routes()
        // // Swagger AUTH
        // .route("swagger-ui-auth", r -> r.path("/auth/swagger-ui/**")
        // .filters(f -> f.rewritePath("/auth/swagger-ui/(?<segment>.*)",
        // "/swagger-ui/${segment}"))
        // .uri("lb://AUTH-SERVICE"))
        // // API Docs AUTH
        // .route("api-docs-auth", r -> r.path("/auth/v3/api-docs/**")
        // .filters(f -> f.rewritePath("/auth/v3/api-docs/(?<segment>.*)",
        // "/v3/api-docs/${segment}"))
        // .uri("lb://AUTH-SERVICE"))
        // // Swagger USUARIO
        // .route("swagger-ui-usuario", r -> r.path("/usuario/swagger-ui/**")
        // .filters(f -> f.rewritePath("/usuario/swagger-ui/(?<segment>.*)",
        // "/swagger-ui/${segment}"))
        // .uri("lb://LEGALCONNECT-USUARIO-SERVICE"))
        // // API Docs USUARIO
        // .route("api-docs-usuario", r -> r.path("/usuario/v3/api-docs/**")
        // .filters(f -> f.rewritePath("/usuario/v3/api-docs/(?<segment>.*)",
        // "/v3/api-docs/${segment}"))
        // .uri("lb://LEGALCONNECT-USUARIO-SERVICE"))
        // .build();
        // }

        @Bean
        public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
                return builder.routes()
                                // Rota principal para o serviço de usuário
                                .route("usuario-service", r -> r.path("/api/usuarios/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/(?<segment>.*)",
                                                                "/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                // Rota para a documentação OpenAPI
                                .route("usuario-service-api-docs", r -> r.path("/api/usuarios/v3/api-docs/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/v3/api-docs/(?<segment>.*)",
                                                                "/v3/api-docs/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                // Rota para o Swagger UI
                                .route("usuario-service-swagger-ui", r -> r.path("/api/usuarios/swagger-ui/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/swagger-ui/(?<segment>.*)",
                                                                "/swagger-ui/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                .build();
        }

}

```
```java
package br.com.legalconnect.gateway.config;

import java.util.List;
import java.util.Map;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.util.JwtUtil;
import reactor.core.publisher.Mono;

@Component // Nome do bean para uso no application.yml
public class JwtTokenFilter implements GatewayFilter {

    private final JwtUtil jwtUtil;

    public JwtTokenFilter(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();

        // Verifica se a rota é pública (ex: /auth/** ou Swagger)
        // Isso é mais robusto fazer com Spring Security WebFilterChain
        // Mas para este exemplo, podemos verificar o path
        if (isPublicPath(request.getPath().value())) {
            return chain.filter(exchange);
        }

        List<String> authHeaders = request.getHeaders().get(HttpHeaders.AUTHORIZATION);

        if (authHeaders == null || authHeaders.isEmpty() || !authHeaders.get(0).startsWith("Bearer ")) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        String token = authHeaders.get(0).substring(7); // Remove "Bearer "

        if (!jwtUtil.validateToken(token)) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        // Extrai e remove claims específicos
        Map<String, Object> claims = jwtUtil.getAllClaimsFromToken(token);
        String userId = (String) claims.get("X-Correlaton-ID");
        String tenantId = (String) claims.get("X-Tenant-ID");

        // Remove os claims do token original (se necessário para nova validação
        // downstream)
        // Isso é mais complexo pois você precisaria gerar um novo token sem esses
        // claims.
        // Uma abordagem mais comum é manter o token original e propagar os claims
        // em headers separados para os microserviços.
        // Para este projeto, vamos propagar os claims como headers.

        ServerHttpRequest.Builder builder = request.mutate();
        if (userId != null) {
            builder.header("X-User-Id", userId);
        }
        if (tenantId != null) {
            builder.header("X-Tenant-Id", tenantId);
        }

        // Para evitar que o token completo seja enviado para os serviços downstream
        // Se você precisar do token completo downstream, considere remover essa linha
        // ou validar a necessidade.
        builder.header(HttpHeaders.AUTHORIZATION, "Bearer " + token); // Mantém o token original

        return chain.filter(exchange.mutate().request(builder.build()).build());
    }

    // Helper para verificar se o path é público
    private boolean isPublicPath(String path) {
        // Rotas que devem ser liberadas sem autenticação
        return path.startsWith("/auth/") ||
                path.startsWith("/swagger-ui/") ||
                path.startsWith("/v3/api-docs/");
    }
}

```
```java
// com.example.gateway.config/SecurityConfig.java
package br.com.legalconnect.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

@Configuration
public class SecurityConfig {
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
```
```java
package br.com.legalconnect.gateway.util;

import java.util.Date;
import java.util.Map;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureException;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.security.Keys;

@Component
public class JwtUtil {

    @Value("${application.security.jwt.secret-key}")
    private String secret;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public Map<String, Object> getAllClaimsFromToken(String token) {
        return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
    }

    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = (Claims) getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }

    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            // Logger.error("Assinatura JWT inválida: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            // Logger.error("Token JWT malformado: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            // Logger.error("Token JWT expirado: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            // Logger.error("Token JWT não suportado: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            // Logger.error("String JWT compacta vazia: {}", e.getMessage());
        }
        return false;
    }
}
```
```java
# Server Configuration
server.port=8080

# Application Configuration
spring.application.name=legalconnect-gateway

# Gateway Discovery Configuration
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

# Eureka Discovery Configuration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.client.fetch-registry=true
eureka.client.register-with-eureka=true
eureka.instance.prefer-ip-address=true

# Swagger Configuration
 

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
```
```java
package br.com.legalconnect.common.common_lib;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CommonLibApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java

```
```java
package br.com.legalconnect.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class LegalconnectGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(LegalconnectGatewayApplication.class, args);
	}

}

```
```java
package br.com.legalconnect.gateway.config.enums;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
package br.com.legalconnect.gateway.config.exception;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonInclude;

import br.com.legalconnect.gateway.config.enums.StatusResponse;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class BaseResponse
 * @brief DTO base para padronizar as respostas da API.
 *
 *        Inclui campos comuns para todas as respostas, como status, mensagem,
 *        timestamp e, opcionalmente, uma lista de erros.
 *        Utiliza Lombok para reduzir boilerplate (getters, setters,
 *        construtores, builder).
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL) // Inclui apenas campos não nulos na serialização JSON
public class BaseResponse<T> {

    private StatusResponse status; // Status da resposta (ex: StatusResponse.SUCESSO, StatusResponse.ERRO,
                                   // "WARNING")
    private String message; // Mensagem descritiva da resposta
    private LocalDateTime timestamp; // Data e hora da resposta
    private T data; // Payload da resposta (dados de sucesso)
    private List<String> errors; // Lista de mensagens de erro, se houver
}
```
```java
package br.com.legalconnect.gateway.config.exception;

import org.springframework.http.HttpStatus;

import lombok.Getter;

/**
 * @class BusinessException
 * @brief Exceção personalizada para representar erros de negócio na aplicação.
 *
 *        Esta exceção é lançada quando uma regra de negócio não é satisfeita.
 *        Ela encapsula um {@link ErrorCode} e, opcionalmente, argumentos para
 *        formatar
 *        a mensagem de erro, além de um status HTTP para a resposta da API.
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode; // O código de erro padronizado
    private final String[] args; // Argumentos para formatar a mensagem do erro
    private final HttpStatus httpStatus; // Status HTTP associado a esta exceção

    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String args) {
        super(args);
        this.errorCode = errorCode;
        this.args = new String[] { args, errorCode.getMessage() };
        this.httpStatus = httpStatus;
    }

    /**
     * Construtor para BusinessException com um ErrorCode e status HTTP padrão
     * (BAD_REQUEST).
     *
     * @param errorCode O código de erro que define o tipo de exceção de negócio.
     * @param args      Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, String... args) {
        this(errorCode, HttpStatus.BAD_REQUEST, args); // Por padrão, erros de negócio são BAD_REQUEST
    }

    /**
     * Construtor para BusinessException com um ErrorCode e um status HTTP
     * específico.
     *
     * @param errorCode  O código de erro que define o tipo de exceção de negócio.
     * @param httpStatus O status HTTP a ser retornado na resposta da API.
     * @param args       Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String... args) {
        super(errorCode.getFormattedMessage(args)); // Define a mensagem da exceção usando a mensagem formatada do
                                                    // ErrorCode
        this.errorCode = errorCode;
        this.args = args;
        this.httpStatus = httpStatus;

    }

    /**
     * @brief Retorna a mensagem de erro formatada.
     * @return A mensagem de erro formatada.
     */
    @Override
    public String getMessage() {
        return errorCode.getFormattedMessage(args);
    }

    /**
     * @brief Retorna o código de erro.
     * @return O código de erro.
     */
    public String getCode() {
        return errorCode.getCode();
    }
}
```
```java
package br.com.legalconnect.gateway.config.exception;

import lombok.Getter;

/**
 * @enum ErrorCode
 * @brief Enumeração que define códigos de erro padronizados para a aplicação.
 *
 *        Cada código de erro possui uma mensagem associada, facilitando a
 *        padronização
 *        de respostas de erro na API e a internacionalização ou localização
 *        futura.
 */
@Getter
public enum ErrorCode {
    // Erros gerais de validação
    DADOS_INVALIDOS("001", "Dados fornecidos são inválidos."),
    REQUISICAO_MAL_FORMADA("002", "A requisição está mal formada."),
    PARAMETRO_AUSENTE("003", "Parâmetro obrigatório ausente."),

    // Erros de entidade / negócio
    ENTIDADE_NAO_ENCONTRADA("100", "Entidade não encontrada."),
    EMPRESA_NAO_ENCONTRADA("101", "Empresa não encontrada."),
    PROFISSIONAL_NAO_ENCONTRADO("102", "Profissional não encontrado."),
    CLIENTE_NAO_ENCONTRADO("103", "Cliente não encontrado."),
    ADMINISTRADOR_NAO_ENCONTRADO("104", "Administrador não encontrado."),
    PLANO_NAO_ENCONTRADO("105", "Plano não encontrado."),
    USER_NAO_ENCONTRADO("106", "Usuário associado não encontrado."),

    // Erros de duplicidade
    CNPJ_DUPLICADO("200", "CNPJ já cadastrado."),
    CPF_DUPLICADO("201", "CPF já cadastrado."),
    OAB_DUPLICADA("202", "Número da OAB já cadastrado."),
    EMAIL_DUPLICADO("203", "Email já cadastrado."),
    NOME_PLANO_DUPLICADO("204", "Nome do plano já cadastrado."),

    // Erros de integridade
    INTEGRIDADE_VIOLADA("300", "Violação de integridade de dados."),
    RECURSO_EM_USO("301", "Recurso não pode ser excluído pois está em uso."),

    // Erros de sistema / internos
    ERRO_INTERNO_SERVIDOR("500", "Ocorreu um erro interno no servidor."),
    SERVICO_INDISPONIVEL("503", "Serviço temporariamente indisponível."),

    // Erros Gerais/Comuns (1000-1999)
    GENERIC_ERROR("1000", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde."),
    INVALID_INPUT("1001", "Dados de entrada inválidos."),
    RESOURCE_NOT_FOUND("1002", "Recurso não encontrado."),
    UNAUTHORIZED_ACCESS("1003", "Acesso não autorizado. Credenciais inválidas ou ausentes."),
    FORBIDDEN_ACCESS("1004", "Acesso negado. Você não tem permissão para realizar esta ação."),
    SERVICE_UNAVAILABLE("1005", "O serviço está temporariamente indisponível. Tente novamente mais tarde."),
    TOO_MANY_REQUESTS("1006", "Muitas requisições. Por favor, aguarde e tente novamente."),
    VALIDATION_ERROR("1007", "Erro de validação nos dados fornecidos."),
    DATABASE_ERROR("1008", "Erro ao acessar o banco de dados."),
    INTEGRATION_ERROR("1009", "Erro de integração com serviço externo."),

    // Erros de Autenticação e Autorização (2000-2999)
    INVALID_CREDENTIALS("2000", "Credenciais de autenticação inválidas."),
    ACCOUNT_LOCKED("2001", "Sua conta está bloqueada."),
    ACCOUNT_DISABLED("2002", "Sua conta está desativada."),
    TOKEN_EXPIRED("2003", "O token de acesso expirou."),
    INVALID_TOKEN("2004", "O token de acesso é inválido."),
    REFRESH_TOKEN_EXPIRED("2005", "O refresh token expirou. Faça login novamente."),
    INVALID_REFRESH_TOKEN("2006", "O refresh token é inválido."),
    USER_NOT_FOUND("2007", "Usuário não encontrado."),
    EMAIL_ALREADY_REGISTERED("2008", "Este e-mail já está cadastrado."),
    PASSWORD_RESET_FAILED("2009", "Falha ao redefinir a senha."),
    INVALID_CURRENT_PASSWORD("2010", "A senha atual fornecida está incorreta."), // Novo erro
    PASSWORD_RESET_TOKEN_INVALID("2011", "Token de redefinição de senha inválido."), // Novo erro
    PASSWORD_RESET_TOKEN_EXPIRED("2012", "Token de redefinição de senha expirado."), // Novo erro
    PASSWORD_RESET_TOKEN_USED("2013", "Token de redefinição de senha já utilizado."), // Novo erro
    PASSWORD_RESET_TOKEN_EXCEEDED("2014", "Limite de redefinições de senha excedido."), // Novo erro

    // Erros de Negócio Específicos (3000-3999) - Exemplo
    TENANT_NOT_FOUND("3000", "Tenant não encontrado."),
    TENANT_DISABLED("3001", "O tenant está desativado."),
    SUBSCRIPTION_EXPIRED("3002", "Sua assinatura expirou."),
    PLAN_NOT_ACTIVE("3003", "O plano selecionado não está ativo."),
    SERVICE_LIMIT_EXCEEDED("3004", "Limite de serviços agendáveis excedido para o seu plano."),
    ADVOCATE_NOT_AVAILABLE("3005", "Advogado não disponível no horário selecionado."),
    APPOINTMENT_CONFLICT("3006", "Conflito de agendamento. O horário já está ocupado."),
    PAYMENT_FAILED("3007", "Falha no processamento do pagamento."),
    INVALID_PROMO_CODE("3008", "Código promocional inválido ou expirado."),
    DOCUMENT_UPLOAD_FAILED("3009", "Falha ao fazer upload do documento."),
    INVALID_DOCUMENT_FORMAT("3010", "Formato de documento inválido."),

    // Erros de Validação de Campo (4000-4999) - Mais específicos, geralmente
    // tratados por @Valid
    FIELD_REQUIRED("4000", "O campo '%s' é obrigatório."),
    INVALID_FORMAT("4001", "O campo '%s' possui formato inválido."),
    MIN_LENGTH("4002", "O campo '%s' deve ter no mínimo %d caracteres."),
    MAX_LENGTH("4003", "O campo '%s' deve ter no máximo %d caracteres."),
    INVALID_EMAIL("4004", "O e-mail fornecido é inválido."),
    INVALID_CPF("4005", "O CPF fornecido é inválido."),
    INVALID_CNPJ("4006", "O CNPJ fornecido é inválido."),
    PASSWORD_TOO_WEAK("4007", "A senha é muito fraca."),
    DATE_IN_PAST("4008", "A data não pode ser no passado."),
    INVALID_ENUM_VALUE("4009", "Valor inválido para o campo '%s'.");

    private final String code;
    private final String message;

    /**
     * Construtor para ErrorCode.
     *
     * @param code    O código único do erro.
     * @param message A mensagem descritiva do erro.
     */
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    /**
     * @brief Retorna a mensagem de erro formatada com argumentos.
     * @param args Argumentos para formatar a mensagem.
     * @return A mensagem de erro formatada.
     */
    public String getFormattedMessage(Object... args) {
        return String.format(this.message, args);
    }
}

```
```java
package br.com.legalconnect.gateway.config.exception;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.config.enums.StatusResponse;
import reactor.core.publisher.Mono;

@RestControllerAdvice
public class GlobalExceptionHandler {

        @ExceptionHandler(BusinessException.class)
        public Mono<ResponseEntity<BaseResponse>> handleBusinessException(
                        BusinessException ex,
                        ServerWebExchange exchange) {

                BaseResponse response = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ex.getMessage())
                                .build();

                return Mono.just(ResponseEntity
                                .status(ex.getHttpStatus())
                                .body(response));
        }
}
```
```java
package br.com.legalconnect.gateway.util;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.config.exception.BusinessException;
import br.com.legalconnect.gateway.config.exception.ErrorCode;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component

public class AuthFilter extends AbstractGatewayFilterFactory<AuthFilter.Config> {

    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    public AuthFilter(

    ) {
        super(Config.class);

    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            try {
                String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

                if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "Token não encontrado");
                }

                String token = authHeader.substring(7);

                if (token == null || token.isBlank()) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "Token não encontrado");
                }

                Claims claims = extractAllClaims(token);
                if (isTokenExpired(token)) {
                    throw new BusinessException(ErrorCode.TOKEN_EXPIRED, "Token expirado");
                }
                String correlationId = claims.get("X-Correlation-ID", String.class);
                String tenantId = claims.get("X-Tenant-ID", String.class);

                if (correlationId == null || correlationId.isBlank()) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "X-Correlation-ID não encontrado no token");
                }

                if (tenantId == null || tenantId.isBlank()) {
                    throw new BusinessException(ErrorCode.TENANT_NOT_FOUND, "tenantId não encontrado no token");
                }

                ServerWebExchange mutated = exchange.mutate()
                        .request(builder -> {
                            builder.header("X-Correlation-ID", correlationId);
                            builder.header("X-Tenant-ID", tenantId);

                        })
                        .build();

                return chain.filter(mutated);

            } catch (Exception e) {
                log.error("Erro ao processar token JWT: {}", e.getMessage());
                // if (e instanceof BusinessException) {
                // throw (BusinessException) e;
                // }
                throw new BusinessException(ErrorCode.INVALID_TOKEN, "Token inválido ou malformado");
            }
        };
    }

    public static class Config {
    }

    private Claims extractAllClaims(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    /**
     * Verifica se o token JWT expirou.
     * 
     * @param token O token JWT.
     * @return True se o token expirou, false caso contrário.
     */
    private boolean isTokenExpired(String token) {
        Date expiration = extractExpiration(token);
        boolean expired = expiration.before(new Date());
        if (expired) {
            log.debug("Token expirado em: {}", expiration);
        }
        return expired;
    }

    /**
     * Extrai a data de expiração do token JWT.
     * 
     * @param token O token JWT.
     * @return A data de expiração.
     */
    Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUsername(String token) {
        try {
            return extractClaim(token, Claims::getSubject);
        } catch (Exception e) {
            log.warn("Erro ao extrair username do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extrai uma claim específica do token JWT.
     * 
     * @param token          O token JWT.
     * @param claimsResolver Função para resolver a claim.
     * @param <T>            Tipo da claim.
     * @return O valor da claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

}
```
```java

# src/main/resources/application.properties
# Configuração do Servidor
server.port=8080

# Configuração da Aplicação
spring.application.name=legalconnect-gateway

 
# Configuração de Descoberta do Eureka
# URL do servidor Eureka.
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
# Habilita a busca do registro de serviços do Eureka.
eureka.client.fetch-registry=true
# Habilita o registro deste serviço no Eureka.
eureka.client.register-with-eureka=true
# Prefere o endereço IP ao invés do hostname para registro no Eureka.
eureka.instance.prefer-ip-address=true
# Additional Swagger configuration
 

# Swagger configuration
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
spring.mvc.favicon.enabled=false

# Configuração do Swagger (Espaço reservado, pode ser configurado dinamicamente via GatewayConfig)

# Configuração do Actuator
# Inclui endpoints do Actuator para monitoramento de saúde e informações.
management.endpoints.web.exposure.include=health,info
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true
 
# application.properties

# Nome da sua aplicação Gateway 

# Configuração das rotas do Gateway
# spring.cloud.gateway.routes[0].id=clientes-route
# spring.cloud.gateway.routes[0].uri=lb://legalconnect-usuario-service
# spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/clientes/**


# # Filtros específicos para a rota 'clientes-route'
# # Exemplo de filtro: remove os 2 primeiros segmentos do path
# spring.cloud.gateway.routes[0].filters[0]=StripPrefix=2
# # Exemplo de filtro personalizado (se você tiver um filtro Java chamado MyCustomFilterGatewayFilterFactory)
# spring.cloud.gateway.routes[0].filters[1]=MyCustomFilter
# # Exemplo de filtro que adiciona um cabeçalho à requisição 

# Filtros padrão que se aplicam a todas as rotas

spring.cloud.gateway.routes[1].id=auth-service-route
spring.cloud.gateway.routes[1].uri=lb://auth-service
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/auth/**
# spring.cloud.gateway.routes[1].filters[0]=AuthFilter

spring.cloud.gateway.routes[0].id=clientes-route
spring.cloud.gateway.routes[0].uri=lb://legalconnect-usuario-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/usuarios/**
spring.cloud.gateway.routes[0].filters[0]=AuthFilter
spring.cloud.gateway.global-filters[0].DedupeResponseHeader.strategy=RETAIN_LAST

spring.cloud.gateway.routes[2].id=advogados-route
spring.cloud.gateway.routes[2].uri=lb://legalconnect-advogados
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/advogados/**
spring.cloud.gateway.routes[2].filters[0]=AuthFilter
spring.cloud.gateway.global-filters[2].DedupeResponseHeader.strategy=RETAIN_LAST
# Chave secreta JWT
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Rotas públicas
application.security.public-paths=/auth/**,/swagger-ui/**,/v3/api-docs/**,/api/usuarios/swagger-ui.html,/api/usuarios/webjars/**,/api/usuarios/v3/api-docs/**

# Configurações específicas para a rota de clientes
application.security.routes.clientes.required-role=CLIENT
application.security.routes.clientes.required-scopes=client.read,client.write
# Desabilite o tratamento de erro padrão do Spring
# Desabilite o tratamento de erro padrão do Spring
spring.webflux.auto-configure-error=false
```
```java
package br.com.legalconnect.common.common_lib;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CommonLibApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```java

# src/main/resources/application.properties
# Configuração do Servidor
server.port=8080

# Configuração da Aplicação
spring.application.name=legalconnect-gateway

 
# Configuração de Descoberta do Eureka
# URL do servidor Eureka.
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
# Habilita a busca do registro de serviços do Eureka.
eureka.client.fetch-registry=true
# Habilita o registro deste serviço no Eureka.
eureka.client.register-with-eureka=true
# Prefere o endereço IP ao invés do hostname para registro no Eureka.
eureka.instance.prefer-ip-address=true
# Additional Swagger configuration
 

# Swagger configuration
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
spring.mvc.favicon.enabled=false

# Configuração do Swagger (Espaço reservado, pode ser configurado dinamicamente via GatewayConfig)

# Configuração do Actuator
# Inclui endpoints do Actuator para monitoramento de saúde e informações.
management.endpoints.web.exposure.include=health,info
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true
 
# application.properties

# Nome da sua aplicação Gateway 

# Configuração das rotas do Gateway
# spring.cloud.gateway.routes[0].id=clientes-route
# spring.cloud.gateway.routes[0].uri=lb://legalconnect-usuario-service
# spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/clientes/**


# # Filtros específicos para a rota 'clientes-route'
# # Exemplo de filtro: remove os 2 primeiros segmentos do path
# spring.cloud.gateway.routes[0].filters[0]=StripPrefix=2
# # Exemplo de filtro personalizado (se você tiver um filtro Java chamado MyCustomFilterGatewayFilterFactory)
# spring.cloud.gateway.routes[0].filters[1]=MyCustomFilter
# # Exemplo de filtro que adiciona um cabeçalho à requisição 

# Filtros padrão que se aplicam a todas as rotas

spring.cloud.gateway.routes[1].id=auth-service-route
spring.cloud.gateway.routes[1].uri=lb://auth-service
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/auth/**
# spring.cloud.gateway.routes[1].filters[0]=AuthFilter

spring.cloud.gateway.routes[0].id=clientes-route
spring.cloud.gateway.routes[0].uri=lb://legalconnect-usuario-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/usuarios/**
spring.cloud.gateway.routes[0].filters[0]=AuthFilter
spring.cloud.gateway.global-filters[0].DedupeResponseHeader.strategy=RETAIN_LAST

spring.cloud.gateway.routes[2].id=advogados-route
spring.cloud.gateway.routes[2].uri=lb://legalconnect-advogados
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/advogados/**
spring.cloud.gateway.routes[2].filters[0]=AuthFilter
spring.cloud.gateway.global-filters[2].DedupeResponseHeader.strategy=RETAIN_LAST
# Chave secreta JWT
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Rotas públicas
application.security.public-paths=/auth/**,/swagger-ui/**,/v3/api-docs/**,/api/usuarios/swagger-ui.html,/api/usuarios/webjars/**,/api/usuarios/v3/api-docs/**

# Configurações específicas para a rota de clientes
application.security.routes.clientes.required-role=CLIENT
application.security.routes.clientes.required-scopes=client.read,client.write
# Desabilite o tratamento de erro padrão do Spring
# Desabilite o tratamento de erro padrão do Spring
spring.webflux.auto-configure-error=false
```
```java
Êþº¾   =   :br/com/legalconnect/gateway/LegalconnectGatewayApplication  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this <Lbr/com/legalconnect/gateway/LegalconnectGatewayApplication; main ([Ljava/lang/String;)V
    *org/springframework/boot/SpringApplication   run b(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext; args [Ljava/lang/String; MethodParameters 
SourceFile #LegalconnectGatewayApplication.java RuntimeVisibleAnnotations >Lorg/springframework/boot/autoconfigure/SpringBootApplication; BLorg/springframework/cloud/client/discovery/EnableDiscoveryClient; !               /     *· ±    
       	          
   	       6     *¸ W±    
   
      
                             
       
```
```java
Êþº¾   = 6  7br/com/legalconnect/gateway/config/enums/StatusResponse  java/lang/Enum SUCESSO 9Lbr/com/legalconnect/gateway/config/enums/StatusResponse; ERRO AVISO ENUM$VALUES :[Lbr/com/legalconnect/gateway/config/enums/StatusResponse; <clinit> ()V Code 
     <init> (Ljava/lang/String;I)V	     	     	    	   	 
 LineNumberTable LocalVariableTable
   this 
$enum$name 
$enum$ordinal MethodParameters values <()[Lbr/com/legalconnect/gateway/config/enums/StatusResponse;
 ' ) ( java/lang/System * + 	arraycopy *(Ljava/lang/Object;ILjava/lang/Object;II)V valueOf M(Ljava/lang/String;)Lbr/com/legalconnect/gateway/config/enums/StatusResponse;
  / , 0 5(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; name 
SourceFile StatusResponse.java 	Signature KLjava/lang/Enum<Lbr/com/legalconnect/gateway/config/enums/StatusResponse;>;@1     @    @    @     	 
        
   m      A» Y· ³ » Y· ³ » Y· ³ ½ Y² SY² SY² S³ ±            
    '            
   1     *+· ±                         #   	 !  "  	 $ %  
   6     ² YK*¾Y<½ YM¸ &,°                  	 , -  
   *     
*¸ .À °                  #    1   2    3 4    5
```
```java
Êþº¾   = \  Mbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder  java/lang/Object status 9Lbr/com/legalconnect/gateway/config/enums/StatusResponse; RuntimeInvisibleAnnotations Llombok/Generated; message Ljava/lang/String; 	timestamp Ljava/time/LocalDateTime; data Ljava/lang/Object; 	Signature TT; errors Ljava/util/List; $Ljava/util/List<Ljava/lang/String;>; <init> ()V Code
     LineNumberTable LocalVariableTable this OLbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; LocalVariableTypeTable TLbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>; (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>;	  "   MethodParameters c(Ljava/lang/String;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; h(Ljava/lang/String;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>;	  ' 	 
 j(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; o(Ljava/time/LocalDateTime;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>;	  +   c(Ljava/lang/Object;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; Y(TT;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>;	  / 
  a(Ljava/util/List;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; z(Ljava/util/List<Ljava/lang/String;>;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>;	  3   build =()Lbr/com/legalconnect/gateway/config/exception/BaseResponse; B()Lbr/com/legalconnect/gateway/config/exception/BaseResponse<TT;>; 8 9br/com/legalconnect/gateway/config/exception/BaseResponse
 7 :  ; (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;Ljava/lang/Object;Ljava/util/List;)V toString ()Ljava/lang/String;
 ? A @ java/lang/String B C valueOf &(Ljava/lang/Object;)Ljava/lang/String;   E F G makeConcatWithConstants n(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 
SourceFile BaseResponse.java (<T:Ljava/lang/Object;>Ljava/lang/Object; BootstrapMethods
 M O N $java/lang/invoke/StringConcatFactory F P (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite; L S TBaseResponse.BaseResponseBuilder(status=, message=, timestamp=, data=, errors=) InnerClasses BaseResponseBuilder W %java/lang/invoke/MethodHandles$Lookup Y java/lang/invoke/MethodHandles Lookup NestHost !                   	 
                       
                                                  A     *· ±                                                         M     *+µ !*°                                          #       	 $      %            M     *+µ &*°                           	 
              #    	    (      )            M     *+µ **°                                          #       
 ,      -            W     *+µ .*°                           
                  
   #    
    0      1            W     *+µ 2*°                                                #       4 5      6            X     » 7Y*´ !*´ &*´ **´ .*´ 2· 9°                                     < =             b     &*´ !¸ >*´ &*´ *¸ >*´ .¸ >*´ 2¸ >º D  °                   &            &      H    I     J         K     Q  R T      7 U 	 V X Z  [    7
```
```java
Êþº¾   =   9br/com/legalconnect/gateway/config/exception/BaseResponse  java/lang/Object status 9Lbr/com/legalconnect/gateway/config/enums/StatusResponse; message Ljava/lang/String; 	timestamp Ljava/time/LocalDateTime; data Ljava/lang/Object; 	Signature TT; errors Ljava/util/List; $Ljava/util/List<Ljava/lang/String;>; builder Q()Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder; l<T:Ljava/lang/Object;>()Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder<TT;>; RuntimeInvisibleAnnotations Llombok/Generated; Code  Mbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder
     <init> ()V LineNumberTable LocalVariableTable 	getStatus ;()Lbr/com/legalconnect/gateway/config/enums/StatusResponse;	  #   this ;Lbr/com/legalconnect/gateway/config/exception/BaseResponse; LocalVariableTypeTable @Lbr/com/legalconnect/gateway/config/exception/BaseResponse<TT;>; 
getMessage ()Ljava/lang/String;	  +   getTimestamp ()Ljava/time/LocalDateTime;	  / 	 
 getData ()Ljava/lang/Object; ()TT;	  4   	getErrors ()Ljava/util/List; &()Ljava/util/List<Ljava/lang/String;>;	  9   	setStatus <(Lbr/com/legalconnect/gateway/config/enums/StatusResponse;)V MethodParameters 
setMessage (Ljava/lang/String;)V setTimestamp (Ljava/time/LocalDateTime;)V setData (Ljava/lang/Object;)V (TT;)V 	setErrors (Ljava/util/List;)V '(Ljava/util/List<Ljava/lang/String;>;)V equals (Ljava/lang/Object;)Z
  J K H canEqual
  M   !
  O G H
  Q ( )
  S , -
  U 0 1
  W 5 6 o other this$status other$status this$message 
other$message this$timestamp other$timestamp 	this$data 
other$data this$errors other$errors >Lbr/com/legalconnect/gateway/config/exception/BaseResponse<*>; 
StackMapTable hashCode ()I
  i f g PRIME I result $status $message 
$timestamp $data $errors toString
 t v u java/lang/String w x valueOf &(Ljava/lang/Object;)Ljava/lang/String;   z { | makeConcatWithConstants n(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;
   (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;Ljava/lang/Object;Ljava/util/List;)V (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;Ljava/lang/String;Ljava/time/LocalDateTime;TT;Ljava/util/List<Ljava/lang/String;>;)V 
SourceFile BaseResponse.java (<T:Ljava/lang/Object;>Ljava/lang/Object; RuntimeVisibleAnnotations .Lcom/fasterxml/jackson/annotation/JsonInclude; value 6Lcom/fasterxml/jackson/annotation/JsonInclude$Include; NON_NULL BootstrapMethods
    $java/lang/invoke/StringConcatFactory {  (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/invoke/CallSite;   @BaseResponse(status=, message=, timestamp=, data=, errors=) InnerClasses BaseResponseBuilder  4com/fasterxml/jackson/annotation/JsonInclude$Include  ,com/fasterxml/jackson/annotation/JsonInclude Include  %java/lang/invoke/MethodHandles$Lookup  java/lang/invoke/MethodHandles Lookup NestMembers !                 	 
       
         
      	    
                (      » Y· °                     !             A     *´ "°                    $ %   &        $ '    ( )             A     *´ *°                    $ %   &        $ '    , -             A     *´ .°                    $ %   &        $ '    0 1  
    2            A     *´ 3°                    $ %   &        $ '    5 6  
    7            A     *´ 8°                    $ %   &        $ '    : ;             L     *+µ "±                    $ %         &        $ '   <       = >             L     *+µ *±                    $ %         &        $ '   <       ? @             L     *+µ .±                    $ %      	 
  &        $ '   <    	   A B  
    C            V     *+µ 3±                    $ %         &        $ '         <       D E  
    F            V     *+µ 8±                    $ %         &        $ '         <       G H            Ü  
   ×+*¦ ¬+Á  ¬+À M,*¶ I ¬*¶ LN,¶ L:-Ç Æ § -¶ N ¬*¶ P:,¶ P:Ç Æ § 
¶ N ¬*¶ R:,¶ R:Ç Æ § 
¶ N ¬*¶ T:	,¶ T:
	Ç 
Æ § 
	
¶ N ¬*¶ V:,¶ V:Ç Æ § 
¶ N ¬¬                
   × $ %     × X    Â Y %  $ ³ Z   * ­ [   G  \   M  ]   l k ^   r e _    F `  	  @ a  
 ¶ ! b   ¼  c   &       × $ '    Â Y d  e   A ü  ý   ý   	ý   	ý   	ý   	 <    X   K H             K     +Á ¬                    $ %      Y   &        $ '   <    Y   f g            ö     ;<=*¶ LN;h-Ç +§ -¶ h`=*¶ P:;hÇ +§ ¶ h`=*¶ R:;hÇ +§ ¶ h`=*¶ T:;hÇ +§ ¶ h`=*¶ V:;hÇ +§ ¶ h`=¬               R     $ %     j k    l k  
  m   # h n   > M o   Y 2 p   t  q   &        $ '   e   ã 
ÿ     ÿ     ÿ      ÿ      ÿ       ÿ       ÿ        ÿ        ÿ         ÿ           r )             b     &*¶ L¸ s*¶ P*¶ R¸ s*¶ T¸ s*¶ V¸ sº y  °                   & $ %   &       & $ '                  A     *· }±                    $ %   &        $ '     ~  
                ¢      *· }*+µ "*,µ **-µ .*µ 3*µ 8±               >      $ %                     	 
                &          $ '                 <        	            
        
    e                   	   @          
```
```java
Êþº¾   = ?  >br/com/legalconnect/gateway/config/exception/BusinessException  java/lang/RuntimeException 	errorCode 8Lbr/com/legalconnect/gateway/config/exception/ErrorCode; args [Ljava/lang/String; 
httpStatus %Lorg/springframework/http/HttpStatus; <init> r(Lbr/com/legalconnect/gateway/config/exception/ErrorCode;Lorg/springframework/http/HttpStatus;Ljava/lang/String;)V Code
     (Ljava/lang/String;)V	      java/lang/String
    6br/com/legalconnect/gateway/config/exception/ErrorCode   
getMessage ()Ljava/lang/String;	    	   	 
 LineNumberTable LocalVariableTable this @Lbr/com/legalconnect/gateway/config/exception/BusinessException; Ljava/lang/String; MethodParameters N(Lbr/com/legalconnect/gateway/config/exception/ErrorCode;[Ljava/lang/String;)V	 ' ) ( #org/springframework/http/HttpStatus * 
 BAD_REQUEST
  ,  - s(Lbr/com/legalconnect/gateway/config/exception/ErrorCode;Lorg/springframework/http/HttpStatus;[Ljava/lang/String;)V
  / 0 1 getFormattedMessage '([Ljava/lang/Object;)Ljava/lang/String; getCode
  4 2  getErrorCode :()Lbr/com/legalconnect/gateway/config/exception/ErrorCode; RuntimeInvisibleAnnotations Llombok/Generated; getArgs ()[Ljava/lang/String; 
getHttpStatus '()Lorg/springframework/http/HttpStatus; 
SourceFile BusinessException.java !                 	 
        
   {     #*-· *+µ *½ Y-SY+¶ Sµ *,µ ±              
    "      *    # ! "     #      # 	 
    #  #  $   
    	        %  
   L     
*+² &,· +±       
    & 	 '          
 ! "     
      
    $   	         -  
   q     *+-¶ .· *+µ *-µ *,µ ±           2 	 4  5  6  8     *     ! "            	 
        $   
    	          
   6     *´ *´ ¶ .°           @          ! "    2   
   2     *´ ¶ 3°           H          ! "    5 6  7     8   
   /     *´ °                     ! "    9 :  7     8   
   /     *´ °                     ! "    ; <  7     8   
   /     *´ °                     ! "    =    >
```
```java
Êþº¾   =J  6br/com/legalconnect/gateway/config/exception/ErrorCode  java/lang/Enum DADOS_INVALIDOS 8Lbr/com/legalconnect/gateway/config/exception/ErrorCode; REQUISICAO_MAL_FORMADA PARAMETRO_AUSENTE ENTIDADE_NAO_ENCONTRADA EMPRESA_NAO_ENCONTRADA PROFISSIONAL_NAO_ENCONTRADO CLIENTE_NAO_ENCONTRADO ADMINISTRADOR_NAO_ENCONTRADO PLANO_NAO_ENCONTRADO USER_NAO_ENCONTRADO CNPJ_DUPLICADO 
CPF_DUPLICADO 
OAB_DUPLICADA EMAIL_DUPLICADO NOME_PLANO_DUPLICADO INTEGRIDADE_VIOLADA RECURSO_EM_USO ERRO_INTERNO_SERVIDOR SERVICO_INDISPONIVEL 
GENERIC_ERROR 
INVALID_INPUT RESOURCE_NOT_FOUND UNAUTHORIZED_ACCESS FORBIDDEN_ACCESS SERVICE_UNAVAILABLE TOO_MANY_REQUESTS VALIDATION_ERROR DATABASE_ERROR INTEGRATION_ERROR INVALID_CREDENTIALS ACCOUNT_LOCKED ACCOUNT_DISABLED 
TOKEN_EXPIRED 
INVALID_TOKEN REFRESH_TOKEN_EXPIRED INVALID_REFRESH_TOKEN USER_NOT_FOUND EMAIL_ALREADY_REGISTERED PASSWORD_RESET_FAILED INVALID_CURRENT_PASSWORD PASSWORD_RESET_TOKEN_INVALID PASSWORD_RESET_TOKEN_EXPIRED PASSWORD_RESET_TOKEN_USED PASSWORD_RESET_TOKEN_EXCEEDED TENANT_NOT_FOUND TENANT_DISABLED SUBSCRIPTION_EXPIRED PLAN_NOT_ACTIVE SERVICE_LIMIT_EXCEEDED ADVOCATE_NOT_AVAILABLE APPOINTMENT_CONFLICT PAYMENT_FAILED INVALID_PROMO_CODE DOCUMENT_UPLOAD_FAILED INVALID_DOCUMENT_FORMAT FIELD_REQUIRED INVALID_FORMAT 
MIN_LENGTH 
MAX_LENGTH 
INVALID_EMAIL INVALID_CPF INVALID_CNPJ PASSWORD_TOO_WEAK DATE_IN_PAST INVALID_ENUM_VALUE code Ljava/lang/String; message ENUM$VALUES 9[Lbr/com/legalconnect/gateway/config/exception/ErrorCode; <clinit> ()V Code  Q 001 S !Dados fornecidos sÃ£o invÃ¡lidos.
  U V W <init> :(Ljava/lang/String;ILjava/lang/String;Ljava/lang/String;)V	  Y    \ 002 ^ !A requisiÃ§Ã£o estÃ¡ mal formada.	  `    c 003 e  ParÃ¢metro obrigatÃ³rio ausente.	  g   	 j 100 l Entidade nÃ£o encontrada.	  n 	  
 q 101 s Empresa nÃ£o encontrada.	  u 
   x 102 z Profissional nÃ£o encontrado.	  |     103  Cliente nÃ£o encontrado.	     
  104  Administrador nÃ£o encontrado.	   
    105  Plano nÃ£o encontrado.	       106  #UsuÃ¡rio associado nÃ£o encontrado.	       200  CNPJ jÃ¡ cadastrado.	      ¢ 201 ¤ CPF jÃ¡ cadastrado.	  ¦    © 202 « NÃºmero da OAB jÃ¡ cadastrado.	  ­    ° 203 ² Email jÃ¡ cadastrado.	  ´    · 204 ¹ Nome do plano jÃ¡ cadastrado.	  »    ¾ 300 À #ViolaÃ§Ã£o de integridade de dados.	  Â    Å 301 Ç 2Recurso nÃ£o pode ser excluÃ­do pois estÃ¡ em uso.	  É    Ì 500 Î $Ocorreu um erro interno no servidor.	  Ð    Ó 503 Õ 'ServiÃ§o temporariamente indisponÃ­vel.	  ×    Ú 1000 Ü BOcorreu um erro inesperado. Por favor, tente novamente mais tarde.	  Þ    á 1001 ã Dados de entrada invÃ¡lidos.	  å    è 1002 ê Recurso nÃ£o encontrado.	  ì    ï 1003 ñ ;Acesso nÃ£o autorizado. Credenciais invÃ¡lidas ou ausentes.	  ó    ö 1004 ø CAcesso negado. VocÃª nÃ£o tem permissÃ£o para realizar esta aÃ§Ã£o.	  ú    ý 1005 ÿ KO serviÃ§o estÃ¡ temporariamente indisponÃ­vel. Tente novamente mais tarde.	     1006 ;Muitas requisiÃ§Ãµes. Por favor, aguarde e tente novamente.	      1007
 )Erro de validaÃ§Ã£o nos dados fornecidos.	     ! 1008 !Erro ao acessar o banco de dados.	  !  " 1009 *Erro de integraÃ§Ã£o com serviÃ§o externo.	  "  #  2000" )Credenciais de autenticaÃ§Ã£o invÃ¡lidas.	 $ #  $' 2001) Sua conta estÃ¡ bloqueada.	 + $  %. 20020 Sua conta estÃ¡ desativada.	 2 %  &5 20037 O token de acesso expirou.	 9 &  '< 2004> O token de acesso Ã© invÃ¡lido.	 @ '  (C 2005E /O refresh token expirou. FaÃ§a login novamente.	 G (  )J 2006L O refresh token Ã© invÃ¡lido.	 N )  *Q 2007S UsuÃ¡rio nÃ£o encontrado.	 U *  +X 2008Z !Este e-mail jÃ¡ estÃ¡ cadastrado.	 \ +  ,_ 2009a Falha ao redefinir a senha.	 c ,  -f 2010h (A senha atual fornecida estÃ¡ incorreta.	 j -  .m 2011o *Token de redefiniÃ§Ã£o de senha invÃ¡lido.	 q .  /t 2012v )Token de redefiniÃ§Ã£o de senha expirado.	 x /  0{ 2013} .Token de redefiniÃ§Ã£o de senha jÃ¡ utilizado.	  0  1 2014 +Limite de redefiniÃ§Ãµes de senha excedido.	  1  2 3000 Tenant nÃ£o encontrado.	  2  3 3001 O tenant estÃ¡ desativado.	  3  4 3002 Sua assinatura expirou.	  4  5 3003  %O plano selecionado nÃ£o estÃ¡ ativo.	 ¢ 5  6¥ 3004§ :Limite de serviÃ§os agendÃ¡veis excedido para o seu plano.	 © 6  7¬ 3005® 2Advogado nÃ£o disponÃ­vel no horÃ¡rio selecionado.	 ° 7  8³ 3006µ 6Conflito de agendamento. O horÃ¡rio jÃ¡ estÃ¡ ocupado.	 · 8  9º 3007¼ $Falha no processamento do pagamento.	 ¾ 9  :Á 3008Ã *CÃ³digo promocional invÃ¡lido ou expirado.	 Å :  ;È 3009Ê #Falha ao fazer upload do documento.	 Ì ;  <Ï 3010Ñ Formato de documento invÃ¡lido.	 Ó <  =Ö 4000Ø O campo '%s' Ã© obrigatÃ³rio.	 Ú =  >Ý 4001ß &O campo '%s' possui formato invÃ¡lido.	 á >  ?ä 4002æ /O campo '%s' deve ter no mÃ­nimo %d caracteres.	 è ?  @ë 4003í /O campo '%s' deve ter no mÃ¡ximo %d caracteres.	 ï @  Aò 4004ô  O e-mail fornecido Ã© invÃ¡lido.	 ö A  Bù 4005û O CPF fornecido Ã© invÃ¡lido.	 ý B  C  4006 O CNPJ fornecido Ã© invÃ¡lido.	  C  D 4007	 A senha Ã© muito fraca.	  D  E 4008  A data nÃ£o pode ser no passado.	  E  F 4009 "Valor invÃ¡lido para o campo '%s'.	  F 	  J K LineNumberTable LocalVariableTable
  V  (Ljava/lang/String;I)V	 " G H	 $ I H this 
$enum$name 
$enum$ordinal MethodParameters getFormattedMessage '([Ljava/lang/Object;)Ljava/lang/String;
,.- java/lang/String/0 format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; args [Ljava/lang/Object; getCode ()Ljava/lang/String; RuntimeInvisibleAnnotations Llombok/Generated; 
getMessage values ;()[Lbr/com/legalconnect/gateway/config/exception/ErrorCode;
;=< java/lang/System>? 	arraycopy *(Ljava/lang/Object;ILjava/lang/Object;II)V valueOf L(Ljava/lang/String;)Lbr/com/legalconnect/gateway/config/exception/ErrorCode;
 C@D 5(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Enum; name 
SourceFile ErrorCode.java 	Signature JLjava/lang/Enum<Lbr/com/legalconnect/gateway/config/exception/ErrorCode;>;@1     D@    @    @    @ 	   @ 
   @    @    @ 
   @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @    @     @ !   @ "   @ #   @ $   @ %   @ &   @ '   @ (   @ )   @ *   @ +   @ ,   @ -   @ .   @ /   @ 0   @ 1   @ 2   @ 3   @ 4   @ 5   @ 6   @ 7   @ 8   @ 9   @ :   @ ;   @ <   @ =   @ >   @ ?   @ @   @ A   @ B   @ C   @ D   @ E   @ F     G H    I H   J K     L M  N       Î» YOPR· T³ X» YZ[]· T³ _» Yabd· T³ f» Yhik· T³ m» Yopr· T³ t» Yvwy· T³ {» Y}~· T³ » Y· T³ » Y· T³ » Y	· T³ » Y
· T³ » Y ¡£· T³ ¥» Y§¨ª· T³ ¬» Y®
¯±· T³ ³» Yµ¶¸· T³ º» Y¼½¿· T³ Á» YÃÄÆ· T³ È» YÊËÍ· T³ Ï» YÑÒÔ· T³ Ö» YØÙÛ· T³ Ý» Yßàâ· T³ ä» Yæçé· T³ ë» Yíîð· T³ ò» Yôõ÷· T³ ù» Yûüþ· T³ » Y· T³» Y	
· T³» Y· T³» Y· T³» Y!· T³#» Y%&(· T³*» Y,-/· T³1» Y3 46· T³8» Y:!;=· T³?» YA"BD· T³F» YH#IK· T³M» YO$PR· T³T» YV%WY· T³[» Y]&^`· T³b» Yd'eg· T³i» Yk(ln· T³p» Yr)su· T³w» Yy*z|· T³~» Y+· T³» Y,· T³» Y-· T³» Y.· T³» Y/· T³¡» Y£0¤¦· T³¨» Yª1«­· T³¯» Y±2²´· T³¶» Y¸3¹»· T³½» Y¿4ÀÂ· T³Ä» YÆ5ÇÉ· T³Ë» YÍ6ÎÐ· T³Ò» YÔ7Õ×· T³Ù» YÛ8ÜÞ· T³à» Yâ9ãå· T³ç» Yé:êì· T³î» Yð;ñó· T³õ» Y÷<øú· T³ü» Yþ=ÿ· T³» Y>· T³
» Y?
· T³» Y@· T³A½ Y² XSY² _SY² fSY² mSY² tSY² {SY² SY² SY² SY	² SY
² SY² ¥SY² ¬SY
² ³SY² ºSY² ÁSY² ÈSY² ÏSY² ÖSY² ÝSY² äSY² ëSY² òSY² ùSY² SY²SY²SY²SY²SY²#SY²*SY²1SY ²8SY!²?SY"²FSY#²MSY$²TSY%²[SY&²bSY'²iSY(²pSY)²wSY*²~SY+²SY,²SY-²SY.²SY/²¡SY0²¨SY1²¯SY2²¶SY3²½SY4²ÄSY5²ËSY6²ÒSY7²ÙSY8²àSY9²çSY:²îSY;²õSY<²üSY=²SY>²
SY?²SY@²S³±     * J        "  3  :  D  U  f  x      ®  ¶  À   Ò ! ä " ö # % & ', )4 *> +P -X .b /t 0 1 2ª 3¼ 4Ñ 5æ 6û 7 9 :% ;: <O =d >y ? @£ A¸ BÍ Câ D÷ E F! G6 HK K` Lu M N O´ PÉ QÞ Ró S T U2 W; YG Z\ [q \ ] ^° _Å `Ú aï b        V W  N   \     *+·*-µ!*µ#±          m  n  o  p        %       G H     I H (   & '  G   I   )*  N   =     	*´#+¸+°          x       	%      	12 (   1   34 5    6   N   /     *´!°                 %    74 5    6   N   /     *´#°                 %    	89  N   6     ²YK*¾Y<½ YM¸:,°                	@A  N   *     
*¸BÀ °               (   E  F   GH   I
```
```java
Êþº¾   = W  Cbr/com/legalconnect/gateway/config/exception/GlobalExceptionHandler  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this ELbr/com/legalconnect/gateway/config/exception/GlobalExceptionHandler; handleBusinessException (Lbr/com/legalconnect/gateway/config/exception/BusinessException;Lorg/springframework/web/server/ServerWebExchange;)Lreactor/core/publisher/Mono; 	Signature ù(Lbr/com/legalconnect/gateway/config/exception/BusinessException;Lorg/springframework/web/server/ServerWebExchange;)Lreactor/core/publisher/Mono<Lorg/springframework/http/ResponseEntity<Lbr/com/legalconnect/gateway/config/exception/BaseResponse;>;>; RuntimeVisibleAnnotations :Lorg/springframework/web/bind/annotation/ExceptionHandler; value @Lbr/com/legalconnect/gateway/config/exception/BusinessException;
    9br/com/legalconnect/gateway/config/exception/BaseResponse   builder Q()Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder;	    7br/com/legalconnect/gateway/config/enums/StatusResponse   ! ERRO 9Lbr/com/legalconnect/gateway/config/enums/StatusResponse;
 # % $ Mbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder & ' status (Lbr/com/legalconnect/gateway/config/enums/StatusResponse;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder;
 ) + * >br/com/legalconnect/gateway/config/exception/BusinessException , - 
getMessage ()Ljava/lang/String;
 # / 0 1 message c(Ljava/lang/String;)Lbr/com/legalconnect/gateway/config/exception/BaseResponse$BaseResponseBuilder;
 # 3 4 5 build =()Lbr/com/legalconnect/gateway/config/exception/BaseResponse;
 ) 7 8 9 
getHttpStatus '()Lorg/springframework/http/HttpStatus;
 ; = < 'org/springframework/http/ResponseEntity & > `(Lorg/springframework/http/HttpStatusCode;)Lorg/springframework/http/ResponseEntity$BodyBuilder; @ B A 3org/springframework/http/ResponseEntity$BodyBuilder C D body =(Ljava/lang/Object;)Lorg/springframework/http/ResponseEntity;
 F H G reactor/core/publisher/Mono I J just 1(Ljava/lang/Object;)Lreactor/core/publisher/Mono; ex exchange 2Lorg/springframework/web/server/ServerWebExchange; response ;Lbr/com/legalconnect/gateway/config/exception/BaseResponse; MethodParameters 
SourceFile GlobalExceptionHandler.java >Lorg/springframework/web/bind/annotation/RestControllerAdvice; InnerClasses BaseResponseBuilder BodyBuilder !               /     *· ±    
                 
                   [ c          %¸ ² ¶ "+¶ (¶ .¶ 2N+¶ 6¸ :-¹ ? ¸ E°    
   "       	          !     *    %  
     % K     % L M    N O  P   	 K   L    Q    R      S   T     #  U 	 @ ; V	
```
```java
Êþº¾   =   2br/com/legalconnect/gateway/util/AuthFilter$Config  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this 4Lbr/com/legalconnect/gateway/util/AuthFilter$Config; 
SourceFile AuthFilter.java InnerClasses  +br/com/legalconnect/gateway/util/AuthFilter Config NestHost !               /     *· ±    
       Y          
            
     	     
```
```java
Êþº¾   =O  +br/com/legalconnect/gateway/util/AuthFilter  Morg/springframework/cloud/gateway/filter/factory/AbstractGatewayFilterFactory log Lorg/slf4j/Logger; RuntimeInvisibleAnnotations Llombok/Generated; 	secretKey Ljava/lang/String; RuntimeVisibleAnnotations 4Lorg/springframework/beans/factory/annotation/Value; value &${application.security.jwt.secret-key} <clinit> ()V Code
    org/slf4j/LoggerFactory   	getLogger %(Ljava/lang/Class;)Lorg/slf4j/Logger;	     LineNumberTable LocalVariableTable <init>  2br/com/legalconnect/gateway/util/AuthFilter$Config
     ! (Ljava/lang/Class;)V this -Lbr/com/legalconnect/gateway/util/AuthFilter; apply n(Lbr/com/legalconnect/gateway/util/AuthFilter$Config;)Lorg/springframework/cloud/gateway/filter/GatewayFilter;   ' ( ) filter g(Lbr/com/legalconnect/gateway/util/AuthFilter;)Lorg/springframework/cloud/gateway/filter/GatewayFilter; config 4Lbr/com/legalconnect/gateway/util/AuthFilter$Config; MethodParameters extractAllClaims ,(Ljava/lang/String;)Lio/jsonwebtoken/Claims;	  0 	 
	 2 4 3 !java/nio/charset/StandardCharsets 5 6 UTF_8 Ljava/nio/charset/Charset;
 8 : 9 java/lang/String ; < getBytes (Ljava/nio/charset/Charset;)[B
 > @ ? io/jsonwebtoken/security/Keys A B 
hmacShaKeyFor ([B)Ljavax/crypto/SecretKey;
 D F E io/jsonwebtoken/Jwts G H parser $()Lio/jsonwebtoken/JwtParserBuilder; J L K  io/jsonwebtoken/JwtParserBuilder M N 
verifyWith <(Ljavax/crypto/SecretKey;)Lio/jsonwebtoken/JwtParserBuilder; J P Q R build ()Lio/jsonwebtoken/JwtParser; T V U io/jsonwebtoken/JwtParser W X parseSignedClaims /(Ljava/lang/CharSequence;)Lio/jsonwebtoken/Jws; Z \ [ io/jsonwebtoken/Jws ] ^ 
getPayload ()Ljava/lang/Object; ` io/jsonwebtoken/Claims token key Ljavax/crypto/SecretKey; isTokenExpired (Ljava/lang/String;)Z
  g h i extractExpiration $(Ljava/lang/String;)Ljava/util/Date; k java/util/Date
 j m  
 j o p q before (Ljava/util/Date;)Z s Token expirado em: {} u w v org/slf4j/Logger x y debug '(Ljava/lang/String;Ljava/lang/Object;)V 
expiration Ljava/util/Date; expired Z 
StackMapTable   $  ()Ljava/util/function/Function;
     extractClaim C(Ljava/lang/String;Ljava/util/function/Function;)Ljava/lang/Object; extractUsername &(Ljava/lang/String;)Ljava/lang/String;    %Erro ao extrair username do token: {}
    java/lang/Exception   
getMessage ()Ljava/lang/String; u   y warn e Ljava/lang/Exception; 	Signature g<T:Ljava/lang/Object;>(Ljava/lang/String;Ljava/util/function/Function<Lio/jsonwebtoken/Claims;TT;>;)TT;
   - .    java/util/function/Function $  &(Ljava/lang/Object;)Ljava/lang/Object; claimsResolver Ljava/util/function/Function; claims Lio/jsonwebtoken/Claims; LocalVariableTypeTable :Ljava/util/function/Function<Lio/jsonwebtoken/Claims;TT;>; L(Ljava/lang/Object;)Lorg/springframework/cloud/gateway/filter/GatewayFilter;
  § $ % lambda$0 (Lorg/springframework/web/server/ServerWebExchange;Lorg/springframework/cloud/gateway/filter/GatewayFilterChain;)Lreactor/core/publisher/Mono; « ­ ¬ 0org/springframework/web/server/ServerWebExchange ® ¯ 
getRequest >()Lorg/springframework/http/server/reactive/ServerHttpRequest; ± ³ ² :org/springframework/http/server/reactive/ServerHttpRequest ´ µ 
getHeaders (()Lorg/springframework/http/HttpHeaders; · $org/springframework/http/HttpHeaders ¹ 
Authorization
 ¶ » ¼  getFirst ¾ Bearer 
 8 À Á e 
startsWith Ã >br/com/legalconnect/gateway/config/exception/BusinessException	 Å Ç Æ 6br/com/legalconnect/gateway/config/exception/ErrorCode È É USER_NOT_FOUND 8Lbr/com/legalconnect/gateway/config/exception/ErrorCode; Ë Token nÃ£o encontrado
 Â Í  Î N(Lbr/com/legalconnect/gateway/config/exception/ErrorCode;[Ljava/lang/String;)V
 8 Ð Ñ Ò 	substring (I)Ljava/lang/String;
 8 Ô Õ Ö isBlank ()Z
  Ø d e	 Å Ú Û É 
TOKEN_EXPIRED Ý Token expirado ß X-Correlation-ID _ á â ã get 7(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object; å X-Tenant-ID ç )X-Correlation-ID nÃ£o encontrado no token	 Å é ê É TENANT_NOT_FOUND ì !tenantId nÃ£o encontrado no token « î ï ð mutate <()Lorg/springframework/web/server/ServerWebExchange$Builder;  ò ó ô accept C(Ljava/lang/String;Ljava/lang/String;)Ljava/util/function/Consumer; ö ø ÷ 8org/springframework/web/server/ServerWebExchange$Builder ù ú request Y(Ljava/util/function/Consumer;)Lorg/springframework/web/server/ServerWebExchange$Builder; ö ü Q ý 4()Lorg/springframework/web/server/ServerWebExchange; ÿ  ;org/springframework/cloud/gateway/filter/GatewayFilterChain ( Q(Lorg/springframework/web/server/ServerWebExchange;)Lreactor/core/publisher/Mono; Erro ao processar token JWT: {} u y error	 Å	
 É 
INVALID_TOKEN Token invÃ¡lido ou malformado exchange 2Lorg/springframework/web/server/ServerWebExchange; chain =Lorg/springframework/cloud/gateway/filter/GatewayFilterChain; 
authHeader 
correlationId tenantId mutated lambda$1 k(Ljava/lang/String;Ljava/lang/String;Lorg/springframework/http/server/reactive/ServerHttpRequest$Builder;)V Borg/springframework/http/server/reactive/ServerHttpRequest$Builder header k(Ljava/lang/String;[Ljava/lang/String;)Lorg/springframework/http/server/reactive/ServerHttpRequest$Builder; builder DLorg/springframework/http/server/reactive/ServerHttpRequest$Builder; 
SourceFile AuthFilter.java Lorg/springframework/cloud/gateway/filter/factory/AbstractGatewayFilterFactory<Lbr/com/legalconnect/gateway/util/AuthFilter$Config;>; *Lorg/springframework/stereotype/Component; BootstrapMethods
%'& "java/lang/invoke/LambdaMetafactory() metafactory Ì(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;$ ©
 - ¨ ©, ©  _234 
getExpiration ()Ljava/util/Date;	1 *(Lio/jsonwebtoken/Claims;)Ljava/util/Date;6  _:;  
getSubject	9 ,(Lio/jsonwebtoken/Claims;)Ljava/lang/String;= (Ljava/lang/Object;)V?
 BA G(Lorg/springframework/http/server/reactive/ServerHttpRequest$Builder;)VD InnerClasses ConfigI %java/lang/invoke/MethodHandles$LookupK java/lang/invoke/MethodHandles Lookup Builder NestMembers !                   	 
         
s          )      	¸ ³ ±                         5     *· ±       
    "  $         " #    $ %     ;     *º &  °           (         " #      * +  ,    *    - .          +*´ /² 1¶ 7¸ =M¸ C,¹ I ¹ O +¹ S ¹ Y À _°           ]  ^  _  `  a " b * ^         + " #     + a 
    b c  ,    a    d e          #*+¶ fM,» jY· l¶ n> ² r,¹ t ¬           l  m  n  o ! q    *    # " #     # a 
    z {    | }  ~   	 ý ! j ,    a     h i     B     *+º   ¶ À j°           {         " #      a 
  ,    a          }     *+º   ¶ À 8°M² ,¶ ¹  °    
                           " #      a 
       ~    N  ,    a               l     *+¶ N,-¹  °       
          *     " #      a 
           ¡ ¢  £         ¤  ,   	 a     A $ ¥     )     	*+À ¶ ¦°                  ¨ ©    J  	  ++¹ ª ¹ ° ¸¶ ºN-Æ -½¶ ¿ » ÂY² Ä½ 8YÊS· Ì¿-¶ Ï:Æ ¶ Ó » ÂY² Ä½ 8YÊS· Ì¿*¶ :*¶ × » ÂY² Ù½ 8YÜS· Ì¿Þ8¹ à À 8:ä8¹ à À 8:Æ ¶ Ó » ÂY² Ä½ 8YæS· Ì¿Æ ¶ Ó » ÂY² è½ 8YëS· Ì¿+¹ í º ñ  ¹ õ ¹ û :,¹ þ °N² -¶ ¹ » ÂY²½ 8YS· Ì¿         ^    *  ,  - 2 0 : 2 G 3 [ 6 c 7 l 8  :  ;   = ­ > Á A Î B â E è F ö K û E ý M O P T    f 
  + " #    +
   +   õ 
  : Ì a 
  c £ ¡ ¢   v 
    f 
  ý 	  $    ~   5 
ü  8ü  8ü $ _ý , 8 8ÿ #   « ÿ  
     U     #,Þ½ 8Y*S¹ W,ä½ 8Y+S¹ W±           G  H " J        #          !     "  #   * * +./* 057* 8<>* @CEF   "   G 	HJL  ±M	 ö «M	N     
```
```java
br\com\legalconnect\gateway\config\exception\GlobalExceptionHandler.class
br\com\legalconnect\gateway\util\AuthFilter.class
br\com\legalconnect\gateway\config\exception\BusinessException.class
br\com\legalconnect\gateway\config\exception\BaseResponse$BaseResponseBuilder.class
br\com\legalconnect\gateway\util\AuthFilter$Config.class
br\com\legalconnect\gateway\config\exception\ErrorCode.class
br\com\legalconnect\gateway\config\exception\BaseResponse.class
br\com\legalconnect\gateway\LegalconnectGatewayApplication.class
br\com\legalconnect\gateway\config\enums\StatusResponse.class

```
```java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\config\exception\BusinessException.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\LegalconnectGatewayApplication.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\config\enums\StatusResponse.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\config\exception\BaseResponse.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\util\AuthFilter.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\config\exception\ErrorCode.java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\main\java\br\com\legalconnect\gateway\config\exception\GlobalExceptionHandler.java

```
```java
br\com\legalconnect\common\common_lib\CommonLibApplicationTests.class

```
```java
E:\legalconnect\legalconnect\microservices\legal-gaateway\src\test\java\br\com\legalconnect\common\common_lib\CommonLibApplicationTests.java

```
```java
# Created at 2025-07-26T08:38:07.418
Boot Manifest-JAR contains absolute paths in classpath 'E:\legalconnect\legalconnect\microservices\legal-gaateway\target\test-classes'
Hint: <argLine>-Djdk.net.URLClassPath.disableClassPathURLCheck=true</argLine>
'other' has different root


```
```java
-------------------------------------------------------------------------------
Test set: br.com.legalconnect.common.common_lib.CommonLibApplicationTests
-------------------------------------------------------------------------------
Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 0.387 s <<< FAILURE! -- in br.com.legalconnect.common.common_lib.CommonLibApplicationTests
br.com.legalconnect.common.common_lib.CommonLibApplicationTests -- Time elapsed: 0.387 s <<< ERROR!
java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test
	at org.springframework.util.Assert.state(Assert.java:76)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.findConfigurationClass(SpringBootTestContextBootstrapper.java:246)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:233)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:150)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:351)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:267)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:215)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:108)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:111)
	at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:142)
	at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:126)
	at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:366)
	at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:131)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)


```
```java
<?xml version="1.0" encoding="UTF-8"?>
<testsuite xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://maven.apache.org/surefire/maven-surefire-plugin/xsd/surefire-test-report-3.0.xsd" version="3.0" name="br.com.legalconnect.common.common_lib.CommonLibApplicationTests" time="0.387" tests="1" errors="1" skipped="0" failures="0">
  <properties>
    <property name="java.specification.version" value="17"/>
    <property name="sun.cpu.isalist" value="amd64"/>
    <property name="sun.jnu.encoding" value="Cp1252"/>
    <property name="java.class.path" value="E:\legalconnect\legalconnect\microservices\legal-gaateway\target\test-classes;E:\legalconnect\legalconnect\microservices\legal-gaateway\target\classes;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-gateway\4.1.5\spring-cloud-starter-gateway-4.1.5.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter\4.1.4\spring-cloud-starter-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-context\4.1.4\spring-cloud-context-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-rsa\1.1.3\spring-security-rsa-1.1.3.jar;C:\Users\marce\.m2\repository\org\bouncycastle\bcprov-jdk18on\1.78\bcprov-jdk18on-1.78.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-gateway-server\4.1.5\spring-cloud-gateway-server-4.1.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-validation\3.2.5\spring-boot-starter-validation-3.2.5.jar;C:\Users\marce\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\10.1.20\tomcat-embed-el-10.1.20.jar;C:\Users\marce\.m2\repository\org\hibernate\validator\hibernate-validator\8.0.1.Final\hibernate-validator-8.0.1.Final.jar;C:\Users\marce\.m2\repository\jakarta\validation\jakarta.validation-api\3.0.2\jakarta.validation-api-3.0.2.jar;C:\Users\marce\.m2\repository\org\jboss\logging\jboss-logging\3.5.3.Final\jboss-logging-3.5.3.Final.jar;C:\Users\marce\.m2\repository\com\fasterxml\classmate\1.6.0\classmate-1.6.0.jar;C:\Users\marce\.m2\repository\io\projectreactor\addons\reactor-extra\3.5.1\reactor-extra-3.5.1.jar;C:\Users\marce\.m2\repository\io\projectreactor\reactor-core\3.6.5\reactor-core-3.6.5.jar;C:\Users\marce\.m2\repository\org\reactivestreams\reactive-streams\1.0.4\reactive-streams-1.0.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-webflux\3.2.5\spring-boot-starter-webflux-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-json\3.2.5\spring-boot-starter-json-3.2.5.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.15.4\jackson-datatype-jdk8-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.15.4\jackson-datatype-jsr310-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.15.4\jackson-module-parameter-names-2.15.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-reactor-netty\3.2.5\spring-boot-starter-reactor-netty-3.2.5.jar;C:\Users\marce\.m2\repository\io\projectreactor\netty\reactor-netty-http\1.1.18\reactor-netty-http-1.1.18.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-http\4.1.109.Final\netty-codec-http-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-common\4.1.109.Final\netty-common-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-buffer\4.1.109.Final\netty-buffer-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport\4.1.109.Final\netty-transport-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec\4.1.109.Final\netty-codec-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-handler\4.1.109.Final\netty-handler-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-http2\4.1.109.Final\netty-codec-http2-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns\4.1.109.Final\netty-resolver-dns-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver\4.1.109.Final\netty-resolver-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-dns\4.1.109.Final\netty-codec-dns-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns-native-macos\4.1.109.Final\netty-resolver-dns-native-macos-4.1.109.Final-osx-x86_64.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns-classes-macos\4.1.109.Final\netty-resolver-dns-classes-macos-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-native-epoll\4.1.109.Final\netty-transport-native-epoll-4.1.109.Final-linux-x86_64.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-native-unix-common\4.1.109.Final\netty-transport-native-unix-common-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-classes-epoll\4.1.109.Final\netty-transport-classes-epoll-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\projectreactor\netty\reactor-netty-core\1.1.18\reactor-netty-core-1.1.18.jar;C:\Users\marce\.m2\repository\io\netty\netty-handler-proxy\4.1.109.Final\netty-handler-proxy-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-socks\4.1.109.Final\netty-codec-socks-4.1.109.Final.jar;C:\Users\marce\.m2\repository\org\springframework\spring-webflux\6.1.6\spring-webflux-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-netflix-eureka-client\4.1.3\spring-cloud-starter-netflix-eureka-client-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-netflix-eureka-client\4.1.3\spring-cloud-netflix-eureka-client-4.1.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\client5\httpclient5\5.2.3\httpclient5-5.2.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\core5\httpcore5\5.2.4\httpcore5-5.2.4.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\core5\httpcore5-h2\5.2.4\httpcore5-h2-5.2.4.jar;C:\Users\marce\.m2\repository\com\netflix\eureka\eureka-client\2.0.3\eureka-client-2.0.3.jar;C:\Users\marce\.m2\repository\com\thoughtworks\xstream\xstream\1.4.20\xstream-1.4.20.jar;C:\Users\marce\.m2\repository\io\github\x-stream\mxparser\1.2.2\mxparser-1.2.2.jar;C:\Users\marce\.m2\repository\xmlpull\xmlpull\1.1.3.1\xmlpull-1.1.3.1.jar;C:\Users\marce\.m2\repository\jakarta\ws\rs\jakarta.ws.rs-api\3.1.0\jakarta.ws.rs-api-3.1.0.jar;C:\Users\marce\.m2\repository\jakarta\inject\jakarta.inject-api\2.0.1\jakarta.inject-api-2.0.1.jar;C:\Users\marce\.m2\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;C:\Users\marce\.m2\repository\com\netflix\spectator\spectator-api\1.7.3\spectator-api-1.7.3.jar;C:\Users\marce\.m2\repository\org\slf4j\slf4j-api\2.0.13\slf4j-api-2.0.13.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\httpclient\4.5.3\httpclient-4.5.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\httpcore\4.4.16\httpcore-4.4.16.jar;C:\Users\marce\.m2\repository\commons-codec\commons-codec\1.16.1\commons-codec-1.16.1.jar;C:\Users\marce\.m2\repository\commons-configuration\commons-configuration\1.10\commons-configuration-1.10.jar;C:\Users\marce\.m2\repository\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.15.4\jackson-annotations-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.15.4\jackson-core-2.15.4.jar;C:\Users\marce\.m2\repository\com\netflix\netflix-commons\netflix-eventbus\0.3.0\netflix-eventbus-0.3.0.jar;C:\Users\marce\.m2\repository\com\netflix\netflix-commons\netflix-infix\0.3.0\netflix-infix-0.3.0.jar;C:\Users\marce\.m2\repository\commons-jxpath\commons-jxpath\1.3\commons-jxpath-1.3.jar;C:\Users\marce\.m2\repository\joda-time\joda-time\2.3\joda-time-2.3.jar;C:\Users\marce\.m2\repository\org\antlr\antlr-runtime\3.4\antlr-runtime-3.4.jar;C:\Users\marce\.m2\repository\org\antlr\stringtemplate\3.2.1\stringtemplate-3.2.1.jar;C:\Users\marce\.m2\repository\antlr\antlr\2.7.7\antlr-2.7.7.jar;C:\Users\marce\.m2\repository\com\google\code\gson\gson\2.10.1\gson-2.10.1.jar;C:\Users\marce\.m2\repository\com\netflix\servo\servo-core\0.5.3\servo-core-0.5.3.jar;C:\Users\marce\.m2\repository\org\apache\commons\commons-math\2.2\commons-math-2.2.jar;C:\Users\marce\.m2\repository\javax\annotation\javax.annotation-api\1.2\javax.annotation-api-1.2.jar;C:\Users\marce\.m2\repository\org\codehaus\jettison\jettison\1.5.4\jettison-1.5.4.jar;C:\Users\marce\.m2\repository\com\netflix\eureka\eureka-core\2.0.3\eureka-core-2.0.3.jar;C:\Users\marce\.m2\repository\com\fasterxml\woodstox\woodstox-core\6.2.1\woodstox-core-6.2.1.jar;C:\Users\marce\.m2\repository\org\codehaus\woodstox\stax2-api\4.2.1\stax2-api-4.2.1.jar;C:\Users\marce\.m2\repository\com\google\guava\guava\33.0.0-jre\guava-33.0.0-jre.jar;C:\Users\marce\.m2\repository\com\google\guava\failureaccess\1.0.2\failureaccess-1.0.2.jar;C:\Users\marce\.m2\repository\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;C:\Users\marce\.m2\repository\org\checkerframework\checker-qual\3.41.0\checker-qual-3.41.0.jar;C:\Users\marce\.m2\repository\com\google\errorprone\error_prone_annotations\2.23.0\error_prone_annotations-2.23.0.jar;C:\Users\marce\.m2\repository\com\google\j2objc\j2objc-annotations\2.8\j2objc-annotations-2.8.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-loadbalancer\4.1.4\spring-cloud-starter-loadbalancer-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-loadbalancer\4.1.4\spring-cloud-loadbalancer-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-cache\3.2.5\spring-boot-starter-cache-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\spring-context-support\6.1.6\spring-context-support-6.1.6.jar;C:\Users\marce\.m2\repository\com\stoyanr\evictor\1.0.0\evictor-1.0.0.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-webflux-ui\2.0.2\springdoc-openapi-starter-webflux-ui-2.0.2.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-webflux-api\2.0.2\springdoc-openapi-starter-webflux-api-2.0.2.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-common\2.0.2\springdoc-openapi-starter-common-2.0.2.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-core-jakarta\2.2.7\swagger-core-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\org\apache\commons\commons-lang3\3.13.0\commons-lang3-3.13.0.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-annotations-jakarta\2.2.7\swagger-annotations-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-models-jakarta\2.2.7\swagger-models-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\dataformat\jackson-dataformat-yaml\2.15.4\jackson-dataformat-yaml-2.15.4.jar;C:\Users\marce\.m2\repository\org\webjars\swagger-ui\4.15.5\swagger-ui-4.15.5.jar;C:\Users\marce\.m2\repository\org\webjars\webjars-locator-core\0.55\webjars-locator-core-0.55.jar;C:\Users\marce\.m2\repository\io\github\classgraph\classgraph\4.8.149\classgraph-4.8.149.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-api\0.12.6\jjwt-api-0.12.6.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-impl\0.12.6\jjwt-impl-0.12.6.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-jackson\0.12.6\jjwt-jackson-0.12.6.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.15.4\jackson-databind-2.15.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-openfeign\4.1.3\spring-cloud-starter-openfeign-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-openfeign-core\4.1.3\spring-cloud-openfeign-core-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\3.2.5\spring-boot-autoconfigure-3.2.5.jar;C:\Users\marce\.m2\repository\io\github\openfeign\form\feign-form-spring\3.8.0\feign-form-spring-3.8.0.jar;C:\Users\marce\.m2\repository\io\github\openfeign\form\feign-form\3.8.0\feign-form-3.8.0.jar;C:\Users\marce\.m2\repository\commons-fileupload\commons-fileupload\1.5\commons-fileupload-1.5.jar;C:\Users\marce\.m2\repository\commons-io\commons-io\2.11.0\commons-io-2.11.0.jar;C:\Users\marce\.m2\repository\org\springframework\spring-web\6.1.6\spring-web-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-beans\6.1.6\spring-beans-6.1.6.jar;C:\Users\marce\.m2\repository\io\micrometer\micrometer-observation\1.12.5\micrometer-observation-1.12.5.jar;C:\Users\marce\.m2\repository\io\micrometer\micrometer-commons\1.12.5\micrometer-commons-1.12.5.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-commons\4.1.4\spring-cloud-commons-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-crypto\6.2.4\spring-security-crypto-6.2.4.jar;C:\Users\marce\.m2\repository\io\github\openfeign\feign-core\13.3\feign-core-13.3.jar;C:\Users\marce\.m2\repository\io\github\openfeign\feign-slf4j\13.3\feign-slf4j-13.3.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-test\3.2.5\spring-boot-starter-test-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter\3.2.5\spring-boot-starter-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot\3.2.5\spring-boot-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-logging\3.2.5\spring-boot-starter-logging-3.2.5.jar;C:\Users\marce\.m2\repository\ch\qos\logback\logback-classic\1.4.14\logback-classic-1.4.14.jar;C:\Users\marce\.m2\repository\ch\qos\logback\logback-core\1.4.14\logback-core-1.4.14.jar;C:\Users\marce\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.21.1\log4j-to-slf4j-2.21.1.jar;C:\Users\marce\.m2\repository\org\apache\logging\log4j\log4j-api\2.21.1\log4j-api-2.21.1.jar;C:\Users\marce\.m2\repository\org\slf4j\jul-to-slf4j\2.0.13\jul-to-slf4j-2.0.13.jar;C:\Users\marce\.m2\repository\org\yaml\snakeyaml\2.2\snakeyaml-2.2.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-test\3.2.5\spring-boot-test-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-test-autoconfigure\3.2.5\spring-boot-test-autoconfigure-3.2.5.jar;C:\Users\marce\.m2\repository\com\jayway\jsonpath\json-path\2.9.0\json-path-2.9.0.jar;C:\Users\marce\.m2\repository\jakarta\xml\bind\jakarta.xml.bind-api\4.0.2\jakarta.xml.bind-api-4.0.2.jar;C:\Users\marce\.m2\repository\jakarta\activation\jakarta.activation-api\2.1.3\jakarta.activation-api-2.1.3.jar;C:\Users\marce\.m2\repository\net\minidev\json-smart\2.5.1\json-smart-2.5.1.jar;C:\Users\marce\.m2\repository\net\minidev\accessors-smart\2.5.1\accessors-smart-2.5.1.jar;C:\Users\marce\.m2\repository\org\ow2\asm\asm\9.6\asm-9.6.jar;C:\Users\marce\.m2\repository\org\assertj\assertj-core\3.24.2\assertj-core-3.24.2.jar;C:\Users\marce\.m2\repository\net\bytebuddy\byte-buddy\1.14.13\byte-buddy-1.14.13.jar;C:\Users\marce\.m2\repository\org\awaitility\awaitility\4.2.1\awaitility-4.2.1.jar;C:\Users\marce\.m2\repository\org\hamcrest\hamcrest\2.2\hamcrest-2.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter\5.10.2\junit-jupiter-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.10.2\junit-jupiter-api-5.10.2.jar;C:\Users\marce\.m2\repository\org\opentest4j\opentest4j\1.3.0\opentest4j-1.3.0.jar;C:\Users\marce\.m2\repository\org\junit\platform\junit-platform-commons\1.10.2\junit-platform-commons-1.10.2.jar;C:\Users\marce\.m2\repository\org\apiguardian\apiguardian-api\1.1.2\apiguardian-api-1.1.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-params\5.10.2\junit-jupiter-params-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.10.2\junit-jupiter-engine-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\platform\junit-platform-engine\1.10.2\junit-platform-engine-1.10.2.jar;C:\Users\marce\.m2\repository\org\mockito\mockito-core\5.7.0\mockito-core-5.7.0.jar;C:\Users\marce\.m2\repository\net\bytebuddy\byte-buddy-agent\1.14.13\byte-buddy-agent-1.14.13.jar;C:\Users\marce\.m2\repository\org\objenesis\objenesis\3.3\objenesis-3.3.jar;C:\Users\marce\.m2\repository\org\mockito\mockito-junit-jupiter\5.7.0\mockito-junit-jupiter-5.7.0.jar;C:\Users\marce\.m2\repository\org\skyscreamer\jsonassert\1.5.1\jsonassert-1.5.1.jar;C:\Users\marce\.m2\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;C:\Users\marce\.m2\repository\org\springframework\spring-core\6.1.6\spring-core-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-jcl\6.1.6\spring-jcl-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-test\6.1.6\spring-test-6.1.6.jar;C:\Users\marce\.m2\repository\org\xmlunit\xmlunit-core\2.9.1\xmlunit-core-2.9.1.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-test\6.2.4\spring-security-test-6.2.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-core\6.2.4\spring-security-core-6.2.4.jar;C:\Users\marce\.m2\repository\org\springframework\spring-aop\6.1.6\spring-aop-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-context\6.1.6\spring-context-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-expression\6.1.6\spring-expression-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-web\6.2.4\spring-security-web-6.2.4.jar;C:\Users\marce\.m2\repository\org\projectlombok\lombok\1.18.20\lombok-1.18.20.jar;"/>
    <property name="java.vm.vendor" value="Amazon.com Inc."/>
    <property name="sun.arch.data.model" value="64"/>
    <property name="user.variant" value=""/>
    <property name="java.vendor.url" value="https://aws.amazon.com/corretto/"/>
    <property name="user.timezone" value="America/Sao_Paulo"/>
    <property name="os.name" value="Windows 11"/>
    <property name="java.vm.specification.version" value="17"/>
    <property name="sun.java.launcher" value="SUN_STANDARD"/>
    <property name="user.country" value="BR"/>
    <property name="sun.boot.library.path" value="C:\Users\marce\.jdks\corretto-17.0.14\bin"/>
    <property name="sun.java.command" value="C:\Users\marce\AppData\Local\Temp\surefire2990045693632684528\surefirebooter-20250726083807353_3.jar C:\Users\marce\AppData\Local\Temp\surefire2990045693632684528 2025-07-26T08-38-07_161-jvmRun1 surefire-20250726083807353_1tmp surefire_0-20250726083807353_2tmp"/>
    <property name="jdk.debug" value="release"/>
    <property name="surefire.test.class.path" value="E:\legalconnect\legalconnect\microservices\legal-gaateway\target\test-classes;E:\legalconnect\legalconnect\microservices\legal-gaateway\target\classes;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-gateway\4.1.5\spring-cloud-starter-gateway-4.1.5.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter\4.1.4\spring-cloud-starter-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-context\4.1.4\spring-cloud-context-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-rsa\1.1.3\spring-security-rsa-1.1.3.jar;C:\Users\marce\.m2\repository\org\bouncycastle\bcprov-jdk18on\1.78\bcprov-jdk18on-1.78.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-gateway-server\4.1.5\spring-cloud-gateway-server-4.1.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-validation\3.2.5\spring-boot-starter-validation-3.2.5.jar;C:\Users\marce\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\10.1.20\tomcat-embed-el-10.1.20.jar;C:\Users\marce\.m2\repository\org\hibernate\validator\hibernate-validator\8.0.1.Final\hibernate-validator-8.0.1.Final.jar;C:\Users\marce\.m2\repository\jakarta\validation\jakarta.validation-api\3.0.2\jakarta.validation-api-3.0.2.jar;C:\Users\marce\.m2\repository\org\jboss\logging\jboss-logging\3.5.3.Final\jboss-logging-3.5.3.Final.jar;C:\Users\marce\.m2\repository\com\fasterxml\classmate\1.6.0\classmate-1.6.0.jar;C:\Users\marce\.m2\repository\io\projectreactor\addons\reactor-extra\3.5.1\reactor-extra-3.5.1.jar;C:\Users\marce\.m2\repository\io\projectreactor\reactor-core\3.6.5\reactor-core-3.6.5.jar;C:\Users\marce\.m2\repository\org\reactivestreams\reactive-streams\1.0.4\reactive-streams-1.0.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-webflux\3.2.5\spring-boot-starter-webflux-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-json\3.2.5\spring-boot-starter-json-3.2.5.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.15.4\jackson-datatype-jdk8-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.15.4\jackson-datatype-jsr310-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.15.4\jackson-module-parameter-names-2.15.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-reactor-netty\3.2.5\spring-boot-starter-reactor-netty-3.2.5.jar;C:\Users\marce\.m2\repository\io\projectreactor\netty\reactor-netty-http\1.1.18\reactor-netty-http-1.1.18.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-http\4.1.109.Final\netty-codec-http-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-common\4.1.109.Final\netty-common-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-buffer\4.1.109.Final\netty-buffer-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport\4.1.109.Final\netty-transport-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec\4.1.109.Final\netty-codec-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-handler\4.1.109.Final\netty-handler-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-http2\4.1.109.Final\netty-codec-http2-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns\4.1.109.Final\netty-resolver-dns-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver\4.1.109.Final\netty-resolver-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-dns\4.1.109.Final\netty-codec-dns-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns-native-macos\4.1.109.Final\netty-resolver-dns-native-macos-4.1.109.Final-osx-x86_64.jar;C:\Users\marce\.m2\repository\io\netty\netty-resolver-dns-classes-macos\4.1.109.Final\netty-resolver-dns-classes-macos-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-native-epoll\4.1.109.Final\netty-transport-native-epoll-4.1.109.Final-linux-x86_64.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-native-unix-common\4.1.109.Final\netty-transport-native-unix-common-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-transport-classes-epoll\4.1.109.Final\netty-transport-classes-epoll-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\projectreactor\netty\reactor-netty-core\1.1.18\reactor-netty-core-1.1.18.jar;C:\Users\marce\.m2\repository\io\netty\netty-handler-proxy\4.1.109.Final\netty-handler-proxy-4.1.109.Final.jar;C:\Users\marce\.m2\repository\io\netty\netty-codec-socks\4.1.109.Final\netty-codec-socks-4.1.109.Final.jar;C:\Users\marce\.m2\repository\org\springframework\spring-webflux\6.1.6\spring-webflux-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-netflix-eureka-client\4.1.3\spring-cloud-starter-netflix-eureka-client-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-netflix-eureka-client\4.1.3\spring-cloud-netflix-eureka-client-4.1.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\client5\httpclient5\5.2.3\httpclient5-5.2.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\core5\httpcore5\5.2.4\httpcore5-5.2.4.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\core5\httpcore5-h2\5.2.4\httpcore5-h2-5.2.4.jar;C:\Users\marce\.m2\repository\com\netflix\eureka\eureka-client\2.0.3\eureka-client-2.0.3.jar;C:\Users\marce\.m2\repository\com\thoughtworks\xstream\xstream\1.4.20\xstream-1.4.20.jar;C:\Users\marce\.m2\repository\io\github\x-stream\mxparser\1.2.2\mxparser-1.2.2.jar;C:\Users\marce\.m2\repository\xmlpull\xmlpull\1.1.3.1\xmlpull-1.1.3.1.jar;C:\Users\marce\.m2\repository\jakarta\ws\rs\jakarta.ws.rs-api\3.1.0\jakarta.ws.rs-api-3.1.0.jar;C:\Users\marce\.m2\repository\jakarta\inject\jakarta.inject-api\2.0.1\jakarta.inject-api-2.0.1.jar;C:\Users\marce\.m2\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;C:\Users\marce\.m2\repository\com\netflix\spectator\spectator-api\1.7.3\spectator-api-1.7.3.jar;C:\Users\marce\.m2\repository\org\slf4j\slf4j-api\2.0.13\slf4j-api-2.0.13.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\httpclient\4.5.3\httpclient-4.5.3.jar;C:\Users\marce\.m2\repository\org\apache\httpcomponents\httpcore\4.4.16\httpcore-4.4.16.jar;C:\Users\marce\.m2\repository\commons-codec\commons-codec\1.16.1\commons-codec-1.16.1.jar;C:\Users\marce\.m2\repository\commons-configuration\commons-configuration\1.10\commons-configuration-1.10.jar;C:\Users\marce\.m2\repository\commons-lang\commons-lang\2.6\commons-lang-2.6.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.15.4\jackson-annotations-2.15.4.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.15.4\jackson-core-2.15.4.jar;C:\Users\marce\.m2\repository\com\netflix\netflix-commons\netflix-eventbus\0.3.0\netflix-eventbus-0.3.0.jar;C:\Users\marce\.m2\repository\com\netflix\netflix-commons\netflix-infix\0.3.0\netflix-infix-0.3.0.jar;C:\Users\marce\.m2\repository\commons-jxpath\commons-jxpath\1.3\commons-jxpath-1.3.jar;C:\Users\marce\.m2\repository\joda-time\joda-time\2.3\joda-time-2.3.jar;C:\Users\marce\.m2\repository\org\antlr\antlr-runtime\3.4\antlr-runtime-3.4.jar;C:\Users\marce\.m2\repository\org\antlr\stringtemplate\3.2.1\stringtemplate-3.2.1.jar;C:\Users\marce\.m2\repository\antlr\antlr\2.7.7\antlr-2.7.7.jar;C:\Users\marce\.m2\repository\com\google\code\gson\gson\2.10.1\gson-2.10.1.jar;C:\Users\marce\.m2\repository\com\netflix\servo\servo-core\0.5.3\servo-core-0.5.3.jar;C:\Users\marce\.m2\repository\org\apache\commons\commons-math\2.2\commons-math-2.2.jar;C:\Users\marce\.m2\repository\javax\annotation\javax.annotation-api\1.2\javax.annotation-api-1.2.jar;C:\Users\marce\.m2\repository\org\codehaus\jettison\jettison\1.5.4\jettison-1.5.4.jar;C:\Users\marce\.m2\repository\com\netflix\eureka\eureka-core\2.0.3\eureka-core-2.0.3.jar;C:\Users\marce\.m2\repository\com\fasterxml\woodstox\woodstox-core\6.2.1\woodstox-core-6.2.1.jar;C:\Users\marce\.m2\repository\org\codehaus\woodstox\stax2-api\4.2.1\stax2-api-4.2.1.jar;C:\Users\marce\.m2\repository\com\google\guava\guava\33.0.0-jre\guava-33.0.0-jre.jar;C:\Users\marce\.m2\repository\com\google\guava\failureaccess\1.0.2\failureaccess-1.0.2.jar;C:\Users\marce\.m2\repository\com\google\guava\listenablefuture\9999.0-empty-to-avoid-conflict-with-guava\listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar;C:\Users\marce\.m2\repository\org\checkerframework\checker-qual\3.41.0\checker-qual-3.41.0.jar;C:\Users\marce\.m2\repository\com\google\errorprone\error_prone_annotations\2.23.0\error_prone_annotations-2.23.0.jar;C:\Users\marce\.m2\repository\com\google\j2objc\j2objc-annotations\2.8\j2objc-annotations-2.8.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-loadbalancer\4.1.4\spring-cloud-starter-loadbalancer-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-loadbalancer\4.1.4\spring-cloud-loadbalancer-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-cache\3.2.5\spring-boot-starter-cache-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\spring-context-support\6.1.6\spring-context-support-6.1.6.jar;C:\Users\marce\.m2\repository\com\stoyanr\evictor\1.0.0\evictor-1.0.0.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-webflux-ui\2.0.2\springdoc-openapi-starter-webflux-ui-2.0.2.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-webflux-api\2.0.2\springdoc-openapi-starter-webflux-api-2.0.2.jar;C:\Users\marce\.m2\repository\org\springdoc\springdoc-openapi-starter-common\2.0.2\springdoc-openapi-starter-common-2.0.2.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-core-jakarta\2.2.7\swagger-core-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\org\apache\commons\commons-lang3\3.13.0\commons-lang3-3.13.0.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-annotations-jakarta\2.2.7\swagger-annotations-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\io\swagger\core\v3\swagger-models-jakarta\2.2.7\swagger-models-jakarta-2.2.7.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\dataformat\jackson-dataformat-yaml\2.15.4\jackson-dataformat-yaml-2.15.4.jar;C:\Users\marce\.m2\repository\org\webjars\swagger-ui\4.15.5\swagger-ui-4.15.5.jar;C:\Users\marce\.m2\repository\org\webjars\webjars-locator-core\0.55\webjars-locator-core-0.55.jar;C:\Users\marce\.m2\repository\io\github\classgraph\classgraph\4.8.149\classgraph-4.8.149.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-api\0.12.6\jjwt-api-0.12.6.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-impl\0.12.6\jjwt-impl-0.12.6.jar;C:\Users\marce\.m2\repository\io\jsonwebtoken\jjwt-jackson\0.12.6\jjwt-jackson-0.12.6.jar;C:\Users\marce\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.15.4\jackson-databind-2.15.4.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-starter-openfeign\4.1.3\spring-cloud-starter-openfeign-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-openfeign-core\4.1.3\spring-cloud-openfeign-core-4.1.3.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\3.2.5\spring-boot-autoconfigure-3.2.5.jar;C:\Users\marce\.m2\repository\io\github\openfeign\form\feign-form-spring\3.8.0\feign-form-spring-3.8.0.jar;C:\Users\marce\.m2\repository\io\github\openfeign\form\feign-form\3.8.0\feign-form-3.8.0.jar;C:\Users\marce\.m2\repository\commons-fileupload\commons-fileupload\1.5\commons-fileupload-1.5.jar;C:\Users\marce\.m2\repository\commons-io\commons-io\2.11.0\commons-io-2.11.0.jar;C:\Users\marce\.m2\repository\org\springframework\spring-web\6.1.6\spring-web-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-beans\6.1.6\spring-beans-6.1.6.jar;C:\Users\marce\.m2\repository\io\micrometer\micrometer-observation\1.12.5\micrometer-observation-1.12.5.jar;C:\Users\marce\.m2\repository\io\micrometer\micrometer-commons\1.12.5\micrometer-commons-1.12.5.jar;C:\Users\marce\.m2\repository\org\springframework\cloud\spring-cloud-commons\4.1.4\spring-cloud-commons-4.1.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-crypto\6.2.4\spring-security-crypto-6.2.4.jar;C:\Users\marce\.m2\repository\io\github\openfeign\feign-core\13.3\feign-core-13.3.jar;C:\Users\marce\.m2\repository\io\github\openfeign\feign-slf4j\13.3\feign-slf4j-13.3.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-test\3.2.5\spring-boot-starter-test-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter\3.2.5\spring-boot-starter-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot\3.2.5\spring-boot-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-starter-logging\3.2.5\spring-boot-starter-logging-3.2.5.jar;C:\Users\marce\.m2\repository\ch\qos\logback\logback-classic\1.4.14\logback-classic-1.4.14.jar;C:\Users\marce\.m2\repository\ch\qos\logback\logback-core\1.4.14\logback-core-1.4.14.jar;C:\Users\marce\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.21.1\log4j-to-slf4j-2.21.1.jar;C:\Users\marce\.m2\repository\org\apache\logging\log4j\log4j-api\2.21.1\log4j-api-2.21.1.jar;C:\Users\marce\.m2\repository\org\slf4j\jul-to-slf4j\2.0.13\jul-to-slf4j-2.0.13.jar;C:\Users\marce\.m2\repository\org\yaml\snakeyaml\2.2\snakeyaml-2.2.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-test\3.2.5\spring-boot-test-3.2.5.jar;C:\Users\marce\.m2\repository\org\springframework\boot\spring-boot-test-autoconfigure\3.2.5\spring-boot-test-autoconfigure-3.2.5.jar;C:\Users\marce\.m2\repository\com\jayway\jsonpath\json-path\2.9.0\json-path-2.9.0.jar;C:\Users\marce\.m2\repository\jakarta\xml\bind\jakarta.xml.bind-api\4.0.2\jakarta.xml.bind-api-4.0.2.jar;C:\Users\marce\.m2\repository\jakarta\activation\jakarta.activation-api\2.1.3\jakarta.activation-api-2.1.3.jar;C:\Users\marce\.m2\repository\net\minidev\json-smart\2.5.1\json-smart-2.5.1.jar;C:\Users\marce\.m2\repository\net\minidev\accessors-smart\2.5.1\accessors-smart-2.5.1.jar;C:\Users\marce\.m2\repository\org\ow2\asm\asm\9.6\asm-9.6.jar;C:\Users\marce\.m2\repository\org\assertj\assertj-core\3.24.2\assertj-core-3.24.2.jar;C:\Users\marce\.m2\repository\net\bytebuddy\byte-buddy\1.14.13\byte-buddy-1.14.13.jar;C:\Users\marce\.m2\repository\org\awaitility\awaitility\4.2.1\awaitility-4.2.1.jar;C:\Users\marce\.m2\repository\org\hamcrest\hamcrest\2.2\hamcrest-2.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter\5.10.2\junit-jupiter-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-api\5.10.2\junit-jupiter-api-5.10.2.jar;C:\Users\marce\.m2\repository\org\opentest4j\opentest4j\1.3.0\opentest4j-1.3.0.jar;C:\Users\marce\.m2\repository\org\junit\platform\junit-platform-commons\1.10.2\junit-platform-commons-1.10.2.jar;C:\Users\marce\.m2\repository\org\apiguardian\apiguardian-api\1.1.2\apiguardian-api-1.1.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-params\5.10.2\junit-jupiter-params-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\jupiter\junit-jupiter-engine\5.10.2\junit-jupiter-engine-5.10.2.jar;C:\Users\marce\.m2\repository\org\junit\platform\junit-platform-engine\1.10.2\junit-platform-engine-1.10.2.jar;C:\Users\marce\.m2\repository\org\mockito\mockito-core\5.7.0\mockito-core-5.7.0.jar;C:\Users\marce\.m2\repository\net\bytebuddy\byte-buddy-agent\1.14.13\byte-buddy-agent-1.14.13.jar;C:\Users\marce\.m2\repository\org\objenesis\objenesis\3.3\objenesis-3.3.jar;C:\Users\marce\.m2\repository\org\mockito\mockito-junit-jupiter\5.7.0\mockito-junit-jupiter-5.7.0.jar;C:\Users\marce\.m2\repository\org\skyscreamer\jsonassert\1.5.1\jsonassert-1.5.1.jar;C:\Users\marce\.m2\repository\com\vaadin\external\google\android-json\0.0.20131108.vaadin1\android-json-0.0.20131108.vaadin1.jar;C:\Users\marce\.m2\repository\org\springframework\spring-core\6.1.6\spring-core-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-jcl\6.1.6\spring-jcl-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-test\6.1.6\spring-test-6.1.6.jar;C:\Users\marce\.m2\repository\org\xmlunit\xmlunit-core\2.9.1\xmlunit-core-2.9.1.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-test\6.2.4\spring-security-test-6.2.4.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-core\6.2.4\spring-security-core-6.2.4.jar;C:\Users\marce\.m2\repository\org\springframework\spring-aop\6.1.6\spring-aop-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-context\6.1.6\spring-context-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\spring-expression\6.1.6\spring-expression-6.1.6.jar;C:\Users\marce\.m2\repository\org\springframework\security\spring-security-web\6.2.4\spring-security-web-6.2.4.jar;C:\Users\marce\.m2\repository\org\projectlombok\lombok\1.18.20\lombok-1.18.20.jar;"/>
    <property name="sun.cpu.endian" value="little"/>
    <property name="user.home" value="C:\Users\marce"/>
    <property name="user.language" value="pt"/>
    <property name="java.specification.vendor" value="Oracle Corporation"/>
    <property name="java.version.date" value="2025-01-21"/>
    <property name="java.home" value="C:\Users\marce\.jdks\corretto-17.0.14"/>
    <property name="file.separator" value="\"/>
    <property name="basedir" value="E:\legalconnect\legalconnect\microservices\legal-gaateway"/>
    <property name="java.vm.compressedOopsMode" value="Zero based"/>
    <property name="line.separator" value="&#10;"/>
    <property name="java.vm.specification.vendor" value="Oracle Corporation"/>
    <property name="java.specification.name" value="Java Platform API Specification"/>
    <property name="surefire.real.class.path" value="C:\Users\marce\AppData\Local\Temp\surefire2990045693632684528\surefirebooter-20250726083807353_3.jar"/>
    <property name="user.script" value=""/>
    <property name="sun.management.compiler" value="HotSpot 64-Bit Tiered Compilers"/>
    <property name="java.runtime.version" value="17.0.14+7-LTS"/>
    <property name="user.name" value="marce"/>
    <property name="path.separator" value=";"/>
    <property name="os.version" value="10.0"/>
    <property name="java.runtime.name" value="OpenJDK Runtime Environment"/>
    <property name="file.encoding" value="Cp1252"/>
    <property name="java.vm.name" value="OpenJDK 64-Bit Server VM"/>
    <property name="java.vendor.version" value="Corretto-17.0.14.7.1"/>
    <property name="localRepository" value="C:\Users\marce\.m2\repository"/>
    <property name="java.vendor.url.bug" value="https://github.com/corretto/corretto-17/issues/"/>
    <property name="java.io.tmpdir" value="C:\Users\marce\AppData\Local\Temp\"/>
    <property name="java.version" value="17.0.14"/>
    <property name="user.dir" value="E:\legalconnect\legalconnect\microservices\legal-gaateway"/>
    <property name="os.arch" value="amd64"/>
    <property name="java.vm.specification.name" value="Java Virtual Machine Specification"/>
    <property name="sun.os.patch.level" value=""/>
    <property name="native.encoding" value="Cp1252"/>
    <property name="java.library.path" value="C:\Users\marce\.jdks\corretto-17.0.14\bin;C:\WINDOWS\Sun\Java\bin;C:\WINDOWS\system32;C:\WINDOWS;C:\Python313\Scripts\;C:\Python313\;C:\Program Files\Python312\Scripts\;C:\Program Files\Python312\;C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;C:\WINDOWS\System32\WindowsPowerShell\v1.0\;C:\WINDOWS\System32\OpenSSH\;C:\Program Files\Git\cmd;C:\Users\marce\AppData\Local\nvm;C:\nvm4w\nodejs;C:\Program Files (x86)\Windows Kits\10\Windows Performance Toolkit\;C:\ProgramData\chocolatey\bin;C:\Program Files\Docker\Docker\resources\bin;C:\Users\marce\.jbang\bin;C:\Users\marce\.local\bin;C:\Users\marce\AppData\Local\Microsoft\WindowsApps;C:\Users\marce\AppData\Local\Programs\Microsoft VS Code\bin;C:\Users\marce\AppData\Local\nvm;C:\nvm4w\nodejs;E:\dev\ambiente\apache-maven-3.9.9\bin;C:\Program Files\Python312\Scripts\;C:\Program Files\Python312\;C:\Users\marce\.jdks\corretto-17.0.14\bin;;C:\Users\marce\AppData\Local\Programs\Ollama;c:\Users\marce\AppData\Roaming\Code\User\globalStorage\github.copilot-chat\debugCommand;."/>
    <property name="java.vm.info" value="mixed mode, sharing"/>
    <property name="java.vendor" value="Amazon.com Inc."/>
    <property name="java.vm.version" value="17.0.14+7-LTS"/>
    <property name="java.specification.maintenance.version" value="1"/>
    <property name="sun.io.unicode.encoding" value="UnicodeLittle"/>
    <property name="java.class.version" value="61.0"/>
  </properties>
  <testcase name="" classname="br.com.legalconnect.common.common_lib.CommonLibApplicationTests" time="0.387">
    <error message="Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test" type="java.lang.IllegalStateException"><![CDATA[java.lang.IllegalStateException: Unable to find a @SpringBootConfiguration, you need to use @ContextConfiguration or @SpringBootTest(classes=...) with your test
	at org.springframework.util.Assert.state(Assert.java:76)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.findConfigurationClass(SpringBootTestContextBootstrapper.java:246)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.getOrFindConfigurationClasses(SpringBootTestContextBootstrapper.java:233)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.processMergedContextConfiguration(SpringBootTestContextBootstrapper.java:150)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:351)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildDefaultMergedContextConfiguration(AbstractTestContextBootstrapper.java:267)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildMergedContextConfiguration(AbstractTestContextBootstrapper.java:215)
	at org.springframework.test.context.support.AbstractTestContextBootstrapper.buildTestContext(AbstractTestContextBootstrapper.java:108)
	at org.springframework.boot.test.context.SpringBootTestContextBootstrapper.buildTestContext(SpringBootTestContextBootstrapper.java:111)
	at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:142)
	at org.springframework.test.context.TestContextManager.<init>(TestContextManager.java:126)
	at org.springframework.test.context.junit.jupiter.SpringExtension.getTestContextManager(SpringExtension.java:366)
	at org.springframework.test.context.junit.jupiter.SpringExtension.beforeAll(SpringExtension.java:131)
	at java.base/java.util.ArrayList.forEach(ArrayList.java:1511)
]]></error>
    <system-out><![CDATA[08:38:08.667 [main] INFO org.springframework.test.context.support.AnnotationConfigContextLoaderUtils -- Could not detect default configuration classes for test class [br.com.legalconnect.common.common_lib.CommonLibApplicationTests]: CommonLibApplicationTests does not declare any static, non-private, non-final, nested classes annotated with @Configuration.
]]></system-out>
  </testcase>
</testsuite>
```
```java
Êþº¾   =   ?br/com/legalconnect/common/common_lib/CommonLibApplicationTests  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this ALbr/com/legalconnect/common/common_lib/CommonLibApplicationTests; contextLoads RuntimeVisibleAnnotations Lorg/junit/jupiter/api/Test; 
SourceFile CommonLibApplicationTests.java 6Lorg/springframework/boot/test/context/SpringBootTest;                  /     *· ±    
                 
                   +      ±    
                 
                
```
```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version> <!-- Usando 3.2.5, uma versão estável do Spring Boot 3 -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>gateway</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>legalconnect-gateway</name>
	<description>API Gateway for LegalConnect Microservices</description>

	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.3</spring-cloud.version>
	</properties>

	<dependencies>
		<!-- Spring Cloud Gateway -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway</artifactId>
		</dependency>

		<!-- Service Discovery (Eureka) -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>

		<!-- Swagger para documentação do Gateway -->
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
			<version>2.0.2</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-api</artifactId>
			<version>0.12.6</version>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-impl</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>io.jsonwebtoken</groupId>
			<artifactId>jjwt-jackson</artifactId>
			<version>0.12.6</version>
			<scope>runtime</scope>
		</dependency>
		<!-- common-lib (se aplicável, mantenha a versão correta) -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-openfeign</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.20</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-LegalconnectGatewayApplication<gateway>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.gateway.LegalconnectGatewayApplication",
      "projectName": "gateway",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive"
}

```
```java
2025-07-19T00:04:15.152-03:00  INFO 15528 --- [api-gateway] [main] b.c.l.g.LegalconnectGatewayApplication   : Starting LegalconnectGatewayApplication using Java 17.0.14 with PID 15528 (E:\legalconnect\legalconnect\microservices\legal-gaateway\target\classes started by marce in E:\legalconnect\legalconnect\microservices\legal-gaateway)
2025-07-19T00:04:15.157-03:00  INFO 15528 --- [api-gateway] [main] b.c.l.g.LegalconnectGatewayApplication   : The following 1 profile is active: "prod"
2025-07-19T00:04:16.294-03:00  INFO 15528 --- [api-gateway] [main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=5f08001b-9a87-30ca-868e-5ada63b5f73e
2025-07-19T00:04:16.371-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration$DeferringLoadBalancerInterceptorConfig' of type [org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration$DeferringLoadBalancerInterceptorConfig] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). The currently created BeanPostProcessor [lbRestClientPostProcessor] is declared through a non-static factory method on that class; consider declaring it as static instead.
2025-07-19T00:04:16.375-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'deferringLoadBalancerInterceptor' of type [org.springframework.cloud.client.loadbalancer.DeferringLoadBalancerInterceptor] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [lbRestClientPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:16.377-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration' of type [org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). The currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor] is declared through a non-static factory method on that class; consider declaring it as static instead.
2025-07-19T00:04:16.379-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration$ReactorDeferringLoadBalancerFilterConfig' of type [org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration$ReactorDeferringLoadBalancerFilterConfig] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:16.381-03:00  WARN 15528 --- [api-gateway] [main] trationDelegate$BeanPostProcessorChecker : Bean 'reactorDeferringLoadBalancerExchangeFilterFunction' of type [org.springframework.cloud.client.loadbalancer.reactive.DeferringLoadBalancerExchangeFilterFunction] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying). Is this bean getting eagerly injected into a currently created BeanPostProcessor [loadBalancerWebClientBuilderBeanPostProcessor]? Check the corresponding BeanPostProcessor declaration and its dependencies.
2025-07-19T00:04:17.438-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [After]
2025-07-19T00:04:17.439-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Before]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Between]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Cookie]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Header]
2025-07-19T00:04:17.440-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Host]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Method]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Path]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Query]
2025-07-19T00:04:17.441-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [ReadBody]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [RemoteAddr]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [XForwardedRemoteAddr]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [Weight]
2025-07-19T00:04:17.442-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.g.r.RouteDefinitionRouteLocator    : Loaded RoutePredicateFactory [CloudFoundryRouteService]
2025-07-19T00:04:17.939-03:00  INFO 15528 --- [api-gateway] [main] DiscoveryClientOptionalArgsConfiguration : Eureka HTTP Client uses RestTemplate.
2025-07-19T00:04:18.093-03:00  WARN 15528 --- [api-gateway] [main] iguration$LoadBalancerCaffeineWarnLogger : Spring Cloud LoadBalancer is currently working with the default cache. While this cache implementation is useful for development and tests, it's recommended to use Caffeine cache in production.You can switch to using Caffeine cache, by adding it and org.springframework.cache.caffeine.CaffeineCacheManager to the classpath.
2025-07-19T00:04:18.162-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING
2025-07-19T00:04:18.195-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka in region us-east-1
2025-07-19T00:04:18.200-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration
2025-07-19T00:04:18.224-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Disable delta property : false
2025-07-19T00:04:18.226-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null
2025-07-19T00:04:18.226-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : false
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Application is null : false
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : true
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Application version is -1: true
2025-07-19T00:04:18.227-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server
2025-07-19T00:04:18.629-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : The response status is 200
2025-07-19T00:04:18.632-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30
2025-07-19T00:04:18.634-03:00  INFO 15528 --- [api-gateway] [main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4
2025-07-19T00:04:18.642-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1752894258641 with initial instances count: 1
2025-07-19T00:04:18.644-03:00  INFO 15528 --- [api-gateway] [main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application API-GATEWAY with eureka with status UP
2025-07-19T00:04:18.646-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1752894258646, current=UP, previous=STARTING]
2025-07-19T00:04:18.649-03:00  INFO 15528 --- [api-gateway] [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080: registering service...
2025-07-19T00:04:18.701-03:00  INFO 15528 --- [api-gateway] [DiscoveryClient-InstanceInfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080 - registration status: 204
2025-07-19T00:04:18.699-03:00 ERROR 15528 --- [api-gateway] [main] o.s.c.gateway.route.CachingRouteLocator  : Refresh routes error !!!

java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name name
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.loadGatewayFilters(RouteDefinitionRouteLocator.java:145) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.getFilters(RouteDefinitionRouteLocator.java:186) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.convertToRoute(RouteDefinitionRouteLocator.java:132) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:492) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:424) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.drain(FluxMergeSequential.java:439) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.innerComplete(FluxMergeSequential.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialInner.onSubscribe(FluxMergeSequential.java:559) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4568) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribeWith(Mono.java:4634) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4534) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4470) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Mono.subscribe(Mono.java:4442) ~[reactor-core-3.6.5.jar:3.6.5]
	at org.springframework.cloud.gateway.route.CachingRouteLocator.onApplicationEvent(CachingRouteLocator.java:100) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.CachingRouteLocator.onApplicationEvent(CachingRouteLocator.java:42) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.reset(RouteRefreshListener.java:73) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.onApplicationEvent(RouteRefreshListener.java:54) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration.start(EurekaAutoServiceRegistration.java:91) ~[spring-cloud-netflix-eureka-client-4.1.1.jar:4.1.1]
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:288) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:471) ~[spring-context-6.1.6.jar:6.1.6]
	at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]
	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:260) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:205) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:981) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:627) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]

2025-07-19T00:04:18.715-03:00  WARN 15528 --- [api-gateway] [main] onfigReactiveWebServerApplicationContext : Exception encountered during context initialization - cancelling refresh attempt: org.springframework.context.ApplicationContextException: Failed to start bean 'eurekaAutoServiceRegistration'
2025-07-19T00:04:18.723-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...
2025-07-19T00:04:21.733-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Unregistering ...
2025-07-19T00:04:21.742-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8761/eureka/} exception=Connection pool shut down stacktrace=java.lang.IllegalStateException: Connection pool shut down
	at org.apache.hc.core5.util.Asserts.check(Asserts.java:38)
	at org.apache.hc.core5.pool.StrictConnPool.lease(StrictConnPool.java:176)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.lease(PoolingHttpClientConnectionManager.java:298)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.acquireEndpoint(InternalExecRuntime.java:103)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:125)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:87)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.apache.hc.client5.http.classic.HttpClient.executeOpen(HttpClient.java:183)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:95)
	at org.springframework.http.client.AbstractStreamingClientHttpRequest.executeInternal(AbstractStreamingClientHttpRequest.java:70)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:112)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:88)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:72)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:889)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:790)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:672)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.cancel(RestTemplateEurekaHttpClient.java:87)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:91)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916)
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195)
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389)
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637)
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18)

2025-07-19T00:04:21.744-03:00  WARN 15528 --- [api-gateway] [main] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: Connection pool shut down
2025-07-19T00:04:21.749-03:00  INFO 15528 --- [api-gateway] [main] c.n.d.s.t.d.RedirectingEurekaHttpClient  : Request execution error. endpoint=DefaultEndpoint{ serviceUrl='http://localhost:8761/eureka/}, exception=Connection pool shut down stacktrace=java.lang.IllegalStateException: Connection pool shut down
	at org.apache.hc.core5.util.Asserts.check(Asserts.java:38)
	at org.apache.hc.core5.pool.StrictConnPool.lease(StrictConnPool.java:176)
	at org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager.lease(PoolingHttpClientConnectionManager.java:298)
	at org.apache.hc.client5.http.impl.classic.InternalExecRuntime.acquireEndpoint(InternalExecRuntime.java:103)
	at org.apache.hc.client5.http.impl.classic.ConnectExec.execute(ConnectExec.java:125)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ProtocolExec.execute(ProtocolExec.java:192)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.HttpRequestRetryExec.execute(HttpRequestRetryExec.java:96)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.ContentCompressionExec.execute(ContentCompressionExec.java:152)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.RedirectExec.execute(RedirectExec.java:115)
	at org.apache.hc.client5.http.impl.classic.ExecChainElement.execute(ExecChainElement.java:51)
	at org.apache.hc.client5.http.impl.classic.InternalHttpClient.doExecute(InternalHttpClient.java:170)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:87)
	at org.apache.hc.client5.http.impl.classic.CloseableHttpClient.execute(CloseableHttpClient.java:55)
	at org.apache.hc.client5.http.classic.HttpClient.executeOpen(HttpClient.java:183)
	at org.springframework.http.client.HttpComponentsClientHttpRequest.executeInternal(HttpComponentsClientHttpRequest.java:95)
	at org.springframework.http.client.AbstractStreamingClientHttpRequest.executeInternal(AbstractStreamingClientHttpRequest.java:70)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:112)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateTransportClientFactory.lambda$restTemplate$0(RestTemplateTransportClientFactory.java:143)
	at org.springframework.http.client.InterceptingClientHttpRequest$InterceptingRequestExecution.execute(InterceptingClientHttpRequest.java:88)
	at org.springframework.http.client.InterceptingClientHttpRequest.executeInternal(InterceptingClientHttpRequest.java:72)
	at org.springframework.http.client.AbstractBufferingClientHttpRequest.executeInternal(AbstractBufferingClientHttpRequest.java:48)
	at org.springframework.http.client.AbstractClientHttpRequest.execute(AbstractClientHttpRequest.java:66)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:889)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:790)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:672)
	at org.springframework.cloud.netflix.eureka.http.RestTemplateEurekaHttpClient.cancel(RestTemplateEurekaHttpClient.java:87)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.executeOnNewServer(RedirectingEurekaHttpClient.java:121)
	at com.netflix.discovery.shared.transport.decorator.RedirectingEurekaHttpClient.execute(RedirectingEurekaHttpClient.java:80)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:120)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74)
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77)
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71)
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916)
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195)
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389)
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136)
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195)
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637)
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343)
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18)

2025-07-19T00:04:21.749-03:00  WARN 15528 --- [api-gateway] [main] c.n.d.s.t.d.RetryableEurekaHttpClient    : Request execution failed with message: Connection pool shut down
2025-07-19T00:04:21.750-03:00 ERROR 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_API-GATEWAY/host.docker.internal:api-gateway:8080 - de-registration failedCannot execute request on any known server

com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server
	at com.netflix.discovery.shared.transport.decorator.RetryableEurekaHttpClient.execute(RetryableEurekaHttpClient.java:112) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator$2.execute(EurekaHttpClientDecorator.java:74) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.SessionedEurekaHttpClient.execute(SessionedEurekaHttpClient.java:77) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.shared.transport.decorator.EurekaHttpClientDecorator.cancel(EurekaHttpClientDecorator.java:71) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.DiscoveryClient.unregister(DiscoveryClient.java:916) ~[eureka-client-2.0.2.jar:2.0.2]
	at com.netflix.discovery.DiscoveryClient.shutdown(DiscoveryClient.java:892) ~[eureka-client-2.0.2.jar:2.0.2]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77) ~[na:na]
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:569) ~[na:na]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeDestroyMethods(InitDestroyAnnotationBeanPostProcessor.java:415) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeDestruction(InitDestroyAnnotationBeanPostProcessor.java:239) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:202) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.run(DisposableBeanAdapter.java:195) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.cloud.context.scope.GenericScope$BeanLifecycleWrapper.destroy(GenericScope.java:389) ~[spring-cloud-context-4.1.2.jar:4.1.2]
	at org.springframework.cloud.context.scope.GenericScope.destroy(GenericScope.java:136) ~[spring-cloud-context-4.1.2.jar:4.1.2]
	at org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:211) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:587) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingleton(DefaultSingletonBeanRegistry.java:559) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingleton(DefaultListableBeanFactory.java:1202) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:520) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.destroySingletons(DefaultListableBeanFactory.java:1195) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1186) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:637) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]

2025-07-19T00:04:21.756-03:00  INFO 15528 --- [api-gateway] [main] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient
2025-07-19T00:04:21.770-03:00  INFO 15528 --- [api-gateway] [main] .s.b.a.l.ConditionEvaluationReportLogger : 

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-07-19T00:04:21.790-03:00 ERROR 15528 --- [api-gateway] [main] o.s.boot.SpringApplication               : Application run failed

org.springframework.context.ApplicationContextException: Failed to start bean 'eurekaAutoServiceRegistration'
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:291) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor$LifecycleGroup.start(DefaultLifecycleProcessor.java:471) ~[spring-context-6.1.6.jar:6.1.6]
	at java.base/java.lang.Iterable.forEach(Iterable.java:75) ~[na:na]
	at org.springframework.context.support.DefaultLifecycleProcessor.startBeans(DefaultLifecycleProcessor.java:260) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.DefaultLifecycleProcessor.onRefresh(DefaultLifecycleProcessor.java:205) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.finishRefresh(AbstractApplicationContext.java:981) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:627) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext.refresh(ReactiveWebServerApplicationContext.java:66) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:334) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1354) ~[spring-boot-3.2.5.jar:3.2.5]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1343) ~[spring-boot-3.2.5.jar:3.2.5]
	at br.com.legalconnect.gateway.LegalconnectGatewayApplication.main(LegalconnectGatewayApplication.java:18) ~[classes/:na]
Caused by: java.lang.IllegalArgumentException: Unable to find GatewayFilterFactory with name name
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.loadGatewayFilters(RouteDefinitionRouteLocator.java:145) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.getFilters(RouteDefinitionRouteLocator.java:186) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator.convertToRoute(RouteDefinitionRouteLocator.java:132) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:492) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:424) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.drain(FluxMergeSequential.java:439) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.innerComplete(FluxMergeSequential.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialInner.onSubscribe(FluxMergeSequential.java:559) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onNext(FluxMergeSequential.java:237) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.slowPath(FluxIterable.java:335) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable$IterableSubscription.request(FluxIterable.java:294) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxMergeSequential$MergeSequentialMain.onSubscribe(FluxMergeSequential.java:198) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:201) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxIterable.subscribe(FluxIterable.java:83) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.FluxDefer.subscribe(FluxDefer.java:54) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.subscribe(Flux.java:8840) ~[reactor-core-3.6.5.jar:3.6.5]
	at reactor.core.publisher.Flux.blockLast(Flux.java:2816) ~[reactor-core-3.6.5.jar:3.6.5]
	at org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter.lambda$onApplicationEvent$3(WeightCalculatorWebFilter.java:156) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory$DependencyObjectProvider.ifAvailable(DefaultListableBeanFactory.java:2126) ~[spring-beans-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.filter.WeightCalculatorWebFilter.onApplicationEvent(WeightCalculatorWebFilter.java:156) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.reset(RouteRefreshListener.java:73) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.cloud.gateway.route.RouteRefreshListener.onApplicationEvent(RouteRefreshListener.java:54) ~[spring-cloud-gateway-server-4.1.2.jar:4.1.2]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:185) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:178) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:156) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:451) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:384) ~[spring-context-6.1.6.jar:6.1.6]
	at org.springframework.cloud.netflix.eureka.serviceregistry.EurekaAutoServiceRegistration.start(EurekaAutoServiceRegistration.java:91) ~[spring-cloud-netflix-eureka-client-4.1.1.jar:4.1.1]
	at org.springframework.context.support.DefaultLifecycleProcessor.doStart(DefaultLifecycleProcessor.java:288) ~[spring-context-6.1.6.jar:6.1.6]
	... 13 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:104) ~[reactor-core-3.6.5.jar:3.6.5]
		at reactor.core.publisher.Flux.blockLast(Flux.java:2817) ~[reactor-core-3.6.5.jar:3.6.5]
		... 30 common frames omitted


```
```java
{
  "openapi": "3.0.1",
  "info": {
    "title": "LegalConnect Gateway API",
    "description": "API Gateway para o sistema LegalConnect",
    "version": "1.0"
  },
  "servers": [
    { "url": "http://192.168.1.4:54557", "description": "Generated server url" }
  ],
  "security": [{ "JWT": [] }],
  "paths": {
    "/api/v1/auth/socios/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerSocio",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/redefinir": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "resetPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ResetPasswordRequest" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/senhas/recuperar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "recoverPassword",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RecoverPasswordRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/refresh-token": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "refreshToken",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefreshTokenRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/login": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "authenticate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/LoginRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAuthResponse"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/clientes/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerClient",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/advogados/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdvogado",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/auth/administradores/registrar": {
      "post": {
        "tags": ["auth-controller"],
        "operationId": "registerAdmin",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseUserResponseDTO"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "UserRegistrationRequest": {
        "required": ["cpf", "email", "nomeCompleto", "senha", "userType"],
        "type": "object",
        "properties": {
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "email": { "maxLength": 255, "minLength": 0, "type": "string" },
          "cpf": {
            "pattern": "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$",
            "type": "string"
          },
          "telefone": { "maxLength": 20, "minLength": 0, "type": "string" },
          "senha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          },
          "userType": { "type": "string" }
        }
      },
      "BaseResponseUserResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/UserResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "nomeCompleto": { "type": "string" },
          "email": { "type": "string" },
          "cpf": { "type": "string" },
          "telefone": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "status": { "type": "string" }
        }
      },
      "ResetPasswordRequest": {
        "required": ["novaSenha", "token"],
        "type": "object",
        "properties": {
          "token": { "type": "string" },
          "novaSenha": {
            "maxLength": 2147483647,
            "minLength": 8,
            "type": "string"
          }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "RecoverPasswordRequest": {
        "required": ["email"],
        "type": "object",
        "properties": { "email": { "type": "string" } }
      },
      "RefreshTokenRequestDTO": {
        "required": ["refreshToken"],
        "type": "object",
        "properties": { "refreshToken": { "type": "string" } }
      },
      "AuthResponse": {
        "type": "object",
        "properties": {
          "accessToken": { "type": "string" },
          "refreshToken": { "type": "string" },
          "tokenType": { "type": "string" },
          "expiresIn": { "type": "integer", "format": "int64" }
        }
      },
      "BaseResponseAuthResponse": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AuthResponse" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "LoginRequestDTO": {
        "required": ["email", "senha"],
        "type": "object",
        "properties": {
          "email": { "type": "string" },
          "senha": { "type": "string" }
        }
      }
    },
    "securitySchemes": {
      "JWT": {
        "type": "http",
        "name": "JWT",
        "scheme": "bearer",
        "bearerFormat": "JWT"
      }
    }
  }
}

```
```java
```java
package br.com.legalconnect.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class LegalconnectGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(LegalconnectGatewayApplication.class, args);
	}

}

```
```java
package br.com.legalconnect.gateway.config;

import java.net.URI;

import org.springframework.cloud.client.discovery.DiscoveryClient;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayConfig {

    // Este bean é para permitir o roteamento dinâmico no application.yml
    // para o Swagger, onde precisamos pegar o URI de qualquer serviço.
    @Bean
    public CustomDiscoveryClientService customDiscoveryClientService(DiscoveryClient discoveryClient) {
        return new CustomDiscoveryClientService(discoveryClient);
    }

    public static class CustomDiscoveryClientService {
        private final DiscoveryClient discoveryClient;

        public CustomDiscoveryClientService(DiscoveryClient discoveryClient) {
            this.discoveryClient = discoveryClient;
        }

        public URI getServiceUri() {
            // Este método será usado no application.yml para resolver o URI dinamicamente.
            // Para o Swagger, precisamos de um URI genérico para que o Gateway possa
            // proxyar requisições para qualquer serviço.
            // Em um cenário real, você pode querer listar todos os serviços
            // e construir as rotas do Swagger dinamicamente em tempo de execução
            // ou ter um serviço de agregação de Swagger.
            // Aqui, apenas retornamos um URI base para o balanceador de carga.
            return URI.create("lb://");
        }
    }

}

```
```java
package br.com.legalconnect.gateway.config;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.route.RouteLocator;
import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class GatewayRouteConfig {
        private final GatewayFilter jwtFilter;

        public GatewayRouteConfig(GatewayFilter jwtFilter) {
                this.jwtFilter = jwtFilter;
        }
        // @Bean
        // public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
        // return builder.routes()
        // // Swagger AUTH
        // .route("swagger-ui-auth", r -> r.path("/auth/swagger-ui/**")
        // .filters(f -> f.rewritePath("/auth/swagger-ui/(?<segment>.*)",
        // "/swagger-ui/${segment}"))
        // .uri("lb://AUTH-SERVICE"))
        // // API Docs AUTH
        // .route("api-docs-auth", r -> r.path("/auth/v3/api-docs/**")
        // .filters(f -> f.rewritePath("/auth/v3/api-docs/(?<segment>.*)",
        // "/v3/api-docs/${segment}"))
        // .uri("lb://AUTH-SERVICE"))
        // // Swagger USUARIO
        // .route("swagger-ui-usuario", r -> r.path("/usuario/swagger-ui/**")
        // .filters(f -> f.rewritePath("/usuario/swagger-ui/(?<segment>.*)",
        // "/swagger-ui/${segment}"))
        // .uri("lb://LEGALCONNECT-USUARIO-SERVICE"))
        // // API Docs USUARIO
        // .route("api-docs-usuario", r -> r.path("/usuario/v3/api-docs/**")
        // .filters(f -> f.rewritePath("/usuario/v3/api-docs/(?<segment>.*)",
        // "/v3/api-docs/${segment}"))
        // .uri("lb://LEGALCONNECT-USUARIO-SERVICE"))
        // .build();
        // }

        @Bean
        public RouteLocator customRouteLocator(RouteLocatorBuilder builder) {
                return builder.routes()
                                // Rota principal para o serviço de usuário
                                .route("usuario-service", r -> r.path("/api/usuarios/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/(?<segment>.*)",
                                                                "/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                // Rota para a documentação OpenAPI
                                .route("usuario-service-api-docs", r -> r.path("/api/usuarios/v3/api-docs/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/v3/api-docs/(?<segment>.*)",
                                                                "/v3/api-docs/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                // Rota para o Swagger UI
                                .route("usuario-service-swagger-ui", r -> r.path("/api/usuarios/swagger-ui/**")
                                                .filters(f -> f.rewritePath("/api/usuarios/swagger-ui/(?<segment>.*)",
                                                                "/swagger-ui/${segment}"))
                                                .uri("lb://legalconnect-usuario-service"))

                                .build();
        }

}

```
```java
package br.com.legalconnect.gateway.config;

import java.util.List;
import java.util.Map;

import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.util.JwtUtil;
import reactor.core.publisher.Mono;

@Component // Nome do bean para uso no application.yml
public class JwtTokenFilter implements GatewayFilter {

    private final JwtUtil jwtUtil;

    public JwtTokenFilter(JwtUtil jwtUtil) {
        this.jwtUtil = jwtUtil;
    }

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();

        // Verifica se a rota é pública (ex: /auth/** ou Swagger)
        // Isso é mais robusto fazer com Spring Security WebFilterChain
        // Mas para este exemplo, podemos verificar o path
        if (isPublicPath(request.getPath().value())) {
            return chain.filter(exchange);
        }

        List<String> authHeaders = request.getHeaders().get(HttpHeaders.AUTHORIZATION);

        if (authHeaders == null || authHeaders.isEmpty() || !authHeaders.get(0).startsWith("Bearer ")) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        String token = authHeaders.get(0).substring(7); // Remove "Bearer "

        if (!jwtUtil.validateToken(token)) {
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        // Extrai e remove claims específicos
        Map<String, Object> claims = jwtUtil.getAllClaimsFromToken(token);
        String userId = (String) claims.get("X-Correlaton-ID");
        String tenantId = (String) claims.get("X-Tenant-ID");

        // Remove os claims do token original (se necessário para nova validação
        // downstream)
        // Isso é mais complexo pois você precisaria gerar um novo token sem esses
        // claims.
        // Uma abordagem mais comum é manter o token original e propagar os claims
        // em headers separados para os microserviços.
        // Para este projeto, vamos propagar os claims como headers.

        ServerHttpRequest.Builder builder = request.mutate();
        if (userId != null) {
            builder.header("X-User-Id", userId);
        }
        if (tenantId != null) {
            builder.header("X-Tenant-Id", tenantId);
        }

        // Para evitar que o token completo seja enviado para os serviços downstream
        // Se você precisar do token completo downstream, considere remover essa linha
        // ou validar a necessidade.
        builder.header(HttpHeaders.AUTHORIZATION, "Bearer " + token); // Mantém o token original

        return chain.filter(exchange.mutate().request(builder.build()).build());
    }

    // Helper para verificar se o path é público
    private boolean isPublicPath(String path) {
        // Rotas que devem ser liberadas sem autenticação
        return path.startsWith("/auth/") ||
                path.startsWith("/swagger-ui/") ||
                path.startsWith("/v3/api-docs/");
    }
}

```
```java
// com.example.gateway.config/SecurityConfig.java
package br.com.legalconnect.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsWebFilter;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;

@Configuration
public class SecurityConfig {
    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("*");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
```
```java
package br.com.legalconnect.gateway.util;

import java.util.Date;
import java.util.Map;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.SignatureException;
import io.jsonwebtoken.UnsupportedJwtException;
import io.jsonwebtoken.security.Keys;

@Component
public class JwtUtil {

    @Value("${application.security.jwt.secret-key}")
    private String secret;

    private SecretKey getSigningKey() {
        byte[] keyBytes = secret.getBytes();
        return Keys.hmacShaKeyFor(keyBytes);
    }

    public Map<String, Object> getAllClaimsFromToken(String token) {
        return Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token).getBody();
    }

    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = (Claims) getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }

    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }

    private Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }

    public Boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(getSigningKey()).build().parseClaimsJws(token);
            return true;
        } catch (SignatureException e) {
            // Logger.error("Assinatura JWT inválida: {}", e.getMessage());
        } catch (MalformedJwtException e) {
            // Logger.error("Token JWT malformado: {}", e.getMessage());
        } catch (ExpiredJwtException e) {
            // Logger.error("Token JWT expirado: {}", e.getMessage());
        } catch (UnsupportedJwtException e) {
            // Logger.error("Token JWT não suportado: {}", e.getMessage());
        } catch (IllegalArgumentException e) {
            // Logger.error("String JWT compacta vazia: {}", e.getMessage());
        }
        return false;
    }
}
```
```java
# Server Configuration
server.port=8080

# Application Configuration
spring.application.name=legalconnect-gateway

# Gateway Discovery Configuration
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

# Eureka Discovery Configuration
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
eureka.client.fetch-registry=true
eureka.client.register-with-eureka=true
eureka.instance.prefer-ip-address=true

# Swagger Configuration
 

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970
```
```java
package br.com.legalconnect.common.common_lib;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CommonLibApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java

```
```java
package br.com.legalconnect.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@SpringBootApplication
@EnableDiscoveryClient
public class LegalconnectGatewayApplication {

	public static void main(String[] args) {
		SpringApplication.run(LegalconnectGatewayApplication.class, args);
	}

}

```
```java
package br.com.legalconnect.gateway.config.enums;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
package br.com.legalconnect.gateway.config.exception;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonInclude;

import br.com.legalconnect.gateway.config.enums.StatusResponse;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class BaseResponse
 * @brief DTO base para padronizar as respostas da API.
 *
 *        Inclui campos comuns para todas as respostas, como status, mensagem,
 *        timestamp e, opcionalmente, uma lista de erros.
 *        Utiliza Lombok para reduzir boilerplate (getters, setters,
 *        construtores, builder).
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL) // Inclui apenas campos não nulos na serialização JSON
public class BaseResponse<T> {

    private StatusResponse status; // Status da resposta (ex: StatusResponse.SUCESSO, StatusResponse.ERRO,
                                   // "WARNING")
    private String message; // Mensagem descritiva da resposta
    private LocalDateTime timestamp; // Data e hora da resposta
    private T data; // Payload da resposta (dados de sucesso)
    private List<String> errors; // Lista de mensagens de erro, se houver
}
```
```java
package br.com.legalconnect.gateway.config.exception;

import org.springframework.http.HttpStatus;

import lombok.Getter;

/**
 * @class BusinessException
 * @brief Exceção personalizada para representar erros de negócio na aplicação.
 *
 *        Esta exceção é lançada quando uma regra de negócio não é satisfeita.
 *        Ela encapsula um {@link ErrorCode} e, opcionalmente, argumentos para
 *        formatar
 *        a mensagem de erro, além de um status HTTP para a resposta da API.
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode; // O código de erro padronizado
    private final String[] args; // Argumentos para formatar a mensagem do erro
    private final HttpStatus httpStatus; // Status HTTP associado a esta exceção

    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String args) {
        super(args);
        this.errorCode = errorCode;
        this.args = new String[] { args, errorCode.getMessage() };
        this.httpStatus = httpStatus;
    }

    /**
     * Construtor para BusinessException com um ErrorCode e status HTTP padrão
     * (BAD_REQUEST).
     *
     * @param errorCode O código de erro que define o tipo de exceção de negócio.
     * @param args      Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, String... args) {
        this(errorCode, HttpStatus.BAD_REQUEST, args); // Por padrão, erros de negócio são BAD_REQUEST
    }

    /**
     * Construtor para BusinessException com um ErrorCode e um status HTTP
     * específico.
     *
     * @param errorCode  O código de erro que define o tipo de exceção de negócio.
     * @param httpStatus O status HTTP a ser retornado na resposta da API.
     * @param args       Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String... args) {
        super(errorCode.getFormattedMessage(args)); // Define a mensagem da exceção usando a mensagem formatada do
                                                    // ErrorCode
        this.errorCode = errorCode;
        this.args = args;
        this.httpStatus = httpStatus;

    }

    /**
     * @brief Retorna a mensagem de erro formatada.
     * @return A mensagem de erro formatada.
     */
    @Override
    public String getMessage() {
        return errorCode.getFormattedMessage(args);
    }

    /**
     * @brief Retorna o código de erro.
     * @return O código de erro.
     */
    public String getCode() {
        return errorCode.getCode();
    }
}
```
```java
package br.com.legalconnect.gateway.config.exception;

import lombok.Getter;

/**
 * @enum ErrorCode
 * @brief Enumeração que define códigos de erro padronizados para a aplicação.
 *
 *        Cada código de erro possui uma mensagem associada, facilitando a
 *        padronização
 *        de respostas de erro na API e a internacionalização ou localização
 *        futura.
 */
@Getter
public enum ErrorCode {
    // Erros gerais de validação
    DADOS_INVALIDOS("001", "Dados fornecidos são inválidos."),
    REQUISICAO_MAL_FORMADA("002", "A requisição está mal formada."),
    PARAMETRO_AUSENTE("003", "Parâmetro obrigatório ausente."),

    // Erros de entidade / negócio
    ENTIDADE_NAO_ENCONTRADA("100", "Entidade não encontrada."),
    EMPRESA_NAO_ENCONTRADA("101", "Empresa não encontrada."),
    PROFISSIONAL_NAO_ENCONTRADO("102", "Profissional não encontrado."),
    CLIENTE_NAO_ENCONTRADO("103", "Cliente não encontrado."),
    ADMINISTRADOR_NAO_ENCONTRADO("104", "Administrador não encontrado."),
    PLANO_NAO_ENCONTRADO("105", "Plano não encontrado."),
    USER_NAO_ENCONTRADO("106", "Usuário associado não encontrado."),

    // Erros de duplicidade
    CNPJ_DUPLICADO("200", "CNPJ já cadastrado."),
    CPF_DUPLICADO("201", "CPF já cadastrado."),
    OAB_DUPLICADA("202", "Número da OAB já cadastrado."),
    EMAIL_DUPLICADO("203", "Email já cadastrado."),
    NOME_PLANO_DUPLICADO("204", "Nome do plano já cadastrado."),

    // Erros de integridade
    INTEGRIDADE_VIOLADA("300", "Violação de integridade de dados."),
    RECURSO_EM_USO("301", "Recurso não pode ser excluído pois está em uso."),

    // Erros de sistema / internos
    ERRO_INTERNO_SERVIDOR("500", "Ocorreu um erro interno no servidor."),
    SERVICO_INDISPONIVEL("503", "Serviço temporariamente indisponível."),

    // Erros Gerais/Comuns (1000-1999)
    GENERIC_ERROR("1000", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde."),
    INVALID_INPUT("1001", "Dados de entrada inválidos."),
    RESOURCE_NOT_FOUND("1002", "Recurso não encontrado."),
    UNAUTHORIZED_ACCESS("1003", "Acesso não autorizado. Credenciais inválidas ou ausentes."),
    FORBIDDEN_ACCESS("1004", "Acesso negado. Você não tem permissão para realizar esta ação."),
    SERVICE_UNAVAILABLE("1005", "O serviço está temporariamente indisponível. Tente novamente mais tarde."),
    TOO_MANY_REQUESTS("1006", "Muitas requisições. Por favor, aguarde e tente novamente."),
    VALIDATION_ERROR("1007", "Erro de validação nos dados fornecidos."),
    DATABASE_ERROR("1008", "Erro ao acessar o banco de dados."),
    INTEGRATION_ERROR("1009", "Erro de integração com serviço externo."),

    // Erros de Autenticação e Autorização (2000-2999)
    INVALID_CREDENTIALS("2000", "Credenciais de autenticação inválidas."),
    ACCOUNT_LOCKED("2001", "Sua conta está bloqueada."),
    ACCOUNT_DISABLED("2002", "Sua conta está desativada."),
    TOKEN_EXPIRED("2003", "O token de acesso expirou."),
    INVALID_TOKEN("2004", "O token de acesso é inválido."),
    REFRESH_TOKEN_EXPIRED("2005", "O refresh token expirou. Faça login novamente."),
    INVALID_REFRESH_TOKEN("2006", "O refresh token é inválido."),
    USER_NOT_FOUND("2007", "Usuário não encontrado."),
    EMAIL_ALREADY_REGISTERED("2008", "Este e-mail já está cadastrado."),
    PASSWORD_RESET_FAILED("2009", "Falha ao redefinir a senha."),
    INVALID_CURRENT_PASSWORD("2010", "A senha atual fornecida está incorreta."), // Novo erro
    PASSWORD_RESET_TOKEN_INVALID("2011", "Token de redefinição de senha inválido."), // Novo erro
    PASSWORD_RESET_TOKEN_EXPIRED("2012", "Token de redefinição de senha expirado."), // Novo erro
    PASSWORD_RESET_TOKEN_USED("2013", "Token de redefinição de senha já utilizado."), // Novo erro
    PASSWORD_RESET_TOKEN_EXCEEDED("2014", "Limite de redefinições de senha excedido."), // Novo erro

    // Erros de Negócio Específicos (3000-3999) - Exemplo
    TENANT_NOT_FOUND("3000", "Tenant não encontrado."),
    TENANT_DISABLED("3001", "O tenant está desativado."),
    SUBSCRIPTION_EXPIRED("3002", "Sua assinatura expirou."),
    PLAN_NOT_ACTIVE("3003", "O plano selecionado não está ativo."),
    SERVICE_LIMIT_EXCEEDED("3004", "Limite de serviços agendáveis excedido para o seu plano."),
    ADVOCATE_NOT_AVAILABLE("3005", "Advogado não disponível no horário selecionado."),
    APPOINTMENT_CONFLICT("3006", "Conflito de agendamento. O horário já está ocupado."),
    PAYMENT_FAILED("3007", "Falha no processamento do pagamento."),
    INVALID_PROMO_CODE("3008", "Código promocional inválido ou expirado."),
    DOCUMENT_UPLOAD_FAILED("3009", "Falha ao fazer upload do documento."),
    INVALID_DOCUMENT_FORMAT("3010", "Formato de documento inválido."),

    // Erros de Validação de Campo (4000-4999) - Mais específicos, geralmente
    // tratados por @Valid
    FIELD_REQUIRED("4000", "O campo '%s' é obrigatório."),
    INVALID_FORMAT("4001", "O campo '%s' possui formato inválido."),
    MIN_LENGTH("4002", "O campo '%s' deve ter no mínimo %d caracteres."),
    MAX_LENGTH("4003", "O campo '%s' deve ter no máximo %d caracteres."),
    INVALID_EMAIL("4004", "O e-mail fornecido é inválido."),
    INVALID_CPF("4005", "O CPF fornecido é inválido."),
    INVALID_CNPJ("4006", "O CNPJ fornecido é inválido."),
    PASSWORD_TOO_WEAK("4007", "A senha é muito fraca."),
    DATE_IN_PAST("4008", "A data não pode ser no passado."),
    INVALID_ENUM_VALUE("4009", "Valor inválido para o campo '%s'.");

    private final String code;
    private final String message;

    /**
     * Construtor para ErrorCode.
     *
     * @param code    O código único do erro.
     * @param message A mensagem descritiva do erro.
     */
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    /**
     * @brief Retorna a mensagem de erro formatada com argumentos.
     * @param args Argumentos para formatar a mensagem.
     * @return A mensagem de erro formatada.
     */
    public String getFormattedMessage(Object... args) {
        return String.format(this.message, args);
    }
}

```
```java
package br.com.legalconnect.gateway.config.exception;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.config.enums.StatusResponse;
import reactor.core.publisher.Mono;

@RestControllerAdvice
public class GlobalExceptionHandler {

        @ExceptionHandler(BusinessException.class)
        public Mono<ResponseEntity<BaseResponse>> handleBusinessException(
                        BusinessException ex,
                        ServerWebExchange exchange) {

                BaseResponse response = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ex.getMessage())
                                .build();

                return Mono.just(ResponseEntity
                                .status(ex.getHttpStatus())
                                .body(response));
        }
}
```
```java
package br.com.legalconnect.gateway.util;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import br.com.legalconnect.gateway.config.exception.BusinessException;
import br.com.legalconnect.gateway.config.exception.ErrorCode;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component

public class AuthFilter extends AbstractGatewayFilterFactory<AuthFilter.Config> {

    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    public AuthFilter(

    ) {
        super(Config.class);

    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            try {
                String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

                if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "Token não encontrado");
                }

                String token = authHeader.substring(7);

                if (token == null || token.isBlank()) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "Token não encontrado");
                }

                Claims claims = extractAllClaims(token);
                if (isTokenExpired(token)) {
                    throw new BusinessException(ErrorCode.TOKEN_EXPIRED, "Token expirado");
                }
                List<String> userRoles = (List<String>) claims.get("roles", List.class);

                String correlationId = claims.get("X-Correlation-ID", String.class);

                // String tenantId = claims.get("X-Tenant-ID", String.class);

                if (correlationId == null || correlationId.isBlank()) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "X-Correlation-ID não encontrado no token");
                }

                if (userRoles == null || userRoles.isEmpty()) {
                    throw new BusinessException(ErrorCode.USER_NOT_FOUND, "Role não encontrada no token");
                }

                ServerWebExchange mutated = exchange.mutate()
                        .request(builder -> {
                            builder.header("X-Correlation-ID", correlationId);
                            builder.header("X-Tenant-ID", "public");
                            builder.header("X-User-Roles", String.join(",", userRoles));

                        })
                        .build();

                return chain.filter(mutated);

            } catch (Exception e) {
                log.error("Erro ao processar token JWT: {}", e.getMessage());
                // if (e instanceof BusinessException) {
                // throw (BusinessException) e;
                // }
                throw new BusinessException(ErrorCode.INVALID_TOKEN, "Token inválido ou malformado");
            }
        };
    }

    public static class Config {
    }

    private Claims extractAllClaims(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    /**
     * Verifica se o token JWT expirou.
     * 
     * @param token O token JWT.
     * @return True se o token expirou, false caso contrário.
     */
    private boolean isTokenExpired(String token) {
        Date expiration = extractExpiration(token);
        boolean expired = expiration.before(new Date());
        if (expired) {
            log.debug("Token expirado em: {}", expiration);
        }
        return expired;
    }

    /**
     * Extrai a data de expiração do token JWT.
     * 
     * @param token O token JWT.
     * @return A data de expiração.
     */
    Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUsername(String token) {
        try {
            return extractClaim(token, Claims::getSubject);
        } catch (Exception e) {
            log.warn("Erro ao extrair username do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extrai uma claim específica do token JWT.
     * 
     * @param token          O token JWT.
     * @param claimsResolver Função para resolver a claim.
     * @param <T>            Tipo da claim.
     * @return O valor da claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

}
```
```java
package br.com.legalconnect.gateway.util;

import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component

public class AuthorizationHeaderFilter extends AbstractGatewayFilterFactory<AuthorizationHeaderFilter.Config> {

    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    public AuthorizationHeaderFilter(

    ) {
        super(Config.class);

    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            try {
                String authHeader = exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION);

                if (authHeader == null || !authHeader.startsWith("Bearer ")) {
                    return chain.filter(exchange);
                }

                String token = authHeader.substring(7);

                if (token == null || token.isBlank()) {
                    return chain.filter(exchange);
                }

                Claims claims = extractAllClaims(token);
                if (isTokenExpired(token)) {
                    return chain.filter(exchange);
                }
                List<String> userRoles = (List<String>) claims.get("roles", List.class);

                String correlationId = claims.get("X-Correlation-ID", String.class);

                // String tenantId = claims.get("X-Tenant-ID", String.class);

                ServerWebExchange mutated = exchange.mutate()
                        .request(builder -> {
                            builder.header("X-Correlation-ID", correlationId);
                            builder.header("X-Tenant-ID", "public");
                            builder.header("X-User-Roles", String.join(",", userRoles));

                        })
                        .build();

                return chain.filter(mutated);

            } catch (Exception e) {
                log.error("Erro ao processar token JWT: {}", e.getMessage());
                return chain.filter(exchange);
            }
        };
    }

    public static class Config {
    }

    private Claims extractAllClaims(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    /**
     * Verifica se o token JWT expirou.
     * 
     * @param token O token JWT.
     * @return True se o token expirou, false caso contrário.
     */
    private boolean isTokenExpired(String token) {
        Date expiration = extractExpiration(token);
        boolean expired = expiration.before(new Date());
        if (expired) {
            log.debug("Token expirado em: {}", expiration);
        }
        return expired;
    }

    /**
     * Extrai a data de expiração do token JWT.
     * 
     * @param token O token JWT.
     * @return A data de expiração.
     */
    Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    public String extractUsername(String token) {
        try {
            return extractClaim(token, Claims::getSubject);
        } catch (Exception e) {
            log.warn("Erro ao extrair username do token: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Extrai uma claim específica do token JWT.
     * 
     * @param token          O token JWT.
     * @param claimsResolver Função para resolver a claim.
     * @param <T>            Tipo da claim.
     * @return O valor da claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

}
```
```java
package br.com.legalconnect.gateway.util;

import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.Date;
import java.util.List;
import java.util.function.Function;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;

/**
 * Utilitário para manipulação de tokens JWT no Gateway.
 * Esta classe é responsável por decodificar e validar tokens JWT.
 * A chave de assinatura DEVE ser a mesma utilizada para gerar o token no
 * AUTH-SERVICE.
 */
@Component
public class JwtUtil {

    // A chave secreta deve ser a mesma usada no AUTH-SERVICE para assinar o JWT
    // É crucial que esta chave seja tratada como um segredo e não seja exposta.
    @Value("${application.security.jwt.secret-key}")
    private String secretKey;

    private Key getSigningKey() {
        // Gera a chave a partir do segredo. Use Keys.hmacShaKeyFor(secret.getBytes())
        // para chaves de 256 bits ou mais.
        // Certifique-se de que 'secret' é longo o suficiente (mínimo 32 caracteres para
        // HS256).
        return Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
    }

    /**
     * Extrai todas as claims (informações) do token JWT.
     * 
     * @param token O token JWT.
     * @return As claims contidas no token.
     */
    public Claims extractAllClaims(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));
        return Jwts.parser()
                .verifyWith(key)
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }

    /**
     * Extrai uma claim específica do token JWT.
     * 
     * @param token          O token JWT.
     * @param claimsResolver Função para resolver a claim desejada.
     * @param <T>            Tipo da claim.
     * @return O valor da claim.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Extrai o nome de usuário (subject) do token JWT.
     * 
     * @param token O token JWT.
     * @return O nome de usuário.
     */
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * Extrai a data de expiração do token JWT.
     * 
     * @param token O token JWT.
     * @return A data de expiração.
     */
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    /**
     * Verifica se o token JWT é válido (não expirado e com assinatura válida).
     * 
     * @param token O token JWT.
     * @return true se o token é válido, false caso contrário.
     */
    public Boolean validateToken(String token) {
        try {
            return !isTokenExpired(token);
        } catch (Exception e) {
            // Logar a exceção para depuração (ex: token malformado, assinatura inválida)
            System.err.println("Erro ao validar token JWT: " + e.getMessage());
            return false;
        }
    }

    /**
     * Verifica se o token JWT está expirado.
     * 
     * @param token O token JWT.
     * @return true se o token expirou, false caso contrário.
     */
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    /**
     * Extrai as roles (cargos/permissões) do token JWT.
     * Assume que as roles estão em uma claim chamada "roles" ou similar.
     * É crucial que o AUTH-SERVICE inclua esta claim no JWT.
     * 
     * @param token O token JWT.
     * @return Uma lista de strings representando as roles.
     */
    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        // Assumindo que as roles são armazenadas como uma lista de strings na claim
        // "roles"
        // Adapte "roles" para o nome real da claim que seu AUTH-SERVICE usa.
        return (List<String>) claims.get("roles", List.class);
    }
}
```
```java
# ===================================================================
# Configurações Gerais do Gateway
# ===================================================================
spring.application.name=legalconnect-gateway
server.port=8080
spring.webflux.auto-configure-error=false
server.forward-headers-strategy=FRAMEWORK

# ===================================================================
# Configurações do Eureka Client
# ===================================================================
eureka.client.service-url.defaultZone=${EUREKA_CLIENT_SERVICE_URL:http://localhost:8761/eureka}
eureka.client.fetch-registry=true
eureka.client.register-with-eureka=true
eureka.instance.prefer-ip-address=true

spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true
spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Spring Cloud Gateway Discovery Locator
# ===================================================================
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

# ===================================================================
# Configurações do SpringDoc OpenAPI (Swagger UI)
# ===================================================================
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
spring.mvc.favicon.enabled=false

# ===================================================================
# Configurações do Actuator
# ===================================================================
management.endpoints.web.exposure.include=health,info

# ===================================================================
# Configurações de Filtros Globais do Gateway
# ===================================================================
# Filtro global para deduzir cabeçalhos de resposta duplicados.
spring.cloud.gateway.globalfilters[0].DedupeResponseHeader.strategy=RETAIN_LAST

# ===================================================================
# Definição de Rotas do Gateway
# ===================================================================

# Rota para o serviço de autenticação (público)
spring.cloud.gateway.routes[0].id=auth-service-public
spring.cloud.gateway.routes[0].uri=lb://auth-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/api/v1/auth/**

# Rota para o serviço de autenticação (privado, com AuthFilter)
spring.cloud.gateway.routes[1].id=auth-service-private
spring.cloud.gateway.routes[1].uri=lb://auth-service
spring.cloud.gateway.routes[1].predicates[0]=Path=/api/v1/privado/auth/**
spring.cloud.gateway.routes[1].filters[0]=AuthFilter


# Rota para o serviço de usuários (clientes, com AuthFilter)
spring.cloud.gateway.routes[3].id=clientes-route
spring.cloud.gateway.routes[3].uri=lb://legalconnect-usuario-service
spring.cloud.gateway.routes[3].predicates[0]=Path=/api/v1/usuarios/**
spring.cloud.gateway.routes[3].filters[0]=AuthFilter

# Rota 4 - /api/v1/advogados/** com AuthFilter
spring.cloud.gateway.routes[4].id=advogados-auth-route
spring.cloud.gateway.routes[4].uri=lb://legalconnect-advogados
spring.cloud.gateway.routes[4].predicates[0]=Path=/api/v1/advogados/**
spring.cloud.gateway.routes[4].filters[0]=AuthFilter

# Rota 5 - /api/v1/publico/advogados/profissionais/** com AuthorizationHeaderFilter
spring.cloud.gateway.routes[5].id=advogados-public-route
spring.cloud.gateway.routes[5].uri=lb://legalconnect-advogados
spring.cloud.gateway.routes[5].predicates[0]=Path=/api/v1/publico/advogados/profissionais/**
spring.cloud.gateway.routes[5].filters[0]=AuthorizationHeaderFilter

# Rota 6 - /api/v1/marketplace/** com AuthFilter
spring.cloud.gateway.routes[6].id=destaques-auth-route
spring.cloud.gateway.routes[6].uri=lb://legalconnect-marketplace 
spring.cloud.gateway.routes[6].predicates[0]=Path=/api/v1/marketplace/**
spring.cloud.gateway.routes[6].filters[0]=AuthFilter

# # Rota 7 - /api/v1/publico/marketplace/** com AuthorizationHeaderFilter
# spring.cloud.gateway.routes[7].id=destaques-public-route
# spring.cloud.gateway.routes[7].uri=lb://legalconnect-marketplace
# spring.cloud.gateway.routes[7].predicates[0]=Path=/api/v1/publico/marketplace/**
# spring.cloud.gateway.routes[7].filters[0]=AuthorizationHeaderFilter
# Rota para o serviço Legal Marketplace (rotas públicas)
spring.cloud.gateway.routes[2].id=legal-marketplace-public
spring.cloud.gateway.routes[2].uri=lb://legalconnect-marketplace
spring.cloud.gateway.routes[2].predicates[0]=Path=/api/v1/publico/marketplace/**
spring.cloud.gateway.routes[2].filters[0]=AuthorizationHeaderFilter


# # Rota para o serviço de advogados (sem) AuthFilter)
# spring.cloud.gateway.routes[5].id=advogados-route-publico
# spring.cloud.gateway.routes[5].uri=lb://legalconnect-advogados

# ===================================================================
# Configurações de Segurança da Aplicação (JWT e Rotas)
# ===================================================================
application.security.jwt.secret-key=${JWT_SECRET_KEY:404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970}
application.security.public-paths=/auth/**,/swagger-ui/**,/v3/api-docs/**,/api/usuarios/swagger-ui.html,/api/usuarios/webjars/**,/api/usuarios/v3/api-docs/**

# Configurações específicas para a rota de clientes
application.security.routes.clientes.required-role=CLIENT
application.security.routes.clientes.required-scopes=client.read,client.write

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
{
  "openapi": "3.0.1",
  "info": {
    "title": "LegalConnect API Gateway",
    "description": "Documentação da API via Gateway",
    "version": "1.0"
  },
  "servers": [
    { "url": "http://localhost:8080", "description": "Gateway Server" }
  ],
  "paths": {
    "/api/v1/usuarios/empresas/{id}": {
      "get": {
        "tags": ["controlador-empresa"],
        "operationId": "buscarEmpresaPorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-empresa"],
        "operationId": "atualizarEmpresa",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/EmpresaRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-empresa"],
        "operationId": "excluirEmpresa",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/clientes/{id}": {
      "get": {
        "tags": ["controlador-cliente"],
        "operationId": "buscarClientePorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-cliente"],
        "operationId": "atualizarCliente",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ClienteRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-cliente"],
        "operationId": "excluirCliente",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/administradores-plataforma/{id}": {
      "get": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "buscarAdministradorPorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "atualizarAdministrador",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdministradorRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "excluirAdministrador",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/empresas": {
      "get": {
        "tags": ["controlador-empresa"],
        "operationId": "listarEmpresas",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-empresa"],
        "operationId": "cadastrarEmpresa",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/EmpresaRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/clientes": {
      "get": {
        "tags": ["controlador-cliente"],
        "operationId": "listarClientes",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-cliente"],
        "operationId": "cadastrarCliente",
        "parameters": [
          {
            "name": "X-Correlation-Id",
            "in": "header",
            "required": false,
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ClienteRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/administradores-plataforma": {
      "get": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "listarAdministradores",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "cadastrarAdministrador",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdministradorRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "EmpresaRequestDTO": {
        "required": ["cnpj", "nomeFantasia", "razaoSocial"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeFantasia": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "razaoSocial": { "maxLength": 255, "minLength": 0, "type": "string" },
          "cnpj": {
            "pattern": "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}",
            "type": "string"
          },
          "emailContato": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          }
        }
      },
      "EnderecoRequestDTO": {
        "required": [
          "bairro",
          "cep",
          "cidade",
          "estado",
          "logradouro",
          "numero",
          "pais",
          "tipoEndereco"
        ],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "logradouro": { "maxLength": 255, "minLength": 0, "type": "string" },
          "numero": { "maxLength": 20, "minLength": 0, "type": "string" },
          "complemento": { "maxLength": 255, "minLength": 0, "type": "string" },
          "bairro": { "maxLength": 100, "minLength": 0, "type": "string" },
          "cidade": { "maxLength": 100, "minLength": 0, "type": "string" },
          "estado": { "maxLength": 2, "minLength": 2, "type": "string" },
          "cep": { "pattern": "\\d{5}-\\d{3}", "type": "string" },
          "pais": { "maxLength": 50, "minLength": 0, "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          }
        }
      },
      "BaseResponseEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/EmpresaResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "EmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeFantasia": { "type": "string" },
          "razaoSocial": { "type": "string" },
          "cnpj": { "type": "string" },
          "emailContato": { "type": "string" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "EnderecoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "logradouro": { "type": "string" },
          "numero": { "type": "string" },
          "complemento": { "type": "string" },
          "bairro": { "type": "string" },
          "cidade": { "type": "string" },
          "estado": { "type": "string" },
          "cep": { "type": "string" },
          "pais": { "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "ClienteRequestDTO": {
        "required": ["cpf", "nomeCompleto"],
        "type": "object",
        "properties": {
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "pattern": "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "status": { "type": "string" }
        }
      },
      "UserRequestDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "email": { "type": "string" }
        }
      },
      "BaseResponseClienteResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/ClienteResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "ClienteResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserResponseDTO" },
          "nomeCompleto": { "type": "string" },
          "cpf": { "type": "string" },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" },
          "status": { "type": "string" },
          "tipo": { "type": "string" }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "email": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "AdministradorRequestDTO": {
        "required": ["cpf", "nomeCompleto"],
        "type": "object",
        "properties": {
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "pattern": "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "status": { "type": "string" }
        }
      },
      "AdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserResponseDTO" },
          "nomeCompleto": { "type": "string" },
          "cpf": { "type": "string" },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" },
          "status": { "type": "string" }
        }
      },
      "BaseResponseAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AdministradorResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "Pageable": {
        "type": "object",
        "properties": {
          "page": { "minimum": 0, "type": "integer", "format": "int32" },
          "size": { "minimum": 1, "type": "integer", "format": "int32" },
          "sort": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponsePageEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/PageEmpresaResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EmpresaResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "PageableObject": {
        "type": "object",
        "properties": {
          "offset": { "type": "integer", "format": "int64" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "pageNumber": { "type": "integer", "format": "int32" },
          "pageSize": { "type": "integer", "format": "int32" },
          "paged": { "type": "boolean" },
          "unpaged": { "type": "boolean" }
        }
      },
      "SortObject": {
        "type": "object",
        "properties": {
          "direction": { "type": "string" },
          "nullHandling": { "type": "string" },
          "ascending": { "type": "boolean" },
          "property": { "type": "string" },
          "ignoreCase": { "type": "boolean" }
        }
      },
      "BaseResponsePageClienteResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/PageClienteResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageClienteResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ClienteResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "BaseResponsePageAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "$ref": "#/components/schemas/PageAdministradorResponseDTO"
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/AdministradorResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}

```
```java
# Read Me First

The following was discovered as part of building this project:

- The original package name 'br.com.legalconnect.auth.auth-service' is invalid and this project uses 'br.com.legalconnect.auth.auth_service' instead.

# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

- [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
- [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
- [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.

docker run --name jusplatform_db -e POSTGRES_DB=jusplatform_db -e POSTGRES_USER=jususer -e POSTGRES_PASSWORD=juspassword -p 5432:5432 -d postgres

```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version> <!-- Mantendo 3.2.5 para consistência com o Gateway, mas você pode usar
        3.2.12 se preferir -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>
    <groupId>br.com.legalconnect</groupId>
    <artifactId>legalconnect-marketplace</artifactId> <!-- Certifique-se de que o artifactId está correto para o auth-service -->
    <version>0.0.1-SNAPSHOT</version>
    <name>legalconnect-marketplace</name>
    <description>Authentication Microservice for LegalConnect</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>

        <jjwt.version>0.11.5</jjwt.version>
        <flyway.version>11.8.2</flyway.version>
        <lombok.version>1.18.30</lombok.version>
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version>
        <springdoc.version>2.5.0</springdoc.version>
    </properties>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- MapStruct for DTO-Entity mapping -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${org.mapstruct.version}</version>
            <scope>provided</scope>
        </dependency>

        <!-- common-lib (se aplicável, mantenha a versão correta) -->
        <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-lib</artifactId>
            <version>1.0.1</version>
        </dependency>

        <dependency>
            <groupId>br.com.legalconnect.common</groupId> <!-- GroupId da biblioteca -->
            <artifactId>common-role</artifactId> <!-- ArtifactId da biblioteca -->
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
        <!-- Lombok for boilerplate code reduction -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- OpenAPI/Swagger UI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Jackson for JSON processing (used by JwtAuthEntryPoint) -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>


    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <!-- Plugin para MapStruct -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <arg>-Amapstruct.defaultComponentModel=spring</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "LegalMarketplaceApplication",
      "request": "launch",
      "mainClass": "br.com.legalconnect.LegalMarketplaceApplication",
      "projectName": "legalconnect-usuario-service"
    },
    {
      "type": "java",
      "name": "Spring Boot-AuthServiceApplication<legalconnect-usuario-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.AuthServiceApplication",
      "projectName": "legalconnect-usuario-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    },
    {
      "type": "java",
      "name": "Spring Boot-LegalUsuarioApplication<legalconnect-usuario-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.LegalUsuarioApplication",
      "projectName": "legalconnect-usuario-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    },
    {
      "type": "java",
      "name": "Spring Boot-LegalLegalMarketplaceApplication<legalconnect-usuario-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.LegalLegalMarketplaceApplication",
      "projectName": "legalconnect-usuario-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env",
      "vmArgs": " -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=62457 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dspring.jmx.enabled=true -Djava.rmi.server.hostname=localhost -Dspring.application.admin.enabled=true -Dspring.boot.project.name=legalconnect-usuario-service"
    },
    {
      "type": "java",
      "name": "Spring Boot-LegalMarketplaceApplication<legal-marketplace>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.LegalMarketplaceApplication",
      "projectName": "legal-marketplace",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
{
  "java.configuration.updateBuildConfiguration": "interactive",
  "java.debug.settings.onBuildFailureProceed": true
}

```
```java
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableDiscoveryClient
@SpringBootApplication(scanBasePackages = "br.com.legalconnect")
@EntityScan(basePackages = {
        "br.com.legalconnect.depoimento.domain.model",
        "br.com.legalconnect.entity",
        "br.com.legalconnect.patrocinio.domain"
})
@EnableJpaRepositories(basePackages = {
        "br.com.legalconnect.depoimento.repository",
        "br.com.legalconnect.patrocinio.repository"
})
public class LegalMarketplaceApplication {

    public static void main(String[] args) {
        SpringApplication.run(LegalMarketplaceApplication.class, args);
    }
}

```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.depoimento.domain.model.User.UserStatus;
import br.com.legalconnect.depoimento.domain.model.User.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
{
  "openapi": "3.0.1",
  "info": { "title": "OpenAPI definition", "version": "v0" },
  "servers": [
    { "url": "http://localhost:49784", "description": "Generated server url" }
  ],
  "tags": [
    {
      "name": "Depoimentos",
      "description": "Gerenciamento de depoimentos para o marketplace jurídico"
    }
  ],
  "paths": {
    "/api/v1/publico/depoimentos/{id}": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Busca um depoimento por ID (administração)",
        "description": "Retorna um depoimento específico pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "buscarDepoimentoPorIdAdmin",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser buscado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento encontrado",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      },
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Atualiza um depoimento existente",
        "description": "Atualiza os dados de um depoimento pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "atualizarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser atualizado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "requestBody": {
          "description": "Dados atualizados do depoimento",
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/DepoimentoRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Depoimento atualizado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Requisição inválida",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      },
      "delete": {
        "tags": ["Depoimentos"],
        "summary": "Exclui um depoimento",
        "description": "Exclui um depoimento permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "excluirDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser excluído",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "204": {
            "description": "Depoimento excluído com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Lista depoimentos para a página inicial",
        "description": "Retorna uma lista de depoimentos aprovados, com opções de limite e ordenação aleatória.",
        "operationId": "listarParaHome",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Número máximo de depoimentos a serem retornados (padrão: 5)",
            "required": false,
            "schema": { "type": "integer", "format": "int32", "default": 5 },
            "example": 5
          },
          {
            "name": "random",
            "in": "query",
            "description": "Indica se os depoimentos devem ser aleatórios (padrão: false)",
            "required": false,
            "schema": { "type": "boolean", "default": false },
            "example": true
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimentos listados com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Depoimentos"],
        "summary": "Cria um novo depoimento",
        "description": "Cria um novo depoimento no sistema. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "criarDepoimento",
        "parameters": [
          {
            "name": "X-Correlation-ID",
            "in": "header",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "description": "Dados do depoimento a ser criado",
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/DepoimentoRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Depoimento criado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Requisição inválida",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/{id}/reprovar": {
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Reprova um depoimento",
        "description": "Altera o status de um depoimento para 'REPROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "reprovarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser reprovado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento reprovado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/{id}/aprovar": {
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Aprova um depoimento",
        "description": "Altera o status de um depoimento para 'APROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "aprovarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser aprovado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento aprovado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/todos": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Lista todos os depoimentos (administração)",
        "description": "Retorna uma lista completa de todos os depoimentos, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "listarTodosAdmin",
        "responses": {
          "200": {
            "description": "Todos os depoimentos listados para administração",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    }
  },
  "components": {
    "schemas": {
      "DepoimentoRequestDTO": {
        "required": ["nome", "texto", "tipoDepoimento", "userId"],
        "type": "object",
        "properties": {
          "texto": { "maxLength": 500, "minLength": 0, "type": "string" },
          "nome": { "maxLength": 100, "minLength": 0, "type": "string" },
          "local": { "maxLength": 100, "minLength": 0, "type": "string" },
          "fotoUrl": {
            "maxLength": 255,
            "minLength": 0,
            "pattern": "^(https?|ftp)://[^ /$.?#].[^ ]*$",
            "type": "string"
          },
          "userId": { "type": "string", "format": "uuid" },
          "tipoDepoimento": {
            "pattern": "CLIENTE|PROFISSIONAL",
            "type": "string"
          },
          "status": {
            "pattern": "PENDENTE|APROVADO|REPROVADO",
            "type": "string"
          }
        }
      },
      "DepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "texto": { "type": "string" },
          "nome": { "type": "string" },
          "local": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "userId": { "type": "string", "format": "uuid" },
          "tipoDepoimento": { "type": "string" },
          "status": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "BaseResponseDepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/DepoimentoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListDepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/DepoimentoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}

```
```java
package br.com.legalconnect.depoimento.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping; // Adicionada a importação para @RequestMapping no nível da classe
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.depoimento.dto.DepoimentoRequestDTO;
import br.com.legalconnect.depoimento.dto.DepoimentoResponseDTO;
import br.com.legalconnect.depoimento.service.DepoimentoAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement; // Para segurança JWT
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

/**
 * Controlador REST para o módulo de Depoimentos.
 * Gerencia endpoints públicos e de administração (com segurança).
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/marketplace/depoimentos") // Mover o prefixo da URL para o nível da classe
@Tag(name = "Depoimentos", description = "Gerenciamento de depoimentos para o marketplace jurídico")
public class DepoimentoController {

        private final DepoimentoAppService appService;

        @Operation(summary = "Lista depoimentos para a página inicial", description = "Retorna uma lista de depoimentos aprovados, com opções de limite e ordenação aleatória.", parameters = {
                        @Parameter(name = "limit", description = "Número máximo de depoimentos a serem retornados (padrão: 5)", example = "5"),
                        @Parameter(name = "random", description = "Indica se os depoimentos devem ser aleatórios (padrão: false)", example = "true")
        }, responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimentos listados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class)))
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<DepoimentoResponseDTO>>> listarParaHome(
                        @RequestParam(defaultValue = "5") int limit,
                        @RequestParam(defaultValue = "false") boolean random) {
                List<DepoimentoResponseDTO> depoimentos = appService.listarParaHome(limit, random);
                return ResponseEntity.ok(BaseResponse.<List<DepoimentoResponseDTO>>builder()
                                .data(depoimentos)
                                .message("Depoimentos listados com sucesso.")
                                .build());
        }

        @Operation(summary = "Cria um novo depoimento", description = "Cria um novo depoimento no sistema. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Dados do depoimento a ser criado", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoRequestDTO.class))), responses = {
                        @ApiResponse(responseCode = "201", description = "Depoimento criado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth")) // Referência ao esquema de segurança JWT
        @PostMapping("/publico/depoimentos")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> criarDepoimento(
                        @RequestBody @Valid DepoimentoRequestDTO request,
                        @RequestHeader("X-Correlation-ID") String userId) {
                request.setUserId(UUID.fromString(userId));
                DepoimentoResponseDTO novoDepoimento = appService.criarDepoimento(request);
                return ResponseEntity.status(HttpStatus.CREATED).body(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(novoDepoimento)
                                .message("Depoimento criado com sucesso.")
                                .build());
        }

        @Operation(summary = "Atualiza um depoimento existente", description = "Atualiza os dados de um depoimento pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser atualizado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Dados atualizados do depoimento", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoRequestDTO.class))), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento atualizado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> atualizarDepoimento(
                        @PathVariable UUID id,
                        @RequestBody @Valid DepoimentoRequestDTO request) {
                DepoimentoResponseDTO depoimentoAtualizado = appService.atualizarDepoimento(id, request);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoAtualizado)
                                .message("Depoimento atualizado com sucesso.")
                                .build());
        }

        @Operation(summary = "Exclui um depoimento", description = "Exclui um depoimento permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser excluído", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "204", description = "Depoimento excluído com sucesso"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @DeleteMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<Void>> excluirDepoimento(@PathVariable UUID id) {
                appService.excluirDepoimento(id);
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(BaseResponse.<Void>builder()
                                .message("Depoimento excluído com sucesso.")
                                .build());
        }

        @Operation(summary = "Aprova um depoimento", description = "Altera o status de um depoimento para 'APROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser aprovado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento aprovado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}/aprovar")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> aprovarDepoimento(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimentoAprovado = appService.aprovarDepoimento(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoAprovado)
                                .message("Depoimento aprovado com sucesso.")
                                .build());
        }

        @Operation(summary = "Reprova um depoimento", description = "Altera o status de um depoimento para 'REPROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser reprovado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento reprovado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}/reprovar")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> reprovarDepoimento(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimentoReprovado = appService.reprovarDepoimento(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoReprovado)
                                .message("Depoimento reprovado com sucesso.")
                                .build());
        }

        @Operation(summary = "Lista todos os depoimentos (administração)", description = "Retorna uma lista completa de todos os depoimentos, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Todos os depoimentos listados para administração", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping("/publico/depoimentos/todos")
        public ResponseEntity<BaseResponse<List<DepoimentoResponseDTO>>> listarTodosAdmin() {
                List<DepoimentoResponseDTO> depoimentos = appService.listarTodos();
                return ResponseEntity.ok(BaseResponse.<List<DepoimentoResponseDTO>>builder()
                                .data(depoimentos)
                                .message("Todos os depoimentos listados para administração.")
                                .build());
        }

        @Operation(summary = "Busca um depoimento por ID (administração)", description = "Retorna um depoimento específico pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser buscado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento encontrado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> buscarDepoimentoPorIdAdmin(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimento = appService.buscarPorId(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimento)
                                .message("Depoimento encontrado.")
                                .build());
        }
}

```
```java
package br.com.legalconnect.depoimento.domain.enums;

/**
 * Enum para definir o status de um depoimento.
 */
public enum DepoimentoStatus {
    PENDENTE, // Depoimento enviado, aguardando revisão
    APROVADO, // Depoimento revisado e aprovado, pode ser exibido
    REPROVADO // Depoimento revisado e reprovado, não será exibido
}
```
```java
package br.com.legalconnect.depoimento.domain.enums;

/**
 * Enum para definir o tipo de depoimento (CLIENTE ou PROFISSIONAL).
 */
public enum TipoDepoimento {
    CLIENTE,
    PROFISSIONAL
}
```
```java
package br.com.legalconnect.depoimento.domain.model; // CORRETO - 'marketplace' adicionado

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Entidade JPA para representar um depoimento.
 * Inclui associação com o usuário, o tipo de depoimento e seu status.
 */
@Entity
@Table(name = "tb_depoimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Depoimento extends BaseEntity { // O campo 'id' e suas anotações já são herdados de BaseEntity e não
                                             // precisam ser redeclarados aqui.

    @Column(nullable = false, length = 500)
    private String texto;

    @Column(nullable = false, length = 100)
    private String nome; // Nome da pessoa que deu o depoimento

    @Column(length = 100)
    private String local; // Cidade/Estado ou empresa

    @Column(name = "foto_url", length = 255)
    private String fotoUrl; // URL da foto do depoente

    @Column(name = "user_id", nullable = false)
    private UUID userId; // ID do usuário (cliente ou profissional) relacionado ao depoimento

    @Enumerated(EnumType.STRING) // Armazena o enum como String no banco de dados
    @Column(name = "tipo_depoimento", nullable = false, length = 20)
    private TipoDepoimento tipoDepoimento; // Tipo: CLIENTE ou PROFISSIONAL

    @Enumerated(EnumType.STRING) // Armazena o enum como String no banco de dados
    @Column(name = "status", nullable = false, length = 20)
    @Builder.Default // Define um valor padrão para o Builder
    private DepoimentoStatus status = DepoimentoStatus.PENDENTE; // Status inicial PENDENTE
}

```
```java
package br.com.legalconnect.depoimento.domain.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.depoimento.domain.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.stereotype.Service;

import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;
import br.com.legalconnect.depoimento.repository.DepoimentoJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de domínio para gerenciar operações relacionadas a Depoimentos.
 * Contém a lógica de negócio principal e interage diretamente com o
 * repositório.
 * Este serviço deve focar nas operações sobre o agregado de Depoimento, não em
 * casos de uso específicos.
 */
@Service
@RequiredArgsConstructor
public class DepoimentoService {

    private final DepoimentoJpaRepository repository;

    /**
     * Salva um novo depoimento.
     * 
     * @param novoDepoimento A entidade Depoimento a ser salva.
     * @return O depoimento salvo.
     */
    public Depoimento salvar(Depoimento novoDepoimento) {
        return repository.save(novoDepoimento);
    }

    /**
     * Atualiza um depoimento existente.
     * 
     * @param id                   O ID do depoimento a ser atualizado.
     * @param depoimentoAtualizado A entidade Depoimento com os dados atualizados.
     * @return O depoimento atualizado.
     */
    public Optional<Depoimento> atualizar(UUID id, Depoimento depoimentoAtualizado) {
        return repository.findById(id).map(depoimento -> {
            depoimento.setTexto(depoimentoAtualizado.getTexto());
            depoimento.setNome(depoimentoAtualizado.getNome());
            depoimento.setLocal(depoimentoAtualizado.getLocal());
            depoimento.setFotoUrl(depoimentoAtualizado.getFotoUrl());
            depoimento.setUserId(depoimentoAtualizado.getUserId());
            depoimento.setTipoDepoimento(depoimentoAtualizado.getTipoDepoimento());
            depoimento.setStatus(depoimentoAtualizado.getStatus()); // Atualiza o status
            return repository.save(depoimento);
        });
    }

    /**
     * Altera o status de um depoimento.
     * 
     * @param id         O ID do depoimento.
     * @param novoStatus O novo status a ser atribuído.
     * @return Um Optional contendo o depoimento atualizado, se encontrado.
     */
    public Optional<Depoimento> alterarStatus(UUID id, DepoimentoStatus novoStatus) {
        return repository.findById(id).map(depoimento -> {
            depoimento.setStatus(novoStatus);
            return repository.save(depoimento);
        });
    }

    /**
     * Exclui um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento a ser excluído.
     */
    public void excluir(UUID id) {
        repository.deleteById(id);
    }

    /**
     * Busca um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento.
     * @return Um Optional contendo o depoimento, se encontrado.
     */
    public Optional<Depoimento> buscarPorId(UUID id) {
        return repository.findById(id);
    }

    /**
     * Lista todos os depoimentos.
     * 
     * @return Uma lista de todos os depoimentos.
     */
    public List<Depoimento> listarTodos() {
        return repository.findAll();
    }

    /**
     * Lista depoimentos por tipo.
     * 
     * @param tipo O tipo de depoimento (CLIENTE ou PROFISSIONAL).
     * @return Uma lista de depoimentos do tipo especificado.
     */
    public List<Depoimento> listarPorTipo(TipoDepoimento tipo) {
        return repository.findByTipoDepoimento(tipo);
    }

    /**
     * Lista depoimentos por ID de usuário.
     * 
     * @param userId O ID do usuário.
     * @return Uma lista de depoimentos associados ao usuário.
     */
    public List<Depoimento> listarPorUserId(UUID userId) {
        return repository.findByUserId(userId);
    }
}
```
```java
package br.com.legalconnect.depoimento.dto;

import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para requisições de criação/atualização de depoimentos.
 * Inclui validações para garantir a integridade dos dados.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepoimentoRequestDTO {

    @NotBlank(message = "O texto do depoimento é obrigatório.")
    @Size(max = 500, message = "O texto do depoimento não pode exceder 500 caracteres.")
    private String texto;

    @NotBlank(message = "O nome é obrigatório.")
    @Size(max = 100, message = "O nome não pode exceder 100 caracteres.")
    private String nome;

    @Size(max = 100, message = "O local não pode exceder 100 caracteres.")
    private String local;

    @Size(max = 255, message = "A URL da foto não pode exceder 255 caracteres.")
    @Pattern(regexp = "^(https?|ftp)://[^\s/$.?#].[^\s]*$", message = "URL da foto inválida.")
    private String fotoUrl;

    @NotNull(message = "O ID do usuário é obrigatório.")
    private UUID userId;

    @NotBlank(message = "O tipo de depoimento é obrigatório.")
    @Pattern(regexp = "CLIENTE|PROFISSIONAL", message = "O tipo de depoimento deve ser CLIENTE ou PROFISSIONAL.")
    private String tipoDepoimento; // Recebido como String e convertido para Enum no Mapper

    // Novo campo para o status do depoimento. Opcional na requisição para usuários
    // comuns.
    @Pattern(regexp = "PENDENTE|APROVADO|REPROVADO", message = "O status do depoimento deve ser PENDENTE, APROVADO ou REPROVADO.")
    private String status; // Recebido como String e convertido para Enum no Mapper
}
```
```java
package br.com.legalconnect.depoimento.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para respostas de depoimentos.
 * Expõe apenas os campos relevantes para o cliente da API.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepoimentoResponseDTO {
    private UUID id;
    private String texto;
    private String nome;
    private String local;
    private String fotoUrl;
    private UUID userId; // Expor o ID do usuário
    private String tipoDepoimento; // Expor o tipo como String
    private String status; // Expor o status como String
    private LocalDateTime createdAt; // Data de criação
    private LocalDateTime updatedAt; // Data de atualização
}
```
```java
package br.com.legalconnect.depoimento.repository;

import java.util.List;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;

/**
 * Repositório JPA para a entidade Depoimento, usando Spring Data JPA.
 * Define métodos para operações CRUD e consultas personalizadas.
 */
@Repository
public interface DepoimentoJpaRepository extends JpaRepository<Depoimento, UUID> {

    /**
     * Busca uma lista de depoimentos aleatórios, limitada pela quantidade
     * especificada, apenas os APROVADOS.
     * 
     * @param limite O número máximo de depoimentos a serem retornados.
     * @return Uma lista de depoimentos aleatórios.
     */
    @Query(value = "SELECT * FROM tb_depoimento WHERE status = 'APROVADO' ORDER BY random() LIMIT :limite", nativeQuery = true)
    List<Depoimento> buscarAleatoriosAprovados(@Param("limite") int limite);

    /**
     * Busca os 5 depoimentos APROVADOS mais recentes, ordenados pela data de
     * criação em ordem decrescente.
     * 
     * @param status O status do depoimento (APROVADO).
     * @return Uma lista dos 5 depoimentos mais recentes.
     */
    List<Depoimento> findTop5ByStatusOrderByCreatedAtDesc(DepoimentoStatus status);

    /**
     * Busca depoimentos por tipo de depoimento.
     * 
     * @param tipoDepoimento O tipo de depoimento (CLIENTE ou PROFISSIONAL).
     * @return Uma lista de depoimentos do tipo especificado.
     */
    List<Depoimento> findByTipoDepoimento(TipoDepoimento tipoDepoimento);

    /**
     * Busca depoimentos relacionados a um ID de usuário específico.
     * 
     * @param userId O ID do usuário.
     * @return Uma lista de depoimentos associados ao usuário.
     */
    List<Depoimento> findByUserId(UUID userId);

    /**
     * Busca depoimentos por status.
     * 
     * @param status O status do depoimento.
     * @return Uma lista de depoimentos com o status especificado.
     */
    List<Depoimento> findByStatus(DepoimentoStatus status);
}
```
```java
package br.com.legalconnect.depoimento.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.depoimento.domain.model.User;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

}
```
```java
package br.com.legalconnect.depoimento.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;
import br.com.legalconnect.depoimento.domain.service.DepoimentoService;
import br.com.legalconnect.depoimento.dto.DepoimentoRequestDTO;
import br.com.legalconnect.depoimento.dto.DepoimentoResponseDTO;
import br.com.legalconnect.depoimento.repository.DepoimentoJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de aplicação para o módulo de Depoimentos.
 * Orquestra operações entre DTOs, e o serviço de domínio, realizando mapeamento
 * manual com Builder.
 * Contém regras de negócio de alto nível e validações.
 */
@Service
@RequiredArgsConstructor
public class DepoimentoAppService {

    private final DepoimentoService domainService;
    private final DepoimentoJpaRepository repository;
    private final UserServiceImpl userService;

    /**
     * Converte um DepoimentoRequestDTO para uma entidade Depoimento.
     * 
     * @param dto O DTO de requisição.
     * @return A entidade Depoimento.
     */
    private Depoimento toEntity(DepoimentoRequestDTO dto) {
        return Depoimento.builder()
                .texto(dto.getTexto())
                .nome(dto.getNome())
                .local(dto.getLocal())
                .fotoUrl(dto.getFotoUrl())
                .userId(dto.getUserId())
                .tipoDepoimento(TipoDepoimento.valueOf(dto.getTipoDepoimento().toUpperCase()))
                // O status é definido posteriormente na lógica de negócio, não aqui
                .build();
    }

    /**
     * Converte uma entidade Depoimento para um DepoimentoResponseDTO.
     * 
     * @param entity A entidade Depoimento.
     * @return O DTO de resposta.
     */
    private DepoimentoResponseDTO toResponse(Depoimento entity) {
        return DepoimentoResponseDTO.builder()
                .id(entity.getId())
                .texto(entity.getTexto())
                .nome(entity.getNome())
                .local(entity.getLocal())
                .fotoUrl(entity.getFotoUrl())
                .userId(entity.getUserId())
                .tipoDepoimento(entity.getTipoDepoimento().name())
                .status(entity.getStatus().name())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }

    /**
     * Atualiza uma entidade Depoimento existente a partir de um DTO de requisição.
     * 
     * @param dto    O DTO de requisição.
     * @param entity A entidade a ser atualizada.
     */
    private void updateEntityFromDto(DepoimentoRequestDTO dto, Depoimento entity) {
        entity.setTexto(dto.getTexto());
        entity.setNome(dto.getNome());
        entity.setLocal(dto.getLocal());
        entity.setFotoUrl(dto.getFotoUrl());
        entity.setUserId(dto.getUserId());
        entity.setTipoDepoimento(TipoDepoimento.valueOf(dto.getTipoDepoimento().toUpperCase()));
        // O status é atualizado separadamente pela lógica de negócio no AppService
    }

    /**
     * Converte uma String para DepoimentoStatus.
     * 
     * @param status String do status.
     * @return DepoimentoStatus ou null se a string for nula ou vazia.
     */
    private DepoimentoStatus mapStringToDepoimentoStatus(String status) {
        return (status != null && !status.isEmpty()) ? DepoimentoStatus.valueOf(status.toUpperCase()) : null;
    }

    /**
     * Cria um novo depoimento a partir de um DTO de requisição.
     * Implementa regras de negócio para status e validação de usuário.
     * 
     * @param request O DTO contendo os dados do novo depoimento.
     * @return O DTO de resposta do depoimento criado.
     * @throws BusinessException se o texto do depoimento for muito longo,
     *                           o usuário não for encontrado ou o status inicial
     *                           for inválido.
     */
    public DepoimentoResponseDTO criarDepoimento(DepoimentoRequestDTO request) {
        if (request.getTexto().length() > 500) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, ErrorCode.DADOS_INVALIDOS.getMessage());
        }

        if (!userService.userExists(request.getUserId())) {
            throw new BusinessException(ErrorCode.USER_NAO_ENCONTRADO, ErrorCode.USER_NAO_ENCONTRADO.getMessage());
        }

        Depoimento depoimento = toEntity(request); // Usando o método toEntity manual

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdmin = authentication != null && authentication.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_PLATAFORMA_ADMIN"));

        if (!isAdmin && request.getStatus() != null
                && !request.getStatus().equalsIgnoreCase(DepoimentoStatus.PENDENTE.name())) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, ErrorCode.FORBIDDEN_ACCESS.getMessage());
        }

        if (request.getStatus() != null && isAdmin) {
            depoimento.setStatus(DepoimentoStatus.valueOf(request.getStatus().toUpperCase()));
        } else {
            depoimento.setStatus(DepoimentoStatus.PENDENTE);
        }

        Depoimento salvo = domainService.salvar(depoimento);
        return toResponse(salvo); // Usando o método toResponse manual
    }

    /**
     * Atualiza um depoimento existente.
     * 
     * @param id      O ID do depoimento a ser atualizado.
     * @param request O DTO contendo os dados atualizados.
     * @return O DTO de resposta do depoimento atualizado.
     * @throws BusinessException se o depoimento não for encontrado, o texto for
     *                           muito longo,
     *                           o usuário não for encontrado ou o status for
     *                           inválido para a operação.
     */
    public DepoimentoResponseDTO atualizarDepoimento(UUID id, DepoimentoRequestDTO request) {
        if (request.getTexto().length() > 500) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, ErrorCode.DADOS_INVALIDOS.getMessage());
        }

        if (!userService.userExists(request.getUserId())) {
            throw new BusinessException(ErrorCode.USER_NAO_ENCONTRADO, ErrorCode.USER_NAO_ENCONTRADO.getMessage());
        }

        return domainService.buscarPorId(id)
                .map(depoimentoExistente -> {
                    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
                    boolean isAdmin = authentication != null && authentication.getAuthorities().stream()
                            .anyMatch(a -> a.getAuthority().equals("ROLE_PLATAFORMA_ADMIN"));

                    DepoimentoStatus novoStatus = mapStringToDepoimentoStatus(request.getStatus());

                    if (novoStatus != null && novoStatus != depoimentoExistente.getStatus() && !isAdmin) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS,
                                ErrorCode.FORBIDDEN_ACCESS.getMessage());
                    }

                    updateEntityFromDto(request, depoimentoExistente); // Usando o método updateEntityFromDto manual
                    if (novoStatus != null && isAdmin) {
                        depoimentoExistente.setStatus(novoStatus);
                    }

                    return toResponse(domainService.salvar(depoimentoExistente)); // Usando o método toResponse manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Exclui um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento a ser excluído.
     * @throws BusinessException se o depoimento não for encontrado.
     */
    public void excluirDepoimento(UUID id) {
        if (!domainService.buscarPorId(id).isPresent()) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                    ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage());
        }
        domainService.excluir(id);
    }

    /**
     * Aprova um depoimento. Apenas administradores podem realizar esta operação.
     * 
     * @param id O ID do depoimento a ser aprovado.
     * @return O DTO do depoimento aprovado.
     * @throws BusinessException se o depoimento não for encontrado ou se o status
     *                           já for APROVADO.
     */
    public DepoimentoResponseDTO aprovarDepoimento(UUID id) {
        return domainService.buscarPorId(id)
                .map(depoimento -> {
                    if (depoimento.getStatus() == DepoimentoStatus.APROVADO) {
                        // throw new BusinessException(ErrorCode.DEPOIMENTO_ALREADY_APPROVED,
                        // ErrorCode.DEPOIMENTO_ALREADY_APPROVED.getMessage());
                    }
                    return toResponse(domainService.alterarStatus(id, DepoimentoStatus.APROVADO).get()); // Usando o
                                                                                                         // método
                                                                                                         // toResponse
                                                                                                         // manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Reprova um depoimento. Apenas administradores podem realizar esta operação.
     * 
     * @param id O ID do depoimento a ser reprovado.
     * @return O DTO do depoimento reprovado.
     * @throws BusinessException se o depoimento não for encontrado ou se o status
     *                           já for REPROVADO.
     */
    public DepoimentoResponseDTO reprovarDepoimento(UUID id) {
        return domainService.buscarPorId(id)
                .map(depoimento -> {
                    if (depoimento.getStatus() == DepoimentoStatus.REPROVADO) {
                        // throw new BusinessException(ErrorCode.DEPOIMENTO_ALREADY_REJECTED,
                        // ErrorCode.DEPOIMENTO_ALREADY_REJECTED.getMessage());
                    }
                    return toResponse(domainService.alterarStatus(id, DepoimentoStatus.REPROVADO).get()); // Usando o
                                                                                                          // método
                                                                                                          // toResponse
                                                                                                          // manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Lista todos os depoimentos, convertendo-os para DTOs de resposta.
     * 
     * @return Uma lista de DTOs de resposta de depoimentos.
     */
    public List<DepoimentoResponseDTO> listarTodos() {
        return domainService.listarTodos().stream()
                .map(this::toResponse) // Usando o método toResponse manual
                .collect(Collectors.toList());
    }

    /**
     * Busca um depoimento pelo seu ID e o converte para DTO de resposta.
     * 
     * @param id O ID do depoimento.
     * @return O DTO de resposta do depoimento.
     * @throws BusinessException se o depoimento não for encontrado.
     */
    public DepoimentoResponseDTO buscarPorId(UUID id) {
        return domainService.buscarPorId(id)
                .map(this::toResponse) // Usando o método toResponse manual
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Lista depoimentos para a página inicial, com opções de limite e
     * aleatoriedade.
     * Esta é uma responsabilidade do AppService, pois é um caso de uso específico.
     * 
     * @param limit  O número máximo de depoimentos a serem retornados.
     * @param random Booleano indicando se a busca deve ser aleatória.
     * @return Uma lista de DTOs de resposta de depoimentos.
     */
    public List<DepoimentoResponseDTO> listarParaHome(int limit, boolean random) {
        List<Depoimento> depoimentos;
        if (random) {
            depoimentos = repository.buscarAleatoriosAprovados(limit);
        } else {
            depoimentos = repository.findTop5ByStatusOrderByCreatedAtDesc(DepoimentoStatus.APROVADO);
        }
        return depoimentos.stream()
                .map(this::toResponse) // Usando o método toResponse manual
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.depoimento.service;

import java.util.UUID;

import org.springframework.stereotype.Service;

import br.com.legalconnect.depoimento.repository.UserRepository;
import lombok.RequiredArgsConstructor;

/**
 * Implementação mock do serviço de usuário para fins de demonstração.
 * Em uma aplicação real, esta classe faria a comunicação com o repositório de
 * usuários
 * ou outro serviço de identidade.
 */
@Service
@RequiredArgsConstructor
public class UserServiceImpl {

    private final UserRepository userRepository;

    public boolean userExists(UUID userId) {
        // Lógica mock: Em uma aplicação real, você consultaria o UserRepository aqui.
        // Para este exemplo, verifica se o ID está no conjunto de IDs simulados.
        return userRepository.existsById(userId);

    }
}
```
```java
//
// Controlador REST para gerenciar os patrocinadores do marketplace jurídico.
// Este controlador lida com os endpoints de administração.
//
package br.com.legalconnect.patrocinio.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.patrocinio.dto.DestaquesRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import br.com.legalconnect.patrocinio.service.PatrocinioAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

/**
 * Controlador REST para os endpoints de gerenciamento de patrocinadores
 * (admin).
 * Separado do controlador público para melhor organização e controle de acesso.
 */
@RestController
@RequiredArgsConstructor
@Tag(name = "Patrocínios (Admin)", description = "Endpoints para gerenciamento de patrocinadores no marketplace jurídico (acesso administrativo)")
@RequestMapping("/api/v1/marketplace/destaques")
@PreAuthorize("hasRole('ROLE_PLATAFORMA_ADMIN')")
public class AdminDestaquesController {

        private final PatrocinioAppService patrocinioAppService;

        /**
         * Endpoint privado para listar todos os patrocinadores, independentemente do
         * status.
         * Requer a role ROLE_PLATAFORMA_ADMIN.
         *
         * @return ResponseEntity contendo a lista completa de patrocinadores e uma
         *         resposta padrão.
         */
        @Operation(summary = "Lista todos os patrocinadores (administração)", description = "Retorna uma lista completa de todos os patrocinadores, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Todos os patrocinadores listados", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping
        public ResponseEntity<BaseResponse<List<DestaquesResponseDTO>>> getAllPatrocinios() {
                List<DestaquesResponseDTO> patrocinadores = patrocinioAppService.findAllPatrocinios();
                return ResponseEntity.ok(BaseResponse.<List<DestaquesResponseDTO>>builder()
                                .data(patrocinadores)
                                .message("Todos os patrocinadores listados.")
                                .build());
        }

        /**
         * Endpoint privado para criar um novo patrocinador.
         * A API aceita um DTO polimórfico, permitindo a criação de diferentes tipos de
         * patrocinadores.
         *
         * @param requestDTO DTO com os dados do novo patrocinador.
         * @return ResponseEntity com o patrocinador criado e uma resposta padrão.
         */
        @Operation(summary = "Cria um novo patrocinador", description = "Cria um novo patrocinador. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "201", description = "Patrocinador criado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PostMapping
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> createPatrocinio(
                        @RequestBody @Valid DestaquesRequestDTO requestDTO) {
                DestaquesResponseDTO novoPatrocinio = patrocinioAppService.createPatrocinio(requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED).body(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(novoPatrocinio)
                                .message("Patrocinador criado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para atualizar um patrocinador existente.
         * A API aceita um DTO polimórfico para a atualização.
         *
         * @param id         ID do patrocinador a ser atualizado.
         * @param requestDTO DTO com os dados atualizados.
         * @return ResponseEntity com o patrocinador atualizado e uma resposta padrão.
         */
        @Operation(summary = "Atualiza um patrocinador existente", description = "Atualiza um patrocinador pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Patrocinador atualizado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> updatePatrocinio(
                        @PathVariable UUID id,
                        @RequestBody @Valid DestaquesRequestDTO requestDTO) {
                DestaquesResponseDTO updatedPatrocinio = patrocinioAppService.updatePatrocinio(id, requestDTO);
                return ResponseEntity.ok(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(updatedPatrocinio)
                                .message("Patrocinador atualizado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para mudar o status de um patrocinador.
         *
         * @param id     ID do patrocinador.
         * @param status O novo status (e.g., "ACTIVE", "INACTIVE").
         * @return ResponseEntity com o patrocinador atualizado e uma resposta padrão.
         */
        @Operation(summary = "Muda o status de um patrocinador", description = "Altera o status de um patrocinador (ex: de INACTIVE para ACTIVE). Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Status do patrocinador alterado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PatchMapping("/{id}/status")
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> updatePatrocinioStatus(
                        @PathVariable UUID id,
                        @RequestParam String status) {
                DestaquesResponseDTO updatedPatrocinio = patrocinioAppService.updatePatrocinioStatus(id, status);
                return ResponseEntity.ok(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(updatedPatrocinio)
                                .message("Status do patrocinador alterado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para excluir um patrocinador.
         *
         * @param id ID do patrocinador a ser excluído.
         * @return ResponseEntity com status 204 (No Content) em caso de sucesso.
         */
        @Operation(summary = "Exclui um patrocinador", description = "Exclui um patrocinador permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "204", description = "Patrocinador excluído com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deletePatrocinio(@PathVariable UUID id) {
                patrocinioAppService.deletePatrocinio(id);
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(BaseResponse.<Void>builder()
                                .message("Patrocinador excluído com sucesso.")
                                .build());
        }
}
```
```java
//
// Controlador REST para gerenciar os patrocinadores do marketplace jurídico.
// Este controlador é o ponto de entrada da API, lidando com as requisições HTTP
// e orquestrando o serviço de aplicação para executar a lógica de negócio.
//
package br.com.legalconnect.patrocinio.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import br.com.legalconnect.patrocinio.service.PatrocinioAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@Tag(name = "Patrocínios", description = "Endpoints para gerenciamento de patrocinadores no marketplace jurídico")
@RequestMapping("/api/v1/publico/marketplace/destaques")
public class DestaquesController {

        private final PatrocinioAppService patrocinioAppService;

        // =================================================================================================================
        // Endpoint Público
        // =================================================================================================================

        /**
         * Endpoint público para listar todos os patrocinadores com status ATIVO.
         * Retorna uma lista de DTOs polimórficos que podem representar diferentes tipos
         * de patrocínios (Eventos, Escritórios, etc.).
         *
         * @return ResponseEntity contendo a lista de patrocinadores ativos e uma
         *         resposta padrão.
         */
        @Operation(summary = "Lista patrocinadores ativos", description = "Retorna uma lista de patrocinadores com status ATIVO. A resposta pode conter diferentes tipos de patrocinadores.", responses = {
                        @ApiResponse(responseCode = "200", description = "Patrocinadores ativos listados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class)))
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<DestaquesResponseDTO>>> getActivePatrocinios() {
                List<DestaquesResponseDTO> patrocinadores = patrocinioAppService.findActivePatrocinios();
                return ResponseEntity.ok(BaseResponse.<List<DestaquesResponseDTO>>builder()
                                .data(patrocinadores)
                                .message("Patrocinadores ativos listados com sucesso.")
                                .build());
        }
}
```
```java

package br.com.legalconnect.patrocinio.domain;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("ESCRITORIO")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorio extends DestaquesItem {
    @Column(length = 255)
    private String nome;
    @Column(length = 255)
    private String slogan;
    @Column(name = "logo_url", length = 255)
    private String logoUrl;

    @PostLoad
    public void setTipo() {
        this.tipo = "ESCRITORIO";
    }
}
```
```java
//
// Entidade JPA para um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("EVENTO")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesEvento extends DestaquesItem {
    @Column(length = 255)
    private String titulo;
    private LocalDateTime dataEvento;
    @Column(name = "imagem_url", length = 255)
    private String imagemUrl;

    @PostLoad
    public void setTipo() {
        this.tipo = "EVENTO";
    }
}
```
```java
//
// Entidade base abstrata JPA para representar um item de patrocínio.
// Usa herança de tabela única (@Inheritance) para persistir todos os tipos de patrocínio em uma única tabela.
//
package br.com.legalconnect.patrocinio.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorColumn;
import jakarta.persistence.DiscriminatorType;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * Entidade JPA base abstrata para itens de patrocínio.
 * Usa herança de tabela única (@Inheritance) para centralizar todos os
 * patrocínios em uma única tabela.
 * O campo 'tipo' atua como o discriminador.
 */
@Entity
@Table(name = "tb_patrocinio")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "tipo", discriminatorType = DiscriminatorType.STRING)
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public abstract class DestaquesItem extends BaseEntity {

    @Column(name = "tipo", insertable = false, updatable = false)
    protected String tipo;

    @Column(nullable = false, length = 255)
    protected String link;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    protected PatrocinioStatus status;
}
```
```java
//
// Entidade JPA para um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("NOTICIA")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticia extends DestaquesItem {
    @Column(length = 255)
    private String titulo;
    @Column(name = "imagem_url", length = 255)
    private String imagemUrl;
    @Column(name = "data_publicacao")
    private LocalDateTime dataPublicacao;

    @PostLoad
    public void setTipo() {
        this.tipo = "NOTICIA";
    }
}
```
```java
//
// Enum para o status dos patrocinadores.
//
package br.com.legalconnect.patrocinio.domain.enums;

/**
 * Define os possíveis status de um patrocinador.
 */
public enum PatrocinioStatus {
    ACTIVE,   // Patrocinador está ativo e pode ser exibido.
    INACTIVE  // Patrocinador está inativo e não deve ser exibido.
}
```
```java
//
// DTO específico para um patrocínio de escritório.
//
package br.com.legalconnect.patrocinio.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorioRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O nome do escritório é obrigatório.")
    private String nome;
    @NotBlank(message = "O slogan do escritório é obrigatório.")
    private String slogan;
    @Size(max = 255, message = "A URL da logo deve ter no máximo 255 caracteres.")
    private String logoUrl; // Opcional, se não houver, pode ser usado um placeholder
}
```
```java
//
// DTO específico para a resposta de um patrocínio de escritório.
//
package br.com.legalconnect.patrocinio.dto;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorioResponseDTO extends DestaquesResponseDTO {
    private String nome;
    private String slogan;
    private String logoUrl;
}
```
```java
//
// DTO específico para um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEventoRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O título do evento é obrigatório.")
    private String titulo;
    @NotNull(message = "A data do evento é obrigatória.")
    private LocalDateTime dataEvento;
    @NotBlank(message = "A URL da imagem é obrigatória.")
    private String imagemUrl;
}
```
```java
//
// DTO específico para a resposta de um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEventoResponseDTO extends DestaquesResponseDTO {
    private String titulo;
    private LocalDateTime dataEvento;
    private String imagemUrl;
}
```
```java
//
// DTO específico para um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticiaRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O título da notícia é obrigatório.")
    private String titulo;
    @NotBlank(message = "A URL da imagem é obrigatória.")
    private String imagemUrl;
    @NotNull(message = "A data de publicação da notícia é obrigatória.")
    private LocalDateTime dataPublicacao;
}
```
```java
//
// DTO específico para a resposta de um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticiaResponseDTO extends DestaquesResponseDTO {
    private String titulo;
    private String imagemUrl;
    private LocalDateTime dataPublicacao;
}
```
```java
//
// DTO para a requisição de criação/atualização de patrocinadores.
// A anotação @JsonTypeInfo permite que o Spring determine qual classe de DTO
// concreta deve ser usada com base no valor do campo 'tipo'.
//
package br.com.legalconnect.patrocinio.dto;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.experimental.SuperBuilder;

/**
 * DTO base polimórfico para a requisição de criação e atualização de
 * patrocinadores.
 * A API usará este DTO para deserializar diferentes tipos de patrocinadores.
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "tipo")
@JsonSubTypes({
                @JsonSubTypes.Type(value = DestaquesEventoRequestDTO.class, name = "EVENTO"),
                @JsonSubTypes.Type(value = DestaquesEscritorioRequestDTO.class, name = "ESCRITORIO"),
                @JsonSubTypes.Type(value = DestaquesNoticiaRequestDTO.class, name = "NOTICIA")
})
@Data
@SuperBuilder
public abstract class DestaquesRequestDTO {
        @NotBlank(message = "O tipo de patrocínio é obrigatório.")
        protected String tipo; // EVENTO, ESCRITORIO, NOTICIA
        @NotBlank(message = "O link é obrigatório.")
        protected String link;
        protected String status;
}
```
```java
//
// DTO base polimórfico para a resposta da API de patrocinadores.
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import lombok.Data;
import lombok.experimental.SuperBuilder;

/**
 * DTO base polimórfico para a resposta da API de patrocinadores.
 * Utiliza o campo 'tipo' como discriminador para serializar o objeto correto.
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "tipo")
@JsonSubTypes({
                @JsonSubTypes.Type(value = DestaquesEventoResponseDTO.class, name = "EVENTO"),
                @JsonSubTypes.Type(value = DestaquesEscritorioResponseDTO.class, name = "ESCRITORIO"),
                @JsonSubTypes.Type(value = DestaquesNoticiaResponseDTO.class, name = "NOTICIA")
})
@Data
@SuperBuilder
public abstract class DestaquesResponseDTO {
        protected UUID id;
        protected String tipo;
        protected String link;
        protected String status;
        protected LocalDateTime createdAt;
        protected LocalDateTime updatedAt;
}
```
```java
//
// Repositório JPA genérico para a entidade base PatrocinioItem.
//
package br.com.legalconnect.patrocinio.repository;

import java.util.List;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;

/**
 * Repositório Spring Data JPA para a entidade base PatrocinioItem.
 * Através do polimorfismo, este repositório pode lidar com todos os tipos de
 * patrocínios.
 */
@Repository
public interface DestaquesJpaRepository extends JpaRepository<DestaquesItem, UUID> {
    /**
     * Busca uma lista de patrocinadores pelo seu status.
     *
     * @param status O status do patrocinador (ACTIVE ou INACTIVE).
     * @return Uma lista de patrocinadores com o status especificado.
     */
    List<DestaquesItem> findByStatus(PatrocinioStatus status);
}
```
```java
//
// Serviço de domínio que interage com o repositório JPA de patrocinadores.
// Contém a lógica de negócio principal e a comunicação direta com a camada de infraestrutura (repositórios).
//
package br.com.legalconnect.patrocinio.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.patrocinio.domain.DestaquesEscritorio;
import br.com.legalconnect.patrocinio.domain.DestaquesEvento;
import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.DestaquesNoticia;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import br.com.legalconnect.patrocinio.repository.DestaquesJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de domínio responsável por gerenciar a persistência dos
 * patrocinadores.
 * Esta camada deve ser agnóstica à API e se concentrar em operações de dados.
 */
@Service
@RequiredArgsConstructor
public class DestaquesDomainService {

    private static final Logger log = LoggerFactory.getLogger(DestaquesDomainService.class);
    private final DestaquesJpaRepository repository;

    /**
     * Busca todos os patrocinadores com status ATIVO.
     *
     * @return Uma lista de entidades PatrocinioItem com o status ATIVO.
     */
    public List<DestaquesItem> findActivePatrocinios() {
        log.debug("Buscando patrocinadores ativos no repositório.");
        return repository.findByStatus(PatrocinioStatus.ACTIVE);
    }

    /**
     * Busca todos os patrocinadores, independente do status.
     *
     * @return Uma lista de todas as entidades PatrocinioItem.
     */
    public List<DestaquesItem> findAllPatrocinios() {
        log.debug("Buscando todos os patrocinadores no repositório.");
        return repository.findAll();
    }

    /**
     * Busca um patrocinador pelo seu ID.
     *
     * @param id O ID do patrocinador.
     * @return Um Optional contendo a entidade PatrocinioItem, se encontrada.
     */
    public Optional<DestaquesItem> findPatrocinioById(UUID id) {
        log.debug("Buscando patrocinador por ID: {}", id);
        return repository.findById(id);
    }

    /**
     * Cria um novo patrocinador no banco de dados.
     *
     * @param patrocinio A entidade PatrocinioItem a ser salva.
     * @return A entidade PatrocinioItem salva, com o ID gerado.
     */
    public DestaquesItem createPatrocinio(DestaquesItem patrocinio) {
        log.info("Salvando novo patrocinador do tipo {}: {}", patrocinio.getTipo(), patrocinio.toString());
        return repository.save(patrocinio);
    }

    /**
     * Atualiza um patrocinador existente.
     *
     * @param id                O ID da entidade a ser atualizada.
     * @param updatedPatrocinio A entidade PatrocinioItem com os dados atualizados.
     * @return A entidade PatrocinioItem salva.
     */
    public DestaquesItem updatePatrocinio(UUID id, DestaquesItem updatedPatrocinio) {
        log.info("Atualizando patrocinador com ID: {}", id);
        return repository.findById(id).map(existing -> {
            // A lógica de atualização é genérica, mas a JPA cuida do tipo concreto
            existing.setLink(updatedPatrocinio.getLink());
            existing.setStatus(updatedPatrocinio.getStatus());

            // A cópia dos dados específicos para cada tipo de patrocínio
            if (existing instanceof DestaquesEvento && updatedPatrocinio instanceof DestaquesEvento) {
                DestaquesEvento existingEvento = (DestaquesEvento) existing;
                DestaquesEvento updatedEvento = (DestaquesEvento) updatedPatrocinio;
                existingEvento.setTitulo(updatedEvento.getTitulo());
                existingEvento.setDataEvento(updatedEvento.getDataEvento());
                existingEvento.setImagemUrl(updatedEvento.getImagemUrl());
            } else if (existing instanceof DestaquesEscritorio && updatedPatrocinio instanceof DestaquesEscritorio) {
                DestaquesEscritorio existingEscritorio = (DestaquesEscritorio) existing;
                DestaquesEscritorio updatedEscritorio = (DestaquesEscritorio) updatedPatrocinio;
                existingEscritorio.setNome(updatedEscritorio.getNome());
                existingEscritorio.setSlogan(updatedEscritorio.getSlogan());
                existingEscritorio.setLogoUrl(updatedEscritorio.getLogoUrl());
            } else if (existing instanceof DestaquesNoticia && updatedPatrocinio instanceof DestaquesNoticia) {
                DestaquesNoticia existingNoticia = (DestaquesNoticia) existing;
                DestaquesNoticia updatedNoticia = (DestaquesNoticia) updatedPatrocinio;
                existingNoticia.setTitulo(updatedNoticia.getTitulo());
                existingNoticia.setImagemUrl(updatedNoticia.getImagemUrl());
                existingNoticia.setDataPublicacao(updatedNoticia.getDataPublicacao());
            } else {
                throw new BusinessException(ErrorCode.DADOS_INVALIDOS,
                        "Tentativa de atualizar um tipo de patrocínio com dados incompatíveis.");
            }
            return repository.save(existing);
        }).orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));
    }

    /**
     * Altera o status de um patrocinador.
     *
     * @param id     ID do patrocinador.
     * @param status O novo status.
     * @return A entidade PatrocinioItem com o status alterado.
     * @throws BusinessException se o patrocinador não for encontrado.
     */
    public DestaquesItem updatePatrocinioStatus(UUID id, PatrocinioStatus status) {
        log.info("Tentando alterar o status do patrocinador {} para {}", id, status);
        return repository.findById(id)
                .map(patrocinio -> {
                    patrocinio.setStatus(status);
                    return repository.save(patrocinio);
                })
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));
    }

    /**
     * Exclui um patrocinador pelo ID.
     *
     * @param id O ID do patrocinador a ser excluído.
     * @throws BusinessException se o patrocinador não for encontrado.
     */
    public void deletePatrocinio(UUID id) {
        log.info("Excluindo patrocinador com ID: {}", id);
        if (!repository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado.");
        }
        repository.deleteById(id);
    }
}
```
```java
//
// Serviço de aplicação para a lógica de negócio dos patrocinadores.
//
package br.com.legalconnect.patrocinio.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.patrocinio.domain.DestaquesEscritorio;
import br.com.legalconnect.patrocinio.domain.DestaquesEvento;
import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.DestaquesNoticia;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import br.com.legalconnect.patrocinio.dto.DestaquesEscritorioRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEscritorioResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEventoRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEventoResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesNoticiaRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesNoticiaResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de aplicação para gerenciar a lógica de negócio dos patrocinadores.
 * Atua como uma camada de tradução entre o mundo da API (DTOs) e o mundo do
 * domínio (entidades).
 * Contém a lógica de conversão entre DTOs e entidades de forma polimórfica.
 */
@Service
@RequiredArgsConstructor
public class PatrocinioAppService {

    private static final Logger log = LoggerFactory.getLogger(PatrocinioAppService.class);
    private final DestaquesDomainService domainService;

    /**
     * Converte uma entidade de domínio PatrocinioItem para um DTO de resposta
     * polimórfico.
     * 
     * @param entity A entidade a ser convertida.
     * @return O DTO de resposta.
     */
    private DestaquesResponseDTO toResponseDTO(DestaquesItem entity) {
        if (entity instanceof DestaquesEvento) {
            DestaquesEvento evento = (DestaquesEvento) entity;
            return DestaquesEventoResponseDTO.builder()
                    .id(evento.getId())
                    .tipo(evento.getTipo())
                    .link(evento.getLink())
                    .status(evento.getStatus().name())
                    .titulo(evento.getTitulo())
                    .dataEvento(evento.getDataEvento())
                    .imagemUrl(evento.getImagemUrl())
                    .createdAt(evento.getCreatedAt())
                    .updatedAt(evento.getUpdatedAt())
                    .build();
        } else if (entity instanceof DestaquesEscritorio) {
            DestaquesEscritorio escritorio = (DestaquesEscritorio) entity;
            return DestaquesEscritorioResponseDTO.builder()
                    .id(escritorio.getId())
                    .tipo(escritorio.getTipo())
                    .link(escritorio.getLink())
                    .status(escritorio.getStatus().name())
                    .nome(escritorio.getNome())
                    .slogan(escritorio.getSlogan())
                    .logoUrl(escritorio.getLogoUrl())
                    .createdAt(escritorio.getCreatedAt())
                    .updatedAt(escritorio.getUpdatedAt())
                    .build();
        } else if (entity instanceof DestaquesNoticia) {
            DestaquesNoticia noticia = (DestaquesNoticia) entity;
            return DestaquesNoticiaResponseDTO.builder()
                    .id(noticia.getId())
                    .tipo(noticia.getTipo())
                    .link(noticia.getLink())
                    .status(noticia.getStatus().name())
                    .titulo(noticia.getTitulo())
                    .imagemUrl(noticia.getImagemUrl())
                    .dataPublicacao(noticia.getDataPublicacao())
                    .createdAt(noticia.getCreatedAt())
                    .updatedAt(noticia.getUpdatedAt())
                    .build();
        }
        return null;
    }

    /**
     * Converte um DTO de requisição polimórfico para uma entidade de domínio
     * PatrocinioItem.
     * 
     * @param dto O DTO de requisição.
     * @param id  O ID da entidade (pode ser null para criação).
     * @return A entidade de domínio.
     */
    private DestaquesItem toEntity(DestaquesRequestDTO dto, UUID id) {
        PatrocinioStatus status = PatrocinioStatus.INACTIVE;
        if (dto.getStatus() != null) {
            try {
                status = PatrocinioStatus.valueOf(dto.getStatus().toUpperCase());
            } catch (IllegalArgumentException e) {
                log.warn("Status inválido '{}' fornecido na requisição. Usando status padrão INACTIVE.",
                        dto.getStatus());
            }
        }

        if ("EVENTO".equalsIgnoreCase(dto.getTipo())) {
            DestaquesEventoRequestDTO eventoDto = (DestaquesEventoRequestDTO) dto;
            return DestaquesEvento.builder()
                    .id(id)
                    .link(eventoDto.getLink())
                    .status(status)
                    .titulo(eventoDto.getTitulo())
                    .dataEvento(eventoDto.getDataEvento())
                    .imagemUrl(eventoDto.getImagemUrl())
                    .build();
        } else if ("ESCRITORIO".equalsIgnoreCase(dto.getTipo())) {
            DestaquesEscritorioRequestDTO escritorioDto = (DestaquesEscritorioRequestDTO) dto;
            return DestaquesEscritorio.builder()
                    .id(id)
                    .link(escritorioDto.getLink())
                    .status(status)
                    .nome(escritorioDto.getNome())
                    .slogan(escritorioDto.getSlogan())
                    .logoUrl(escritorioDto.getLogoUrl())
                    .build();
        } else if ("NOTICIA".equalsIgnoreCase(dto.getTipo())) {
            DestaquesNoticiaRequestDTO noticiaDto = (DestaquesNoticiaRequestDTO) dto;
            return DestaquesNoticia.builder()
                    .id(id)
                    .link(noticiaDto.getLink())
                    .status(status)
                    .titulo(noticiaDto.getTitulo())
                    .imagemUrl(noticiaDto.getImagemUrl())
                    .dataPublicacao(noticiaDto.getDataPublicacao())
                    .build();
        }
        throw new BusinessException(ErrorCode.DADOS_INVALIDOS, "Tipo de patrocínio inválido.");
    }

    /**
     * Busca todos os patrocinadores com status ATIVO.
     *
     * @return Uma lista de DTOs de resposta de patrocinadores ativos.
     */
    public List<DestaquesResponseDTO> findActivePatrocinios() {
        log.info("Buscando patrocinadores ativos...");
        return domainService.findActivePatrocinios().stream()
                .map(this::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Busca todos os patrocinadores, independente do status.
     * Requer privilégios de administrador.
     *
     * @return Uma lista de DTOs de resposta de todos os patrocinadores.
     */
    public List<DestaquesResponseDTO> findAllPatrocinios() {
        log.info("Buscando todos os patrocinadores para administração...");
        return domainService.findAllPatrocinios().stream()
                .map(this::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Cria um novo patrocinador a partir de um DTO.
     *
     * @param requestDTO O DTO de requisição com os dados do patrocinador.
     * @return O DTO de resposta do patrocinador criado.
     */
    public DestaquesResponseDTO createPatrocinio(DestaquesRequestDTO requestDTO) {
        log.info("Iniciando a criação de um novo patrocinador do tipo: {}", requestDTO.getTipo());
        DestaquesItem newEntity = toEntity(requestDTO, null);
        DestaquesItem savedEntity = domainService.createPatrocinio(newEntity);
        log.info("Patrocinador criado com sucesso. ID: {}", savedEntity.getId());
        return toResponseDTO(savedEntity);
    }

    /**
     * Atualiza um patrocinador existente.
     *
     * @param id         ID do patrocinador a ser atualizado.
     * @param requestDTO O DTO de requisição com os dados atualizados.
     * @return O DTO de resposta do patrocinador atualizado.
     * @throws BusinessException se o patrocinador não for encontrado ou o status
     *                           for inválido.
     */
    public DestaquesResponseDTO updatePatrocinio(UUID id, DestaquesRequestDTO requestDTO) {
        log.info("Iniciando a atualização do patrocinador com ID: {}", id);
        DestaquesItem existingEntity = domainService.findPatrocinioById(id)
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));

        // Preenche a entidade existente com os novos dados do DTO
        DestaquesItem updatedEntity = toEntity(requestDTO, id);
        DestaquesItem savedEntity = domainService.updatePatrocinio(id, updatedEntity);
        log.info("Patrocinador com ID {} atualizado com sucesso.", savedEntity.getId());
        return toResponseDTO(savedEntity);
    }

    /**
     * Atualiza o status de um patrocinador.
     *
     * @param id     ID do patrocinador.
     * @param status A string do novo status (ex: "ACTIVE").
     * @return O DTO de resposta do patrocinador com o status alterado.
     * @throws BusinessException se o patrocinador não for encontrado ou o status
     *                           for inválido.
     */
    public DestaquesResponseDTO updatePatrocinioStatus(UUID id, String status) {
        log.info("Tentando atualizar o status do patrocinador com ID {} para: {}", id, status);
        PatrocinioStatus newStatus;
        try {
            newStatus = PatrocinioStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, "Status inválido fornecido: " + status);
        }

        DestaquesItem updatedEntity = domainService.updatePatrocinioStatus(id, newStatus);
        log.info("Status do patrocinador com ID {} alterado para {}.", id, newStatus);
        return toResponseDTO(updatedEntity);
    }

    /**
     * Exclui um patrocinador pelo ID.
     *
     * @param id O ID do patrocinador a ser excluído.
     */
    public void deletePatrocinio(UUID id) {
        log.warn("Solicitação para excluir patrocinador com ID: {}", id);
        domainService.deletePatrocinio(id);
        log.warn("Patrocinador com ID {} excluído com sucesso.", id);
    }
}
```
```java
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================
spring.application.name=legalconnect-marketplace
server.port=${PORT:0}
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true

# ===================================================================
# Configurações do Eureka Client (Service Discovery)
# ===================================================================
eureka.client.enabled=true
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30

# ===================================================================
# Configurações do SpringDoc OpenAPI (Swagger UI)
# ===================================================================
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
 
# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================
logging.level.br.com.legalconnect=INFO
logging.level.org.springframework=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN
logging.level.org.hibernate.hbm2ddl=WARN
logging.level.org.hibernate.engine.jdbc.connections=WARN
 
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping=TRACE

 
# ===================================================================
# Configurações do Spring Boot Actuator (Monitoramento)
# ===================================================================
management.endpoints.web.exposure.include=*
management.endpoints.web.base-path=/actuator
 
# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true
spring.web.cors.max-age=3600

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================
app.frontend.url=http://localhost:4200
# app.feature.new-registration-enabled=true

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableDiscoveryClient
@SpringBootApplication(scanBasePackages = "br.com.legalconnect")
@EntityScan(basePackages = {
        "br.com.legalconnect.depoimento.domain.model",
        "br.com.legalconnect.entity",
        "br.com.legalconnect.patrocinio.domain"
})
@EnableJpaRepositories(basePackages = {
        "br.com.legalconnect.depoimento.repository",
        "br.com.legalconnect.patrocinio.repository"
})
public class LegalMarketplaceApplication {

    public static void main(String[] args) {
        SpringApplication.run(LegalMarketplaceApplication.class, args);
    }
}

```
```java
package br.com.legalconnect.commom.dto.request;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/put)
    private UUID id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.depoimento.domain.model.User.UserStatus;
import br.com.legalconnect.depoimento.domain.model.User.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
{
  "openapi": "3.0.1",
  "info": { "title": "OpenAPI definition", "version": "v0" },
  "servers": [
    { "url": "http://localhost:49784", "description": "Generated server url" }
  ],
  "tags": [
    {
      "name": "Depoimentos",
      "description": "Gerenciamento de depoimentos para o marketplace jurídico"
    }
  ],
  "paths": {
    "/api/v1/publico/depoimentos/{id}": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Busca um depoimento por ID (administração)",
        "description": "Retorna um depoimento específico pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "buscarDepoimentoPorIdAdmin",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser buscado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento encontrado",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      },
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Atualiza um depoimento existente",
        "description": "Atualiza os dados de um depoimento pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "atualizarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser atualizado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "requestBody": {
          "description": "Dados atualizados do depoimento",
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/DepoimentoRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Depoimento atualizado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Requisição inválida",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      },
      "delete": {
        "tags": ["Depoimentos"],
        "summary": "Exclui um depoimento",
        "description": "Exclui um depoimento permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "excluirDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser excluído",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "204": {
            "description": "Depoimento excluído com sucesso",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Lista depoimentos para a página inicial",
        "description": "Retorna uma lista de depoimentos aprovados, com opções de limite e ordenação aleatória.",
        "operationId": "listarParaHome",
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "description": "Número máximo de depoimentos a serem retornados (padrão: 5)",
            "required": false,
            "schema": { "type": "integer", "format": "int32", "default": 5 },
            "example": 5
          },
          {
            "name": "random",
            "in": "query",
            "description": "Indica se os depoimentos devem ser aleatórios (padrão: false)",
            "required": false,
            "schema": { "type": "boolean", "default": false },
            "example": true
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimentos listados com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Depoimentos"],
        "summary": "Cria um novo depoimento",
        "description": "Cria um novo depoimento no sistema. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "criarDepoimento",
        "parameters": [
          {
            "name": "X-Correlation-ID",
            "in": "header",
            "required": true,
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "description": "Dados do depoimento a ser criado",
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/DepoimentoRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Depoimento criado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "400": {
            "description": "Requisição inválida",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/{id}/reprovar": {
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Reprova um depoimento",
        "description": "Altera o status de um depoimento para 'REPROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "reprovarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser reprovado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento reprovado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/{id}/aprovar": {
      "put": {
        "tags": ["Depoimentos"],
        "summary": "Aprova um depoimento",
        "description": "Altera o status de um depoimento para 'APROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "aprovarDepoimento",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "ID do depoimento a ser aprovado",
            "required": true,
            "schema": { "type": "string", "format": "uuid" },
            "example": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
          }
        ],
        "responses": {
          "200": {
            "description": "Depoimento aprovado com sucesso",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          },
          "404": {
            "description": "Depoimento não encontrado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    },
    "/api/v1/publico/depoimentos/todos": {
      "get": {
        "tags": ["Depoimentos"],
        "summary": "Lista todos os depoimentos (administração)",
        "description": "Retorna uma lista completa de todos os depoimentos, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).",
        "operationId": "listarTodosAdmin",
        "responses": {
          "200": {
            "description": "Todos os depoimentos listados para administração",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DepoimentoResponseDTO"
                }
              }
            }
          },
          "401": {
            "description": "Não autorizado",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDepoimentoResponseDTO"
                }
              }
            }
          },
          "403": {
            "description": "Acesso proibido",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseListDepoimentoResponseDTO"
                }
              }
            }
          }
        },
        "security": [{ "bearerAuth": [] }]
      }
    }
  },
  "components": {
    "schemas": {
      "DepoimentoRequestDTO": {
        "required": ["nome", "texto", "tipoDepoimento", "userId"],
        "type": "object",
        "properties": {
          "texto": { "maxLength": 500, "minLength": 0, "type": "string" },
          "nome": { "maxLength": 100, "minLength": 0, "type": "string" },
          "local": { "maxLength": 100, "minLength": 0, "type": "string" },
          "fotoUrl": {
            "maxLength": 255,
            "minLength": 0,
            "pattern": "^(https?|ftp)://[^ /$.?#].[^ ]*$",
            "type": "string"
          },
          "userId": { "type": "string", "format": "uuid" },
          "tipoDepoimento": {
            "pattern": "CLIENTE|PROFISSIONAL",
            "type": "string"
          },
          "status": {
            "pattern": "PENDENTE|APROVADO|REPROVADO",
            "type": "string"
          }
        }
      },
      "DepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "texto": { "type": "string" },
          "nome": { "type": "string" },
          "local": { "type": "string" },
          "fotoUrl": { "type": "string" },
          "userId": { "type": "string", "format": "uuid" },
          "tipoDepoimento": { "type": "string" },
          "status": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "BaseResponseDepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/DepoimentoResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseListDepoimentoResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/DepoimentoResponseDTO" }
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}

```
```java
package br.com.legalconnect.depoimento.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping; // Adicionada a importação para @RequestMapping no nível da classe
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.depoimento.dto.DepoimentoRequestDTO;
import br.com.legalconnect.depoimento.dto.DepoimentoResponseDTO;
import br.com.legalconnect.depoimento.service.DepoimentoAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement; // Para segurança JWT
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

/**
 * Controlador REST para o módulo de Depoimentos.
 * Gerencia endpoints públicos e de administração (com segurança).
 */
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/publico/marketplace/depoimentos") // Mover o prefixo da URL para o nível da classe
@Tag(name = "Depoimentos", description = "Gerenciamento de depoimentos para o marketplace jurídico")
public class DepoimentoController {

        private final DepoimentoAppService appService;

        @Operation(summary = "Lista depoimentos para a página inicial", description = "Retorna uma lista de depoimentos aprovados, com opções de limite e ordenação aleatória.", parameters = {
                        @Parameter(name = "limit", description = "Número máximo de depoimentos a serem retornados (padrão: 5)", example = "5"),
                        @Parameter(name = "random", description = "Indica se os depoimentos devem ser aleatórios (padrão: false)", example = "true")
        }, responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimentos listados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class)))
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<DepoimentoResponseDTO>>> listarParaHome(
                        @RequestParam(defaultValue = "5") int limit,
                        @RequestParam(defaultValue = "false") boolean random) {
                List<DepoimentoResponseDTO> depoimentos = appService.listarParaHome(limit, random);
                return ResponseEntity.ok(BaseResponse.<List<DepoimentoResponseDTO>>builder()
                                .data(depoimentos)
                                .message("Depoimentos listados com sucesso.")
                                .build());
        }

        @Operation(summary = "Cria um novo depoimento", description = "Cria um novo depoimento no sistema. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Dados do depoimento a ser criado", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoRequestDTO.class))), responses = {
                        @ApiResponse(responseCode = "201", description = "Depoimento criado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth")) // Referência ao esquema de segurança JWT
        @PostMapping("/publico/depoimentos")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> criarDepoimento(
                        @RequestBody @Valid DepoimentoRequestDTO request,
                        @RequestHeader("X-Correlation-ID") String userId) {
                request.setUserId(UUID.fromString(userId));
                DepoimentoResponseDTO novoDepoimento = appService.criarDepoimento(request);
                return ResponseEntity.status(HttpStatus.CREATED).body(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(novoDepoimento)
                                .message("Depoimento criado com sucesso.")
                                .build());
        }

        @Operation(summary = "Atualiza um depoimento existente", description = "Atualiza os dados de um depoimento pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser atualizado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Dados atualizados do depoimento", required = true, content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoRequestDTO.class))), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento atualizado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> atualizarDepoimento(
                        @PathVariable UUID id,
                        @RequestBody @Valid DepoimentoRequestDTO request) {
                DepoimentoResponseDTO depoimentoAtualizado = appService.atualizarDepoimento(id, request);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoAtualizado)
                                .message("Depoimento atualizado com sucesso.")
                                .build());
        }

        @Operation(summary = "Exclui um depoimento", description = "Exclui um depoimento permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser excluído", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "204", description = "Depoimento excluído com sucesso"),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @DeleteMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<Void>> excluirDepoimento(@PathVariable UUID id) {
                appService.excluirDepoimento(id);
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(BaseResponse.<Void>builder()
                                .message("Depoimento excluído com sucesso.")
                                .build());
        }

        @Operation(summary = "Aprova um depoimento", description = "Altera o status de um depoimento para 'APROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser aprovado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento aprovado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}/aprovar")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> aprovarDepoimento(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimentoAprovado = appService.aprovarDepoimento(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoAprovado)
                                .message("Depoimento aprovado com sucesso.")
                                .build());
        }

        @Operation(summary = "Reprova um depoimento", description = "Altera o status de um depoimento para 'REPROVADO'. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser reprovado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento reprovado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/publico/depoimentos/{id}/reprovar")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> reprovarDepoimento(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimentoReprovado = appService.reprovarDepoimento(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimentoReprovado)
                                .message("Depoimento reprovado com sucesso.")
                                .build());
        }

        @Operation(summary = "Lista todos os depoimentos (administração)", description = "Retorna uma lista completa de todos os depoimentos, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Todos os depoimentos listados para administração", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping("/publico/depoimentos/todos")
        public ResponseEntity<BaseResponse<List<DepoimentoResponseDTO>>> listarTodosAdmin() {
                List<DepoimentoResponseDTO> depoimentos = appService.listarTodos();
                return ResponseEntity.ok(BaseResponse.<List<DepoimentoResponseDTO>>builder()
                                .data(depoimentos)
                                .message("Todos os depoimentos listados para administração.")
                                .build());
        }

        @Operation(summary = "Busca um depoimento por ID (administração)", description = "Retorna um depoimento específico pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", parameters = @Parameter(name = "id", description = "ID do depoimento a ser buscado", required = true, example = "a1b2c3d4-e5f6-7890-1234-567890abcdef"), responses = {
                        @ApiResponse(responseCode = "200", description = "Depoimento encontrado", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DepoimentoResponseDTO.class))),
                        @ApiResponse(responseCode = "401", description = "Não autorizado"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Depoimento não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping("/publico/depoimentos/{id}")
        public ResponseEntity<BaseResponse<DepoimentoResponseDTO>> buscarDepoimentoPorIdAdmin(@PathVariable UUID id) {
                DepoimentoResponseDTO depoimento = appService.buscarPorId(id);
                return ResponseEntity.ok(BaseResponse.<DepoimentoResponseDTO>builder()
                                .data(depoimento)
                                .message("Depoimento encontrado.")
                                .build());
        }
}

```
```java
package br.com.legalconnect.depoimento.domain.enums;

/**
 * Enum para definir o status de um depoimento.
 */
public enum DepoimentoStatus {
    PENDENTE, // Depoimento enviado, aguardando revisão
    APROVADO, // Depoimento revisado e aprovado, pode ser exibido
    REPROVADO // Depoimento revisado e reprovado, não será exibido
}
```
```java
package br.com.legalconnect.depoimento.domain.enums;

/**
 * Enum para definir o tipo de depoimento (CLIENTE ou PROFISSIONAL).
 */
public enum TipoDepoimento {
    CLIENTE,
    PROFISSIONAL
}
```
```java
package br.com.legalconnect.depoimento.domain.model; // CORRETO - 'marketplace' adicionado

import java.util.UUID;

import br.com.legalconnect.common.dto.BaseEntity;
import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * Entidade JPA para representar um depoimento.
 * Inclui associação com o usuário, o tipo de depoimento e seu status.
 */
@Entity
@Table(name = "tb_depoimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Depoimento extends BaseEntity { // O campo 'id' e suas anotações já são herdados de BaseEntity e não
                                             // precisam ser redeclarados aqui.

    @Column(nullable = false, length = 500)
    private String texto;

    @Column(nullable = false, length = 100)
    private String nome; // Nome da pessoa que deu o depoimento

    @Column(length = 100)
    private String local; // Cidade/Estado ou empresa

    @Column(name = "foto_url", length = 255)
    private String fotoUrl; // URL da foto do depoente

    @Column(name = "user_id", nullable = false)
    private UUID userId; // ID do usuário (cliente ou profissional) relacionado ao depoimento

    @Enumerated(EnumType.STRING) // Armazena o enum como String no banco de dados
    @Column(name = "tipo_depoimento", nullable = false, length = 20)
    private TipoDepoimento tipoDepoimento; // Tipo: CLIENTE ou PROFISSIONAL

    @Enumerated(EnumType.STRING) // Armazena o enum como String no banco de dados
    @Column(name = "status", nullable = false, length = 20)
    @Builder.Default // Define um valor padrão para o Builder
    private DepoimentoStatus status = DepoimentoStatus.PENDENTE; // Status inicial PENDENTE
}

```
```java
package br.com.legalconnect.depoimento.domain.model;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.depoimento.domain.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.stereotype.Service;

import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;
import br.com.legalconnect.depoimento.repository.DepoimentoJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de domínio para gerenciar operações relacionadas a Depoimentos.
 * Contém a lógica de negócio principal e interage diretamente com o
 * repositório.
 * Este serviço deve focar nas operações sobre o agregado de Depoimento, não em
 * casos de uso específicos.
 */
@Service
@RequiredArgsConstructor
public class DepoimentoService {

    private final DepoimentoJpaRepository repository;

    /**
     * Salva um novo depoimento.
     * 
     * @param novoDepoimento A entidade Depoimento a ser salva.
     * @return O depoimento salvo.
     */
    public Depoimento salvar(Depoimento novoDepoimento) {
        return repository.save(novoDepoimento);
    }

    /**
     * Atualiza um depoimento existente.
     * 
     * @param id                   O ID do depoimento a ser atualizado.
     * @param depoimentoAtualizado A entidade Depoimento com os dados atualizados.
     * @return O depoimento atualizado.
     */
    public Optional<Depoimento> atualizar(UUID id, Depoimento depoimentoAtualizado) {
        return repository.findById(id).map(depoimento -> {
            depoimento.setTexto(depoimentoAtualizado.getTexto());
            depoimento.setNome(depoimentoAtualizado.getNome());
            depoimento.setLocal(depoimentoAtualizado.getLocal());
            depoimento.setFotoUrl(depoimentoAtualizado.getFotoUrl());
            depoimento.setUserId(depoimentoAtualizado.getUserId());
            depoimento.setTipoDepoimento(depoimentoAtualizado.getTipoDepoimento());
            depoimento.setStatus(depoimentoAtualizado.getStatus()); // Atualiza o status
            return repository.save(depoimento);
        });
    }

    /**
     * Altera o status de um depoimento.
     * 
     * @param id         O ID do depoimento.
     * @param novoStatus O novo status a ser atribuído.
     * @return Um Optional contendo o depoimento atualizado, se encontrado.
     */
    public Optional<Depoimento> alterarStatus(UUID id, DepoimentoStatus novoStatus) {
        return repository.findById(id).map(depoimento -> {
            depoimento.setStatus(novoStatus);
            return repository.save(depoimento);
        });
    }

    /**
     * Exclui um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento a ser excluído.
     */
    public void excluir(UUID id) {
        repository.deleteById(id);
    }

    /**
     * Busca um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento.
     * @return Um Optional contendo o depoimento, se encontrado.
     */
    public Optional<Depoimento> buscarPorId(UUID id) {
        return repository.findById(id);
    }

    /**
     * Lista todos os depoimentos.
     * 
     * @return Uma lista de todos os depoimentos.
     */
    public List<Depoimento> listarTodos() {
        return repository.findAll();
    }

    /**
     * Lista depoimentos por tipo.
     * 
     * @param tipo O tipo de depoimento (CLIENTE ou PROFISSIONAL).
     * @return Uma lista de depoimentos do tipo especificado.
     */
    public List<Depoimento> listarPorTipo(TipoDepoimento tipo) {
        return repository.findByTipoDepoimento(tipo);
    }

    /**
     * Lista depoimentos por ID de usuário.
     * 
     * @param userId O ID do usuário.
     * @return Uma lista de depoimentos associados ao usuário.
     */
    public List<Depoimento> listarPorUserId(UUID userId) {
        return repository.findByUserId(userId);
    }
}
```
```java
package br.com.legalconnect.depoimento.dto;

import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para requisições de criação/atualização de depoimentos.
 * Inclui validações para garantir a integridade dos dados.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepoimentoRequestDTO {

    @NotBlank(message = "O texto do depoimento é obrigatório.")
    @Size(max = 500, message = "O texto do depoimento não pode exceder 500 caracteres.")
    private String texto;

    @NotBlank(message = "O nome é obrigatório.")
    @Size(max = 100, message = "O nome não pode exceder 100 caracteres.")
    private String nome;

    @Size(max = 100, message = "O local não pode exceder 100 caracteres.")
    private String local;

    @Size(max = 255, message = "A URL da foto não pode exceder 255 caracteres.")
    @Pattern(regexp = "^(https?|ftp)://[^\s/$.?#].[^\s]*$", message = "URL da foto inválida.")
    private String fotoUrl;

    @NotNull(message = "O ID do usuário é obrigatório.")
    private UUID userId;

    @NotBlank(message = "O tipo de depoimento é obrigatório.")
    @Pattern(regexp = "CLIENTE|PROFISSIONAL", message = "O tipo de depoimento deve ser CLIENTE ou PROFISSIONAL.")
    private String tipoDepoimento; // Recebido como String e convertido para Enum no Mapper

    // Novo campo para o status do depoimento. Opcional na requisição para usuários
    // comuns.
    @Pattern(regexp = "PENDENTE|APROVADO|REPROVADO", message = "O status do depoimento deve ser PENDENTE, APROVADO ou REPROVADO.")
    private String status; // Recebido como String e convertido para Enum no Mapper
}
```
```java
package br.com.legalconnect.depoimento.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO para respostas de depoimentos.
 * Expõe apenas os campos relevantes para o cliente da API.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DepoimentoResponseDTO {
    private UUID id;
    private String texto;
    private String nome;
    private String local;
    private String fotoUrl;
    private UUID userId; // Expor o ID do usuário
    private String tipoDepoimento; // Expor o tipo como String
    private String status; // Expor o status como String
    private LocalDateTime createdAt; // Data de criação
    private LocalDateTime updatedAt; // Data de atualização
}
```
```java
package br.com.legalconnect.depoimento.repository;

import java.util.List;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;

/**
 * Repositório JPA para a entidade Depoimento, usando Spring Data JPA.
 * Define métodos para operações CRUD e consultas personalizadas.
 */
@Repository
public interface DepoimentoJpaRepository extends JpaRepository<Depoimento, UUID> {

    /**
     * Busca uma lista de depoimentos aleatórios, limitada pela quantidade
     * especificada, apenas os APROVADOS.
     * 
     * @param limite O número máximo de depoimentos a serem retornados.
     * @return Uma lista de depoimentos aleatórios.
     */
    @Query(value = "SELECT * FROM tb_depoimento WHERE status = 'APROVADO' ORDER BY random() LIMIT :limite", nativeQuery = true)
    List<Depoimento> buscarAleatoriosAprovados(@Param("limite") int limite);

    /**
     * Busca os 5 depoimentos APROVADOS mais recentes, ordenados pela data de
     * criação em ordem decrescente.
     * 
     * @param status O status do depoimento (APROVADO).
     * @return Uma lista dos 5 depoimentos mais recentes.
     */
    List<Depoimento> findTop5ByStatusOrderByCreatedAtDesc(DepoimentoStatus status);

    /**
     * Busca depoimentos por tipo de depoimento.
     * 
     * @param tipoDepoimento O tipo de depoimento (CLIENTE ou PROFISSIONAL).
     * @return Uma lista de depoimentos do tipo especificado.
     */
    List<Depoimento> findByTipoDepoimento(TipoDepoimento tipoDepoimento);

    /**
     * Busca depoimentos relacionados a um ID de usuário específico.
     * 
     * @param userId O ID do usuário.
     * @return Uma lista de depoimentos associados ao usuário.
     */
    List<Depoimento> findByUserId(UUID userId);

    /**
     * Busca depoimentos por status.
     * 
     * @param status O status do depoimento.
     * @return Uma lista de depoimentos com o status especificado.
     */
    List<Depoimento> findByStatus(DepoimentoStatus status);
}
```
```java
package br.com.legalconnect.depoimento.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.depoimento.domain.model.User;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

}
```
```java
package br.com.legalconnect.depoimento.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.depoimento.domain.enums.DepoimentoStatus;
import br.com.legalconnect.depoimento.domain.enums.TipoDepoimento;
import br.com.legalconnect.depoimento.domain.model.Depoimento;
import br.com.legalconnect.depoimento.domain.service.DepoimentoService;
import br.com.legalconnect.depoimento.dto.DepoimentoRequestDTO;
import br.com.legalconnect.depoimento.dto.DepoimentoResponseDTO;
import br.com.legalconnect.depoimento.repository.DepoimentoJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de aplicação para o módulo de Depoimentos.
 * Orquestra operações entre DTOs, e o serviço de domínio, realizando mapeamento
 * manual com Builder.
 * Contém regras de negócio de alto nível e validações.
 */
@Service
@RequiredArgsConstructor
public class DepoimentoAppService {

    private final DepoimentoService domainService;
    private final DepoimentoJpaRepository repository;
    private final UserServiceImpl userService;

    /**
     * Converte um DepoimentoRequestDTO para uma entidade Depoimento.
     * 
     * @param dto O DTO de requisição.
     * @return A entidade Depoimento.
     */
    private Depoimento toEntity(DepoimentoRequestDTO dto) {
        return Depoimento.builder()
                .texto(dto.getTexto())
                .nome(dto.getNome())
                .local(dto.getLocal())
                .fotoUrl(dto.getFotoUrl())
                .userId(dto.getUserId())
                .tipoDepoimento(TipoDepoimento.valueOf(dto.getTipoDepoimento().toUpperCase()))
                // O status é definido posteriormente na lógica de negócio, não aqui
                .build();
    }

    /**
     * Converte uma entidade Depoimento para um DepoimentoResponseDTO.
     * 
     * @param entity A entidade Depoimento.
     * @return O DTO de resposta.
     */
    private DepoimentoResponseDTO toResponse(Depoimento entity) {
        return DepoimentoResponseDTO.builder()
                .id(entity.getId())
                .texto(entity.getTexto())
                .nome(entity.getNome())
                .local(entity.getLocal())
                .fotoUrl(entity.getFotoUrl())
                .userId(entity.getUserId())
                .tipoDepoimento(entity.getTipoDepoimento().name())
                .status(entity.getStatus().name())
                .createdAt(entity.getCreatedAt())
                .updatedAt(entity.getUpdatedAt())
                .build();
    }

    /**
     * Atualiza uma entidade Depoimento existente a partir de um DTO de requisição.
     * 
     * @param dto    O DTO de requisição.
     * @param entity A entidade a ser atualizada.
     */
    private void updateEntityFromDto(DepoimentoRequestDTO dto, Depoimento entity) {
        entity.setTexto(dto.getTexto());
        entity.setNome(dto.getNome());
        entity.setLocal(dto.getLocal());
        entity.setFotoUrl(dto.getFotoUrl());
        entity.setUserId(dto.getUserId());
        entity.setTipoDepoimento(TipoDepoimento.valueOf(dto.getTipoDepoimento().toUpperCase()));
        // O status é atualizado separadamente pela lógica de negócio no AppService
    }

    /**
     * Converte uma String para DepoimentoStatus.
     * 
     * @param status String do status.
     * @return DepoimentoStatus ou null se a string for nula ou vazia.
     */
    private DepoimentoStatus mapStringToDepoimentoStatus(String status) {
        return (status != null && !status.isEmpty()) ? DepoimentoStatus.valueOf(status.toUpperCase()) : null;
    }

    /**
     * Cria um novo depoimento a partir de um DTO de requisição.
     * Implementa regras de negócio para status e validação de usuário.
     * 
     * @param request O DTO contendo os dados do novo depoimento.
     * @return O DTO de resposta do depoimento criado.
     * @throws BusinessException se o texto do depoimento for muito longo,
     *                           o usuário não for encontrado ou o status inicial
     *                           for inválido.
     */
    public DepoimentoResponseDTO criarDepoimento(DepoimentoRequestDTO request) {
        if (request.getTexto().length() > 500) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, ErrorCode.DADOS_INVALIDOS.getMessage());
        }

        if (!userService.userExists(request.getUserId())) {
            throw new BusinessException(ErrorCode.USER_NAO_ENCONTRADO, ErrorCode.USER_NAO_ENCONTRADO.getMessage());
        }

        Depoimento depoimento = toEntity(request); // Usando o método toEntity manual

        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        boolean isAdmin = authentication != null && authentication.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_PLATAFORMA_ADMIN"));

        if (!isAdmin && request.getStatus() != null
                && !request.getStatus().equalsIgnoreCase(DepoimentoStatus.PENDENTE.name())) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, ErrorCode.FORBIDDEN_ACCESS.getMessage());
        }

        if (request.getStatus() != null && isAdmin) {
            depoimento.setStatus(DepoimentoStatus.valueOf(request.getStatus().toUpperCase()));
        } else {
            depoimento.setStatus(DepoimentoStatus.PENDENTE);
        }

        Depoimento salvo = domainService.salvar(depoimento);
        return toResponse(salvo); // Usando o método toResponse manual
    }

    /**
     * Atualiza um depoimento existente.
     * 
     * @param id      O ID do depoimento a ser atualizado.
     * @param request O DTO contendo os dados atualizados.
     * @return O DTO de resposta do depoimento atualizado.
     * @throws BusinessException se o depoimento não for encontrado, o texto for
     *                           muito longo,
     *                           o usuário não for encontrado ou o status for
     *                           inválido para a operação.
     */
    public DepoimentoResponseDTO atualizarDepoimento(UUID id, DepoimentoRequestDTO request) {
        if (request.getTexto().length() > 500) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, ErrorCode.DADOS_INVALIDOS.getMessage());
        }

        if (!userService.userExists(request.getUserId())) {
            throw new BusinessException(ErrorCode.USER_NAO_ENCONTRADO, ErrorCode.USER_NAO_ENCONTRADO.getMessage());
        }

        return domainService.buscarPorId(id)
                .map(depoimentoExistente -> {
                    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
                    boolean isAdmin = authentication != null && authentication.getAuthorities().stream()
                            .anyMatch(a -> a.getAuthority().equals("ROLE_PLATAFORMA_ADMIN"));

                    DepoimentoStatus novoStatus = mapStringToDepoimentoStatus(request.getStatus());

                    if (novoStatus != null && novoStatus != depoimentoExistente.getStatus() && !isAdmin) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS,
                                ErrorCode.FORBIDDEN_ACCESS.getMessage());
                    }

                    updateEntityFromDto(request, depoimentoExistente); // Usando o método updateEntityFromDto manual
                    if (novoStatus != null && isAdmin) {
                        depoimentoExistente.setStatus(novoStatus);
                    }

                    return toResponse(domainService.salvar(depoimentoExistente)); // Usando o método toResponse manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Exclui um depoimento pelo seu ID.
     * 
     * @param id O ID do depoimento a ser excluído.
     * @throws BusinessException se o depoimento não for encontrado.
     */
    public void excluirDepoimento(UUID id) {
        if (!domainService.buscarPorId(id).isPresent()) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                    ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage());
        }
        domainService.excluir(id);
    }

    /**
     * Aprova um depoimento. Apenas administradores podem realizar esta operação.
     * 
     * @param id O ID do depoimento a ser aprovado.
     * @return O DTO do depoimento aprovado.
     * @throws BusinessException se o depoimento não for encontrado ou se o status
     *                           já for APROVADO.
     */
    public DepoimentoResponseDTO aprovarDepoimento(UUID id) {
        return domainService.buscarPorId(id)
                .map(depoimento -> {
                    if (depoimento.getStatus() == DepoimentoStatus.APROVADO) {
                        // throw new BusinessException(ErrorCode.DEPOIMENTO_ALREADY_APPROVED,
                        // ErrorCode.DEPOIMENTO_ALREADY_APPROVED.getMessage());
                    }
                    return toResponse(domainService.alterarStatus(id, DepoimentoStatus.APROVADO).get()); // Usando o
                                                                                                         // método
                                                                                                         // toResponse
                                                                                                         // manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Reprova um depoimento. Apenas administradores podem realizar esta operação.
     * 
     * @param id O ID do depoimento a ser reprovado.
     * @return O DTO do depoimento reprovado.
     * @throws BusinessException se o depoimento não for encontrado ou se o status
     *                           já for REPROVADO.
     */
    public DepoimentoResponseDTO reprovarDepoimento(UUID id) {
        return domainService.buscarPorId(id)
                .map(depoimento -> {
                    if (depoimento.getStatus() == DepoimentoStatus.REPROVADO) {
                        // throw new BusinessException(ErrorCode.DEPOIMENTO_ALREADY_REJECTED,
                        // ErrorCode.DEPOIMENTO_ALREADY_REJECTED.getMessage());
                    }
                    return toResponse(domainService.alterarStatus(id, DepoimentoStatus.REPROVADO).get()); // Usando o
                                                                                                          // método
                                                                                                          // toResponse
                                                                                                          // manual
                })
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Lista todos os depoimentos, convertendo-os para DTOs de resposta.
     * 
     * @return Uma lista de DTOs de resposta de depoimentos.
     */
    public List<DepoimentoResponseDTO> listarTodos() {
        return domainService.listarTodos().stream()
                .map(this::toResponse) // Usando o método toResponse manual
                .collect(Collectors.toList());
    }

    /**
     * Busca um depoimento pelo seu ID e o converte para DTO de resposta.
     * 
     * @param id O ID do depoimento.
     * @return O DTO de resposta do depoimento.
     * @throws BusinessException se o depoimento não for encontrado.
     */
    public DepoimentoResponseDTO buscarPorId(UUID id) {
        return domainService.buscarPorId(id)
                .map(this::toResponse) // Usando o método toResponse manual
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                        ErrorCode.ENTIDADE_NAO_ENCONTRADA.getMessage()));
    }

    /**
     * Lista depoimentos para a página inicial, com opções de limite e
     * aleatoriedade.
     * Esta é uma responsabilidade do AppService, pois é um caso de uso específico.
     * 
     * @param limit  O número máximo de depoimentos a serem retornados.
     * @param random Booleano indicando se a busca deve ser aleatória.
     * @return Uma lista de DTOs de resposta de depoimentos.
     */
    public List<DepoimentoResponseDTO> listarParaHome(int limit, boolean random) {
        List<Depoimento> depoimentos;
        if (random) {
            depoimentos = repository.buscarAleatoriosAprovados(limit);
        } else {
            depoimentos = repository.findTop5ByStatusOrderByCreatedAtDesc(DepoimentoStatus.APROVADO);
        }
        return depoimentos.stream()
                .map(this::toResponse) // Usando o método toResponse manual
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.depoimento.service;

import java.util.UUID;

import org.springframework.stereotype.Service;

import br.com.legalconnect.depoimento.repository.UserRepository;
import lombok.RequiredArgsConstructor;

/**
 * Implementação mock do serviço de usuário para fins de demonstração.
 * Em uma aplicação real, esta classe faria a comunicação com o repositório de
 * usuários
 * ou outro serviço de identidade.
 */
@Service
@RequiredArgsConstructor
public class UserServiceImpl {

    private final UserRepository userRepository;

    public boolean userExists(UUID userId) {
        // Lógica mock: Em uma aplicação real, você consultaria o UserRepository aqui.
        // Para este exemplo, verifica se o ID está no conjunto de IDs simulados.
        return userRepository.existsById(userId);

    }
}
```
```java
//
// Controlador REST para gerenciar os patrocinadores do marketplace jurídico.
// Este controlador lida com os endpoints de administração.
//
package br.com.legalconnect.patrocinio.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.patrocinio.dto.DestaquesRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import br.com.legalconnect.patrocinio.service.PatrocinioAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;

/**
 * Controlador REST para os endpoints de gerenciamento de patrocinadores
 * (admin).
 * Separado do controlador público para melhor organização e controle de acesso.
 */
@RestController
@RequiredArgsConstructor
@Tag(name = "Patrocínios (Admin)", description = "Endpoints para gerenciamento de patrocinadores no marketplace jurídico (acesso administrativo)")
@RequestMapping("/api/v1/marketplace/destaques")
@PreAuthorize("hasRole('ROLE_PLATAFORMA_ADMIN')")
public class AdminDestaquesController {

        private final PatrocinioAppService patrocinioAppService;

        /**
         * Endpoint privado para listar todos os patrocinadores, independentemente do
         * status.
         * Requer a role ROLE_PLATAFORMA_ADMIN.
         *
         * @return ResponseEntity contendo a lista completa de patrocinadores e uma
         *         resposta padrão.
         */
        @Operation(summary = "Lista todos os patrocinadores (administração)", description = "Retorna uma lista completa de todos os patrocinadores, independentemente do status. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Todos os patrocinadores listados", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @GetMapping
        public ResponseEntity<BaseResponse<List<DestaquesResponseDTO>>> getAllPatrocinios() {
                List<DestaquesResponseDTO> patrocinadores = patrocinioAppService.findAllPatrocinios();
                return ResponseEntity.ok(BaseResponse.<List<DestaquesResponseDTO>>builder()
                                .data(patrocinadores)
                                .message("Todos os patrocinadores listados.")
                                .build());
        }

        /**
         * Endpoint privado para criar um novo patrocinador.
         * A API aceita um DTO polimórfico, permitindo a criação de diferentes tipos de
         * patrocinadores.
         *
         * @param requestDTO DTO com os dados do novo patrocinador.
         * @return ResponseEntity com o patrocinador criado e uma resposta padrão.
         */
        @Operation(summary = "Cria um novo patrocinador", description = "Cria um novo patrocinador. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "201", description = "Patrocinador criado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PostMapping
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> createPatrocinio(
                        @RequestBody @Valid DestaquesRequestDTO requestDTO) {
                DestaquesResponseDTO novoPatrocinio = patrocinioAppService.createPatrocinio(requestDTO);
                return ResponseEntity.status(HttpStatus.CREATED).body(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(novoPatrocinio)
                                .message("Patrocinador criado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para atualizar um patrocinador existente.
         * A API aceita um DTO polimórfico para a atualização.
         *
         * @param id         ID do patrocinador a ser atualizado.
         * @param requestDTO DTO com os dados atualizados.
         * @return ResponseEntity com o patrocinador atualizado e uma resposta padrão.
         */
        @Operation(summary = "Atualiza um patrocinador existente", description = "Atualiza um patrocinador pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Patrocinador atualizado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "400", description = "Requisição inválida"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> updatePatrocinio(
                        @PathVariable UUID id,
                        @RequestBody @Valid DestaquesRequestDTO requestDTO) {
                DestaquesResponseDTO updatedPatrocinio = patrocinioAppService.updatePatrocinio(id, requestDTO);
                return ResponseEntity.ok(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(updatedPatrocinio)
                                .message("Patrocinador atualizado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para mudar o status de um patrocinador.
         *
         * @param id     ID do patrocinador.
         * @param status O novo status (e.g., "ACTIVE", "INACTIVE").
         * @return ResponseEntity com o patrocinador atualizado e uma resposta padrão.
         */
        @Operation(summary = "Muda o status de um patrocinador", description = "Altera o status de um patrocinador (ex: de INACTIVE para ACTIVE). Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "200", description = "Status do patrocinador alterado com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class))),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @PatchMapping("/{id}/status")
        public ResponseEntity<BaseResponse<DestaquesResponseDTO>> updatePatrocinioStatus(
                        @PathVariable UUID id,
                        @RequestParam String status) {
                DestaquesResponseDTO updatedPatrocinio = patrocinioAppService.updatePatrocinioStatus(id, status);
                return ResponseEntity.ok(BaseResponse.<DestaquesResponseDTO>builder()
                                .data(updatedPatrocinio)
                                .message("Status do patrocinador alterado com sucesso.")
                                .build());
        }

        /**
         * Endpoint privado para excluir um patrocinador.
         *
         * @param id ID do patrocinador a ser excluído.
         * @return ResponseEntity com status 204 (No Content) em caso de sucesso.
         */
        @Operation(summary = "Exclui um patrocinador", description = "Exclui um patrocinador permanentemente pelo seu ID. Requer autenticação de administrador (ROLE_PLATAFORMA_ADMIN).", responses = {
                        @ApiResponse(responseCode = "204", description = "Patrocinador excluído com sucesso"),
                        @ApiResponse(responseCode = "403", description = "Acesso proibido"),
                        @ApiResponse(responseCode = "404", description = "Patrocinador não encontrado")
        }, security = @SecurityRequirement(name = "bearerAuth"))
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> deletePatrocinio(@PathVariable UUID id) {
                patrocinioAppService.deletePatrocinio(id);
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(BaseResponse.<Void>builder()
                                .message("Patrocinador excluído com sucesso.")
                                .build());
        }
}
```
```java
//
// Controlador REST para gerenciar os patrocinadores do marketplace jurídico.
// Este controlador é o ponto de entrada da API, lidando com as requisições HTTP
// e orquestrando o serviço de aplicação para executar a lógica de negócio.
//
package br.com.legalconnect.patrocinio.controller;

import java.util.List;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import br.com.legalconnect.patrocinio.service.PatrocinioAppService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

@RestController
@RequiredArgsConstructor
@Tag(name = "Patrocínios", description = "Endpoints para gerenciamento de patrocinadores no marketplace jurídico")
@RequestMapping("/api/v1/publico/marketplace/destaques")
public class DestaquesController {

        private final PatrocinioAppService patrocinioAppService;

        // =================================================================================================================
        // Endpoint Público
        // =================================================================================================================

        /**
         * Endpoint público para listar todos os patrocinadores com status ATIVO.
         * Retorna uma lista de DTOs polimórficos que podem representar diferentes tipos
         * de patrocínios (Eventos, Escritórios, etc.).
         *
         * @return ResponseEntity contendo a lista de patrocinadores ativos e uma
         *         resposta padrão.
         */
        @Operation(summary = "Lista patrocinadores ativos", description = "Retorna uma lista de patrocinadores com status ATIVO. A resposta pode conter diferentes tipos de patrocinadores.", responses = {
                        @ApiResponse(responseCode = "200", description = "Patrocinadores ativos listados com sucesso", content = @Content(mediaType = "application/json", schema = @Schema(implementation = DestaquesResponseDTO.class)))
        })
        @GetMapping
        public ResponseEntity<BaseResponse<List<DestaquesResponseDTO>>> getActivePatrocinios() {
                List<DestaquesResponseDTO> patrocinadores = patrocinioAppService.findActivePatrocinios();
                return ResponseEntity.ok(BaseResponse.<List<DestaquesResponseDTO>>builder()
                                .data(patrocinadores)
                                .message("Patrocinadores ativos listados com sucesso.")
                                .build());
        }
}
```
```java

package br.com.legalconnect.patrocinio.domain;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("ESCRITORIO")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorio extends DestaquesItem {
    @Column(length = 255)
    private String nome;
    @Column(length = 255)
    private String slogan;
    @Column(name = "logo_url", length = 255)
    private String logoUrl;

    @PostLoad
    public void setTipo() {
        this.tipo = "ESCRITORIO";
    }
}
```
```java
//
// Entidade JPA para um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("EVENTO")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesEvento extends DestaquesItem {
    @Column(length = 255)
    private String titulo;
    private LocalDateTime dataEvento;
    @Column(name = "imagem_url", length = 255)
    private String imagemUrl;

    @PostLoad
    public void setTipo() {
        this.tipo = "EVENTO";
    }
}
```
```java
//
// Entidade base abstrata JPA para representar um item de patrocínio.
// Usa herança de tabela única (@Inheritance) para persistir todos os tipos de patrocínio em uma única tabela.
//
package br.com.legalconnect.patrocinio.domain;

import br.com.legalconnect.common.dto.BaseEntity;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorColumn;
import jakarta.persistence.DiscriminatorType;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.Table;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * Entidade JPA base abstrata para itens de patrocínio.
 * Usa herança de tabela única (@Inheritance) para centralizar todos os
 * patrocínios em uma única tabela.
 * O campo 'tipo' atua como o discriminador.
 */
@Entity
@Table(name = "tb_patrocinio")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "tipo", discriminatorType = DiscriminatorType.STRING)
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public abstract class DestaquesItem extends BaseEntity {

    @Column(name = "tipo", insertable = false, updatable = false)
    protected String tipo;

    @Column(nullable = false, length = 255)
    protected String link;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false, length = 20)
    protected PatrocinioStatus status;
}
```
```java
//
// Entidade JPA para um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.domain;

import java.time.LocalDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.DiscriminatorValue;
import jakarta.persistence.Entity;
import jakarta.persistence.PostLoad;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

@Entity
@DiscriminatorValue("NOTICIA")
@Data
@SuperBuilder
@NoArgsConstructor
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticia extends DestaquesItem {
    @Column(length = 255)
    private String titulo;
    @Column(name = "imagem_url", length = 255)
    private String imagemUrl;
    @Column(name = "data_publicacao")
    private LocalDateTime dataPublicacao;

    @PostLoad
    public void setTipo() {
        this.tipo = "NOTICIA";
    }
}
```
```java
//
// Enum para o status dos patrocinadores.
//
package br.com.legalconnect.patrocinio.domain.enums;

/**
 * Define os possíveis status de um patrocinador.
 */
public enum PatrocinioStatus {
    ACTIVE,   // Patrocinador está ativo e pode ser exibido.
    INACTIVE  // Patrocinador está inativo e não deve ser exibido.
}
```
```java
//
// DTO específico para um patrocínio de escritório.
//
package br.com.legalconnect.patrocinio.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorioRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O nome do escritório é obrigatório.")
    private String nome;
    @NotBlank(message = "O slogan do escritório é obrigatório.")
    private String slogan;
    @Size(max = 255, message = "A URL da logo deve ter no máximo 255 caracteres.")
    private String logoUrl; // Opcional, se não houver, pode ser usado um placeholder
}
```
```java
//
// DTO específico para a resposta de um patrocínio de escritório.
//
package br.com.legalconnect.patrocinio.dto;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEscritorioResponseDTO extends DestaquesResponseDTO {
    private String nome;
    private String slogan;
    private String logoUrl;
}
```
```java
//
// DTO específico para um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEventoRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O título do evento é obrigatório.")
    private String titulo;
    @NotNull(message = "A data do evento é obrigatória.")
    private LocalDateTime dataEvento;
    @NotBlank(message = "A URL da imagem é obrigatória.")
    private String imagemUrl;
}
```
```java
//
// DTO específico para a resposta de um patrocínio de evento.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesEventoResponseDTO extends DestaquesResponseDTO {
    private String titulo;
    private LocalDateTime dataEvento;
    private String imagemUrl;
}
```
```java
//
// DTO específico para um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticiaRequestDTO extends DestaquesRequestDTO {
    @NotBlank(message = "O título da notícia é obrigatório.")
    private String titulo;
    @NotBlank(message = "A URL da imagem é obrigatória.")
    private String imagemUrl;
    @NotNull(message = "A data de publicação da notícia é obrigatória.")
    private LocalDateTime dataPublicacao;
}
```
```java
//
// DTO específico para a resposta de um patrocínio de notícia.
//
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;

import lombok.Data;
import lombok.EqualsAndHashCode;
import lombok.experimental.SuperBuilder;

@Data
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class DestaquesNoticiaResponseDTO extends DestaquesResponseDTO {
    private String titulo;
    private String imagemUrl;
    private LocalDateTime dataPublicacao;
}
```
```java
//
// DTO para a requisição de criação/atualização de patrocinadores.
// A anotação @JsonTypeInfo permite que o Spring determine qual classe de DTO
// concreta deve ser usada com base no valor do campo 'tipo'.
//
package br.com.legalconnect.patrocinio.dto;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;
import lombok.experimental.SuperBuilder;

/**
 * DTO base polimórfico para a requisição de criação e atualização de
 * patrocinadores.
 * A API usará este DTO para deserializar diferentes tipos de patrocinadores.
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "tipo")
@JsonSubTypes({
                @JsonSubTypes.Type(value = DestaquesEventoRequestDTO.class, name = "EVENTO"),
                @JsonSubTypes.Type(value = DestaquesEscritorioRequestDTO.class, name = "ESCRITORIO"),
                @JsonSubTypes.Type(value = DestaquesNoticiaRequestDTO.class, name = "NOTICIA")
})
@Data
@SuperBuilder
public abstract class DestaquesRequestDTO {
        @NotBlank(message = "O tipo de patrocínio é obrigatório.")
        protected String tipo; // EVENTO, ESCRITORIO, NOTICIA
        @NotBlank(message = "O link é obrigatório.")
        protected String link;
        protected String status;
}
```
```java
//
// DTO base polimórfico para a resposta da API de patrocinadores.
package br.com.legalconnect.patrocinio.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;

import lombok.Data;
import lombok.experimental.SuperBuilder;

/**
 * DTO base polimórfico para a resposta da API de patrocinadores.
 * Utiliza o campo 'tipo' como discriminador para serializar o objeto correto.
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.EXISTING_PROPERTY, property = "tipo")
@JsonSubTypes({
                @JsonSubTypes.Type(value = DestaquesEventoResponseDTO.class, name = "EVENTO"),
                @JsonSubTypes.Type(value = DestaquesEscritorioResponseDTO.class, name = "ESCRITORIO"),
                @JsonSubTypes.Type(value = DestaquesNoticiaResponseDTO.class, name = "NOTICIA")
})
@Data
@SuperBuilder
public abstract class DestaquesResponseDTO {
        protected UUID id;
        protected String tipo;
        protected String link;
        protected String status;
        protected LocalDateTime createdAt;
        protected LocalDateTime updatedAt;
}
```
```java
//
// Repositório JPA genérico para a entidade base PatrocinioItem.
//
package br.com.legalconnect.patrocinio.repository;

import java.util.List;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;

/**
 * Repositório Spring Data JPA para a entidade base PatrocinioItem.
 * Através do polimorfismo, este repositório pode lidar com todos os tipos de
 * patrocínios.
 */
@Repository
public interface DestaquesJpaRepository extends JpaRepository<DestaquesItem, UUID> {
    /**
     * Busca uma lista de patrocinadores pelo seu status.
     *
     * @param status O status do patrocinador (ACTIVE ou INACTIVE).
     * @return Uma lista de patrocinadores com o status especificado.
     */
    List<DestaquesItem> findByStatus(PatrocinioStatus status);
}
```
```java
//
// Serviço de domínio que interage com o repositório JPA de patrocinadores.
// Contém a lógica de negócio principal e a comunicação direta com a camada de infraestrutura (repositórios).
//
package br.com.legalconnect.patrocinio.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.patrocinio.domain.DestaquesEscritorio;
import br.com.legalconnect.patrocinio.domain.DestaquesEvento;
import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.DestaquesNoticia;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import br.com.legalconnect.patrocinio.repository.DestaquesJpaRepository;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de domínio responsável por gerenciar a persistência dos
 * patrocinadores.
 * Esta camada deve ser agnóstica à API e se concentrar em operações de dados.
 */
@Service
@RequiredArgsConstructor
public class DestaquesDomainService {

    private static final Logger log = LoggerFactory.getLogger(DestaquesDomainService.class);
    private final DestaquesJpaRepository repository;

    /**
     * Busca todos os patrocinadores com status ATIVO.
     *
     * @return Uma lista de entidades PatrocinioItem com o status ATIVO.
     */
    public List<DestaquesItem> findActivePatrocinios() {
        log.debug("Buscando patrocinadores ativos no repositório.");
        return repository.findByStatus(PatrocinioStatus.ACTIVE);
    }

    /**
     * Busca todos os patrocinadores, independente do status.
     *
     * @return Uma lista de todas as entidades PatrocinioItem.
     */
    public List<DestaquesItem> findAllPatrocinios() {
        log.debug("Buscando todos os patrocinadores no repositório.");
        return repository.findAll();
    }

    /**
     * Busca um patrocinador pelo seu ID.
     *
     * @param id O ID do patrocinador.
     * @return Um Optional contendo a entidade PatrocinioItem, se encontrada.
     */
    public Optional<DestaquesItem> findPatrocinioById(UUID id) {
        log.debug("Buscando patrocinador por ID: {}", id);
        return repository.findById(id);
    }

    /**
     * Cria um novo patrocinador no banco de dados.
     *
     * @param patrocinio A entidade PatrocinioItem a ser salva.
     * @return A entidade PatrocinioItem salva, com o ID gerado.
     */
    public DestaquesItem createPatrocinio(DestaquesItem patrocinio) {
        log.info("Salvando novo patrocinador do tipo {}: {}", patrocinio.getTipo(), patrocinio.toString());
        return repository.save(patrocinio);
    }

    /**
     * Atualiza um patrocinador existente.
     *
     * @param id                O ID da entidade a ser atualizada.
     * @param updatedPatrocinio A entidade PatrocinioItem com os dados atualizados.
     * @return A entidade PatrocinioItem salva.
     */
    public DestaquesItem updatePatrocinio(UUID id, DestaquesItem updatedPatrocinio) {
        log.info("Atualizando patrocinador com ID: {}", id);
        return repository.findById(id).map(existing -> {
            // A lógica de atualização é genérica, mas a JPA cuida do tipo concreto
            existing.setLink(updatedPatrocinio.getLink());
            existing.setStatus(updatedPatrocinio.getStatus());

            // A cópia dos dados específicos para cada tipo de patrocínio
            if (existing instanceof DestaquesEvento && updatedPatrocinio instanceof DestaquesEvento) {
                DestaquesEvento existingEvento = (DestaquesEvento) existing;
                DestaquesEvento updatedEvento = (DestaquesEvento) updatedPatrocinio;
                existingEvento.setTitulo(updatedEvento.getTitulo());
                existingEvento.setDataEvento(updatedEvento.getDataEvento());
                existingEvento.setImagemUrl(updatedEvento.getImagemUrl());
            } else if (existing instanceof DestaquesEscritorio && updatedPatrocinio instanceof DestaquesEscritorio) {
                DestaquesEscritorio existingEscritorio = (DestaquesEscritorio) existing;
                DestaquesEscritorio updatedEscritorio = (DestaquesEscritorio) updatedPatrocinio;
                existingEscritorio.setNome(updatedEscritorio.getNome());
                existingEscritorio.setSlogan(updatedEscritorio.getSlogan());
                existingEscritorio.setLogoUrl(updatedEscritorio.getLogoUrl());
            } else if (existing instanceof DestaquesNoticia && updatedPatrocinio instanceof DestaquesNoticia) {
                DestaquesNoticia existingNoticia = (DestaquesNoticia) existing;
                DestaquesNoticia updatedNoticia = (DestaquesNoticia) updatedPatrocinio;
                existingNoticia.setTitulo(updatedNoticia.getTitulo());
                existingNoticia.setImagemUrl(updatedNoticia.getImagemUrl());
                existingNoticia.setDataPublicacao(updatedNoticia.getDataPublicacao());
            } else {
                throw new BusinessException(ErrorCode.DADOS_INVALIDOS,
                        "Tentativa de atualizar um tipo de patrocínio com dados incompatíveis.");
            }
            return repository.save(existing);
        }).orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));
    }

    /**
     * Altera o status de um patrocinador.
     *
     * @param id     ID do patrocinador.
     * @param status O novo status.
     * @return A entidade PatrocinioItem com o status alterado.
     * @throws BusinessException se o patrocinador não for encontrado.
     */
    public DestaquesItem updatePatrocinioStatus(UUID id, PatrocinioStatus status) {
        log.info("Tentando alterar o status do patrocinador {} para {}", id, status);
        return repository.findById(id)
                .map(patrocinio -> {
                    patrocinio.setStatus(status);
                    return repository.save(patrocinio);
                })
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));
    }

    /**
     * Exclui um patrocinador pelo ID.
     *
     * @param id O ID do patrocinador a ser excluído.
     * @throws BusinessException se o patrocinador não for encontrado.
     */
    public void deletePatrocinio(UUID id) {
        log.info("Excluindo patrocinador com ID: {}", id);
        if (!repository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado.");
        }
        repository.deleteById(id);
    }
}
```
```java
//
// Serviço de aplicação para a lógica de negócio dos patrocinadores.
//
package br.com.legalconnect.patrocinio.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.patrocinio.domain.DestaquesEscritorio;
import br.com.legalconnect.patrocinio.domain.DestaquesEvento;
import br.com.legalconnect.patrocinio.domain.DestaquesItem;
import br.com.legalconnect.patrocinio.domain.DestaquesNoticia;
import br.com.legalconnect.patrocinio.domain.enums.PatrocinioStatus;
import br.com.legalconnect.patrocinio.dto.DestaquesEscritorioRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEscritorioResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEventoRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesEventoResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesNoticiaRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesNoticiaResponseDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesRequestDTO;
import br.com.legalconnect.patrocinio.dto.DestaquesResponseDTO;
import lombok.RequiredArgsConstructor;

/**
 * Serviço de aplicação para gerenciar a lógica de negócio dos patrocinadores.
 * Atua como uma camada de tradução entre o mundo da API (DTOs) e o mundo do
 * domínio (entidades).
 * Contém a lógica de conversão entre DTOs e entidades de forma polimórfica.
 */
@Service
@RequiredArgsConstructor
public class PatrocinioAppService {

    private static final Logger log = LoggerFactory.getLogger(PatrocinioAppService.class);
    private final DestaquesDomainService domainService;

    /**
     * Converte uma entidade de domínio PatrocinioItem para um DTO de resposta
     * polimórfico.
     * 
     * @param entity A entidade a ser convertida.
     * @return O DTO de resposta.
     */
    private DestaquesResponseDTO toResponseDTO(DestaquesItem entity) {
        if (entity instanceof DestaquesEvento) {
            DestaquesEvento evento = (DestaquesEvento) entity;
            return DestaquesEventoResponseDTO.builder()
                    .id(evento.getId())
                    .tipo(evento.getTipo())
                    .link(evento.getLink())
                    .status(evento.getStatus().name())
                    .titulo(evento.getTitulo())
                    .dataEvento(evento.getDataEvento())
                    .imagemUrl(evento.getImagemUrl())
                    .createdAt(evento.getCreatedAt())
                    .updatedAt(evento.getUpdatedAt())
                    .build();
        } else if (entity instanceof DestaquesEscritorio) {
            DestaquesEscritorio escritorio = (DestaquesEscritorio) entity;
            return DestaquesEscritorioResponseDTO.builder()
                    .id(escritorio.getId())
                    .tipo(escritorio.getTipo())
                    .link(escritorio.getLink())
                    .status(escritorio.getStatus().name())
                    .nome(escritorio.getNome())
                    .slogan(escritorio.getSlogan())
                    .logoUrl(escritorio.getLogoUrl())
                    .createdAt(escritorio.getCreatedAt())
                    .updatedAt(escritorio.getUpdatedAt())
                    .build();
        } else if (entity instanceof DestaquesNoticia) {
            DestaquesNoticia noticia = (DestaquesNoticia) entity;
            return DestaquesNoticiaResponseDTO.builder()
                    .id(noticia.getId())
                    .tipo(noticia.getTipo())
                    .link(noticia.getLink())
                    .status(noticia.getStatus().name())
                    .titulo(noticia.getTitulo())
                    .imagemUrl(noticia.getImagemUrl())
                    .dataPublicacao(noticia.getDataPublicacao())
                    .createdAt(noticia.getCreatedAt())
                    .updatedAt(noticia.getUpdatedAt())
                    .build();
        }
        return null;
    }

    /**
     * Converte um DTO de requisição polimórfico para uma entidade de domínio
     * PatrocinioItem.
     * 
     * @param dto O DTO de requisição.
     * @param id  O ID da entidade (pode ser null para criação).
     * @return A entidade de domínio.
     */
    private DestaquesItem toEntity(DestaquesRequestDTO dto, UUID id) {
        PatrocinioStatus status = PatrocinioStatus.INACTIVE;
        if (dto.getStatus() != null) {
            try {
                status = PatrocinioStatus.valueOf(dto.getStatus().toUpperCase());
            } catch (IllegalArgumentException e) {
                log.warn("Status inválido '{}' fornecido na requisição. Usando status padrão INACTIVE.",
                        dto.getStatus());
            }
        }

        if ("EVENTO".equalsIgnoreCase(dto.getTipo())) {
            DestaquesEventoRequestDTO eventoDto = (DestaquesEventoRequestDTO) dto;
            return DestaquesEvento.builder()
                    .id(id)
                    .link(eventoDto.getLink())
                    .status(status)
                    .titulo(eventoDto.getTitulo())
                    .dataEvento(eventoDto.getDataEvento())
                    .imagemUrl(eventoDto.getImagemUrl())
                    .build();
        } else if ("ESCRITORIO".equalsIgnoreCase(dto.getTipo())) {
            DestaquesEscritorioRequestDTO escritorioDto = (DestaquesEscritorioRequestDTO) dto;
            return DestaquesEscritorio.builder()
                    .id(id)
                    .link(escritorioDto.getLink())
                    .status(status)
                    .nome(escritorioDto.getNome())
                    .slogan(escritorioDto.getSlogan())
                    .logoUrl(escritorioDto.getLogoUrl())
                    .build();
        } else if ("NOTICIA".equalsIgnoreCase(dto.getTipo())) {
            DestaquesNoticiaRequestDTO noticiaDto = (DestaquesNoticiaRequestDTO) dto;
            return DestaquesNoticia.builder()
                    .id(id)
                    .link(noticiaDto.getLink())
                    .status(status)
                    .titulo(noticiaDto.getTitulo())
                    .imagemUrl(noticiaDto.getImagemUrl())
                    .dataPublicacao(noticiaDto.getDataPublicacao())
                    .build();
        }
        throw new BusinessException(ErrorCode.DADOS_INVALIDOS, "Tipo de patrocínio inválido.");
    }

    /**
     * Busca todos os patrocinadores com status ATIVO.
     *
     * @return Uma lista de DTOs de resposta de patrocinadores ativos.
     */
    public List<DestaquesResponseDTO> findActivePatrocinios() {
        log.info("Buscando patrocinadores ativos...");
        return domainService.findActivePatrocinios().stream()
                .map(this::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Busca todos os patrocinadores, independente do status.
     * Requer privilégios de administrador.
     *
     * @return Uma lista de DTOs de resposta de todos os patrocinadores.
     */
    public List<DestaquesResponseDTO> findAllPatrocinios() {
        log.info("Buscando todos os patrocinadores para administração...");
        return domainService.findAllPatrocinios().stream()
                .map(this::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Cria um novo patrocinador a partir de um DTO.
     *
     * @param requestDTO O DTO de requisição com os dados do patrocinador.
     * @return O DTO de resposta do patrocinador criado.
     */
    public DestaquesResponseDTO createPatrocinio(DestaquesRequestDTO requestDTO) {
        log.info("Iniciando a criação de um novo patrocinador do tipo: {}", requestDTO.getTipo());
        DestaquesItem newEntity = toEntity(requestDTO, null);
        DestaquesItem savedEntity = domainService.createPatrocinio(newEntity);
        log.info("Patrocinador criado com sucesso. ID: {}", savedEntity.getId());
        return toResponseDTO(savedEntity);
    }

    /**
     * Atualiza um patrocinador existente.
     *
     * @param id         ID do patrocinador a ser atualizado.
     * @param requestDTO O DTO de requisição com os dados atualizados.
     * @return O DTO de resposta do patrocinador atualizado.
     * @throws BusinessException se o patrocinador não for encontrado ou o status
     *                           for inválido.
     */
    public DestaquesResponseDTO updatePatrocinio(UUID id, DestaquesRequestDTO requestDTO) {
        log.info("Iniciando a atualização do patrocinador com ID: {}", id);
        DestaquesItem existingEntity = domainService.findPatrocinioById(id)
                .orElseThrow(
                        () -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, "Patrocinador não encontrado."));

        // Preenche a entidade existente com os novos dados do DTO
        DestaquesItem updatedEntity = toEntity(requestDTO, id);
        DestaquesItem savedEntity = domainService.updatePatrocinio(id, updatedEntity);
        log.info("Patrocinador com ID {} atualizado com sucesso.", savedEntity.getId());
        return toResponseDTO(savedEntity);
    }

    /**
     * Atualiza o status de um patrocinador.
     *
     * @param id     ID do patrocinador.
     * @param status A string do novo status (ex: "ACTIVE").
     * @return O DTO de resposta do patrocinador com o status alterado.
     * @throws BusinessException se o patrocinador não for encontrado ou o status
     *                           for inválido.
     */
    public DestaquesResponseDTO updatePatrocinioStatus(UUID id, String status) {
        log.info("Tentando atualizar o status do patrocinador com ID {} para: {}", id, status);
        PatrocinioStatus newStatus;
        try {
            newStatus = PatrocinioStatus.valueOf(status.toUpperCase());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, "Status inválido fornecido: " + status);
        }

        DestaquesItem updatedEntity = domainService.updatePatrocinioStatus(id, newStatus);
        log.info("Status do patrocinador com ID {} alterado para {}.", id, newStatus);
        return toResponseDTO(updatedEntity);
    }

    /**
     * Exclui um patrocinador pelo ID.
     *
     * @param id O ID do patrocinador a ser excluído.
     */
    public void deletePatrocinio(UUID id) {
        log.warn("Solicitação para excluir patrocinador com ID: {}", id);
        domainService.deletePatrocinio(id);
        log.warn("Patrocinador com ID {} excluído com sucesso.", id);
    }
}
```
```java
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================
spring.application.name=legalconnect-marketplace
server.port=${PORT:0}
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true

# ===================================================================
# Configurações do Eureka Client (Service Discovery)
# ===================================================================
eureka.client.enabled=true
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30

# ===================================================================
# Configurações do SpringDoc OpenAPI (Swagger UI)
# ===================================================================
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none
 
# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================
logging.level.br.com.legalconnect=INFO
logging.level.org.springframework=WARN
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN
logging.level.org.hibernate.hbm2ddl=WARN
logging.level.org.hibernate.engine.jdbc.connections=WARN
 
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

logging.level.org.springframework.web=DEBUG
logging.level.org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping=TRACE

 
# ===================================================================
# Configurações do Spring Boot Actuator (Monitoramento)
# ===================================================================
management.endpoints.web.exposure.include=*
management.endpoints.web.base-path=/actuator
 
# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================
spring.web.cors.allowed-origins=*
spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.web.cors.allowed-headers=*
spring.web.cors.allow-credentials=true
spring.web.cors.max-age=3600

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================
app.frontend.url=http://localhost:4200
# app.feature.new-registration-enabled=true

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
{
  "openapi": "3.0.1",
  "info": {
    "title": "LegalConnect API Gateway",
    "description": "Documentação da API via Gateway",
    "version": "1.0"
  },
  "servers": [
    { "url": "http://localhost:8080", "description": "Gateway Server" }
  ],
  "paths": {
    "/api/v1/usuarios/empresas/{id}": {
      "get": {
        "tags": ["controlador-empresa"],
        "operationId": "buscarEmpresaPorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-empresa"],
        "operationId": "atualizarEmpresa",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/EmpresaRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-empresa"],
        "operationId": "excluirEmpresa",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/clientes/{id}": {
      "get": {
        "tags": ["controlador-cliente"],
        "operationId": "buscarClientePorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-cliente"],
        "operationId": "atualizarCliente",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ClienteRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-cliente"],
        "operationId": "excluirCliente",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/administradores-plataforma/{id}": {
      "get": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "buscarAdministradorPorId",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "atualizarAdministrador",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdministradorRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "excluirAdministrador",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "required": true,
            "schema": { "type": "string", "format": "uuid" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": { "$ref": "#/components/schemas/BaseResponseVoid" }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/empresas": {
      "get": {
        "tags": ["controlador-empresa"],
        "operationId": "listarEmpresas",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageEmpresaResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-empresa"],
        "operationId": "cadastrarEmpresa",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/EmpresaRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseEmpresaResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/clientes": {
      "get": {
        "tags": ["controlador-cliente"],
        "operationId": "listarClientes",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageClienteResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-cliente"],
        "operationId": "cadastrarCliente",
        "parameters": [
          {
            "name": "X-Correlation-Id",
            "in": "header",
            "required": false,
            "schema": { "type": "string" }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/ClienteRequestDTO" }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseClienteResponseDTO"
                }
              }
            }
          }
        }
      }
    },
    "/api/v1/usuarios/administradores-plataforma": {
      "get": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "listarAdministradores",
        "parameters": [
          {
            "name": "pageable",
            "in": "query",
            "required": true,
            "schema": { "$ref": "#/components/schemas/Pageable" }
          }
        ],
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponsePageAdministradorResponseDTO"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["controlador-administrador-plataforma"],
        "operationId": "cadastrarAdministrador",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AdministradorRequestDTO"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/BaseResponseAdministradorResponseDTO"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "EmpresaRequestDTO": {
        "required": ["cnpj", "nomeFantasia", "razaoSocial"],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeFantasia": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "razaoSocial": { "maxLength": 255, "minLength": 0, "type": "string" },
          "cnpj": {
            "pattern": "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}",
            "type": "string"
          },
          "emailContato": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          }
        }
      },
      "EnderecoRequestDTO": {
        "required": [
          "bairro",
          "cep",
          "cidade",
          "estado",
          "logradouro",
          "numero",
          "pais",
          "tipoEndereco"
        ],
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "logradouro": { "maxLength": 255, "minLength": 0, "type": "string" },
          "numero": { "maxLength": 20, "minLength": 0, "type": "string" },
          "complemento": { "maxLength": 255, "minLength": 0, "type": "string" },
          "bairro": { "maxLength": 100, "minLength": 0, "type": "string" },
          "cidade": { "maxLength": 100, "minLength": 0, "type": "string" },
          "estado": { "maxLength": 2, "minLength": 2, "type": "string" },
          "cep": { "pattern": "\\d{5}-\\d{3}", "type": "string" },
          "pais": { "maxLength": 50, "minLength": 0, "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          }
        }
      },
      "BaseResponseEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/EmpresaResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "EmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "nomeFantasia": { "type": "string" },
          "razaoSocial": { "type": "string" },
          "cnpj": { "type": "string" },
          "emailContato": { "type": "string" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "EnderecoResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "logradouro": { "type": "string" },
          "numero": { "type": "string" },
          "complemento": { "type": "string" },
          "bairro": { "type": "string" },
          "cidade": { "type": "string" },
          "estado": { "type": "string" },
          "cep": { "type": "string" },
          "pais": { "type": "string" },
          "tipoEndereco": {
            "type": "string",
            "enum": [
              "RESIDENCIAL",
              "COMERCIAL",
              "ESCRITORIO",
              "COBRANCA",
              "ENTREGA",
              "OUTRO"
            ]
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "ClienteRequestDTO": {
        "required": ["cpf", "nomeCompleto"],
        "type": "object",
        "properties": {
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "pattern": "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "status": { "type": "string" }
        }
      },
      "UserRequestDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "email": { "type": "string" }
        }
      },
      "BaseResponseClienteResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/ClienteResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "ClienteResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserResponseDTO" },
          "nomeCompleto": { "type": "string" },
          "cpf": { "type": "string" },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" },
          "status": { "type": "string" },
          "tipo": { "type": "string" }
        }
      },
      "UserResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "email": { "type": "string" },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" }
        }
      },
      "AdministradorRequestDTO": {
        "required": ["cpf", "nomeCompleto"],
        "type": "object",
        "properties": {
          "usuario": { "$ref": "#/components/schemas/UserRequestDTO" },
          "nomeCompleto": {
            "maxLength": 255,
            "minLength": 0,
            "type": "string"
          },
          "cpf": {
            "pattern": "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}",
            "type": "string"
          },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoRequestDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "status": { "type": "string" }
        }
      },
      "AdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "id": { "type": "string", "format": "uuid" },
          "usuario": { "$ref": "#/components/schemas/UserResponseDTO" },
          "nomeCompleto": { "type": "string" },
          "cpf": { "type": "string" },
          "dataNascimento": { "type": "string", "format": "date" },
          "enderecos": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EnderecoResponseDTO" }
          },
          "telefones": {
            "uniqueItems": true,
            "type": "array",
            "items": { "type": "string" }
          },
          "createdAt": { "type": "string", "format": "date-time" },
          "updatedAt": { "type": "string", "format": "date-time" },
          "status": { "type": "string" }
        }
      },
      "BaseResponseAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/AdministradorResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "Pageable": {
        "type": "object",
        "properties": {
          "page": { "minimum": 0, "type": "integer", "format": "int32" },
          "size": { "minimum": 1, "type": "integer", "format": "int32" },
          "sort": { "type": "array", "items": { "type": "string" } }
        }
      },
      "BaseResponsePageEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/PageEmpresaResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageEmpresaResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/EmpresaResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "PageableObject": {
        "type": "object",
        "properties": {
          "offset": { "type": "integer", "format": "int64" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "pageNumber": { "type": "integer", "format": "int32" },
          "pageSize": { "type": "integer", "format": "int32" },
          "paged": { "type": "boolean" },
          "unpaged": { "type": "boolean" }
        }
      },
      "SortObject": {
        "type": "object",
        "properties": {
          "direction": { "type": "string" },
          "nullHandling": { "type": "string" },
          "ascending": { "type": "boolean" },
          "property": { "type": "string" },
          "ignoreCase": { "type": "boolean" }
        }
      },
      "BaseResponsePageClienteResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "$ref": "#/components/schemas/PageClienteResponseDTO" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageClienteResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/ClienteResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "BaseResponsePageAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": {
            "$ref": "#/components/schemas/PageAdministradorResponseDTO"
          },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      },
      "PageAdministradorResponseDTO": {
        "type": "object",
        "properties": {
          "totalPages": { "type": "integer", "format": "int32" },
          "totalElements": { "type": "integer", "format": "int64" },
          "size": { "type": "integer", "format": "int32" },
          "content": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/AdministradorResponseDTO" }
          },
          "number": { "type": "integer", "format": "int32" },
          "sort": {
            "type": "array",
            "items": { "$ref": "#/components/schemas/SortObject" }
          },
          "numberOfElements": { "type": "integer", "format": "int32" },
          "first": { "type": "boolean" },
          "last": { "type": "boolean" },
          "pageable": { "$ref": "#/components/schemas/PageableObject" },
          "empty": { "type": "boolean" }
        }
      },
      "BaseResponseVoid": {
        "type": "object",
        "properties": {
          "status": { "type": "string", "enum": ["SUCESSO", "ERRO", "AVISO"] },
          "message": { "type": "string" },
          "timestamp": { "type": "string", "format": "date-time" },
          "data": { "type": "object" },
          "errors": { "type": "array", "items": { "type": "string" } }
        }
      }
    }
  }
}

```
```java
# Read Me First

The following was discovered as part of building this project:

- The original package name 'br.com.legalconnect.auth.auth-service' is invalid and this project uses 'br.com.legalconnect.auth.auth_service' instead.

# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

- [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
- [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
- [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.

docker run --name jusplatform_db -e POSTGRES_DB=jusplatform_db -e POSTGRES_USER=jususer -e POSTGRES_PASSWORD=juspassword -p 5432:5432 -d postgres

```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version> <!-- Mantendo 3.2.5 para consistência com o Gateway, mas você pode usar
        3.2.12 se preferir -->
        <relativePath /> <!-- lookup parent from repository -->
    </parent>
    <groupId>br.com.legalconnect</groupId>
    <artifactId>legalconnect-usuario-service</artifactId> <!-- Certifique-se de que o artifactId está correto para o auth-service -->
    <version>0.0.1-SNAPSHOT</version>
    <name>legalconnect-usuario-service</name>
    <description>Authentication Microservice for LegalConnect</description>

    <properties>
        <java.version>17</java.version>
        <spring-cloud.version>2023.0.1</spring-cloud.version>

        <jjwt.version>0.11.5</jjwt.version> <!-- Mantido 0.12.5 para compatibilidade com a classe
        JwtUtil -->
        <flyway.version>11.8.2</flyway.version> <!-- CORRIGIDO: Define a versão do Flyway para 11.8.2 -->
        <lombok.version>1.18.30</lombok.version> <!-- Adicionado/Atualizado para garantir
        compatibilidade -->
        <org.mapstruct.version>1.5.5.Final</org.mapstruct.version> <!-- Adicionado/Atualizado para
        garantir compatibilidade -->
        <springdoc.version>2.5.0</springdoc.version> <!-- Atualizado para 2.5.0 para consistência com
        o Gateway -->
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>${jjwt.version}</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>${jjwt.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- MapStruct for DTO-Entity mapping -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${org.mapstruct.version}</version>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct-processor</artifactId>
            <version>${org.mapstruct.version}</version>
            <scope>provided</scope>
        </dependency>

        <!-- common-lib (se aplicável, mantenha a versão correta) -->
        <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-lib</artifactId>
            <version>1.0.1</version>
        </dependency>  <!-- common-lib (se aplicável, mantenha a versão
        correta) -->
        <!-- <dependency>
            <groupId>br.com.legalconnect.common</groupId>
            <artifactId>common-tenent</artifactId>
            <version>1.0.0</version>
        </dependency> -->

        <!-- Lombok for boilerplate code reduction -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Spring Boot Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- OpenAPI/Swagger UI -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- Jackson for JSON processing (used by JwtAuthEntryPoint) -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>


    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>

        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <!-- Plugin para MapStruct -->
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${org.mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                    <compilerArgs>
                        <arg>-Amapstruct.defaultComponentModel=spring</arg>
                    </compilerArgs>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-AuthServiceApplication<legalconnect-usuario-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.AuthServiceApplication",
      "projectName": "legalconnect-usuario-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    },
    {
      "type": "java",
      "name": "Spring Boot-LegalUsuarioApplication<legalconnect-usuario-service>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.LegalUsuarioApplication",
      "projectName": "legalconnect-usuario-service",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
```java
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication(exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui também, se já está no
                                                                // pacote raiz
@EntityScan(basePackages = {
        // "br.com.legalconnect.entity",
        "br.com.legalconnect.entity"
})
// @EnableJpaRepositories(basePackages = {
// "br.com.legalconnect.user.repository",
// "br.com.legalconnect.auth.repository"
// })
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class LegalUsuarioApplication {

    private static final Logger log = LoggerFactory.getLogger(LegalUsuarioApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(LegalUsuarioApplication.class, args);
        log.info("LegalUsuarioApplication iniciada com sucesso!");
    }
}
```
```java
package br.com.legalconnect.config; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.multitenancy.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String tenantIdHeader = request.getHeader(TENANT_HEADER);
            String tenantId = "public";

            if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
                try {
                    tenantId = (tenantIdHeader);
                } catch (IllegalArgumentException e) {
                    // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                    System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                    return;
                }
            } else {
                // Usar o tenant padrão se o cabeçalho não for fornecido
                try {
                    tenantId = (defaultTenantId);
                } catch (IllegalArgumentException e) {
                    System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                            "Configuração de Tenant padrão inválida.");
                    return;
                }
            }

            TenantContext.setCurrentTenant(tenantId);
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear(); // Limpar o TenantContext após a requisição
        }
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.AdministradorRequestDTO;
import dto.AdministradorResponseDTO;
import service.ServicoAdministrador;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorAdministradorPlataforma
 * @brief Controlador REST para gerenciar operações relacionadas a Administradores da Plataforma.
 * Expõe endpoints para CRUD de Administradores.
 */
@RestController
@RequestMapping("/api/v1/administradores-plataforma")
public class ControladorAdministradorPlataforma {

    private final ServicoAdministrador servicoAdministrador;

    @Autowired
    public ControladorAdministradorPlataforma(ServicoAdministrador servicoAdministrador) {
        this.servicoAdministrador = servicoAdministrador;
    }

    /**
     * @brief Cadastra um novo Administrador da Plataforma.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return ResponseEntity com o DTO do Administrador cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> cadastrarAdministrador(@Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.cadastrarAdministrador(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Administrador da Plataforma por ID.
     * @param id ID do Administrador a ser buscado.
     * @return ResponseEntity com o DTO do Administrador encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> buscarAdministradorPorId(@PathVariable UUID id) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.buscarAdministradorPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Administradores da Plataforma com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Administradores e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<AdministradorResponseDTO>>> listarAdministradores(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<AdministradorResponseDTO> responsePage = servicoAdministrador.listarAdministradores(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de administradores recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Administrador da Plataforma existente.
     * @param id ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return ResponseEntity com o DTO do Administrador atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> atualizarAdministrador(
            @PathVariable UUID id,
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.atualizarAdministrador(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Administrador da Plataforma pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirAdministrador(@PathVariable UUID id) {
        servicoAdministrador.excluirAdministrador(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Administrador excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.ClienteRequestDTO;
import dto.ClienteResponseDTO;
import service.ServicoCliente;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorCliente
 * @brief Controlador REST para gerenciar operações relacionadas a Clientes.
 * Expõe endpoints para CRUD de Clientes.
 */
@RestController
@RequestMapping("/api/v1/clientes")
public class ControladorCliente {

    private final ServicoCliente servicoCliente;

    @Autowired
    public ControladorCliente(ServicoCliente servicoCliente) {
        this.servicoCliente = servicoCliente;
    }

    /**
     * @brief Cadastra um novo Cliente.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return ResponseEntity com o DTO do Cliente cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> cadastrarCliente(@Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.cadastrarCliente(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Cliente por ID.
     * @param id ID do Cliente a ser buscado.
     * @return ResponseEntity com o DTO do Cliente encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> buscarClientePorId(@PathVariable UUID id) {
        ClienteResponseDTO responseDTO = servicoCliente.buscarClientePorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Clientes e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ClienteResponseDTO>>> listarClientes(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ClienteResponseDTO> responsePage = servicoCliente.listarClientes(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de clientes recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return ResponseEntity com o DTO do Cliente atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> atualizarCliente(
            @PathVariable UUID id,
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.atualizarCliente(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirCliente(@PathVariable UUID id) {
        servicoCliente.excluirCliente(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Cliente excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.EmpresaRequestDTO;
import dto.EmpresaResponseDTO;
import service.ServicoEmpresa;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorEmpresa
 * @brief Controlador REST para gerenciar operações relacionadas a Empresas.
 * Expõe endpoints para CRUD de Empresas.
 */
@RestController
@RequestMapping("/api/v1/empresas")
public class ControladorEmpresa {

    private final ServicoEmpresa servicoEmpresa;

    @Autowired
    public ControladorEmpresa(ServicoEmpresa servicoEmpresa) {
        this.servicoEmpresa = servicoEmpresa;
    }

    /**
     * @brief Cadastra uma nova Empresa.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return ResponseEntity com o DTO da Empresa cadastrada e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> cadastrarEmpresa(@Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.cadastrarEmpresa(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa cadastrada com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca uma Empresa por ID.
     * @param id ID da Empresa a ser buscada.
     * @return ResponseEntity com o DTO da Empresa encontrada e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> buscarEmpresaPorId(@PathVariable UUID id) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.buscarEmpresaPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa encontrada.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeFantasia,asc).
     * @return ResponseEntity com uma página de DTOs de Empresas e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<EmpresaResponseDTO>>> listarEmpresas(
            @PageableDefault(size = 10, page = 0, sort = "nomeFantasia") Pageable pageable) {
        Page<EmpresaResponseDTO> responsePage = servicoEmpresa.listarEmpresas(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de empresas recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return ResponseEntity com o DTO da Empresa atualizada e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> atualizarEmpresa(
            @PathVariable UUID id,
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.atualizarEmpresa(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa atualizada com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirEmpresa(@PathVariable UUID id) {
        servicoEmpresa.excluirEmpresa(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Empresa excluída com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.controller;

import dto.ProfissionalRequestDTO;
import dto.ProfissionalResponseDTO;
import service.ServicoProfissional;
import common.dto.BaseResponse; // Importa da common-lib
import common.dto.SuccessResponseDTO; // Importa da common-lib
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.UUID;

/**
 * @class ControladorProfissional
 * @brief Controlador REST para gerenciar operações relacionadas a Profissionais.
 * Expõe endpoints para CRUD de Profissionais.
 */
@RestController
@RequestMapping("/api/v1/profissionais")
public class ControladorProfissional {

    private final ServicoProfissional servicoProfissional;

    @Autowired
    public ControladorProfissional(ServicoProfissional servicoProfissional) {
        this.servicoProfissional = servicoProfissional;
    }

    /**
     * @brief Cadastra um novo Profissional.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return ResponseEntity com o DTO do Profissional cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> cadastrarProfissional(@Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.cadastrarProfissional(requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional cadastrado com sucesso.", null, responseDTO, null), HttpStatus.CREATED);
    }

    /**
     * @brief Busca um Profissional por ID.
     * @param id ID do Profissional a ser buscado.
     * @return ResponseEntity com o DTO do Profissional encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> buscarProfissionalPorId(@PathVariable UUID id) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.buscarProfissionalPorId(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional encontrado.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex: ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Profissionais e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> listarProfissionais(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ProfissionalResponseDTO> responsePage = servicoProfissional.listarProfissionais(pageable);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Lista de profissionais recuperada com sucesso.", null, responsePage, null), HttpStatus.OK);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return ResponseEntity com o DTO do Profissional atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> atualizarProfissional(
            @PathVariable UUID id,
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.atualizarProfissional(id, requestDTO);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional atualizado com sucesso.", null, responseDTO, null), HttpStatus.OK);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirProfissional(@PathVariable UUID id) {
        servicoProfissional.excluirProfissional(id);
        return new ResponseEntity<>(new BaseResponse<>("SUCCESS", "Profissional excluído com sucesso.", null, null, null), HttpStatus.NO_CONTENT);
    }
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorRequestDTO
 * @brief DTO para requisições de criação ou atualização de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorResponseDTO
 * @brief DTO para respostas de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorResponseDTO extends PessoaResponseDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteRequestDTO
 * @brief DTO para requisições de criação ou atualização de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteResponseDTO
 * @brief DTO para respostas de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteResponseDTO extends PessoaResponseDTO {
    private String status;
    private String tipo;
}
```
```java
package br.com.legalconnect.dto;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaRequestDTO
 * @brief DTO para requisições de criação ou atualização de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O nome fantasia não pode estar em branco.")
    @Size(max = 255, message = "O nome fantasia deve ter no máximo 255 caracteres.")
    private String nomeFantasia;

    @NotBlank(message = "A razão social não pode estar em branco.")
    @Size(max = 255, message = "A razão social deve ter no máximo 255 caracteres.")
    private String razaoSocial;

    @NotBlank(message = "O CNPJ não pode estar em branco.")
    @Pattern(regexp = "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}", message = "Formato de CNPJ inválido. Use XX.XXX.XXX/XXXX-XX.")
    private String cnpj;

    @Email(message = "Formato de email de contato inválido.")
    @Size(max = 255, message = "O email de contato deve ter no máximo 255 caracteres.")
    private String emailContato;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos;

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaResponseDTO
 * @brief DTO para respostas de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaResponseDTO {
    private UUID id;
    private String nomeFantasia;
    private String razaoSocial;
    private String cnpj;
    private String emailContato;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoRequestDTO
 * @brief DTO para requisições de criação ou atualização de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número não pode estar em branco.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade não pode estar em branco.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado não pode estar em branco.")
    @Size(min = 2, max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "\\d{5}-\\d{3}", message = "Formato de CEP inválido. Use XXXXX-XXX.")
    private String cep;

    @NotBlank(message = "O país não pode estar em branco.")
    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais;

    @NotNull(message = "O tipo de endereço não pode ser nulo.")
    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoResponseDTO
 * @brief DTO para respostas de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;
    private String logradouro;
    private String numero;
    private String complemento;
    private String bairro;
    private String cidade;
    private String estado;
    private String cep;
    private String pais;
    private TipoEndereco tipoEndereco;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.util.List; // Usar List para Enderecos para manter a ordem se necessário
import java.util.Set;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaRequestDTO
 * @brief DTO base para requisições de criação ou atualização de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // Não incluir o ID aqui, pois ele será definido pela entidade base (BaseEntity)
    // e retornado no ResponseDTO.

    @NotNull(message = "Os dados do usuário não podem ser nulos.")
    @Valid // Valida o DTO aninhado
    private UserRequestDTO usuario;

    @NotBlank(message = "O nome completo não pode estar em branco.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Pattern(regexp = "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}", message = "Formato de CPF inválido. Use XXX.XXX.XXX-XX.")
    private String cpf;

    @PastOrPresent(message = "A data de nascimento não pode ser futura.")
    private LocalDate dataNascimento;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos; // Usar List para manter a ordem se necessário

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaResponseDTO
 * @brief DTO base para respostas de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaResponseDTO {
    private UUID id;
    private UserResponseDTO usuario;
    private String nomeCompleto;
    private String cpf;
    private LocalDate dataNascimento;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Plano.VisibilidadeDestaque;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class PlanoResponseDTO
 * @brief DTO para respostas de Plano.
 *        Esta classe é um DTO simplificado para ser usado em outros
 *        microsserviços.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PlanoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
    private BigDecimal precoMensal;
    private BigDecimal precoAnual;
    private Integer limiteServicosAgendaveis;
    private VisibilidadeDestaque visibilidadeDestaque;
    private Boolean acessoRelatoriosAvancados;
    private Boolean permitePedidosOrcamento;
    private Integer periodoTesteDias;
    private Boolean isDefault;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalRequestDTO
 * @brief DTO para requisições de criação ou atualização de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalRequestDTO extends PessoaRequestDTO {
    @NotBlank(message = "O número da OAB não pode estar em branco.")
    @Size(max = 50, message = "O número da OAB deve ter no máximo 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "O status profissional não pode ser nulo.")
    private StatusProfissional statusProfissional;

    @NotNull(message = "A indicação de uso do marketplace não pode ser nula.")
    private Boolean usaMarketplace;

    @NotNull(message = "A indicação de participação em plano não pode ser nula.")
    private Boolean fazParteDePlano;

    private UUID empresaId; // ID da empresa associada (opcional)

    @NotNull(message = "O ID do plano não pode ser nulo.")
    private UUID planoId; // ID do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalResponseDTO
 * @brief DTO para respostas de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalResponseDTO extends PessoaResponseDTO {
    private String numeroOab;
    private StatusProfissional statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private EmpresaResponseDTO empresa; // DTO da empresa associada (simplificado)
    private PlanoResponseDTO plano; // DTO do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserRequestDTO
 * @brief DTO para requisições de criação ou atualização de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    private UUID id;
    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    private String email;

    // @NotBlank(message = "A senha não pode estar em branco.")
    // @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // private String password;

    // O papel (Role) pode ser definido aqui ou inferido pelo serviço de
    // autenticação/usuário
    // dependendo da lógica de negócio. Para simplificar, pode ser incluído se for
    // um input direto.
    // private String role;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserResponseDTO
 * @brief DTO para respostas de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // private String role; // Incluir se o papel for relevante na resposta
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Administrador
 * @brief Entidade que representa um administrador da plataforma.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_administrador' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_administrador")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Administrador extends Pessoa {
    private String status;

    // Atualmente, não há campos adicionais específicos para Administrador além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, nível de acesso
    // administrativo, etc.
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Cliente
 * @brief Entidade que representa um cliente.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_cliente' que se junta a 'tb_pessoa' pela
 *        chave primária.
 */
@Entity
@Table(name = "tb_cliente")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Cliente extends Pessoa {
    private String status;
    private String tipo;

    // Atualmente, não há campos adicionais específicos para Cliente além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, histórico de preferências,
    // etc.
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Empresa
 * @brief Entidade que representa uma empresa que pode contratar planos na
 *        plataforma.
 *        Esta entidade não estende Pessoa, pois representa uma pessoa jurídica.
 *        Mapeada para a tabela 'tb_empresa'.
 */
@Entity
@Table(name = "tb_empresa")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Empresa extends BaseEntity {

    @Column(name = "nome_fantasia", nullable = false, length = 255)
    private String nomeFantasia; // Nome fantasia da empresa

    @Column(name = "razao_social", nullable = false, length = 255)
    private String razaoSocial; // Razão social da empresa

    @Column(name = "cnpj", nullable = false, unique = true, length = 18) // CNPJ com máscara
    private String cnpj; // Número do Cadastro Nacional de Pessoas Jurídicas (CNPJ), único por empresa

    @Column(name = "email_contato", length = 255)
    private String emailContato; // E-mail de contato da empresa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma empresa pode ter múltiplos endereços (sede, filiais, etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Empresa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'empresa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da empresa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_empresa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_empresa_telefones", joinColumns = @JoinColumn(name = "empresa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da empresa

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionais = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id")
    private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set; // Usaremos Set para evitar duplicatas e garantir unicidade

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public abstract class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da pessoa
}
```
```java
package br.com.legalconnect.entity;

import java.math.BigDecimal;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 *        plataforma.
 *        Esta classe é um placeholder e deve ser definida em seu próprio
 *        microsserviço (marketplace).
 *        Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault; // Indica se é o plano padrão para novos cadastros

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     *        plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        PREMIUM,
        DESTAQUE_MAXIMO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Profissional
 * @brief Entidade que representa um profissional do direito.
 *        Estende a entidade Pessoa e adiciona campos específicos de um
 *        profissional.
 *        Mapeado para a tabela 'tb_profissional' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_profissional")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab; // Número de registro na OAB, único por profissional

    @Enumerated(EnumType.STRING)
    @Column(name = "status_profissional", nullable = false, length = 50)
    private StatusProfissional statusProfissional; // Status específico do profissional (ex: ATIVO, LICENCIADO)

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false; // Indica se o profissional deseja aparecer no marketplace

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false; // Indica se o profissional está associado a um plano pago

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um profissional pode pertencer a uma empresa.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id") // Coluna de chave estrangeira para a empresa
    private Empresa empresa; // A empresa à qual o profissional está associado (se houver)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Plano.
     *        Um profissional está associado a um plano de assinatura.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira para o plano
    private Plano plano; // O plano de assinatura do advogado
    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_profissionals_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "profissional_profissionals_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<RoleProfissional> roleProfissionals = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum StatusProfissional
     * @brief Enumeração para representar o status específico de um Profissional.
     */
    public enum StatusProfissional {
        ATIVO, // Profissional ativo e em dia
        LICENCIADO, // Profissional com licença temporariamente suspensa
        SUSPENSO, // Profissional suspenso (ex: por infração)
        EM_ANALISE // Profissional aguardando aprovação/verificação
    }
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 *        Esta tabela de roles agora reside nos schemas de tenant, o que
 *        significa
 *        que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 *        IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RoleProfissional extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface AdministradorMapper
 * @brief Mapper MapStruct para conversão entre Administrador e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface AdministradorMapper extends PessoaMapper {

    AdministradorMapper INSTANCE = Mappers.getMapper(AdministradorMapper.class);

    /**
     * @brief Mapeia um AdministradorRequestDTO para uma entidade Administrador.
     * @param dto O DTO de requisição do administrador.
     * @return A entidade Administrador.
     */
    Administrador toEntity(AdministradorRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Administrador para um AdministradorResponseDTO.
     * @param entity A entidade Administrador.
     * @return O DTO de resposta do administrador.
     */
    @Mapping(source = "status", target = "status")
    AdministradorResponseDTO toResponseDTO(Administrador entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ClienteMapper
 * @brief Mapper MapStruct para conversão entre Cliente e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface ClienteMapper extends PessoaMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    /**
     * @brief Mapeia um ClienteRequestDTO para uma entidade Cliente.
     * @param dto O DTO de requisição do cliente.
     * @return A entidade Cliente.
     */
    Cliente toEntity(ClienteRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Cliente para um ClienteResponseDTO.
     * @param entity A entidade Cliente.
     * @return O DTO de resposta do cliente.
     */
    @Mapping(source = "status", target = "status")
    @Mapping(target = "tipo", ignore = true) // O campo 'tipo' não existe na entidade Cliente, apenas no DTO de resposta
    ClienteResponseDTO toResponseDTO(Cliente entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EmpresaMapper
 * @brief Mapper MapStruct para conversão entre Empresa e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class})
public interface EmpresaMapper {

    EmpresaMapper INSTANCE = Mappers.getMapper(EmpresaMapper.class);

    /**
     * @brief Converte um EmpresaRequestDTO para uma entidade Empresa.
     * @param dto O DTO de requisição da empresa.
     * @return A entidade Empresa.
     */
    @Mapping(target = "id", ignore = true) // ID é gerado, não vem do DTO de requisição
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    Empresa toEntity(EmpresaRequestDTO dto);

    /**
     * @brief Converte uma entidade Empresa para um EmpresaResponseDTO.
     * @param entity A entidade Empresa.
     * @return O DTO de resposta da empresa.
     */
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    EmpresaResponseDTO toResponseDTO(Empresa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Endereco.TipoEndereco; // Importa o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EnderecoMapper
 * @brief Mapper MapStruct para conversão entre Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * @brief Converte um EnderecoRequestDTO para uma entidade Endereco.
     * @param dto O DTO de requisição do endereço.
     * @return A entidade Endereco.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "pessoa", ignore = true) // Será setado no serviço
    @Mapping(target = "empresa", ignore = true) // Será setado no serviço
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * @brief Converte uma entidade Endereco para um EnderecoResponseDTO.
     * @param entity A entidade Endereco.
     * @return O DTO de resposta do endereço.
     */
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * @brief Converte uma lista de EnderecoRequestDTOs para um Set de entidades Endereco.
     * @param dtoList A lista de DTOs de requisição de endereços.
     * @return Um Set de entidades Endereco.
     */
    Set<Endereco> toEntitySet(List<EnderecoRequestDTO> dtoList);

    /**
     * @brief Converte um Set de entidades Endereco para uma lista de EnderecoResponseDTOs.
     * @param entitySet Um Set de entidades Endereco.
     * @return Uma lista de DTOs de resposta de endereços.
     */
    List<EnderecoResponseDTO> toResponseDTOList(Set<Endereco> entitySet);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.InheritInverseConfiguration; // Importar se for usar @InheritInverseConfiguration
import org.mapstruct.factory.Mappers;

/**
 * @interface PessoaMapper
 * @brief Mapper MapStruct para conversão entre Pessoa e seus DTOs.
 * Esta é uma interface base para ser estendida por mappers de subclasses de Pessoa.
 */
@Mapper(componentModel = "spring", uses = {UserMapper.class, EnderecoMapper.class})
public interface PessoaMapper {

    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * @brief Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta da pessoa.
     */
    @Mapping(source = "usuario", target = "usuario")
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    PessoaResponseDTO toResponseDTO(Pessoa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano; // Importar Plano da entidade
import br.com.legalconnect.dto.EmpresaResponseDTO; // Importar EmpresaResponseDTO
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa; // Importar Empresa da entidade
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.Profissional.StatusProfissional; // Importar o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ProfissionalMapper
 * @brief Mapper MapStruct para conversão entre Profissional e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class, EmpresaMapper.class})
public interface ProfissionalMapper extends PessoaMapper {

    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * @brief Mapeia um ProfissionalRequestDTO para uma entidade Profissional.
     * @param dto O DTO de requisição do profissional.
     * @return A entidade Profissional.
     */
    @Mapping(target = "empresa", ignore = true) // Empresa será setada no serviço
    @Mapping(target = "plano", ignore = true)   // Plano será setado no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Não presente no DTO
    Profissional toEntity(ProfissionalRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * @param entity A entidade Profissional.
     * @return O DTO de resposta do profissional.
     */
    @Mapping(source = "empresa", target = "empresa")
    @Mapping(source = "plano", target = "plano")
    ProfissionalResponseDTO toResponseDTO(Profissional entity);

    /**
     * @brief Mapeia uma entidade Plano para um PlanoResponseDTO.
     * @param plano A entidade Plano.
     * @return O DTO de resposta do Plano.
     */
    PlanoResponseDTO toPlanoResponseDTO(Plano plano);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper MapStruct para conversão entre User e seus DTOs.
 */
@Mapper(componentModel = "spring") // Integração com Spring para injeção de dependência
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * @brief Converte um UserRequestDTO para uma entidade User.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserRequestDTO.
     * @param dto O DTO de requisição do usuário.
     * @return A entidade User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "nomeCompleto", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "cpf", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "telefone", ignore = true) // Não presente no DTO de requisição
    // @Mapping(target = "senhaHash", source = "password") // Mapeia password do DTO
    // para senhaHash da entidade
    @Mapping(target = "fotoUrl", ignore = true) // Não presente no DTO de requisição
    User toEntity(UserRequestDTO dto);

    /**
     * @brief Converte uma entidade User para um UserResponseDTO.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserResponseDTO.
     * @param entity A entidade User.
     * @return O DTO de resposta do usuário.
     */
    @Mapping(target = "email", source = "email")
    UserResponseDTO toResponseDTO(User entity);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Administrador;

/**
 * @interface RepositorioAdministrador
 * @brief Repositório Spring Data JPA para a entidade Administrador.
 *        Fornece métodos CRUD e de busca personalizados para Administrador.
 */
@Repository
public interface RepositorioAdministrador extends JpaRepository<Administrador, UUID> {

    /**
     * @brief Busca um Administrador pelo CPF.
     * @param cpf O CPF do administrador.
     * @return Um Optional contendo o Administrador, se encontrado.
     */
    Optional<Administrador> findByCpf(String cpf);

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Administradores.
     */
    Page<Administrador> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Cliente;

/**
 * @interface RepositorioCliente
 * @brief Repositório Spring Data JPA para a entidade Cliente.
 *        Fornece métodos CRUD e de busca personalizados para Cliente.
 */
@Repository
public interface RepositorioCliente extends JpaRepository<Cliente, UUID> {

    /**
     * @brief Busca um Cliente pelo CPF.
     * @param cpf O CPF do cliente.
     * @return Um Optional contendo o Cliente, se encontrado.
     */
    Optional<Cliente> findByCpf(String cpf);

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Clientes.
     */
    Page<Cliente> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Empresa;

/**
 * @interface RepositorioEmpresa
 * @brief Repositório Spring Data JPA para a entidade Empresa.
 *        Fornece métodos CRUD e de busca personalizados para Empresa.
 */
@Repository
public interface RepositorioEmpresa extends JpaRepository<Empresa, UUID> {

    /**
     * @brief Busca uma Empresa pelo CNPJ.
     * @param cnpj O CNPJ da empresa.
     * @return Um Optional contendo a Empresa, se encontrada.
     */
    Optional<Empresa> findByCnpj(String cnpj);

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Empresas.
     */
    Page<Empresa> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Endereco;

/**
 * @interface RepositorioEndereco
 * @brief Repositório Spring Data JPA para a entidade Endereco.
 *        Fornece métodos CRUD básicos para Endereco.
 */
@Repository
public interface RepositorioEndereco extends JpaRepository<Endereco, UUID> {
    // Métodos de busca adicionais podem ser definidos aqui se necessário,
    // como findByPessoaId(UUID pessoaId) ou findByEmpresaId(UUID empresaId)
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Pessoa;

/**
 * @interface RepositorioPessoa
 * @brief Repositório Spring Data JPA para a entidade Pessoa (base).
 *        Fornece métodos CRUD básicos para Pessoa e busca por CPF.
 *        Como Pessoa é uma entidade base abstrata com estratégia JOINED, este
 *        repositório
 *        pode ser usado para operações polimórficas se necessário, mas
 *        geralmente
 *        repositórios específicos para subclasses (Profissional, Cliente,
 *        Administrador)
 *        são mais comuns para operações de negócio.
 */
@Repository
public interface RepositorioPessoa extends JpaRepository<Pessoa, UUID> {

    /**
     * @brief Busca uma Pessoa pelo CPF.
     * @param cpf O CPF da pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Plano;

/**
 * @interface RepositorioPlano
 * @brief Repositório Spring Data JPA para a entidade Plano.
 *        Fornece métodos CRUD e de busca personalizados para Plano.
 *        **Nota:** Em uma arquitetura de microsserviços ideal, esta entidade e
 *        seu
 *        repositório poderiam residir em um serviço de 'marketplace' ou
 *        'assinatura'.
 *        Aqui, é mantido para fins de completude do modelo de dados do
 *        user-service,
 *        mas a gestão real dos planos pode ser externa.
 */
@Repository
public interface RepositorioPlano extends JpaRepository<Plano, UUID> {

    /**
     * @brief Busca um Plano pelo nome.
     * @param nome O nome do plano.
     * @return Um Optional contendo o Plano, se encontrado.
     */
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Profissional;

/**
 * @interface RepositorioProfissional
 * @brief Repositório Spring Data JPA para a entidade Profissional.
 *        Fornece métodos CRUD e de busca personalizados para Profissional.
 */
@Repository
public interface RepositorioProfissional extends JpaRepository<Profissional, UUID> {

    /**
     * @brief Busca um Profissional pelo CPF.
     * @param cpf O CPF do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByCpf(String cpf);

    /**
     * @brief Busca um Profissional pelo número da OAB.
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Profissionais.
     */
    Page<Profissional> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.RoleProfissional;

/**
 * @interface RepositorioRoleProfissional
 * @brief Repositório Spring Data JPA para a entidade RoleProfissional.
 *        Fornece métodos CRUD e de busca personalizados para RoleProfissional.
 *        **Nota:** Em um ambiente multi-tenant, os papéis podem ser globais ou
 *        por tenant.
 *        Este repositório assume que a entidade RoleProfissional está no schema
 *        do tenant.
 */
@Repository
public interface RepositorioRoleProfissional extends JpaRepository<RoleProfissional, UUID> {

    /**
     * @brief Busca um RoleProfissional pelo nome.
     * @param nome O nome do papel.
     * @return Um Optional contendo o RoleProfissional, se encontrado.
     */
    Optional<RoleProfissional> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.User;

/**
 * @interface RepositorioUser
 * @brief Repositório Spring Data JPA para a entidade User.
 *        Fornece métodos CRUD e de busca personalizados para User.
 *        **Nota:** Este repositório é crucial para o pré-requisito de
 *        associação de Pessoa a um User existente.
 *        As operações de criação/atualização de User em si são de
 *        responsabilidade de outro microsserviço (ex: auth-service).
 */
@Repository
public interface RepositorioUser extends JpaRepository<User, UUID> {

    /**
     * @brief Busca um User pelo email.
     * @param email O email do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.AdministradorMapper;
import br.com.legalconnect.repository.RepositorioAdministrador;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoAdministrador
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Administradores.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Administradores.
 */
@Service
public class ServicoAdministrador {

    private final RepositorioAdministrador repositorioAdministrador;
    private final RepositorioUser repositorioUser;
    private final AdministradorMapper administradorMapper;

    @Autowired
    public ServicoAdministrador(RepositorioAdministrador repositorioAdministrador, RepositorioUser repositorioUser,
            AdministradorMapper administradorMapper) {
        this.repositorioAdministrador = repositorioAdministrador;
        this.repositorioUser = repositorioUser;
        this.administradorMapper = administradorMapper;
    }

    /**
     * @brief Cadastra um novo Administrador no sistema.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return DTO com os dados do Administrador cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public AdministradorResponseDTO cadastrarAdministrador(AdministradorRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro administrador.");
        }

        // 3. Mapear DTO para entidade
        Administrador administrador = administradorMapper.toEntity(requestDTO);
        administrador.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Administrador)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = administradorMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(administrador); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        administrador.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Administrador savedAdministrador = repositorioAdministrador.save(administrador);

        // 6. Mapear entidade salva para DTO de resposta
        return administradorMapper.toResponseDTO(savedAdministrador);
    }

    /**
     * @brief Busca um Administrador pelo ID.
     * @param id ID do Administrador a ser buscado.
     * @return DTO com os dados do Administrador encontrado.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional(readOnly = true)
    public AdministradorResponseDTO buscarAdministradorPorId(UUID id) {
        Administrador administrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado."));
        return administradorMapper.toResponseDTO(administrador);
    }

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Administradores.
     */
    @Transactional(readOnly = true)
    public Page<AdministradorResponseDTO> listarAdministradores(Pageable pageable) {
        return repositorioAdministrador.findAll(pageable)
                .map(administradorMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Administrador existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return DTO com os dados do Administrador atualizado.
     * @throws BusinessException Se o Administrador não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public AdministradorResponseDTO atualizarAdministrador(UUID id, AdministradorRequestDTO requestDTO) {
        Administrador existingAdministrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingAdministrador.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro administrador.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Administrador
        // O mapper precisa de um método de atualização, ou fazer manualmente
        existingAdministrador.setNomeCompleto(requestDTO.getNomeCompleto());
        existingAdministrador.setCpf(requestDTO.getCpf());
        existingAdministrador.setDataNascimento(requestDTO.getDataNascimento());
        existingAdministrador.setStatus(requestDTO.getStatus()); // Campo específico de Administrador

        // 3. Atualizar endereços (lógica de sincronização)
        existingAdministrador.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            // Reutiliza o mapper para converter DTO para Endereco
            Endereco newEndereco = administradorMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingAdministrador); // Garante a associação bidirecional
            existingAdministrador.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingAdministrador.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingAdministrador.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Administrador updatedAdministrador = repositorioAdministrador.save(existingAdministrador);

        return administradorMapper.toResponseDTO(updatedAdministrador);
    }

    /**
     * @brief Exclui um Administrador pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional
    public void excluirAdministrador(UUID id) {
        if (!repositorioAdministrador.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Administrador com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioAdministrador.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ClienteMapper;
import br.com.legalconnect.repository.RepositorioCliente;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoCliente
 * @brief Serviço de domínio para gerenciar operações relacionadas a Clientes.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Clientes.
 */
@Service
public class ServicoCliente {

    private final RepositorioCliente repositorioCliente;
    private final RepositorioUser repositorioUser;
    private final ClienteMapper clienteMapper;

    @Autowired
    public ServicoCliente(RepositorioCliente repositorioCliente, RepositorioUser repositorioUser,
            ClienteMapper clienteMapper) {
        this.repositorioCliente = repositorioCliente;
        this.repositorioUser = repositorioUser;
        this.clienteMapper = clienteMapper;
    }

    /**
     * @brief Cadastra um novo Cliente no sistema.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return DTO com os dados do Cliente cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public ClienteResponseDTO cadastrarCliente(ClienteRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro cliente.");
        }

        // 3. Mapear DTO para entidade
        Cliente cliente = clienteMapper.toEntity(requestDTO);
        cliente.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Cliente)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = clienteMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(cliente); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        cliente.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Cliente savedCliente = repositorioCliente.save(cliente);

        // 6. Mapear entidade salva para DTO de resposta
        return clienteMapper.toResponseDTO(savedCliente);
    }

    /**
     * @brief Busca um Cliente pelo ID.
     * @param id ID do Cliente a ser buscado.
     * @return DTO com os dados do Cliente encontrado.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional(readOnly = true)
    public ClienteResponseDTO buscarClientePorId(UUID id) {
        Cliente cliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado."));
        return clienteMapper.toResponseDTO(cliente);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Clientes.
     */
    @Transactional(readOnly = true)
    public Page<ClienteResponseDTO> listarClientes(Pageable pageable) {
        return repositorioCliente.findAll(pageable)
                .map(clienteMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return DTO com os dados do Cliente atualizado.
     * @throws BusinessException Se o Cliente não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public ClienteResponseDTO atualizarCliente(UUID id, ClienteRequestDTO requestDTO) {
        Cliente existingCliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingCliente.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro cliente.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Cliente
        existingCliente.setNomeCompleto(requestDTO.getNomeCompleto());
        existingCliente.setCpf(requestDTO.getCpf());
        existingCliente.setDataNascimento(requestDTO.getDataNascimento());
        existingCliente.setStatus(requestDTO.getStatus()); // Campo específico de Cliente
        existingCliente.setTipo(requestDTO.getTipo()); // Campo específico de Cliente

        // 3. Atualizar endereços (lógica de sincronização)
        existingCliente.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = clienteMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingCliente);
            existingCliente.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingCliente.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingCliente.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Cliente updatedCliente = repositorioCliente.save(existingCliente);

        return clienteMapper.toResponseDTO(updatedCliente);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional
    public void excluirCliente(UUID id) {
        if (!repositorioCliente.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Cliente com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioCliente.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.EmpresaRequestDTO;
import dto.EmpresaResponseDTO;
import entity.Empresa;
import entity.Endereco;
import common.exception.BusinessException; // Importa da common-lib
import mapper.EmpresaMapper;
import repository.RepositorioEmpresa;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoEmpresa
 * @brief Serviço de domínio para gerenciar operações relacionadas a Empresas.
 * Contém a lógica de negócio para criação, busca, atualização e exclusão de Empresas.
 */
@Service
public class ServicoEmpresa {

    private final RepositorioEmpresa repositorioEmpresa;
    private final EmpresaMapper empresaMapper;

    @Autowired
    public ServicoEmpresa(RepositorioEmpresa repositorioEmpresa, EmpresaMapper empresaMapper) {
        this.repositorioEmpresa = repositorioEmpresa;
        this.empresaMapper = empresaMapper;
    }

    /**
     * @brief Cadastra uma nova Empresa no sistema.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return DTO com os dados da Empresa cadastrada.
     * @throws BusinessException Se o CNPJ já estiver cadastrado.
     */
    @Transactional
    public EmpresaResponseDTO cadastrarEmpresa(EmpresaRequestDTO requestDTO) {
        // 1. Validação de duplicidade de CNPJ
        if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CNPJ, "CNPJ já cadastrado para outra empresa.");
        }

        // 2. Mapear DTO para entidade
        Empresa empresa = empresaMapper.toEntity(requestDTO);

        // 3. Associar endereços à empresa
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = empresaMapper.toEntity(enderecoDTO);
                    endereco.setEmpresa(empresa); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        empresa.setEnderecos(enderecos);

        // 4. Salvar a entidade
        Empresa savedEmpresa = repositorioEmpresa.save(empresa);

        // 5. Mapear entidade salva para DTO de resposta
        return empresaMapper.toResponseDTO(savedEmpresa);
    }

    /**
     * @brief Busca uma Empresa pelo ID.
     * @param id ID da Empresa a ser buscada.
     * @return DTO com os dados da Empresa encontrada.
     * @throws BusinessException Se a Empresa não for encontrada.
     */
    @Transactional(readOnly = true)
    public EmpresaResponseDTO buscarEmpresaPorId(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada."));
        return empresaMapper.toResponseDTO(empresa);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Empresas.
     */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDTO> listarEmpresas(Pageable pageable) {
        return repositorioEmpresa.findAll(pageable)
                .map(empresaMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return DTO com os dados da Empresa atualizada.
     * @throws BusinessException Se a Empresa não for encontrada ou se houver duplicidade de CNPJ.
     */
    @Transactional
    public EmpresaResponseDTO atualizarEmpresa(UUID id, EmpresaRequestDTO requestDTO) {
        Empresa existingEmpresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada para atualização."));

        // 1. Validação de duplicidade de CNPJ (se o CNPJ foi alterado)
        if (!existingEmpresa.getCnpj().equals(requestDTO.getCnpj())) {
            if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CNPJ, "Novo CNPJ já cadastrado para outra empresa.");
            }
        }

        // 2. Atualizar campos básicos da Empresa
        existingEmpresa.setNomeFantasia(requestDTO.getNomeFantasia());
        existingEmpresa.setRazaoSocial(requestDTO.getRazaoSocial());
        existingEmpresa.setCnpj(requestDTO.getCnpj());
        existingEmpresa.setEmailContato(requestDTO.getEmailContato());

        // 3. Atualizar endereços (lógica de sincronização)
        existingEmpresa.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = empresaMapper.toEntity(enderecoDTO);
            newEndereco.setEmpresa(existingEmpresa);
            existingEmpresa.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingEmpresa.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingEmpresa.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Empresa updatedEmpresa = repositorioEmpresa.save(existingEmpresa);

        return empresaMapper.toResponseDTO(updatedEmpresa);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @throws BusinessException Se a Empresa não for encontrada ou se possuir profissionais associados.
     */
    @Transactional
    public void excluirEmpresa(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa com ID " + id + " não encontrada para exclusão."));

        // Verificar se existem profissionais associados antes de excluir
        if (!empresa.getProfissionais().isEmpty()) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Empresa não pode ser excluída pois possui profissionais associados.");
        }

        // A exclusão em cascata do Endereco será tratada pelo JPA
        repositorioEmpresa.delete(empresa);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.EnderecoRequestDTO;
import dto.EnderecoResponseDTO;
import entity.Endereco;
import common.exception.BusinessException; // Importa da common-lib
import mapper.EnderecoMapper;
import repository.RepositorioEndereco;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoEndereco
 * @brief Serviço de domínio para gerenciar operações relacionadas a Endereços.
 * Este serviço pode ser usado para operações diretas em Endereços,
 * embora na maioria dos casos eles sejam gerenciados em cascata por Pessoa ou Empresa.
 */
@Service
public class ServicoEndereco {

    private final RepositorioEndereco repositorioEndereco;
    private final EnderecoMapper enderecoMapper;

    @Autowired
    public ServicoEndereco(RepositorioEndereco repositorioEndereco, EnderecoMapper enderecoMapper) {
        this.repositorioEndereco = repositorioEndereco;
        this.enderecoMapper = enderecoMapper;
    }

    /**
     * @brief Cadastra um novo Endereco.
     * @param requestDTO DTO com os dados do Endereco a ser cadastrado.
     * @return DTO com os dados do Endereco cadastrado.
     */
    @Transactional
    public EnderecoResponseDTO cadastrarEndereco(EnderecoRequestDTO requestDTO) {
        Endereco endereco = enderecoMapper.toEntity(requestDTO);
        Endereco savedEndereco = repositorioEndereco.save(endereco);
        return enderecoMapper.toResponseDTO(savedEndereco);
    }

    /**
     * @brief Busca um Endereco pelo ID.
     * @param id ID do Endereco a ser buscado.
     * @return DTO com os dados do Endereco encontrado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional(readOnly = true)
    public EnderecoResponseDTO buscarEnderecoPorId(UUID id) {
        Endereco endereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado."));
        return enderecoMapper.toResponseDTO(endereco);
    }

    /**
     * @brief Lista todos os Enderecos.
     * @return Lista de DTOs de Enderecos.
     */
    @Transactional(readOnly = true)
    public List<EnderecoResponseDTO> listarEnderecos() {
        return repositorioEndereco.findAll().stream()
                .map(enderecoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Atualiza os dados de um Endereco existente.
     * @param id ID do Endereco a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Endereco.
     * @return DTO com os dados do Endereco atualizado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public EnderecoResponseDTO atualizarEndereco(UUID id, EnderecoRequestDTO requestDTO) {
        Endereco existingEndereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado para atualização."));

        // Atualizar campos básicos do Endereco
        existingEndereco.setLogradouro(requestDTO.getLogradouro());
        existingEndereco.setNumero(requestDTO.getNumero());
        existingEndereco.setComplemento(requestDTO.getComplemento());
        existingEndereco.setBairro(requestDTO.getBairro());
        existingEndereco.setCidade(requestDTO.getCidade());
        existingEndereco.setEstado(requestDTO.getEstado());
        existingEndereco.setCep(requestDTO.getCep());
        existingEndereco.setPais(requestDTO.getPais());
        existingEndereco.setTipoEndereco(requestDTO.getTipoEndereco());

        Endereco updatedEndereco = repositorioEndereco.save(existingEndereco);
        return enderecoMapper.toResponseDTO(updatedEndereco);
    }

    /**
     * @brief Exclui um Endereco pelo ID.
     * @param id ID do Endereco a ser excluído.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public void excluirEndereco(UUID id) {
        if (!repositorioEndereco.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Endereço com ID " + id + " não encontrado para exclusão.");
        }
        repositorioEndereco.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.PessoaResponseDTO;
import entity.Pessoa;
import common.exception.BusinessException; // Importa da common-lib
import mapper.PessoaMapper;
import repository.RepositorioPessoa;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoPessoa
 * @brief Serviço de domínio para operações genéricas relacionadas a Pessoas.
 * Como Pessoa é uma entidade base abstrata, este serviço lida com operações
 * que podem ser comuns a todas as subclasses (Profissional, Cliente, Administrador).
 * Operações de criação/atualização específicas devem ser tratadas nos serviços das subclasses.
 */
@Service
public class ServicoPessoa {

    private final RepositorioPessoa repositorioPessoa;
    private final PessoaMapper pessoaMapper;

    @Autowired
    public ServicoPessoa(RepositorioPessoa repositorioPessoa, PessoaMapper pessoaMapper) {
        this.repositorioPessoa = repositorioPessoa;
        this.pessoaMapper = pessoaMapper;
    }

    /**
     * @brief Busca uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser buscada.
     * @return DTO com os dados da Pessoa encontrada.
     * @throws BusinessException Se a Pessoa não for encontrada.
     */
    @Transactional(readOnly = true)
    public PessoaResponseDTO buscarPessoaPorId(UUID id) {
        Pessoa pessoa = repositorioPessoa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Pessoa com ID " + id + " não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * @brief Lista todas as Pessoas.
     * @return Lista de DTOs de Pessoas.
     */
    @Transactional(readOnly = true)
    public List<PessoaResponseDTO> listarTodasPessoas() {
        return repositorioPessoa.findAll().stream()
                .map(pessoaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Exclui uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser excluída.
     * @throws BusinessException Se a Pessoa não for encontrada.
     * **Nota:** A exclusão de Pessoa deve ser feita com cautela, pois pode
     * impactar subclasses (Profissional, Cliente, Administrador) e o User associado.
     * Idealmente, a exclusão de subclasses deveria ser o ponto de entrada.
     */
    @Transactional
    public void excluirPessoa(UUID id) {
        if (!repositorioPessoa.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Pessoa com ID " + id + " não encontrada para exclusão.");
        }
        repositorioPessoa.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.PlanoResponseDTO;
import entity.Plano;
import common.exception.BusinessException; // Importa da common-lib
import mapper.ProfissionalMapper; // Reutilizando mapper de profissional para plano
import repository.RepositorioPlano;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoPlano
 * @brief Serviço de domínio para gerenciar operações relacionadas a Planos.
 * **Nota:** Este serviço é um placeholder. Em uma arquitetura de microsserviços real,
 * a gestão de planos seria feita em um microsserviço dedicado (ex: marketplace ou assinatura).
 * Aqui, ele apenas fornece métodos de busca para que outros serviços possam referenciar planos.
 */
@Service
public class ServicoPlano {

    private final RepositorioPlano repositorioPlano;
    private final ProfissionalMapper profissionalMapper; // Usando o mapper de Profissional que já tem o toPlanoResponseDTO

    @Autowired
    public ServicoPlano(RepositorioPlano repositorioPlano, ProfissionalMapper profissionalMapper) {
        this.repositorioPlano = repositorioPlano;
        this.profissionalMapper = profissionalMapper;
    }

    /**
     * @brief Busca um Plano pelo ID.
     * @param id ID do Plano a ser buscado.
     * @return DTO com os dados do Plano encontrado.
     * @throws BusinessException Se o Plano não for encontrado.
     */
    @Transactional(readOnly = true)
    public PlanoResponseDTO buscarPlanoPorId(UUID id) {
        Plano plano = repositorioPlano.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND, "Plano com ID " + id + " não encontrado."));
        return profissionalMapper.toPlanoResponseDTO(plano);
    }

    /**
     * @brief Lista todos os Planos disponíveis.
     * @return Lista de DTOs de Planos.
     */
    @Transactional(readOnly = true)
    public List<PlanoResponseDTO> listarTodosPlanos() {
        return repositorioPlano.findAll().stream()
                .map(profissionalMapper::toPlanoResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para cadastrar, atualizar e excluir planos não são implementados aqui,
    // pois seriam responsabilidade do microsserviço de marketplace/assinatura.
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ProfissionalMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import br.com.legalconnect.repository.RepositorioPlano;
import br.com.legalconnect.repository.RepositorioProfissional;
import br.com.legalconnect.repository.RepositorioUser;

/**
 * @class ServicoProfissional
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Profissionais.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Profissionais.
 */
@Service
public class ServicoProfissional {

    private final RepositorioProfissional repositorioProfissional;
    private final RepositorioUser repositorioUser;
    private final RepositorioPlano repositorioPlano;
    private final RepositorioEmpresa repositorioEmpresa;
    private final ProfissionalMapper profissionalMapper;

    @Autowired
    public ServicoProfissional(RepositorioProfissional repositorioProfissional,
            RepositorioUser repositorioUser,
            RepositorioPlano repositorioPlano,
            RepositorioEmpresa repositorioEmpresa,
            ProfissionalMapper profissionalMapper) {
        this.repositorioProfissional = repositorioProfissional;
        this.repositorioUser = repositorioUser;
        this.repositorioPlano = repositorioPlano;
        this.repositorioEmpresa = repositorioEmpresa;
        this.profissionalMapper = profissionalMapper;
    }

    /**
     * @brief Cadastra um novo Profissional no sistema.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return DTO com os dados do Profissional cadastrado.
     * @throws BusinessException Se o CPF ou OAB já estiverem cadastrados, ou se o
     *                           User/Plano/Empresa associado não for encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO cadastrarProfissional(ProfissionalRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF e OAB
        if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro profissional.");
        }
        if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_INPUT,
                    "Número da OAB já cadastrado para outro profissional.");
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Mapear DTO para entidade
        Profissional profissional = profissionalMapper.toEntity(requestDTO);
        profissional.setUsuario(user); // Associar o User encontrado
        profissional.setPlano(plano); // Associar o Plano encontrado
        profissional.setEmpresa(empresa); // Associar a Empresa (pode ser null)

        // 5. Associar endereços à pessoa (Profissional)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = profissionalMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(profissional); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        profissional.setEnderecos(enderecos);

        // 6. Salvar a entidade
        Profissional savedProfissional = repositorioProfissional.save(profissional);

        // 7. Mapear entidade salva para DTO de resposta
        return profissionalMapper.toResponseDTO(savedProfissional);
    }

    /**
     * @brief Busca um Profissional pelo ID.
     * @param id ID do Profissional a ser buscado.
     * @return DTO com os dados do Profissional encontrado.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional(readOnly = true)
    public ProfissionalResponseDTO buscarProfissionalPorId(UUID id) {
        Profissional profissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado."));
        return profissionalMapper.toResponseDTO(profissional);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Profissionais.
     */
    @Transactional(readOnly = true)
    public Page<ProfissionalResponseDTO> listarProfissionais(Pageable pageable) {
        return repositorioProfissional.findAll(pageable)
                .map(profissionalMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return DTO com os dados do Profissional atualizado.
     * @throws BusinessException Se o Profissional não for encontrado, ou se houver
     *                           duplicidade de CPF/OAB, ou se Plano/Empresa não for
     *                           encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO atualizarProfissional(UUID id, ProfissionalRequestDTO requestDTO) {
        Profissional existingProfissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingProfissional.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro profissional.");
            }
        }
        // 2. Validação de duplicidade de OAB (se a OAB foi alterada)
        if (!existingProfissional.getNumeroOab().equals(requestDTO.getNumeroOab())) {
            if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_INPUT,
                        "Novo número da OAB já cadastrado para outro profissional.");
            }
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Atualizar campos básicos da Pessoa e Profissional
        existingProfissional.setNomeCompleto(requestDTO.getNomeCompleto());
        existingProfissional.setCpf(requestDTO.getCpf());
        existingProfissional.setDataNascimento(requestDTO.getDataNascimento());
        existingProfissional.setNumeroOab(requestDTO.getNumeroOab());
        existingProfissional.setStatusProfissional(requestDTO.getStatusProfissional());
        existingProfissional.setUsaMarketplace(requestDTO.getUsaMarketplace());
        existingProfissional.setFazParteDePlano(requestDTO.getFazParteDePlano());
        existingProfissional.setPlano(plano);
        existingProfissional.setEmpresa(empresa);

        // 5. Atualizar endereços (lógica de sincronização)
        existingProfissional.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = profissionalMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingProfissional);
            existingProfissional.getEnderecos().add(newEndereco);
        });

        // 6. Atualizar telefones
        existingProfissional.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingProfissional.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 7. Salvar a entidade atualizada
        Profissional updatedProfissional = repositorioProfissional.save(existingProfissional);

        return profissionalMapper.toResponseDTO(updatedProfissional);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional
    public void excluirProfissional(UUID id) {
        if (!repositorioProfissional.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Profissional com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioProfissional.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import common.exception.ErrorCode; // Importa da common-lib
import dto.UserResponseDTO;
import entity.User;
import common.exception.BusinessException; // Importa da common-lib
import mapper.UserMapper;
import repository.RepositorioUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * @class ServicoUser
 * @brief Serviço de domínio para gerenciar operações relacionadas a Users.
 * **Nota:** Este serviço é primariamente para busca e validação de Users existentes
 * para associação com entidades Pessoa (Profissional, Cliente, Administrador).
 * A criação e gestão principal de Users é responsabilidade de outro microsserviço (ex: auth-service).
 */
@Service
public class ServicoUser {

    private final RepositorioUser repositorioUser;
    private final UserMapper userMapper;

    @Autowired
    public ServicoUser(RepositorioUser repositorioUser, UserMapper userMapper) {
        this.repositorioUser = repositorioUser;
        this.userMapper = userMapper;
    }

    /**
     * @brief Busca um User pelo ID.
     * @param id ID do User a ser buscado.
     * @return DTO com os dados do User encontrado.
     * @throws BusinessException Se o User não for encontrado.
     */
    @Transactional(readOnly = true)
    public UserResponseDTO buscarUserPorId(UUID id) {
        User user = repositorioUser.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND, "Usuário com ID " + id + " não encontrado."));
        return userMapper.toResponseDTO(user);
    }

    /**
     * @brief Lista todos os Users.
     * @return Lista de DTOs de Users.
     */
    @Transactional(readOnly = true)
    public List<UserResponseDTO> listarTodosUsers() {
        return repositorioUser.findAll().stream()
                .map(userMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Verifica se um User existe pelo ID.
     * @param id ID do User a ser verificado.
     * @return true se o User existe, false caso contrário.
     */
    @Transactional(readOnly = true)
    public boolean userExiste(UUID id) {
        return repositorioUser.existsById(id);
    }

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o DTO do User, se encontrado.
     */
    @Transactional(readOnly = true)
    public Optional<UserResponseDTO> buscarUserPorCpf(String cpf) {
        return repositorioUser.findByCpf(cpf)
                .map(userMapper::toResponseDTO);
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada
server.port=8084
# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

# Habilita o Eureka Client
eureka.client.enabled=true
# URL do servidor Eureka onde o auth-service irá se registrar
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância para garantir identificação única no Eureka
eureka.instance.hostname=localhost
eureka.instance.instance-id=${spring.application.name}:${instanceId:${random.value}}
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication(exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui também, se já está no
                                                                // pacote raiz
@EntityScan(basePackages = {
        // "br.com.legalconnect.entity",
        "br.com.legalconnect.entity"
})
// @EnableJpaRepositories(basePackages = {
// "br.com.legalconnect.user.repository",
// "br.com.legalconnect.auth.repository"
// })
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class LegalUsuarioApplication {

    private static final Logger log = LoggerFactory.getLogger(LegalUsuarioApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(LegalUsuarioApplication.class, args);
        log.info("LegalUsuarioApplication iniciada com sucesso!");
    }
}
```
```java
package br.com.legalconnect.config; // Importa da common-lib

import java.io.IOException;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import br.com.legalconnect.common.config.multitenancy.TenantContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

/**
 * @class TenantFilter
 * @brief Filtro HTTP para interceptar requisições e extrair o ID do tenant.
 *        Define o tenant ID no TenantContext para que o Hibernate possa usá-lo.
 */
@Component
public class TenantFilter extends OncePerRequestFilter {

    @Value("${application.tenant.default-id}")
    private String defaultTenantId;

    private static final String TENANT_HEADER = "X-Tenant-ID";

    /**
     * @brief Filtra a requisição para extrair e definir o ID do tenant.
     * @param request     A requisição HTTP.
     * @param response    A resposta HTTP.
     * @param filterChain A cadeia de filtros.
     * @throws ServletException Se ocorrer um erro de servlet.
     * @throws IOException      Se ocorrer um erro de I/O.
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String tenantIdHeader = request.getHeader(TENANT_HEADER);
            String tenantId = "public";

            if (tenantIdHeader != null && !tenantIdHeader.isEmpty()) {
                try {
                    tenantId = (tenantIdHeader);
                } catch (IllegalArgumentException e) {
                    // Logar ou tratar o erro de UUID inválido, talvez retornar um 400 Bad Request
                    System.err.println("UUID de Tenant inválido no cabeçalho X-Tenant-ID: " + tenantIdHeader);
                    response.sendError(HttpServletResponse.SC_BAD_REQUEST, "UUID de Tenant inválido.");
                    return;
                }
            } else {
                // Usar o tenant padrão se o cabeçalho não for fornecido
                try {
                    tenantId = (defaultTenantId);
                } catch (IllegalArgumentException e) {
                    System.err.println("UUID de Tenant padrão inválido na configuração: " + defaultTenantId);
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
                            "Configuração de Tenant padrão inválida.");
                    return;
                }
            }

            TenantContext.setCurrentTenant(tenantId);
            filterChain.doFilter(request, response);
        } finally {
            TenantContext.clear(); // Limpar o TenantContext após a requisição
        }
    }
}
```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoAdministrador;
import jakarta.validation.Valid;

/**
 * @class ControladorAdministradorPlataforma
 * @brief Controlador REST para gerenciar operações relacionadas a
 *        Administradores da Plataforma.
 *        Expõe endpoints para CRUD de Administradores.
 */
@RestController
@RequestMapping("/api/v1/administradores-plataforma")
public class ControladorAdministradorPlataforma {

    private final ServicoAdministrador servicoAdministrador;

    @Autowired
    public ControladorAdministradorPlataforma(ServicoAdministrador servicoAdministrador) {
        this.servicoAdministrador = servicoAdministrador;
    }

    /**
     * @brief Cadastra um novo Administrador da Plataforma.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return ResponseEntity com o DTO do Administrador cadastrado e status 201
     *         Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> cadastrarAdministrador(
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.cadastrarAdministrador(requestDTO); // Usar o método
                                                                                                        // 'cadastrar'
        // da classe base
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Administrador da Plataforma por ID.
     * @param id ID do Administrador a ser buscado.
     * @return ResponseEntity com o DTO do Administrador encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> buscarAdministradorPorId(@PathVariable UUID id) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.buscarAdministradorPorId(id); // Usar o método
                                                                                                  // 'buscarPorId' da
        // classe base
        return ResponseEntity.ok(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Administradores da Plataforma com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Administradores e status 200
     *         OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<AdministradorResponseDTO>>> listarAdministradores(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<AdministradorResponseDTO> responsePage = servicoAdministrador.listarAdministradores(pageable); // Usar o
                                                                                                            // método
                                                                                                            // 'listar'
        // da classe base
        return ResponseEntity.ok(
                BaseResponse.<Page<AdministradorResponseDTO>>builder()
                        .message("Lista de administradores recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Administrador da Plataforma existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return ResponseEntity com o DTO do Administrador atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<AdministradorResponseDTO>> atualizarAdministrador(
            @PathVariable UUID id,
            @Valid @RequestBody AdministradorRequestDTO requestDTO) {
        AdministradorResponseDTO responseDTO = servicoAdministrador.atualizarAdministrador(id, requestDTO); // Usar o
                                                                                                            // método
        // 'atualizar' da classe
        // base
        return ResponseEntity.ok(
                BaseResponse.<AdministradorResponseDTO>builder()
                        .message("Administrador atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Administrador da Plataforma pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirAdministrador(@PathVariable UUID id) {
        servicoAdministrador.excluirAdministrador(id); // Usar o método 'excluir' da classe base
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body( // Retorna 204 No Content com um corpo de sucesso
                BaseResponse.<Void>builder()
                        .message("Administrador excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoCliente;
import jakarta.validation.Valid;

/**
 * @class ControladorCliente
 * @brief Controlador REST para gerenciar operações relacionadas a Clientes.
 *        Expõe endpoints para CRUD de Clientes.
 */
@RestController
@RequestMapping("/api/v1/clientes")
public class ControladorCliente {

    private final ServicoCliente servicoCliente;

    @Autowired
    public ControladorCliente(ServicoCliente servicoCliente) {
        this.servicoCliente = servicoCliente;
    }

    /**
     * @brief Cadastra um novo Cliente.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return ResponseEntity com o DTO do Cliente cadastrado e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> cadastrarCliente(
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.cadastrarCliente(requestDTO); // Chamando o método original do
                                                                                      // serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Cliente por ID.
     * @param id ID do Cliente a ser buscado.
     * @return ResponseEntity com o DTO do Cliente encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> buscarClientePorId(@PathVariable UUID id) {
        ClienteResponseDTO responseDTO = servicoCliente.buscarClientePorId(id); // Chamando o método original do serviço
        return ResponseEntity.ok(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Clientes e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ClienteResponseDTO>>> listarClientes(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ClienteResponseDTO> responsePage = servicoCliente.listarClientes(pageable); // Chamando o método original
                                                                                         // do serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<ClienteResponseDTO>>builder()
                        .message("Lista de clientes recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return ResponseEntity com o DTO do Cliente atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ClienteResponseDTO>> atualizarCliente(
            @PathVariable UUID id,
            @Valid @RequestBody ClienteRequestDTO requestDTO) {
        ClienteResponseDTO responseDTO = servicoCliente.atualizarCliente(id, requestDTO); // Chamando o método original
                                                                                          // do serviço
        return ResponseEntity.ok(
                BaseResponse.<ClienteResponseDTO>builder()
                        .message("Cliente atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirCliente(@PathVariable UUID id) {
        servicoCliente.excluirCliente(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Cliente excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoEmpresa;
import jakarta.validation.Valid;

/**
 * @class ControladorEmpresa
 * @brief Controlador REST para gerenciar operações relacionadas a Empresas.
 *        Expõe endpoints para CRUD de Empresas.
 */
@RestController
@RequestMapping("/api/v1/empresas")
public class ControladorEmpresa {

    private final ServicoEmpresa servicoEmpresa;

    @Autowired
    public ControladorEmpresa(ServicoEmpresa servicoEmpresa) {
        this.servicoEmpresa = servicoEmpresa;
    }

    /**
     * @brief Cadastra uma nova Empresa.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return ResponseEntity com o DTO da Empresa cadastrada e status 201 Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> cadastrarEmpresa(
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.cadastrarEmpresa(requestDTO); // Chamando o método original do
                                                                                      // serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa cadastrada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca uma Empresa por ID.
     * @param id ID da Empresa a ser buscada.
     * @return ResponseEntity com o DTO da Empresa encontrada e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> buscarEmpresaPorId(@PathVariable UUID id) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.buscarEmpresaPorId(id); // Chamando o método original do serviço
        return ResponseEntity.ok(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa encontrada.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeFantasia,asc).
     * @return ResponseEntity com uma página de DTOs de Empresas e status 200 OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<EmpresaResponseDTO>>> listarEmpresas(
            @PageableDefault(size = 10, page = 0, sort = "nomeFantasia") Pageable pageable) {
        Page<EmpresaResponseDTO> responsePage = servicoEmpresa.listarEmpresas(pageable); // Chamando o método original
                                                                                         // do serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<EmpresaResponseDTO>>builder()
                        .message("Lista de empresas recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id         ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return ResponseEntity com o DTO da Empresa atualizada e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<EmpresaResponseDTO>> atualizarEmpresa(
            @PathVariable UUID id,
            @Valid @RequestBody EmpresaRequestDTO requestDTO) {
        EmpresaResponseDTO responseDTO = servicoEmpresa.atualizarEmpresa(id, requestDTO); // Chamando o método original
                                                                                          // do serviço
        return ResponseEntity.ok(
                BaseResponse.<EmpresaResponseDTO>builder()
                        .message("Empresa atualizada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirEmpresa(@PathVariable UUID id) {
        servicoEmpresa.excluirEmpresa(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Empresa excluída com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoProfissional;
import jakarta.validation.Valid;

/**
 * @class ControladorProfissional
 * @brief Controlador REST para gerenciar operações relacionadas a
 *        Profissionais.
 *        Expõe endpoints para CRUD de Profissionais.
 */
@RestController
@RequestMapping("/api/v1/profissionais")
public class ControladorProfissional {

    private final ServicoProfissional servicoProfissional;

    @Autowired
    public ControladorProfissional(ServicoProfissional servicoProfissional) {
        this.servicoProfissional = servicoProfissional;
    }

    /**
     * @brief Cadastra um novo Profissional.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return ResponseEntity com o DTO do Profissional cadastrado e status 201
     *         Created.
     */
    @PostMapping
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> cadastrarProfissional(
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.cadastrarProfissional(requestDTO); // Chamando o
                                                                                                     // método original
                                                                                                     // do serviço
        return ResponseEntity.status(HttpStatus.CREATED).body(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional cadastrado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Busca um Profissional por ID.
     * @param id ID do Profissional a ser buscado.
     * @return ResponseEntity com o DTO do Profissional encontrado e status 200 OK.
     */
    @GetMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> buscarProfissionalPorId(@PathVariable UUID id) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.buscarProfissionalPorId(id); // Chamando o método
                                                                                               // original do serviço
        return ResponseEntity.ok(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional encontrado.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação (ex:
     *                 ?page=0&size=10&sort=nomeCompleto,asc).
     * @return ResponseEntity com uma página de DTOs de Profissionais e status 200
     *         OK.
     */
    @GetMapping
    public ResponseEntity<BaseResponse<Page<ProfissionalResponseDTO>>> listarProfissionais(
            @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
        Page<ProfissionalResponseDTO> responsePage = servicoProfissional.listarProfissionais(pageable); // Chamando o
                                                                                                        // método
                                                                                                        // original do
                                                                                                        // serviço
        return ResponseEntity.ok(
                BaseResponse.<Page<ProfissionalResponseDTO>>builder()
                        .message("Lista de profissionais recuperada com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responsePage)
                        .build());
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return ResponseEntity com o DTO do Profissional atualizado e status 200 OK.
     */
    @PutMapping("/{id}")
    public ResponseEntity<BaseResponse<ProfissionalResponseDTO>> atualizarProfissional(
            @PathVariable UUID id,
            @Valid @RequestBody ProfissionalRequestDTO requestDTO) {
        ProfissionalResponseDTO responseDTO = servicoProfissional.atualizarProfissional(id, requestDTO); // Chamando o
                                                                                                         // método
                                                                                                         // original do
                                                                                                         // serviço
        return ResponseEntity.ok(
                BaseResponse.<ProfissionalResponseDTO>builder()
                        .message("Profissional atualizado com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .data(responseDTO)
                        .build());
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @return ResponseEntity com status 204 No Content.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<BaseResponse<Void>> excluirProfissional(@PathVariable UUID id) {
        servicoProfissional.excluirProfissional(id); // Chamando o método original do serviço
        return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                BaseResponse.<Void>builder()
                        .message("Profissional excluído com sucesso.")
                        .status(StatusResponse.SUCESSO)
                        .build());
    }
}

```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorRequestDTO
 * @brief DTO para requisições de criação ou atualização de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorResponseDTO
 * @brief DTO para respostas de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorResponseDTO extends PessoaResponseDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteRequestDTO
 * @brief DTO para requisições de criação ou atualização de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteResponseDTO
 * @brief DTO para respostas de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteResponseDTO extends PessoaResponseDTO {
    private String status;
    private String tipo;
}
```
```java
package br.com.legalconnect.dto;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaRequestDTO
 * @brief DTO para requisições de criação ou atualização de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O nome fantasia não pode estar em branco.")
    @Size(max = 255, message = "O nome fantasia deve ter no máximo 255 caracteres.")
    private String nomeFantasia;

    @NotBlank(message = "A razão social não pode estar em branco.")
    @Size(max = 255, message = "A razão social deve ter no máximo 255 caracteres.")
    private String razaoSocial;

    @NotBlank(message = "O CNPJ não pode estar em branco.")
    @Pattern(regexp = "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}", message = "Formato de CNPJ inválido. Use XX.XXX.XXX/XXXX-XX.")
    private String cnpj;

    @Email(message = "Formato de email de contato inválido.")
    @Size(max = 255, message = "O email de contato deve ter no máximo 255 caracteres.")
    private String emailContato;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos;

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaResponseDTO
 * @brief DTO para respostas de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaResponseDTO {
    private UUID id;
    private String nomeFantasia;
    private String razaoSocial;
    private String cnpj;
    private String emailContato;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoRequestDTO
 * @brief DTO para requisições de criação ou atualização de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número não pode estar em branco.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade não pode estar em branco.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado não pode estar em branco.")
    @Size(min = 2, max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "\\d{5}-\\d{3}", message = "Formato de CEP inválido. Use XXXXX-XXX.")
    private String cep;

    @NotBlank(message = "O país não pode estar em branco.")
    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais;

    @NotNull(message = "O tipo de endereço não pode ser nulo.")
    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoResponseDTO
 * @brief DTO para respostas de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;
    private String logradouro;
    private String numero;
    private String complemento;
    private String bairro;
    private String cidade;
    private String estado;
    private String cep;
    private String pais;
    private TipoEndereco tipoEndereco;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.util.List; // Usar List para Enderecos para manter a ordem se necessário
import java.util.Set;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaRequestDTO
 * @brief DTO base para requisições de criação ou atualização de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // Não incluir o ID aqui, pois ele será definido pela entidade base (BaseEntity)
    // e retornado no ResponseDTO.

    @NotNull(message = "Os dados do usuário não podem ser nulos.")
    @Valid // Valida o DTO aninhado
    private UserRequestDTO usuario;

    @NotBlank(message = "O nome completo não pode estar em branco.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Pattern(regexp = "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}", message = "Formato de CPF inválido. Use XXX.XXX.XXX-XX.")
    private String cpf;

    @PastOrPresent(message = "A data de nascimento não pode ser futura.")
    private LocalDate dataNascimento;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos; // Usar List para manter a ordem se necessário

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaResponseDTO
 * @brief DTO base para respostas de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaResponseDTO {
    private UUID id;
    private UserResponseDTO usuario;
    private String nomeCompleto;
    private String cpf;
    private LocalDate dataNascimento;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Plano.VisibilidadeDestaque;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class PlanoResponseDTO
 * @brief DTO para respostas de Plano.
 *        Esta classe é um DTO simplificado para ser usado em outros
 *        microsserviços.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PlanoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
    private BigDecimal precoMensal;
    private BigDecimal precoAnual;
    private Integer limiteServicosAgendaveis;
    private VisibilidadeDestaque visibilidadeDestaque;
    private Boolean acessoRelatoriosAvancados;
    private Boolean permitePedidosOrcamento;
    private Integer periodoTesteDias;
    private Boolean isDefault;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalRequestDTO
 * @brief DTO para requisições de criação ou atualização de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalRequestDTO extends PessoaRequestDTO {
    @NotBlank(message = "O número da OAB não pode estar em branco.")
    @Size(max = 50, message = "O número da OAB deve ter no máximo 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "O status profissional não pode ser nulo.")
    private StatusProfissional statusProfissional;

    @NotNull(message = "A indicação de uso do marketplace não pode ser nula.")
    private Boolean usaMarketplace;

    @NotNull(message = "A indicação de participação em plano não pode ser nula.")
    private Boolean fazParteDePlano;

    private UUID empresaId; // ID da empresa associada (opcional)

    @NotNull(message = "O ID do plano não pode ser nulo.")
    private UUID planoId; // ID do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalResponseDTO
 * @brief DTO para respostas de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalResponseDTO extends PessoaResponseDTO {
    private String numeroOab;
    private StatusProfissional statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private EmpresaResponseDTO empresa; // DTO da empresa associada (simplificado)
    private PlanoResponseDTO plano; // DTO do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserRequestDTO
 * @brief DTO para requisições de criação ou atualização de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    private UUID id;
    @NotBlank(message = "O email não pode estar em branco.")
    @Email(message = "Formato de email inválido.")
    private String email;

    // @NotBlank(message = "A senha não pode estar em branco.")
    // @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // private String password;

    // O papel (Role) pode ser definido aqui ou inferido pelo serviço de
    // autenticação/usuário
    // dependendo da lógica de negócio. Para simplificar, pode ser incluído se for
    // um input direto.
    // private String role;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserResponseDTO
 * @brief DTO para respostas de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // private String role; // Incluir se o papel for relevante na resposta
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Administrador
 * @brief Entidade que representa um administrador da plataforma.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_administrador' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_administrador")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Administrador extends Pessoa {
    private String status;

    // Atualmente, não há campos adicionais específicos para Administrador além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, nível de acesso
    // administrativo, etc.
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Cliente
 * @brief Entidade que representa um cliente.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_cliente' que se junta a 'tb_pessoa' pela
 *        chave primária.
 */
@Entity
@Table(name = "tb_cliente")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Cliente extends Pessoa {
    private String status;
    private String tipo;

    // Atualmente, não há campos adicionais específicos para Cliente além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, histórico de preferências,
    // etc.
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Empresa
 * @brief Entidade que representa uma empresa que pode contratar planos na
 *        plataforma.
 *        Esta entidade não estende Pessoa, pois representa uma pessoa jurídica.
 *        Mapeada para a tabela 'tb_empresa'.
 */
@Entity
@Table(name = "tb_empresa")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Empresa extends BaseEntity {

    @Column(name = "nome_fantasia", nullable = false, length = 255)
    private String nomeFantasia; // Nome fantasia da empresa

    @Column(name = "razao_social", nullable = false, length = 255)
    private String razaoSocial; // Razão social da empresa

    @Column(name = "cnpj", nullable = false, unique = true, length = 18) // CNPJ com máscara
    private String cnpj; // Número do Cadastro Nacional de Pessoas Jurídicas (CNPJ), único por empresa

    @Column(name = "email_contato", length = 255)
    private String emailContato; // E-mail de contato da empresa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma empresa pode ter múltiplos endereços (sede, filiais, etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Empresa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'empresa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da empresa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_empresa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_empresa_telefones", joinColumns = @JoinColumn(name = "empresa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da empresa

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionais = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id")
    private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set; // Usaremos Set para evitar duplicatas e garantir unicidade

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public abstract class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da pessoa
}
```
```java
package br.com.legalconnect.entity;

import java.math.BigDecimal;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 *        plataforma.
 *        Esta classe é um placeholder e deve ser definida em seu próprio
 *        microsserviço (marketplace).
 *        Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault; // Indica se é o plano padrão para novos cadastros

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     *        plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        PREMIUM,
        DESTAQUE_MAXIMO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Profissional
 * @brief Entidade que representa um profissional do direito.
 *        Estende a entidade Pessoa e adiciona campos específicos de um
 *        profissional.
 *        Mapeado para a tabela 'tb_profissional' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_profissional")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab; // Número de registro na OAB, único por profissional

    @Enumerated(EnumType.STRING)
    @Column(name = "status_profissional", nullable = false, length = 50)
    private StatusProfissional statusProfissional; // Status específico do profissional (ex: ATIVO, LICENCIADO)

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false; // Indica se o profissional deseja aparecer no marketplace

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false; // Indica se o profissional está associado a um plano pago

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um profissional pode pertencer a uma empresa.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id") // Coluna de chave estrangeira para a empresa
    private Empresa empresa; // A empresa à qual o profissional está associado (se houver)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Plano.
     *        Um profissional está associado a um plano de assinatura.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira para o plano
    private Plano plano; // O plano de assinatura do advogado
    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_profissionals_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "profissional_profissionals_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<RoleProfissional> roleProfissionals = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum StatusProfissional
     * @brief Enumeração para representar o status específico de um Profissional.
     */
    public enum StatusProfissional {
        ATIVO, // Profissional ativo e em dia
        LICENCIADO, // Profissional com licença temporariamente suspensa
        SUSPENSO, // Profissional suspenso (ex: por infração)
        EM_ANALISE // Profissional aguardando aprovação/verificação
    }
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 *        Esta tabela de roles agora reside nos schemas de tenant, o que
 *        significa
 *        que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 *        IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RoleProfissional extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface AdministradorMapper
 * @brief Mapper MapStruct para conversão entre Administrador e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface AdministradorMapper extends PessoaMapper {

    AdministradorMapper INSTANCE = Mappers.getMapper(AdministradorMapper.class);

    /**
     * @brief Mapeia um AdministradorRequestDTO para uma entidade Administrador.
     * @param dto O DTO de requisição do administrador.
     * @return A entidade Administrador.
     */
    Administrador toEntity(AdministradorRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Administrador para um AdministradorResponseDTO.
     * @param entity A entidade Administrador.
     * @return O DTO de resposta do administrador.
     */
    @Mapping(source = "status", target = "status")
    AdministradorResponseDTO toResponseDTO(Administrador entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ClienteMapper
 * @brief Mapper MapStruct para conversão entre Cliente e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface ClienteMapper extends PessoaMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    /**
     * @brief Mapeia um ClienteRequestDTO para uma entidade Cliente.
     * @param dto O DTO de requisição do cliente.
     * @return A entidade Cliente.
     */
    Cliente toEntity(ClienteRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Cliente para um ClienteResponseDTO.
     * @param entity A entidade Cliente.
     * @return O DTO de resposta do cliente.
     */
    @Mapping(source = "status", target = "status")
    @Mapping(target = "tipo", ignore = true) // O campo 'tipo' não existe na entidade Cliente, apenas no DTO de resposta
    ClienteResponseDTO toResponseDTO(Cliente entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EmpresaMapper
 * @brief Mapper MapStruct para conversão entre Empresa e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {EnderecoMapper.class})
public interface EmpresaMapper {

    EmpresaMapper INSTANCE = Mappers.getMapper(EmpresaMapper.class);

    /**
     * @brief Converte um EmpresaRequestDTO para uma entidade Empresa.
     * @param dto O DTO de requisição da empresa.
     * @return A entidade Empresa.
     */
    @Mapping(target = "id", ignore = true) // ID é gerado, não vem do DTO de requisição
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    Empresa toEntity(EmpresaRequestDTO dto);

    /**
     * @brief Converte uma entidade Empresa para um EmpresaResponseDTO.
     * @param entity A entidade Empresa.
     * @return O DTO de resposta da empresa.
     */
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    EmpresaResponseDTO toResponseDTO(Empresa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Endereco.TipoEndereco; // Importa o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EnderecoMapper
 * @brief Mapper MapStruct para conversão entre Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * @brief Converte um EnderecoRequestDTO para uma entidade Endereco.
     * @param dto O DTO de requisição do endereço.
     * @return A entidade Endereco.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "pessoa", ignore = true) // Será setado no serviço
    @Mapping(target = "empresa", ignore = true) // Será setado no serviço
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * @brief Converte uma entidade Endereco para um EnderecoResponseDTO.
     * @param entity A entidade Endereco.
     * @return O DTO de resposta do endereço.
     */
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * @brief Converte uma lista de EnderecoRequestDTOs para um Set de entidades Endereco.
     * @param dtoList A lista de DTOs de requisição de endereços.
     * @return Um Set de entidades Endereco.
     */
    Set<Endereco> toEntitySet(List<EnderecoRequestDTO> dtoList);

    /**
     * @brief Converte um Set de entidades Endereco para uma lista de EnderecoResponseDTOs.
     * @param entitySet Um Set de entidades Endereco.
     * @return Uma lista de DTOs de resposta de endereços.
     */
    List<EnderecoResponseDTO> toResponseDTOList(Set<Endereco> entitySet);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.InheritInverseConfiguration; // Importar se for usar @InheritInverseConfiguration
import org.mapstruct.factory.Mappers;

/**
 * @interface PessoaMapper
 * @brief Mapper MapStruct para conversão entre Pessoa e seus DTOs.
 * Esta é uma interface base para ser estendida por mappers de subclasses de Pessoa.
 */
@Mapper(componentModel = "spring", uses = {UserMapper.class, EnderecoMapper.class})
public interface PessoaMapper {

    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * @brief Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta da pessoa.
     */
    @Mapping(source = "usuario", target = "usuario")
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    PessoaResponseDTO toResponseDTO(Pessoa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano; // Importar Plano da entidade
import br.com.legalconnect.dto.EmpresaResponseDTO; // Importar EmpresaResponseDTO
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa; // Importar Empresa da entidade
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.Profissional.StatusProfissional; // Importar o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ProfissionalMapper
 * @brief Mapper MapStruct para conversão entre Profissional e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class, EmpresaMapper.class})
public interface ProfissionalMapper extends PessoaMapper {

    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * @brief Mapeia um ProfissionalRequestDTO para uma entidade Profissional.
     * @param dto O DTO de requisição do profissional.
     * @return A entidade Profissional.
     */
    @Mapping(target = "empresa", ignore = true) // Empresa será setada no serviço
    @Mapping(target = "plano", ignore = true)   // Plano será setado no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Não presente no DTO
    Profissional toEntity(ProfissionalRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * @param entity A entidade Profissional.
     * @return O DTO de resposta do profissional.
     */
    @Mapping(source = "empresa", target = "empresa")
    @Mapping(source = "plano", target = "plano")
    ProfissionalResponseDTO toResponseDTO(Profissional entity);

    /**
     * @brief Mapeia uma entidade Plano para um PlanoResponseDTO.
     * @param plano A entidade Plano.
     * @return O DTO de resposta do Plano.
     */
    PlanoResponseDTO toPlanoResponseDTO(Plano plano);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper MapStruct para conversão entre User e seus DTOs.
 */
@Mapper(componentModel = "spring") // Integração com Spring para injeção de dependência
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * @brief Converte um UserRequestDTO para uma entidade User.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserRequestDTO.
     * @param dto O DTO de requisição do usuário.
     * @return A entidade User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "nomeCompleto", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "cpf", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "telefone", ignore = true) // Não presente no DTO de requisição
    // @Mapping(target = "senhaHash", source = "password") // Mapeia password do DTO
    // para senhaHash da entidade
    @Mapping(target = "fotoUrl", ignore = true) // Não presente no DTO de requisição
    User toEntity(UserRequestDTO dto);

    /**
     * @brief Converte uma entidade User para um UserResponseDTO.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserResponseDTO.
     * @param entity A entidade User.
     * @return O DTO de resposta do usuário.
     */
    @Mapping(target = "email", source = "email")
    UserResponseDTO toResponseDTO(User entity);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Administrador;

/**
 * @interface RepositorioAdministrador
 * @brief Repositório Spring Data JPA para a entidade Administrador.
 *        Fornece métodos CRUD e de busca personalizados para Administrador.
 */
@Repository
public interface RepositorioAdministrador extends JpaRepository<Administrador, UUID> {

    /**
     * @brief Busca um Administrador pelo CPF.
     * @param cpf O CPF do administrador.
     * @return Um Optional contendo o Administrador, se encontrado.
     */
    Optional<Administrador> findByCpf(String cpf);

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Administradores.
     */
    Page<Administrador> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Cliente;

/**
 * @interface RepositorioCliente
 * @brief Repositório Spring Data JPA para a entidade Cliente.
 *        Fornece métodos CRUD e de busca personalizados para Cliente.
 */
@Repository
public interface RepositorioCliente extends JpaRepository<Cliente, UUID> {

    /**
     * @brief Busca um Cliente pelo CPF.
     * @param cpf O CPF do cliente.
     * @return Um Optional contendo o Cliente, se encontrado.
     */
    Optional<Cliente> findByCpf(String cpf);

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Clientes.
     */
    Page<Cliente> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Empresa;

/**
 * @interface RepositorioEmpresa
 * @brief Repositório Spring Data JPA para a entidade Empresa.
 *        Fornece métodos CRUD e de busca personalizados para Empresa.
 */
@Repository
public interface RepositorioEmpresa extends JpaRepository<Empresa, UUID> {

    /**
     * @brief Busca uma Empresa pelo CNPJ.
     * @param cnpj O CNPJ da empresa.
     * @return Um Optional contendo a Empresa, se encontrada.
     */
    Optional<Empresa> findByCnpj(String cnpj);

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Empresas.
     */
    Page<Empresa> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Endereco;

/**
 * @interface RepositorioEndereco
 * @brief Repositório Spring Data JPA para a entidade Endereco.
 *        Fornece métodos CRUD básicos para Endereco.
 */
@Repository
public interface RepositorioEndereco extends JpaRepository<Endereco, UUID> {
    // Métodos de busca adicionais podem ser definidos aqui se necessário,
    // como findByPessoaId(UUID pessoaId) ou findByEmpresaId(UUID empresaId)
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Pessoa;

/**
 * @interface RepositorioPessoa
 * @brief Repositório Spring Data JPA para a entidade Pessoa (base).
 * Fornece métodos CRUD básicos para Pessoa e busca por CPF.
 * Como Pessoa é uma entidade base abstrata com estratégia JOINED, este
 * repositório
 * pode ser usado para operações polimórficas se necessário, mas
 * geralmente
 * repositórios específicos para subclasses (Profissional, Cliente,
 * Administrador)
 * são mais comuns para operações de negócio.
 */
@Repository
public interface RepositorioPessoa extends JpaRepository<Pessoa, UUID> {

    /**
     * @brief Busca uma Pessoa pelo CPF.
     * @param cpf O CPF da pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Plano;

/**
 * @interface RepositorioPlano
 * @brief Repositório Spring Data JPA para a entidade Plano.
 *        Fornece métodos CRUD e de busca personalizados para Plano.
 *        **Nota:** Em uma arquitetura de microsserviços ideal, esta entidade e
 *        seu
 *        repositório poderiam residir em um serviço de 'marketplace' ou
 *        'assinatura'.
 *        Aqui, é mantido para fins de completude do modelo de dados do
 *        user-service,
 *        mas a gestão real dos planos pode ser externa.
 */
@Repository
public interface RepositorioPlano extends JpaRepository<Plano, UUID> {

    /**
     * @brief Busca um Plano pelo nome.
     * @param nome O nome do plano.
     * @return Um Optional contendo o Plano, se encontrado.
     */
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Profissional;

/**
 * @interface RepositorioProfissional
 * @brief Repositório Spring Data JPA para a entidade Profissional.
 *        Fornece métodos CRUD e de busca personalizados para Profissional.
 */
@Repository
public interface RepositorioProfissional extends JpaRepository<Profissional, UUID> {

    /**
     * @brief Busca um Profissional pelo CPF.
     * @param cpf O CPF do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByCpf(String cpf);

    /**
     * @brief Busca um Profissional pelo número da OAB.
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Profissionais.
     */
    Page<Profissional> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.RoleProfissional;

/**
 * @interface RepositorioRoleProfissional
 * @brief Repositório Spring Data JPA para a entidade RoleProfissional.
 *        Fornece métodos CRUD e de busca personalizados para RoleProfissional.
 *        **Nota:** Em um ambiente multi-tenant, os papéis podem ser globais ou
 *        por tenant.
 *        Este repositório assume que a entidade RoleProfissional está no schema
 *        do tenant.
 */
@Repository
public interface RepositorioRoleProfissional extends JpaRepository<RoleProfissional, UUID> {

    /**
     * @brief Busca um RoleProfissional pelo nome.
     * @param nome O nome do papel.
     * @return Um Optional contendo o RoleProfissional, se encontrado.
     */
    Optional<RoleProfissional> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.User;

/**
 * @interface RepositorioUser
 * @brief Repositório Spring Data JPA para a entidade User.
 *        Fornece métodos CRUD e de busca personalizados para User.
 *        **Nota:** Este repositório é crucial para o pré-requisito de
 *        associação de Pessoa a um User existente.
 *        As operações de criação/atualização de User em si são de
 *        responsabilidade de outro microsserviço (ex: auth-service).
 */
@Repository
public interface RepositorioUser extends JpaRepository<User, UUID> {

    /**
     * @brief Busca um User pelo email.
     * @param email O email do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.AdministradorMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioAdministrador;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoAdministrador
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Administradores.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Administradores.
 */
@Service
@RequiredArgsConstructor
public class ServicoAdministrador {

    private final RepositorioAdministrador repositorioAdministrador;
    private final RepositorioUser repositorioUser;
    private final AdministradorMapper administradorMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Administrador no sistema.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return DTO com os dados do Administrador cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public AdministradorResponseDTO cadastrarAdministrador(AdministradorRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro administrador.");
        }

        // 3. Mapear DTO para entidade
        Administrador administrador = administradorMapper.toEntity(requestDTO);
        administrador.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Administrador)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(administrador); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        administrador.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Administrador savedAdministrador = repositorioAdministrador.save(administrador);

        // 6. Mapear entidade salva para DTO de resposta
        return administradorMapper.toResponseDTO(savedAdministrador);
    }

    /**
     * @brief Busca um Administrador pelo ID.
     * @param id ID do Administrador a ser buscado.
     * @return DTO com os dados do Administrador encontrado.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional(readOnly = true)
    public AdministradorResponseDTO buscarAdministradorPorId(UUID id) {
        Administrador administrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado."));
        return administradorMapper.toResponseDTO(administrador);
    }

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Administradores.
     */
    @Transactional(readOnly = true)
    public Page<AdministradorResponseDTO> listarAdministradores(Pageable pageable) {
        return repositorioAdministrador.findAll(pageable)
                .map(administradorMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Administrador existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return DTO com os dados do Administrador atualizado.
     * @throws BusinessException Se o Administrador não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public AdministradorResponseDTO atualizarAdministrador(UUID id, AdministradorRequestDTO requestDTO) {
        Administrador existingAdministrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingAdministrador.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro administrador.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Administrador
        // O mapper precisa de um método de atualização, ou fazer manualmente
        existingAdministrador.setNomeCompleto(requestDTO.getNomeCompleto());
        existingAdministrador.setCpf(requestDTO.getCpf());
        existingAdministrador.setDataNascimento(requestDTO.getDataNascimento());
        existingAdministrador.setStatus(requestDTO.getStatus()); // Campo específico de Administrador

        // 3. Atualizar endereços (lógica de sincronização)
        existingAdministrador.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            // Reutiliza o mapper para converter DTO para Endereco
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingAdministrador); // Garante a associação bidirecional
            existingAdministrador.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingAdministrador.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingAdministrador.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Administrador updatedAdministrador = repositorioAdministrador.save(existingAdministrador);

        return administradorMapper.toResponseDTO(updatedAdministrador);
    }

    /**
     * @brief Exclui um Administrador pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional
    public void excluirAdministrador(UUID id) {
        if (!repositorioAdministrador.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Administrador com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioAdministrador.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ClienteMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioCliente;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoCliente
 * @brief Serviço de domínio para gerenciar operações relacionadas a Clientes.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Clientes.
 */
@Service
@RequiredArgsConstructor
public class ServicoCliente {

    private final RepositorioCliente repositorioCliente;
    private final RepositorioUser repositorioUser;
    private final ClienteMapper clienteMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Cliente no sistema.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return DTO com os dados do Cliente cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public ClienteResponseDTO cadastrarCliente(ClienteRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro cliente.");
        }

        // 3. Mapear DTO para entidade
        Cliente cliente = clienteMapper.toEntity(requestDTO);
        cliente.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Cliente)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(cliente); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        cliente.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Cliente savedCliente = repositorioCliente.save(cliente);

        // 6. Mapear entidade salva para DTO de resposta
        return clienteMapper.toResponseDTO(savedCliente);
    }

    /**
     * @brief Busca um Cliente pelo ID.
     * @param id ID do Cliente a ser buscado.
     * @return DTO com os dados do Cliente encontrado.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional(readOnly = true)
    public ClienteResponseDTO buscarClientePorId(UUID id) {
        Cliente cliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado."));
        return clienteMapper.toResponseDTO(cliente);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Clientes.
     */
    @Transactional(readOnly = true)
    public Page<ClienteResponseDTO> listarClientes(Pageable pageable) {
        return repositorioCliente.findAll(pageable)
                .map(clienteMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return DTO com os dados do Cliente atualizado.
     * @throws BusinessException Se o Cliente não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public ClienteResponseDTO atualizarCliente(UUID id, ClienteRequestDTO requestDTO) {
        Cliente existingCliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingCliente.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro cliente.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Cliente
        existingCliente.setNomeCompleto(requestDTO.getNomeCompleto());
        existingCliente.setCpf(requestDTO.getCpf());
        existingCliente.setDataNascimento(requestDTO.getDataNascimento());
        existingCliente.setStatus(requestDTO.getStatus()); // Campo específico de Cliente
        // existingCliente.setTipo(requestDTO.getTipo()); // Campo específico de Cliente

        // 3. Atualizar endereços (lógica de sincronização)
        existingCliente.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingCliente);
            existingCliente.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingCliente.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingCliente.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Cliente updatedCliente = repositorioCliente.save(existingCliente);

        return clienteMapper.toResponseDTO(updatedCliente);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional
    public void excluirCliente(UUID id) {
        if (!repositorioCliente.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Cliente com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioCliente.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EmpresaMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEmpresa
 * @brief Serviço de domínio para gerenciar operações relacionadas a Empresas.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Empresas.
 */
@Service
@RequiredArgsConstructor
public class ServicoEmpresa {

    private final RepositorioEmpresa repositorioEmpresa;
    private final EmpresaMapper empresaMapper;

    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra uma nova Empresa no sistema.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return DTO com os dados da Empresa cadastrada.
     * @throws BusinessException Se o CNPJ já estiver cadastrado.
     */
    @Transactional
    public EmpresaResponseDTO cadastrarEmpresa(EmpresaRequestDTO requestDTO) {
        // 1. Validação de duplicidade de CNPJ
        if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CNPJ, "CNPJ já cadastrado para outra empresa.");
        }

        // 2. Mapear DTO para entidade
        Empresa empresa = empresaMapper.toEntity(requestDTO);

        // 3. Associar endereços à empresa
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setEmpresa(empresa); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        empresa.setEnderecos(enderecos);

        // 4. Salvar a entidade
        Empresa savedEmpresa = repositorioEmpresa.save(empresa);

        // 5. Mapear entidade salva para DTO de resposta
        return empresaMapper.toResponseDTO(savedEmpresa);
    }

    /**
     * @brief Busca uma Empresa pelo ID.
     * @param id ID da Empresa a ser buscada.
     * @return DTO com os dados da Empresa encontrada.
     * @throws BusinessException Se a Empresa não for encontrada.
     */
    @Transactional(readOnly = true)
    public EmpresaResponseDTO buscarEmpresaPorId(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada."));
        return empresaMapper.toResponseDTO(empresa);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Empresas.
     */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDTO> listarEmpresas(Pageable pageable) {
        return repositorioEmpresa.findAll(pageable)
                .map(empresaMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id         ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return DTO com os dados da Empresa atualizada.
     * @throws BusinessException Se a Empresa não for encontrada ou se houver
     *                           duplicidade de CNPJ.
     */
    @Transactional
    public EmpresaResponseDTO atualizarEmpresa(UUID id, EmpresaRequestDTO requestDTO) {
        Empresa existingEmpresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para atualização."));

        // 1. Validação de duplicidade de CNPJ (se o CNPJ foi alterado)
        if (!existingEmpresa.getCnpj().equals(requestDTO.getCnpj())) {
            if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CNPJ, "Novo CNPJ já cadastrado para outra empresa.");
            }
        }

        // 2. Atualizar campos básicos da Empresa
        existingEmpresa.setNomeFantasia(requestDTO.getNomeFantasia());
        existingEmpresa.setRazaoSocial(requestDTO.getRazaoSocial());
        existingEmpresa.setCnpj(requestDTO.getCnpj());
        existingEmpresa.setEmailContato(requestDTO.getEmailContato());

        // 3. Atualizar endereços (lógica de sincronização)
        existingEmpresa.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setEmpresa(existingEmpresa);
            existingEmpresa.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingEmpresa.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingEmpresa.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Empresa updatedEmpresa = repositorioEmpresa.save(existingEmpresa);

        return empresaMapper.toResponseDTO(updatedEmpresa);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @throws BusinessException Se a Empresa não for encontrada ou se possuir
     *                           profissionais associados.
     */
    @Transactional
    public void excluirEmpresa(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para exclusão."));

        // Verificar se existem profissionais associados antes de excluir
        if (!empresa.getProfissionais().isEmpty()) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Empresa não pode ser excluída pois possui profissionais associados.");
        }

        // A exclusão em cascata do Endereco será tratada pelo JPA
        repositorioEmpresa.delete(empresa);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEndereco;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEndereco
 * @brief Serviço de domínio para gerenciar operações relacionadas a Endereços.
 *        Este serviço pode ser usado para operações diretas em Endereços,
 *        embora na maioria dos casos eles sejam gerenciados em cascata por
 *        Pessoa ou Empresa.
 */
@Service
@RequiredArgsConstructor
public class ServicoEndereco {

    private final RepositorioEndereco repositorioEndereco;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Endereco.
     * @param requestDTO DTO com os dados do Endereco a ser cadastrado.
     * @return DTO com os dados do Endereco cadastrado.
     */
    @Transactional
    public EnderecoResponseDTO cadastrarEndereco(EnderecoRequestDTO requestDTO) {
        Endereco endereco = enderecoMapper.toEntity(requestDTO);
        Endereco savedEndereco = repositorioEndereco.save(endereco);
        return enderecoMapper.toResponseDTO(savedEndereco);
    }

    /**
     * @brief Busca um Endereco pelo ID.
     * @param id ID do Endereco a ser buscado.
     * @return DTO com os dados do Endereco encontrado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional(readOnly = true)
    public EnderecoResponseDTO buscarEnderecoPorId(UUID id) {
        Endereco endereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado."));
        return enderecoMapper.toResponseDTO(endereco);
    }

    /**
     * @brief Lista todos os Enderecos.
     * @return Lista de DTOs de Enderecos.
     */
    @Transactional(readOnly = true)
    public List<EnderecoResponseDTO> listarEnderecos() {
        return repositorioEndereco.findAll().stream()
                .map(enderecoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Atualiza os dados de um Endereco existente.
     * @param id         ID do Endereco a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Endereco.
     * @return DTO com os dados do Endereco atualizado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public EnderecoResponseDTO atualizarEndereco(UUID id, EnderecoRequestDTO requestDTO) {
        Endereco existingEndereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado para atualização."));

        // Atualizar campos básicos do Endereco
        existingEndereco.setLogradouro(requestDTO.getLogradouro());
        existingEndereco.setNumero(requestDTO.getNumero());
        existingEndereco.setComplemento(requestDTO.getComplemento());
        existingEndereco.setBairro(requestDTO.getBairro());
        existingEndereco.setCidade(requestDTO.getCidade());
        existingEndereco.setEstado(requestDTO.getEstado());
        existingEndereco.setCep(requestDTO.getCep());
        existingEndereco.setPais(requestDTO.getPais());
        existingEndereco.setTipoEndereco(requestDTO.getTipoEndereco());

        Endereco updatedEndereco = repositorioEndereco.save(existingEndereco);
        return enderecoMapper.toResponseDTO(updatedEndereco);
    }

    /**
     * @brief Exclui um Endereco pelo ID.
     * @param id ID do Endereco a ser excluído.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public void excluirEndereco(UUID id) {
        if (!repositorioEndereco.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Endereço com ID " + id + " não encontrado para exclusão.");
        }
        repositorioEndereco.deleteById(id);
    }
}
```
```java
// br/com/legalconnect/service/ServicoPessoa.java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier; // Importar Qualifier
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import br.com.legalconnect.mapper.PessoaMapper;
import br.com.legalconnect.repository.RepositorioPessoa;

/**
 * @class ServicoPessoa
 * @brief Serviço de domínio para operações genéricas relacionadas a Pessoas.
 *        Como Pessoa é uma entidade base abstrata, este serviço lida com
 *        operações
 *        que podem ser comuns a todas as subclasses (Profissional, Cliente,
 *        Administrador).
 *        Operações de criação/atualização específicas devem ser tratadas nos
 *        serviços das subclasses.
 */
@Service
public class ServicoPessoa {

    private final RepositorioPessoa repositorioPessoa;
    private final PessoaMapper pessoaMapper;

    @Autowired
    public ServicoPessoa(RepositorioPessoa repositorioPessoa,
            @Qualifier("pessoaMapperImpl") PessoaMapper pessoaMapper) {
        this.repositorioPessoa = repositorioPessoa;
        this.pessoaMapper = pessoaMapper;
    }

    /**
     * @brief Busca uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser buscada.
     * @return DTO com os dados da Pessoa encontrada.
     * @throws BusinessException Se a Pessoa não for encontrada.
     */
    @Transactional(readOnly = true)
    public PessoaResponseDTO buscarPessoaPorId(UUID id) {
        Pessoa pessoa = repositorioPessoa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Pessoa com ID " + id + " não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * @brief Lista todas as Pessoas.
     * @return Lista de DTOs de Pessoas.
     */
    @Transactional(readOnly = true)
    public List<PessoaResponseDTO> listarTodasPessoas() {
        return repositorioPessoa.findAll().stream()
                .map(pessoaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Exclui uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser excluída.
     * @throws BusinessException Se a Pessoa não for encontrada.
     *                           **Nota:** A exclusão de Pessoa deve ser feita com
     *                           cautela, pois pode
     *                           impactar subclasses (Profissional, Cliente,
     *                           Administrador) e o User associado.
     *                           Idealmente, a exclusão de subclasses deveria ser o
     *                           ponto de entrada.
     */
    @Transactional
    public void excluirPessoa(UUID id) {
        if (!repositorioPessoa.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Pessoa com ID " + id + " não encontrada para exclusão.");
        }
        repositorioPessoa.deleteById(id);
    }
}

```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.mapper.ProfissionalMapper; // Reutilizando mapper de profissional para plano
import br.com.legalconnect.repository.RepositorioPlano;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoPlano
 * @brief Serviço de domínio para gerenciar operações relacionadas a Planos.
 *        **Nota:** Este serviço é um placeholder. Em uma arquitetura de
 *        microsserviços real,
 *        a gestão de planos seria feita em um microsserviço dedicado (ex:
 *        marketplace ou assinatura).
 *        Aqui, ele apenas fornece métodos de busca para que outros serviços
 *        possam referenciar planos.
 */
@Service
@RequiredArgsConstructor
public class ServicoPlano {

    private final RepositorioPlano repositorioPlano;
    private final ProfissionalMapper profissionalMapper;

    /**
     * @brief Busca um Plano pelo ID.
     * @param id ID do Plano a ser buscado.
     * @return DTO com os dados do Plano encontrado.
     * @throws BusinessException Se o Plano não for encontrado.
     */
    @Transactional(readOnly = true)
    public PlanoResponseDTO buscarPlanoPorId(UUID id) {
        Plano plano = repositorioPlano.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + id + " não encontrado."));
        return profissionalMapper.toPlanoResponseDTO(plano);
    }

    /**
     * @brief Lista todos os Planos disponíveis.
     * @return Lista de DTOs de Planos.
     */
    @Transactional(readOnly = true)
    public List<PlanoResponseDTO> listarTodosPlanos() {
        return repositorioPlano.findAll().stream()
                .map(profissionalMapper::toPlanoResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para cadastrar, atualizar e excluir planos não são implementados
    // aqui,
    // pois seriam responsabilidade do microsserviço de marketplace/assinatura.
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.mapper.ProfissionalMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import br.com.legalconnect.repository.RepositorioPlano;
import br.com.legalconnect.repository.RepositorioProfissional;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoProfissional
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Profissionais.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Profissionais.
 */
@Service
@RequiredArgsConstructor
public class ServicoProfissional {

    private final RepositorioProfissional repositorioProfissional;
    private final RepositorioUser repositorioUser;
    private final RepositorioPlano repositorioPlano;
    private final RepositorioEmpresa repositorioEmpresa;
    private final ProfissionalMapper profissionalMapper;

    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Profissional no sistema.
     * @param requestDTO DTO com os dados do Profissional a ser cadastrado.
     * @return DTO com os dados do Profissional cadastrado.
     * @throws BusinessException Se o CPF ou OAB já estiverem cadastrados, ou se o
     *                           User/Plano/Empresa associado não for encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO cadastrarProfissional(ProfissionalRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF e OAB
        if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro profissional.");
        }
        if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_INPUT,
                    "Número da OAB já cadastrado para outro profissional.");
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Mapear DTO para entidade
        Profissional profissional = profissionalMapper.toEntity(requestDTO);
        profissional.setUsuario(user); // Associar o User encontrado
        profissional.setPlano(plano); // Associar o Plano encontrado
        profissional.setEmpresa(empresa); // Associar a Empresa (pode ser null)

        // 5. Associar endereços à pessoa (Profissional)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(profissional); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        profissional.setEnderecos(enderecos);

        // 6. Salvar a entidade
        Profissional savedProfissional = repositorioProfissional.save(profissional);

        // 7. Mapear entidade salva para DTO de resposta
        return profissionalMapper.toResponseDTO(savedProfissional);
    }

    /**
     * @brief Busca um Profissional pelo ID.
     * @param id ID do Profissional a ser buscado.
     * @return DTO com os dados do Profissional encontrado.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional(readOnly = true)
    public ProfissionalResponseDTO buscarProfissionalPorId(UUID id) {
        Profissional profissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado."));
        return profissionalMapper.toResponseDTO(profissional);
    }

    /**
     * @brief Lista todos os Profissionais com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Profissionais.
     */
    @Transactional(readOnly = true)
    public Page<ProfissionalResponseDTO> listarProfissionais(Pageable pageable) {
        return repositorioProfissional.findAll(pageable)
                .map(profissionalMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Profissional existente.
     * @param id         ID do Profissional a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Profissional.
     * @return DTO com os dados do Profissional atualizado.
     * @throws BusinessException Se o Profissional não for encontrado, ou se houver
     *                           duplicidade de CPF/OAB, ou se Plano/Empresa não for
     *                           encontrado.
     */
    @Transactional
    public ProfissionalResponseDTO atualizarProfissional(UUID id, ProfissionalRequestDTO requestDTO) {
        Profissional existingProfissional = repositorioProfissional.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Profissional com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingProfissional.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioProfissional.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro profissional.");
            }
        }
        // 2. Validação de duplicidade de OAB (se a OAB foi alterada)
        if (!existingProfissional.getNumeroOab().equals(requestDTO.getNumeroOab())) {
            if (repositorioProfissional.findByNumeroOab(requestDTO.getNumeroOab()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_INPUT,
                        "Novo número da OAB já cadastrado para outro profissional.");
            }
        }

        // 3. Buscar Plano e Empresa (se aplicável)
        Plano plano = repositorioPlano.findById(requestDTO.getPlanoId())
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + requestDTO.getPlanoId() + " não encontrado."));

        Empresa empresa = null;
        if (requestDTO.getEmpresaId() != null) {
            empresa = repositorioEmpresa.findById(requestDTO.getEmpresaId())
                    .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                            "Empresa com ID " + requestDTO.getEmpresaId() + " não encontrada."));
        }

        // 4. Atualizar campos básicos da Pessoa e Profissional
        existingProfissional.setNomeCompleto(requestDTO.getNomeCompleto());
        existingProfissional.setCpf(requestDTO.getCpf());
        existingProfissional.setDataNascimento(requestDTO.getDataNascimento());
        existingProfissional.setNumeroOab(requestDTO.getNumeroOab());
        existingProfissional.setStatusProfissional(requestDTO.getStatusProfissional());
        existingProfissional.setUsaMarketplace(requestDTO.getUsaMarketplace());
        existingProfissional.setFazParteDePlano(requestDTO.getFazParteDePlano());
        existingProfissional.setPlano(plano);
        existingProfissional.setEmpresa(empresa);

        // 5. Atualizar endereços (lógica de sincronização)
        existingProfissional.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingProfissional);
            existingProfissional.getEnderecos().add(newEndereco);
        });

        // 6. Atualizar telefones
        existingProfissional.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingProfissional.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 7. Salvar a entidade atualizada
        Profissional updatedProfissional = repositorioProfissional.save(existingProfissional);

        return profissionalMapper.toResponseDTO(updatedProfissional);
    }

    /**
     * @brief Exclui um Profissional pelo ID.
     * @param id ID do Profissional a ser excluído.
     * @throws BusinessException Se o Profissional não for encontrado.
     */
    @Transactional
    public void excluirProfissional(UUID id) {
        if (!repositorioProfissional.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Profissional com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioProfissional.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.UserMapper;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoUser
 * @brief Serviço de domínio para gerenciar operações relacionadas a Users.
 *        **Nota:** Este serviço é primariamente para busca e validação de Users
 *        existentes
 *        para associação com entidades Pessoa (Profissional, Cliente,
 *        Administrador).
 *        A criação e gestão principal de Users é responsabilidade de outro
 *        microsserviço (ex: auth-service).
 */
@Service
@RequiredArgsConstructor
public class ServicoUser {

    private final RepositorioUser repositorioUser;
    private final UserMapper userMapper;

    /**
     * @brief Busca um User pelo ID.
     * @param id ID do User a ser buscado.
     * @return DTO com os dados do User encontrado.
     * @throws BusinessException Se o User não for encontrado.
     */
    @Transactional(readOnly = true)
    public UserResponseDTO buscarUserPorId(UUID id) {
        User user = repositorioUser.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário com ID " + id + " não encontrado."));
        return userMapper.toResponseDTO(user);
    }

    /**
     * @brief Lista todos os Users.
     * @return Lista de DTOs de Users.
     */
    @Transactional(readOnly = true)
    public List<UserResponseDTO> listarTodosUsers() {
        return repositorioUser.findAll().stream()
                .map(userMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Verifica se um User existe pelo ID.
     * @param id ID do User a ser verificado.
     * @return true se o User existe, false caso contrário.
     */
    @Transactional(readOnly = true)
    public boolean userExiste(UUID id) {
        return repositorioUser.existsById(id);
    }

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o DTO do User, se encontrado.
     */
    @Transactional(readOnly = true)
    public Optional<UserResponseDTO> buscarUserPorCpf(String cpf) {
        return repositorioUser.findByCpf(cpf)
                .map(userMapper::toResponseDTO);
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada
server.port=8084
# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

# Habilita o Eureka Client
eureka.client.enabled=true
# URL do servidor Eureka onde o auth-service irá se registrar
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância para garantir identificação única no Eureka
eureka.instance.hostname=localhost
eureka.instance.instance-id=${spring.application.name}:${instanceId:${random.value}}
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```
```java
package br.com.legalconnect;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;

@EnableDiscoveryClient
@SpringBootApplication // (exclude = FlywayAutoConfiguration.class) // Remova o scanBasePackages aqui
                       // também, se já está no
                       // pacote raiz
@EntityScan(basePackages = {
        // "br.com.legalconnect.entity",
        "br.com.legalconnect.entity",
        "br.com.legalconnect.advogado.domain.modal.entity"
})
// @EnableJpaRepositories(basePackages = {
// "br.com.legalconnect.user.repository",
// "br.com.legalconnect.auth.repository"
// })
// REMOVA COMPLETAMENTE ESTE @ComponentScan, a menos que você tenha um motivo
// muito específico e saiba o que está fazendo
// @ComponentScan(basePackages = { "br.com.legalconnect.auth.service" })
public class LegalUsuarioApplication {

    private static final Logger log = LoggerFactory.getLogger(LegalUsuarioApplication.class);

    public static void main(String[] args) {
        SpringApplication.run(LegalUsuarioApplication.class, args);
        log.info("LegalUsuarioApplication iniciada com sucesso!");
    }
}
```
```java
package br.com.legalconnect.config;

import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
public class FilterAdvice implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request,
            HttpServletResponse response,
            Object handler) throws Exception {
        String userIdHeader = request.getHeader("X-Correlaton-ID");

        if (userIdHeader == null || userIdHeader.isEmpty()) {
            throw new BusinessException(ErrorCode.ACCOUNT_LOCKED, "Acesso inválido.");
        }

        return true; // retorne false para interromper a execução
    }
}

```
```java

package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoAdministrador;
import jakarta.validation.Valid;

/**
 * @class ControladorAdministradorPlataforma
 * @brief Controlador REST para gerenciar operações relacionadas a
 *        Administradores da Plataforma.
 *        Expõe endpoints para CRUD de Administradores.
 */
@RestController
@RequestMapping("/api/v1/usuarios/administradores-plataforma")
public class ControladorAdministradorPlataforma {

        private final ServicoAdministrador servicoAdministrador;

        @Autowired
        public ControladorAdministradorPlataforma(ServicoAdministrador servicoAdministrador) {
                this.servicoAdministrador = servicoAdministrador;
        }

        /**
         * @brief Cadastra um novo Administrador da Plataforma.
         * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
         * @return ResponseEntity com o DTO do Administrador cadastrado e status 201
         *         Created.
         */
        @PostMapping
        public ResponseEntity<BaseResponse<AdministradorResponseDTO>> cadastrarAdministrador(
                        @Valid @RequestBody AdministradorRequestDTO requestDTO) {
                AdministradorResponseDTO responseDTO = servicoAdministrador.cadastrarAdministrador(requestDTO); // Usar
                                                                                                                // o
                                                                                                                // método
                                                                                                                // 'cadastrar'
                // da classe base
                return ResponseEntity.status(HttpStatus.CREATED).body(
                                BaseResponse.<AdministradorResponseDTO>builder()
                                                .message("Administrador cadastrado com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Busca um Administrador da Plataforma por ID.
         * @param id ID do Administrador a ser buscado.
         * @return ResponseEntity com o DTO do Administrador encontrado e status 200 OK.
         */
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<AdministradorResponseDTO>> buscarAdministradorPorId(@PathVariable UUID id) {
                AdministradorResponseDTO responseDTO = servicoAdministrador.buscarAdministradorPorId(id); // Usar o
                                                                                                          // método
                                                                                                          // 'buscarPorId'
                                                                                                          // da
                // classe base
                return ResponseEntity.ok(
                                BaseResponse.<AdministradorResponseDTO>builder()
                                                .message("Administrador encontrado.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Lista todos os Administradores da Plataforma com paginação.
         * @param pageable Objeto Pageable para configuração da paginação (ex:
         *                 ?page=0&size=10&sort=nomeCompleto,asc).
         * @return ResponseEntity com uma página de DTOs de Administradores e status 200
         *         OK.
         */
        @GetMapping
        public ResponseEntity<BaseResponse<Page<AdministradorResponseDTO>>> listarAdministradores(
                        @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
                Page<AdministradorResponseDTO> responsePage = servicoAdministrador.listarAdministradores(pageable); // Usar
                                                                                                                    // o
                                                                                                                    // método
                                                                                                                    // 'listar'
                // da classe base
                return ResponseEntity.ok(
                                BaseResponse.<Page<AdministradorResponseDTO>>builder()
                                                .message("Lista de administradores recuperada com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responsePage)
                                                .build());
        }

        /**
         * @brief Atualiza os dados de um Administrador da Plataforma existente.
         * @param id         ID do Administrador a ser atualizado.
         * @param requestDTO DTO com os dados atualizados do Administrador.
         * @return ResponseEntity com o DTO do Administrador atualizado e status 200 OK.
         */
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<AdministradorResponseDTO>> atualizarAdministrador(
                        @PathVariable UUID id,
                        @Valid @RequestBody AdministradorRequestDTO requestDTO) {
                AdministradorResponseDTO responseDTO = servicoAdministrador.atualizarAdministrador(id, requestDTO); // Usar
                                                                                                                    // o
                                                                                                                    // método
                // 'atualizar' da classe
                // base
                return ResponseEntity.ok(
                                BaseResponse.<AdministradorResponseDTO>builder()
                                                .message("Administrador atualizado com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Exclui um Administrador da Plataforma pelo ID.
         * @param id ID do Administrador a ser excluído.
         * @return ResponseEntity com status 204 No Content.
         */
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> excluirAdministrador(@PathVariable UUID id) {
                servicoAdministrador.excluirAdministrador(id); // Usar o método 'excluir' da classe base
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body( // Retorna 204 No Content com um corpo de
                                                                          // sucesso
                                BaseResponse.<Void>builder()
                                                .message("Administrador excluído com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .build());
        }
}

```
```java
package br.com.legalconnect.controller;

import java.util.Optional;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoCliente;
import jakarta.validation.Valid;

/**
 * @class ControladorCliente
 * @brief Controlador REST para gerenciar operações relacionadas a Clientes.
 *        Expõe endpoints para CRUD de Clientes.
 */
@RestController
@RequestMapping("/api/v1/usuarios/clientes")
public class ControladorCliente {

        private final ServicoCliente servicoCliente;

        @Autowired
        public ControladorCliente(ServicoCliente servicoCliente) {
                this.servicoCliente = servicoCliente;
        }

        /**
         * @brief Cadastra um novo Cliente.
         * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
         * @return ResponseEntity com o DTO do Cliente cadastrado e status 201 Created.
         */
        @PostMapping
        public ResponseEntity<BaseResponse<ClienteResponseDTO>> cadastrarCliente(
                        @Valid @RequestBody ClienteRequestDTO requestDTO,
                        @RequestHeader(value = "X-Correlation-Id", required = false) String userId) { // Fix: Added
                                                                                                      // missing
                                                                                                      // parenthesis
                requestDTO.setUsuario(Optional.ofNullable(requestDTO.getUsuario()) // Fix: Added missing parenthesis
                                .orElseGet(() -> UserRequestDTO.builder().id(UUID.fromString(userId)).build()));

                ClienteResponseDTO responseDTO = servicoCliente.cadastrarCliente(requestDTO); // Chamando o método
                                                                                              // original do
                                                                                              // serviço
                return ResponseEntity.status(HttpStatus.CREATED).body(
                                BaseResponse.<ClienteResponseDTO>builder()
                                                .message("Cliente cadastrado com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Busca um Cliente por ID.
         * @param id ID do Cliente a ser buscado.
         * @return ResponseEntity com o DTO do Cliente encontrado e status 200 OK.
         */
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<ClienteResponseDTO>> buscarClientePorId(@PathVariable UUID id) {
                ClienteResponseDTO responseDTO = servicoCliente.buscarClientePorId(id); // Chamando o método original do
                                                                                        // serviço
                return ResponseEntity.ok(
                                BaseResponse.<ClienteResponseDTO>builder()
                                                .message("Cliente encontrado.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Lista todos os Clientes com paginação.
         * @param pageable Objeto Pageable para configuração da paginação (ex:
         *                 ?page=0&size=10&sort=nomeCompleto,asc).
         * @return ResponseEntity com uma página de DTOs de Clientes e status 200 OK.
         */
        @GetMapping
        public ResponseEntity<BaseResponse<Page<ClienteResponseDTO>>> listarClientes(
                        @PageableDefault(size = 10, page = 0, sort = "nomeCompleto") Pageable pageable) {
                Page<ClienteResponseDTO> responsePage = servicoCliente.listarClientes(pageable); // Chamando o método
                                                                                                 // original
                                                                                                 // do serviço
                return ResponseEntity.ok(
                                BaseResponse.<Page<ClienteResponseDTO>>builder()
                                                .message("Lista de clientes recuperada com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responsePage)
                                                .build());
        }

        /**
         * @brief Atualiza os dados de um Cliente existente.
         * @param id         ID do Cliente a ser atualizado.
         * @param requestDTO DTO com os dados atualizados do Cliente.
         * @return ResponseEntity com o DTO do Cliente atualizado e status 200 OK.
         */
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<ClienteResponseDTO>> atualizarCliente(
                        @PathVariable UUID id,
                        @Valid @RequestBody ClienteRequestDTO requestDTO) {
                ClienteResponseDTO responseDTO = servicoCliente.atualizarCliente(id, requestDTO); // Chamando o método
                                                                                                  // original
                                                                                                  // do serviço
                return ResponseEntity.ok(
                                BaseResponse.<ClienteResponseDTO>builder()
                                                .message("Cliente atualizado com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Exclui um Cliente pelo ID.
         * @param id ID do Cliente a ser excluído.
         * @return ResponseEntity com status 204 No Content.
         */
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> excluirCliente(@PathVariable UUID id) {
                servicoCliente.excluirCliente(id); // Chamando o método original do serviço
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                                BaseResponse.<Void>builder()
                                                .message("Cliente excluído com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .build());
        }
}

```
```java
package br.com.legalconnect.controller;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.web.PageableDefault;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import br.com.legalconnect.common.dto.BaseResponse;
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.enums.StatusResponse;
import br.com.legalconnect.service.ServicoEmpresa;
import jakarta.validation.Valid;

/**
 * @class ControladorEmpresa
 * @brief Controlador REST para gerenciar operações relacionadas a Empresas.
 *        Expõe endpoints para CRUD de Empresas.
 */
@RestController
@RequestMapping("/api/v1/usuarios/empresas")
public class ControladorEmpresa {

        private final ServicoEmpresa servicoEmpresa;

        @Autowired
        public ControladorEmpresa(ServicoEmpresa servicoEmpresa) {
                this.servicoEmpresa = servicoEmpresa;
        }

        /**
         * @brief Cadastra uma nova Empresa.
         * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
         * @return ResponseEntity com o DTO da Empresa cadastrada e status 201 Created.
         */
        @PostMapping
        public ResponseEntity<BaseResponse<EmpresaResponseDTO>> cadastrarEmpresa(
                        @Valid @RequestBody EmpresaRequestDTO requestDTO) {
                EmpresaResponseDTO responseDTO = servicoEmpresa.cadastrarEmpresa(requestDTO); // Chamando o método
                                                                                              // original do
                                                                                              // serviço
                return ResponseEntity.status(HttpStatus.CREATED).body(
                                BaseResponse.<EmpresaResponseDTO>builder()
                                                .message("Empresa cadastrada com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Busca uma Empresa por ID.
         * @param id ID da Empresa a ser buscada.
         * @return ResponseEntity com o DTO da Empresa encontrada e status 200 OK.
         */
        @GetMapping("/{id}")
        public ResponseEntity<BaseResponse<EmpresaResponseDTO>> buscarEmpresaPorId(@PathVariable UUID id) {
                EmpresaResponseDTO responseDTO = servicoEmpresa.buscarEmpresaPorId(id); // Chamando o método original do
                                                                                        // serviço
                return ResponseEntity.ok(
                                BaseResponse.<EmpresaResponseDTO>builder()
                                                .message("Empresa encontrada.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Lista todas as Empresas com paginação.
         * @param pageable Objeto Pageable para configuração da paginação (ex:
         *                 ?page=0&size=10&sort=nomeFantasia,asc).
         * @return ResponseEntity com uma página de DTOs de Empresas e status 200 OK.
         */
        @GetMapping
        public ResponseEntity<BaseResponse<Page<EmpresaResponseDTO>>> listarEmpresas(
                        @PageableDefault(size = 10, page = 0, sort = "nomeFantasia") Pageable pageable) {
                Page<EmpresaResponseDTO> responsePage = servicoEmpresa.listarEmpresas(pageable); // Chamando o método
                                                                                                 // original
                                                                                                 // do serviço
                return ResponseEntity.ok(
                                BaseResponse.<Page<EmpresaResponseDTO>>builder()
                                                .message("Lista de empresas recuperada com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responsePage)
                                                .build());
        }

        /**
         * @brief Atualiza os dados de uma Empresa existente.
         * @param id         ID da Empresa a ser atualizada.
         * @param requestDTO DTO com os dados atualizados da Empresa.
         * @return ResponseEntity com o DTO da Empresa atualizada e status 200 OK.
         */
        @PutMapping("/{id}")
        public ResponseEntity<BaseResponse<EmpresaResponseDTO>> atualizarEmpresa(
                        @PathVariable UUID id,
                        @Valid @RequestBody EmpresaRequestDTO requestDTO) {
                EmpresaResponseDTO responseDTO = servicoEmpresa.atualizarEmpresa(id, requestDTO); // Chamando o método
                                                                                                  // original
                                                                                                  // do serviço
                return ResponseEntity.ok(
                                BaseResponse.<EmpresaResponseDTO>builder()
                                                .message("Empresa atualizada com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .data(responseDTO)
                                                .build());
        }

        /**
         * @brief Exclui uma Empresa pelo ID.
         * @param id ID da Empresa a ser excluída.
         * @return ResponseEntity com status 204 No Content.
         */
        @DeleteMapping("/{id}")
        public ResponseEntity<BaseResponse<Void>> excluirEmpresa(@PathVariable UUID id) {
                servicoEmpresa.excluirEmpresa(id); // Chamando o método original do serviço
                return ResponseEntity.status(HttpStatus.NO_CONTENT).body(
                                BaseResponse.<Void>builder()
                                                .message("Empresa excluída com sucesso.")
                                                .status(StatusResponse.SUCESSO)
                                                .build());
        }
}

```
```java
{
  "folders": [
    {
      "name": "legal-usuario",
      "path": "../../../../../../.."
    },
    {
      "name": "auth-service",
      "path": "../../../../../../../../auth-service"
    },
    {
      "name": "infrastructure",
      "path": "../../../../../../../../infrastructure"
    },
    {
      "name": "legal-advogado",
      "path": "../../../../../../../../legal-advogado"
    },
    {
      "name": "common-role",
      "path": "../../../../../../../../common-role"
    },
    {
      "name": "common-tenent",
      "path": "../../../../../../../../common-tenent"
    },
    {
      "name": "common-lib",
      "path": "../../../../../../../../common-lib"
    },
    {
      "name": "legal-gaateway",
      "path": "../../../../../../../../legal-gaateway"
    },
    {
      "path": "../../../../../../../../legal-marketplace"
    }
  ],
  "settings": {
    "java.configuration.updateBuildConfiguration": "interactive",
    "java.debug.settings.onBuildFailureProceed": true
  }
}

```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorRequestDTO
 * @brief DTO para requisições de criação ou atualização de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class AdministradorResponseDTO
 * @brief DTO para respostas de Administrador.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AdministradorResponseDTO extends PessoaResponseDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteRequestDTO
 * @brief DTO para requisições de criação ou atualização de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteRequestDTO extends PessoaRequestDTO {
    private String status;
}
```
```java
package br.com.legalconnect.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ClienteResponseDTO
 * @brief DTO para respostas de Cliente.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ClienteResponseDTO extends PessoaResponseDTO {
    private String status;
    private String tipo;
}
```
```java
package br.com.legalconnect.dto;

import java.util.List;
import java.util.Set;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaRequestDTO
 * @brief DTO para requisições de criação ou atualização de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O nome fantasia não pode estar em branco.")
    @Size(max = 255, message = "O nome fantasia deve ter no máximo 255 caracteres.")
    private String nomeFantasia;

    @NotBlank(message = "A razão social não pode estar em branco.")
    @Size(max = 255, message = "A razão social deve ter no máximo 255 caracteres.")
    private String razaoSocial;

    @NotBlank(message = "O CNPJ não pode estar em branco.")
    @Pattern(regexp = "\\d{2}\\.\\d{3}\\.\\d{3}/\\d{4}-\\d{2}", message = "Formato de CNPJ inválido. Use XX.XXX.XXX/XXXX-XX.")
    private String cnpj;

    @Email(message = "Formato de email de contato inválido.")
    @Size(max = 255, message = "O email de contato deve ter no máximo 255 caracteres.")
    private String emailContato;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos;

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EmpresaResponseDTO
 * @brief DTO para respostas de Empresa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EmpresaResponseDTO {
    private UUID id;
    private String nomeFantasia;
    private String razaoSocial;
    private String cnpj;
    private String emailContato;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoRequestDTO
 * @brief DTO para requisições de criação ou atualização de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    private UUID id; // Para atualizações, pode ser necessário o ID

    @NotBlank(message = "O logradouro não pode estar em branco.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número não pode estar em branco.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro não pode estar em branco.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade não pode estar em branco.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado não pode estar em branco.")
    @Size(min = 2, max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP não pode estar em branco.")
    @Pattern(regexp = "\\d{5}-\\d{3}", message = "Formato de CEP inválido. Use XXXXX-XXX.")
    private String cep;

    @NotBlank(message = "O país não pode estar em branco.")
    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais;

    @NotNull(message = "O tipo de endereço não pode ser nulo.")
    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Endereco.TipoEndereco;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class EnderecoResponseDTO
 * @brief DTO para respostas de Endereco.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;
    private String logradouro;
    private String numero;
    private String complemento;
    private String bairro;
    private String cidade;
    private String estado;
    private String cep;
    private String pais;
    private TipoEndereco tipoEndereco;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.util.List; // Usar List para Enderecos para manter a ordem se necessário
import java.util.Set;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaRequestDTO
 * @brief DTO base para requisições de criação ou atualização de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // Não incluir o ID aqui, pois ele será definido pela entidade base (BaseEntity)
    // e retornado no ResponseDTO.

    // @NotNull(message = "Os dados do usuário não podem ser nulos.")
    // @Valid // Valida o DTO aninhado
    private UserRequestDTO usuario;

    @NotBlank(message = "O nome completo não pode estar em branco.")
    @Size(max = 255, message = "O nome completo deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF não pode estar em branco.")
    @Pattern(regexp = "\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}", message = "Formato de CPF inválido. Use XXX.XXX.XXX-XX.")
    private String cpf;

    @PastOrPresent(message = "A data de nascimento não pode ser futura.")
    private LocalDate dataNascimento;

    @Valid // Valida a lista de DTOs aninhados
    private List<EnderecoRequestDTO> enderecos; // Usar List para manter a ordem se necessário

    private Set<String> telefones; // Lista de números de telefone como strings
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class PessoaResponseDTO
 * @brief DTO base para respostas de Pessoa.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaResponseDTO {
    private UUID id;
    private UserResponseDTO usuario;
    private String nomeCompleto;
    private String cpf;
    private LocalDate dataNascimento;
    private List<EnderecoResponseDTO> enderecos;
    private Set<String> telefones;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.UUID;

import br.com.legalconnect.entity.Plano.VisibilidadeDestaque;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class PlanoResponseDTO
 * @brief DTO para respostas de Plano.
 *        Esta classe é um DTO simplificado para ser usado em outros
 *        microsserviços.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PlanoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
    private BigDecimal precoMensal;
    private BigDecimal precoAnual;
    private Integer limiteServicosAgendaveis;
    private VisibilidadeDestaque visibilidadeDestaque;
    private Boolean acessoRelatoriosAvancados;
    private Boolean permitePedidosOrcamento;
    private Integer periodoTesteDias;
    private Boolean isDefault;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalRequestDTO
 * @brief DTO para requisições de criação ou atualização de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalRequestDTO extends PessoaRequestDTO {
    @NotBlank(message = "O número da OAB não pode estar em branco.")
    @Size(max = 50, message = "O número da OAB deve ter no máximo 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "O status profissional não pode ser nulo.")
    private StatusProfissional statusProfissional;

    @NotNull(message = "A indicação de uso do marketplace não pode ser nula.")
    private Boolean usaMarketplace;

    @NotNull(message = "A indicação de participação em plano não pode ser nula.")
    private Boolean fazParteDePlano;

    private UUID empresaId; // ID da empresa associada (opcional)

    @NotNull(message = "O ID do plano não pode ser nulo.")
    private UUID planoId; // ID do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import br.com.legalconnect.entity.Profissional.StatusProfissional;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.experimental.SuperBuilder;

/**
 * @class ProfissionalResponseDTO
 * @brief DTO para respostas de Profissional.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ProfissionalResponseDTO extends PessoaResponseDTO {
    private String numeroOab;
    private StatusProfissional statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;
    private EmpresaResponseDTO empresa; // DTO da empresa associada (simplificado)
    private PlanoResponseDTO plano; // DTO do plano de assinatura
}
```
```java
package br.com.legalconnect.dto;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserRequestDTO
 * @brief DTO para requisições de criação ou atualização de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    private UUID id;
    // @NotBlank(message = "O email não pode estar em branco.")
    // @Email(message = "Formato de email inválido.")
    private String email;

    // @NotBlank(message = "A senha não pode estar em branco.")
    // @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
    // private String password;

    // O papel (Role) pode ser definido aqui ou inferido pelo serviço de
    // autenticação/usuário
    // dependendo da lógica de negócio. Para simplificar, pode ser incluído se for
    // um input direto.
    // private String role;
}
```
```java
package br.com.legalconnect.dto;

import java.time.LocalDateTime;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class UserResponseDTO
 * @brief DTO para respostas de User.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String email;
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;
    // private String role; // Incluir se o papel for relevante na resposta
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Administrador
 * @brief Entidade que representa um administrador da plataforma.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_administrador' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_administrador")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Administrador extends Pessoa {
    private String status;

    // Atualmente, não há campos adicionais específicos para Administrador além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, nível de acesso
    // administrativo, etc.
}
```
```java
package br.com.legalconnect.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Cliente
 * @brief Entidade que representa um cliente.
 *        Estende a entidade Pessoa. Atualmente não possui campos adicionais,
 *        mas pode ser expandido.
 *        Mapeado para a tabela 'tb_cliente' que se junta a 'tb_pessoa' pela
 *        chave primária.
 */
@Entity
@Table(name = "tb_cliente")
@PrimaryKeyJoinColumn(name = "id")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Cliente extends Pessoa {
    private String status;
    private String tipo;

    // Atualmente, não há campos adicionais específicos para Cliente além dos
    // herdados de Pessoa.
    // Pode ser expandido no futuro com, por exemplo, histórico de preferências,
    // etc.
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Empresa
 * @brief Entidade que representa uma empresa que pode contratar planos na
 *        plataforma.
 *        Esta entidade não estende Pessoa, pois representa uma pessoa jurídica.
 *        Mapeada para a tabela 'tb_empresa'.
 */
@Entity
@Table(name = "tb_empresa")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Empresa extends BaseEntity {

    @Column(name = "nome_fantasia", nullable = false, length = 255)
    private String nomeFantasia; // Nome fantasia da empresa

    @Column(name = "razao_social", nullable = false, length = 255)
    private String razaoSocial; // Razão social da empresa

    @Column(name = "cnpj", nullable = false, unique = true, length = 18) // CNPJ com máscara
    private String cnpj; // Número do Cadastro Nacional de Pessoas Jurídicas (CNPJ), único por empresa

    @Column(name = "email_contato", length = 255)
    private String emailContato; // E-mail de contato da empresa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma empresa pode ter múltiplos endereços (sede, filiais, etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Empresa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'empresa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da empresa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_empresa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_empresa_telefones", joinColumns = @JoinColumn(name = "empresa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>(); // Conjunto de números de telefone da empresa

    @OneToMany(mappedBy = "empresa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Profissional> profissionais = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id")
    private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set; // Usaremos Set para evitar duplicatas e garantir unicidade

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public abstract class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.entity;

import java.math.BigDecimal;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Plano
 * @brief Entidade que representa um plano de assinatura oferecido na
 *        plataforma.
 *        Esta classe é um placeholder e deve ser definida em seu próprio
 *        microsserviço (marketplace).
 *        Mapeada para a tabela 'tb_plano'.
 */
@Entity
@Table(name = "tb_plano")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Plano extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome do plano (ex: Free, Premium)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Descrição detalhada do plano

    @Column(name = "preco_mensal", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoMensal; // Preço mensal do plano

    @Column(name = "preco_anual", nullable = false, precision = 10, scale = 2)
    private BigDecimal precoAnual; // Preço anual do plano

    @Column(name = "limite_servicos_agendaveis")
    private Integer limiteServicosAgendaveis; // Limite de serviços que podem ser agendados

    @Enumerated(EnumType.STRING)
    @Column(name = "visibilidade_destaque", nullable = false, length = 50)
    private VisibilidadeDestaque visibilidadeDestaque; // Nível de destaque no marketplace

    @Column(name = "acesso_relatorios_avancados", nullable = false)
    private Boolean acessoRelatoriosAvancados; // Indica se o plano dá acesso a relatórios avançados

    @Column(name = "permite_pedidos_orcamento", nullable = false)
    private Boolean permitePedidosOrcamento; // Indica se o plano permite pedidos de orçamento

    @Column(name = "periodo_teste_dias")
    private Integer periodoTesteDias; // Período de teste gratuito em dias

    @Column(name = "is_default", nullable = false)
    private Boolean isDefault; // Indica se é o plano padrão para novos cadastros

    /**
     * @enum VisibilidadeDestaque
     * @brief Enumeração para representar o nível de visibilidade/destaque de um
     *        plano no marketplace.
     */
    public enum VisibilidadeDestaque {
        PADRAO,
        PREMIUM,
        DESTAQUE_MAXIMO
    }
}
```
```java
package br.com.legalconnect.entity;

import java.util.HashSet;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrimaryKeyJoinColumn;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Profissional
 * @brief Entidade que representa um profissional do direito.
 *        Estende a entidade Pessoa e adiciona campos específicos de um
 *        profissional.
 *        Mapeado para a tabela 'tb_profissional' que se junta a 'tb_pessoa'
 *        pela chave primária.
 */
@Entity
@Table(name = "tb_profissional")
@PrimaryKeyJoinColumn(name = "id")
@Getter

@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab; // Número de registro na OAB, único por profissional

    @Enumerated(EnumType.STRING)
    @Column(name = "status_profissional", nullable = false, length = 50)
    private StatusProfissional statusProfissional; // Status específico do profissional (ex: ATIVO, LICENCIADO)

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false; // Indica se o profissional deseja aparecer no marketplace

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false; // Indica se o profissional está associado a um plano pago

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um profissional pode pertencer a uma empresa.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "empresa_id") // Coluna de chave estrangeira para a empresa
    private Empresa empresa; // A empresa à qual o profissional está associado (se houver)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Plano.
     *        Um profissional está associado a um plano de assinatura.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "plano_id", nullable = false) // Coluna de chave estrangeira para o plano
    private Plano plano; // O plano de assinatura do advogado
    @ManyToMany(fetch = FetchType.EAGER) // Relacionamento muitos-para-muitos com Role
    @JoinTable(name = "tb_user_profissionals_role", // Tabela de junção
            joinColumns = @JoinColumn(name = "profissional_profissionals_id"), // Coluna que referencia User
            inverseJoinColumns = @JoinColumn(name = "role_id") // Coluna que referencia Role
    )
    private Set<RoleProfissional> roleProfissionals = new HashSet<>(); // Papéis/perfil de acesso do usuário

    /**
     * @enum StatusProfissional
     * @brief Enumeração para representar o status específico de um Profissional.
     */
    public enum StatusProfissional {
        ATIVO, // Profissional ativo e em dia
        LICENCIADO, // Profissional com licença temporariamente suspensa
        SUSPENSO, // Profissional suspenso (ex: por infração)
        EM_ANALISE // Profissional aguardando aprovação/verificação
    }
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Role
 * @brief Entidade para definir os papéis de acesso do usuário no sistema.
 *
 *        Esta tabela de roles agora reside nos schemas de tenant, o que
 *        significa
 *        que cada tenant pode ter seus próprios conjuntos de roles ou roles com
 *        IDs diferentes.
 */
@Entity
@Table(name = "tb_role") // A tabela tb_role agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class RoleProfissional extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome; // Nome descritivo e único do papel (ex: CLIENTE, ADVOGADO)

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao; // Uma descrição detalhada do papel
}
```
```java
package br.com.legalconnect.entity;

import br.com.legalconnect.common.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface AdministradorMapper
 * @brief Mapper MapStruct para conversão entre Administrador e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface AdministradorMapper extends PessoaMapper {

    AdministradorMapper INSTANCE = Mappers.getMapper(AdministradorMapper.class);

    /**
     * @brief Mapeia um AdministradorRequestDTO para uma entidade Administrador.
     * @param dto O DTO de requisição do administrador.
     * @return A entidade Administrador.
     */
    Administrador toEntity(AdministradorRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Administrador para um AdministradorResponseDTO.
     * @param entity A entidade Administrador.
     * @return O DTO de resposta do administrador.
     */
    @Mapping(source = "status", target = "status")
    AdministradorResponseDTO toResponseDTO(Administrador entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ClienteMapper
 * @brief Mapper MapStruct para conversão entre Cliente e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class})
public interface ClienteMapper extends PessoaMapper {

    ClienteMapper INSTANCE = Mappers.getMapper(ClienteMapper.class);

    /**
     * @brief Mapeia um ClienteRequestDTO para uma entidade Cliente.
     * @param dto O DTO de requisição do cliente.
     * @return A entidade Cliente.
     */
    Cliente toEntity(ClienteRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Cliente para um ClienteResponseDTO.
     * @param entity A entidade Cliente.
     * @return O DTO de resposta do cliente.
     */
    @Mapping(source = "status", target = "status")
    @Mapping(target = "tipo", ignore = true) // O campo 'tipo' não existe na entidade Cliente, apenas no DTO de resposta
    ClienteResponseDTO toResponseDTO(Cliente entity);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;

/**
 * @interface EmpresaMapper
 * @brief Mapper MapStruct para conversão entre Empresa e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = { EnderecoMapper.class })
public interface EmpresaMapper {

    EmpresaMapper INSTANCE = Mappers.getMapper(EmpresaMapper.class);

    /**
     * @brief Converte um EmpresaRequestDTO para uma entidade Empresa.
     * @param dto O DTO de requisição da empresa.
     * @return A entidade Empresa.
     */
    @Mapping(target = "id", ignore = true) // ID é gerado, não vem do DTO de requisição
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    Empresa toEntity(EmpresaRequestDTO dto);

    /**
     * @brief Converte uma entidade Empresa para um EmpresaResponseDTO.
     * @param entity A entidade Empresa.
     * @return O DTO de resposta da empresa.
     */
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    EmpresaResponseDTO toResponseDTO(Empresa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.Endereco.TipoEndereco; // Importa o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import java.util.List;
import java.util.Set;

/**
 * @interface EnderecoMapper
 * @brief Mapper MapStruct para conversão entre Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {

    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * @brief Converte um EnderecoRequestDTO para uma entidade Endereco.
     * @param dto O DTO de requisição do endereço.
     * @return A entidade Endereco.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "pessoa", ignore = true) // Será setado no serviço
    @Mapping(target = "empresa", ignore = true) // Será setado no serviço
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * @brief Converte uma entidade Endereco para um EnderecoResponseDTO.
     * @param entity A entidade Endereco.
     * @return O DTO de resposta do endereço.
     */
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * @brief Converte uma lista de EnderecoRequestDTOs para um Set de entidades Endereco.
     * @param dtoList A lista de DTOs de requisição de endereços.
     * @return Um Set de entidades Endereco.
     */
    Set<Endereco> toEntitySet(List<EnderecoRequestDTO> dtoList);

    /**
     * @brief Converte um Set de entidades Endereco para uma lista de EnderecoResponseDTOs.
     * @param entitySet Um Set de entidades Endereco.
     * @return Uma lista de DTOs de resposta de endereços.
     */
    List<EnderecoResponseDTO> toResponseDTOList(Set<Endereco> entitySet);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.InheritInverseConfiguration; // Importar se for usar @InheritInverseConfiguration
import org.mapstruct.factory.Mappers;

/**
 * @interface PessoaMapper
 * @brief Mapper MapStruct para conversão entre Pessoa e seus DTOs.
 * Esta é uma interface base para ser estendida por mappers de subclasses de Pessoa.
 */
@Mapper(componentModel = "spring", uses = {UserMapper.class, EnderecoMapper.class})
public interface PessoaMapper {

    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * @brief Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta da pessoa.
     */
    @Mapping(source = "usuario", target = "usuario")
    @Mapping(source = "enderecos", target = "enderecos")
    @Mapping(source = "telefones", target = "telefones")
    PessoaResponseDTO toResponseDTO(Pessoa entity);
}
```
```java
package br.com.legalconnect.mapper;

import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano; // Importar Plano da entidade
import br.com.legalconnect.dto.EmpresaResponseDTO; // Importar EmpresaResponseDTO
import br.com.legalconnect.dto.ProfissionalRequestDTO;
import br.com.legalconnect.dto.ProfissionalResponseDTO;
import br.com.legalconnect.entity.Empresa; // Importar Empresa da entidade
import br.com.legalconnect.entity.Profissional;
import br.com.legalconnect.entity.Profissional.StatusProfissional; // Importar o enum correto
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * @interface ProfissionalMapper
 * @brief Mapper MapStruct para conversão entre Profissional e seus DTOs.
 */
@Mapper(componentModel = "spring", uses = {PessoaMapper.class, EnderecoMapper.class, UserMapper.class, EmpresaMapper.class})
public interface ProfissionalMapper extends PessoaMapper {

    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * @brief Mapeia um ProfissionalRequestDTO para uma entidade Profissional.
     * @param dto O DTO de requisição do profissional.
     * @return A entidade Profissional.
     */
    @Mapping(target = "empresa", ignore = true) // Empresa será setada no serviço
    @Mapping(target = "plano", ignore = true)   // Plano será setado no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Não presente no DTO
    Profissional toEntity(ProfissionalRequestDTO dto);

    /**
     * @brief Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * @param entity A entidade Profissional.
     * @return O DTO de resposta do profissional.
     */
    @Mapping(source = "empresa", target = "empresa")
    @Mapping(source = "plano", target = "plano")
    ProfissionalResponseDTO toResponseDTO(Profissional entity);

    /**
     * @brief Mapeia uma entidade Plano para um PlanoResponseDTO.
     * @param plano A entidade Plano.
     * @return O DTO de resposta do Plano.
     */
    PlanoResponseDTO toPlanoResponseDTO(Plano plano);
}
```
```java
package br.com.legalconnect.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.dto.UserRequestDTO;
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;

/**
 * @interface UserMapper
 * @brief Mapper MapStruct para conversão entre User e seus DTOs.
 */
@Mapper(componentModel = "spring") // Integração com Spring para injeção de dependência
public interface UserMapper {

    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * @brief Converte um UserRequestDTO para uma entidade User.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserRequestDTO.
     * @param dto O DTO de requisição do usuário.
     * @return A entidade User.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "updatedAt", ignore = true)
    @Mapping(target = "nomeCompleto", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "cpf", ignore = true) // Não presente no DTO de requisição
    @Mapping(target = "telefone", ignore = true) // Não presente no DTO de requisição
    // @Mapping(target = "senhaHash", source = "password") // Mapeia password do DTO
    // para senhaHash da entidade
    @Mapping(target = "fotoUrl", ignore = true) // Não presente no DTO de requisição
    User toEntity(UserRequestDTO dto);

    /**
     * @brief Converte uma entidade User para um UserResponseDTO.
     *        Ignora campos da entidade User que não estão presentes no
     *        UserResponseDTO.
     * @param entity A entidade User.
     * @return O DTO de resposta do usuário.
     */
    @Mapping(target = "email", source = "email")
    UserResponseDTO toResponseDTO(User entity);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Administrador;

/**
 * @interface RepositorioAdministrador
 * @brief Repositório Spring Data JPA para a entidade Administrador.
 *        Fornece métodos CRUD e de busca personalizados para Administrador.
 */
@Repository
public interface RepositorioAdministrador extends JpaRepository<Administrador, UUID> {

    /**
     * @brief Busca um Administrador pelo CPF.
     * @param cpf O CPF do administrador.
     * @return Um Optional contendo o Administrador, se encontrado.
     */
    Optional<Administrador> findByCpf(String cpf);

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Administradores.
     */
    Page<Administrador> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Cliente;

/**
 * @interface RepositorioCliente
 * @brief Repositório Spring Data JPA para a entidade Cliente.
 *        Fornece métodos CRUD e de busca personalizados para Cliente.
 */
@Repository
public interface RepositorioCliente extends JpaRepository<Cliente, UUID> {

    /**
     * @brief Busca um Cliente pelo CPF.
     * @param cpf O CPF do cliente.
     * @return Um Optional contendo o Cliente, se encontrado.
     */
    Optional<Cliente> findByCpf(String cpf);

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Clientes.
     */
    Page<Cliente> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Empresa;

/**
 * @interface RepositorioEmpresa
 * @brief Repositório Spring Data JPA para a entidade Empresa.
 *        Fornece métodos CRUD e de busca personalizados para Empresa.
 */
@Repository
public interface RepositorioEmpresa extends JpaRepository<Empresa, UUID> {

    /**
     * @brief Busca uma Empresa pelo CNPJ.
     * @param cnpj O CNPJ da empresa.
     * @return Um Optional contendo a Empresa, se encontrada.
     */
    Optional<Empresa> findByCnpj(String cnpj);

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração de paginação.
     * @return Uma página de Empresas.
     */
    Page<Empresa> findAll(Pageable pageable);
}
```
```java
package br.com.legalconnect.repository;

import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Endereco;

/**
 * @interface RepositorioEndereco
 * @brief Repositório Spring Data JPA para a entidade Endereco.
 *        Fornece métodos CRUD básicos para Endereco.
 */
@Repository
public interface RepositorioEndereco extends JpaRepository<Endereco, UUID> {
    // Métodos de busca adicionais podem ser definidos aqui se necessário,
    // como findByPessoaId(UUID pessoaId) ou findByEmpresaId(UUID empresaId)
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Pessoa;

/**
 * @interface RepositorioPessoa
 * @brief Repositório Spring Data JPA para a entidade Pessoa (base).
 * Fornece métodos CRUD básicos para Pessoa e busca por CPF.
 * Como Pessoa é uma entidade base abstrata com estratégia JOINED, este
 * repositório
 * pode ser usado para operações polimórficas se necessário, mas
 * geralmente
 * repositórios específicos para subclasses (Profissional, Cliente,
 * Administrador)
 * são mais comuns para operações de negócio.
 */
@Repository
public interface RepositorioPessoa extends JpaRepository<Pessoa, UUID> {

    /**
     * @brief Busca uma Pessoa pelo CPF.
     * @param cpf O CPF da pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.Plano;

/**
 * @interface RepositorioPlano
 * @brief Repositório Spring Data JPA para a entidade Plano.
 *        Fornece métodos CRUD e de busca personalizados para Plano.
 *        **Nota:** Em uma arquitetura de microsserviços ideal, esta entidade e
 *        seu
 *        repositório poderiam residir em um serviço de 'marketplace' ou
 *        'assinatura'.
 *        Aqui, é mantido para fins de completude do modelo de dados do
 *        user-service,
 *        mas a gestão real dos planos pode ser externa.
 */
@Repository
public interface RepositorioPlano extends JpaRepository<Plano, UUID> {

    /**
     * @brief Busca um Plano pelo nome.
     * @param nome O nome do plano.
     * @return Um Optional contendo o Plano, se encontrado.
     */
    Optional<Plano> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.RoleProfissional;

/**
 * @interface RepositorioRoleProfissional
 * @brief Repositório Spring Data JPA para a entidade RoleProfissional.
 *        Fornece métodos CRUD e de busca personalizados para RoleProfissional.
 *        **Nota:** Em um ambiente multi-tenant, os papéis podem ser globais ou
 *        por tenant.
 *        Este repositório assume que a entidade RoleProfissional está no schema
 *        do tenant.
 */
@Repository
public interface RepositorioRoleProfissional extends JpaRepository<RoleProfissional, UUID> {

    /**
     * @brief Busca um RoleProfissional pelo nome.
     * @param nome O nome do papel.
     * @return Um Optional contendo o RoleProfissional, se encontrado.
     */
    Optional<RoleProfissional> findByNome(String nome);
}
```
```java
package br.com.legalconnect.repository;

import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.entity.User;

/**
 * @interface RepositorioUser
 * @brief Repositório Spring Data JPA para a entidade User.
 *        Fornece métodos CRUD e de busca personalizados para User.
 *        **Nota:** Este repositório é crucial para o pré-requisito de
 *        associação de Pessoa a um User existente.
 *        As operações de criação/atualização de User em si são de
 *        responsabilidade de outro microsserviço (ex: auth-service).
 */
@Repository
public interface RepositorioUser extends JpaRepository<User, UUID> {

    /**
     * @brief Busca um User pelo email.
     * @param email O email do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.AdministradorRequestDTO;
import br.com.legalconnect.dto.AdministradorResponseDTO;
import br.com.legalconnect.entity.Administrador;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.AdministradorMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioAdministrador;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoAdministrador
 * @brief Serviço de domínio para gerenciar operações relacionadas a
 *        Administradores.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Administradores.
 */
@Service
@RequiredArgsConstructor
public class ServicoAdministrador {

    private final RepositorioAdministrador repositorioAdministrador;
    private final RepositorioUser repositorioUser;
    private final AdministradorMapper administradorMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Administrador no sistema.
     * @param requestDTO DTO com os dados do Administrador a ser cadastrado.
     * @return DTO com os dados do Administrador cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public AdministradorResponseDTO cadastrarAdministrador(AdministradorRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF
        if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro administrador.");
        }

        // 3. Mapear DTO para entidade
        Administrador administrador = administradorMapper.toEntity(requestDTO);
        administrador.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Administrador)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(administrador); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        administrador.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Administrador savedAdministrador = repositorioAdministrador.save(administrador);

        // 6. Mapear entidade salva para DTO de resposta
        return administradorMapper.toResponseDTO(savedAdministrador);
    }

    /**
     * @brief Busca um Administrador pelo ID.
     * @param id ID do Administrador a ser buscado.
     * @return DTO com os dados do Administrador encontrado.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional(readOnly = true)
    public AdministradorResponseDTO buscarAdministradorPorId(UUID id) {
        Administrador administrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado."));
        return administradorMapper.toResponseDTO(administrador);
    }

    /**
     * @brief Lista todos os Administradores com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Administradores.
     */
    @Transactional(readOnly = true)
    public Page<AdministradorResponseDTO> listarAdministradores(Pageable pageable) {
        return repositorioAdministrador.findAll(pageable)
                .map(administradorMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Administrador existente.
     * @param id         ID do Administrador a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Administrador.
     * @return DTO com os dados do Administrador atualizado.
     * @throws BusinessException Se o Administrador não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public AdministradorResponseDTO atualizarAdministrador(UUID id, AdministradorRequestDTO requestDTO) {
        Administrador existingAdministrador = repositorioAdministrador.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Administrador com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingAdministrador.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioAdministrador.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro administrador.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Administrador
        // O mapper precisa de um método de atualização, ou fazer manualmente
        existingAdministrador.setNomeCompleto(requestDTO.getNomeCompleto());
        existingAdministrador.setCpf(requestDTO.getCpf());
        existingAdministrador.setDataNascimento(requestDTO.getDataNascimento());
        existingAdministrador.setStatus(requestDTO.getStatus()); // Campo específico de Administrador

        // 3. Atualizar endereços (lógica de sincronização)
        existingAdministrador.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            // Reutiliza o mapper para converter DTO para Endereco
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingAdministrador); // Garante a associação bidirecional
            existingAdministrador.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingAdministrador.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingAdministrador.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Administrador updatedAdministrador = repositorioAdministrador.save(existingAdministrador);

        return administradorMapper.toResponseDTO(updatedAdministrador);
    }

    /**
     * @brief Exclui um Administrador pelo ID.
     * @param id ID do Administrador a ser excluído.
     * @throws BusinessException Se o Administrador não for encontrado.
     */
    @Transactional
    public void excluirAdministrador(UUID id) {
        if (!repositorioAdministrador.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Administrador com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioAdministrador.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.ClienteRequestDTO;
import br.com.legalconnect.dto.ClienteResponseDTO;
import br.com.legalconnect.entity.Cliente;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.ClienteMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioCliente;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoCliente
 * @brief Serviço de domínio para gerenciar operações relacionadas a Clientes.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Clientes.
 */
@Service
@RequiredArgsConstructor
public class ServicoCliente {

    private final RepositorioCliente repositorioCliente;
    private final RepositorioUser repositorioUser;
    private final ClienteMapper clienteMapper;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Cliente no sistema.
     * @param requestDTO DTO com os dados do Cliente a ser cadastrado.
     * @return DTO com os dados do Cliente cadastrado.
     * @throws BusinessException Se o CPF já estiver cadastrado ou o User associado
     *                           não for encontrado.
     */
    @Transactional
    public ClienteResponseDTO cadastrarCliente(ClienteRequestDTO requestDTO) {
        // 1. Verificar pré-requisito: User associado deve existir
        UUID userId = requestDTO.getUsuario().getId(); // Presume que o ID do User vem no DTO
        User user = repositorioUser.findById(userId)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário associado com ID " + userId + " não encontrado."));

        // 2. Validação de duplicidade de CPF

        if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CPF, "CPF já cadastrado para outro cliente.");
        }

        // 3. Mapear DTO para entidade
        Cliente cliente = clienteMapper.toEntity(requestDTO);
        cliente.setUsuario(user); // Associar o User encontrado

        // 4. Associar endereços à pessoa (Cliente)
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setPessoa(cliente); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        cliente.setEnderecos(enderecos);

        // 5. Salvar a entidade
        Cliente savedCliente = repositorioCliente.save(cliente);

        // 6. Mapear entidade salva para DTO de resposta
        return clienteMapper.toResponseDTO(savedCliente);
    }

    /**
     * @brief Busca um Cliente pelo ID.
     * @param id ID do Cliente a ser buscado.
     * @return DTO com os dados do Cliente encontrado.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional(readOnly = true)
    public ClienteResponseDTO buscarClientePorId(UUID id) {
        Cliente cliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado."));
        return clienteMapper.toResponseDTO(cliente);
    }

    /**
     * @brief Lista todos os Clientes com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Clientes.
     */
    @Transactional(readOnly = true)
    public Page<ClienteResponseDTO> listarClientes(Pageable pageable) {
        return repositorioCliente.findAll(pageable)
                .map(clienteMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de um Cliente existente.
     * @param id         ID do Cliente a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Cliente.
     * @return DTO com os dados do Cliente atualizado.
     * @throws BusinessException Se o Cliente não for encontrado ou se houver
     *                           duplicidade de CPF.
     */
    @Transactional
    public ClienteResponseDTO atualizarCliente(UUID id, ClienteRequestDTO requestDTO) {
        Cliente existingCliente = repositorioCliente.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Cliente com ID " + id + " não encontrado para atualização."));

        // 1. Validação de duplicidade de CPF (se o CPF foi alterado)
        if (!existingCliente.getCpf().equals(requestDTO.getCpf())) {
            if (repositorioCliente.findByCpf(requestDTO.getCpf()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CPF, "Novo CPF já cadastrado para outro cliente.");
            }
        }

        // 2. Atualizar campos básicos da Pessoa e Cliente
        existingCliente.setNomeCompleto(requestDTO.getNomeCompleto());
        existingCliente.setCpf(requestDTO.getCpf());
        existingCliente.setDataNascimento(requestDTO.getDataNascimento());
        existingCliente.setStatus(requestDTO.getStatus()); // Campo específico de Cliente
        // existingCliente.setTipo(requestDTO.getTipo()); // Campo específico de Cliente

        // 3. Atualizar endereços (lógica de sincronização)
        existingCliente.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setPessoa(existingCliente);
            existingCliente.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingCliente.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingCliente.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Cliente updatedCliente = repositorioCliente.save(existingCliente);

        return clienteMapper.toResponseDTO(updatedCliente);
    }

    /**
     * @brief Exclui um Cliente pelo ID.
     * @param id ID do Cliente a ser excluído.
     * @throws BusinessException Se o Cliente não for encontrado.
     */
    @Transactional
    public void excluirCliente(UUID id) {
        if (!repositorioCliente.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Cliente com ID " + id + " não encontrado para exclusão.");
        }
        // A exclusão em cascata do Endereco e User (se configurado no mapeamento) será
        // tratada pelo JPA
        repositorioCliente.deleteById(id);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EmpresaRequestDTO;
import br.com.legalconnect.dto.EmpresaResponseDTO;
import br.com.legalconnect.entity.Empresa;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EmpresaMapper;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEmpresa;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEmpresa
 * @brief Serviço de domínio para gerenciar operações relacionadas a Empresas.
 *        Contém a lógica de negócio para criação, busca, atualização e exclusão
 *        de Empresas.
 */
@Service
@RequiredArgsConstructor
public class ServicoEmpresa {

    private final RepositorioEmpresa repositorioEmpresa;
    private final EmpresaMapper empresaMapper;

    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra uma nova Empresa no sistema.
     * @param requestDTO DTO com os dados da Empresa a ser cadastrada.
     * @return DTO com os dados da Empresa cadastrada.
     * @throws BusinessException Se o CNPJ já estiver cadastrado.
     */
    @Transactional
    public EmpresaResponseDTO cadastrarEmpresa(EmpresaRequestDTO requestDTO) {
        // 1. Validação de duplicidade de CNPJ
        if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
            throw new BusinessException(ErrorCode.INVALID_CNPJ, "CNPJ já cadastrado para outra empresa.");
        }

        // 2. Mapear DTO para entidade
        Empresa empresa = empresaMapper.toEntity(requestDTO);

        // 3. Associar endereços à empresa
        Set<Endereco> enderecos = requestDTO.getEnderecos().stream()
                .map(enderecoDTO -> {
                    // Reutiliza o mapper para converter DTO para Endereco
                    Endereco endereco = enderecoMapper.toEntity(enderecoDTO);
                    endereco.setEmpresa(empresa); // Garante a associação bidirecional
                    return endereco;
                })
                .collect(Collectors.toSet());
        empresa.setEnderecos(enderecos);

        // 4. Salvar a entidade
        Empresa savedEmpresa = repositorioEmpresa.save(empresa);

        // 5. Mapear entidade salva para DTO de resposta
        return empresaMapper.toResponseDTO(savedEmpresa);
    }

    /**
     * @brief Busca uma Empresa pelo ID.
     * @param id ID da Empresa a ser buscada.
     * @return DTO com os dados da Empresa encontrada.
     * @throws BusinessException Se a Empresa não for encontrada.
     */
    @Transactional(readOnly = true)
    public EmpresaResponseDTO buscarEmpresaPorId(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada."));
        return empresaMapper.toResponseDTO(empresa);
    }

    /**
     * @brief Lista todas as Empresas com paginação.
     * @param pageable Objeto Pageable para configuração da paginação.
     * @return Página de DTOs de Empresas.
     */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDTO> listarEmpresas(Pageable pageable) {
        return repositorioEmpresa.findAll(pageable)
                .map(empresaMapper::toResponseDTO);
    }

    /**
     * @brief Atualiza os dados de uma Empresa existente.
     * @param id         ID da Empresa a ser atualizada.
     * @param requestDTO DTO com os dados atualizados da Empresa.
     * @return DTO com os dados da Empresa atualizada.
     * @throws BusinessException Se a Empresa não for encontrada ou se houver
     *                           duplicidade de CNPJ.
     */
    @Transactional
    public EmpresaResponseDTO atualizarEmpresa(UUID id, EmpresaRequestDTO requestDTO) {
        Empresa existingEmpresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para atualização."));

        // 1. Validação de duplicidade de CNPJ (se o CNPJ foi alterado)
        if (!existingEmpresa.getCnpj().equals(requestDTO.getCnpj())) {
            if (repositorioEmpresa.findByCnpj(requestDTO.getCnpj()).isPresent()) {
                throw new BusinessException(ErrorCode.INVALID_CNPJ, "Novo CNPJ já cadastrado para outra empresa.");
            }
        }

        // 2. Atualizar campos básicos da Empresa
        existingEmpresa.setNomeFantasia(requestDTO.getNomeFantasia());
        existingEmpresa.setRazaoSocial(requestDTO.getRazaoSocial());
        existingEmpresa.setCnpj(requestDTO.getCnpj());
        existingEmpresa.setEmailContato(requestDTO.getEmailContato());

        // 3. Atualizar endereços (lógica de sincronização)
        existingEmpresa.getEnderecos().clear(); // Limpa os endereços existentes
        requestDTO.getEnderecos().forEach(enderecoDTO -> {
            Endereco newEndereco = enderecoMapper.toEntity(enderecoDTO);
            newEndereco.setEmpresa(existingEmpresa);
            existingEmpresa.getEnderecos().add(newEndereco);
        });

        // 4. Atualizar telefones
        existingEmpresa.getTelefones().clear();
        if (requestDTO.getTelefones() != null) {
            existingEmpresa.getTelefones().addAll(requestDTO.getTelefones());
        }

        // 5. Salvar a entidade atualizada
        Empresa updatedEmpresa = repositorioEmpresa.save(existingEmpresa);

        return empresaMapper.toResponseDTO(updatedEmpresa);
    }

    /**
     * @brief Exclui uma Empresa pelo ID.
     * @param id ID da Empresa a ser excluída.
     * @throws BusinessException Se a Empresa não for encontrada ou se possuir
     *                           profissionais associados.
     */
    @Transactional
    public void excluirEmpresa(UUID id) {
        Empresa empresa = repositorioEmpresa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Empresa com ID " + id + " não encontrada para exclusão."));

        // Verificar se existem profissionais associados antes de excluir
        if (!empresa.getProfissionais().isEmpty()) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Empresa não pode ser excluída pois possui profissionais associados.");
        }

        // A exclusão em cascata do Endereco será tratada pelo JPA
        repositorioEmpresa.delete(empresa);
    }
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.EnderecoRequestDTO;
import br.com.legalconnect.dto.EnderecoResponseDTO;
import br.com.legalconnect.entity.Endereco;
import br.com.legalconnect.mapper.EnderecoMapper;
import br.com.legalconnect.repository.RepositorioEndereco;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoEndereco
 * @brief Serviço de domínio para gerenciar operações relacionadas a Endereços.
 *        Este serviço pode ser usado para operações diretas em Endereços,
 *        embora na maioria dos casos eles sejam gerenciados em cascata por
 *        Pessoa ou Empresa.
 */
@Service
@RequiredArgsConstructor
public class ServicoEndereco {

    private final RepositorioEndereco repositorioEndereco;
    private final EnderecoMapper enderecoMapper;

    /**
     * @brief Cadastra um novo Endereco.
     * @param requestDTO DTO com os dados do Endereco a ser cadastrado.
     * @return DTO com os dados do Endereco cadastrado.
     */
    @Transactional
    public EnderecoResponseDTO cadastrarEndereco(EnderecoRequestDTO requestDTO) {
        Endereco endereco = enderecoMapper.toEntity(requestDTO);
        Endereco savedEndereco = repositorioEndereco.save(endereco);
        return enderecoMapper.toResponseDTO(savedEndereco);
    }

    /**
     * @brief Busca um Endereco pelo ID.
     * @param id ID do Endereco a ser buscado.
     * @return DTO com os dados do Endereco encontrado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional(readOnly = true)
    public EnderecoResponseDTO buscarEnderecoPorId(UUID id) {
        Endereco endereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado."));
        return enderecoMapper.toResponseDTO(endereco);
    }

    /**
     * @brief Lista todos os Enderecos.
     * @return Lista de DTOs de Enderecos.
     */
    @Transactional(readOnly = true)
    public List<EnderecoResponseDTO> listarEnderecos() {
        return repositorioEndereco.findAll().stream()
                .map(enderecoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Atualiza os dados de um Endereco existente.
     * @param id         ID do Endereco a ser atualizado.
     * @param requestDTO DTO com os dados atualizados do Endereco.
     * @return DTO com os dados do Endereco atualizado.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public EnderecoResponseDTO atualizarEndereco(UUID id, EnderecoRequestDTO requestDTO) {
        Endereco existingEndereco = repositorioEndereco.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Endereço com ID " + id + " não encontrado para atualização."));

        // Atualizar campos básicos do Endereco
        existingEndereco.setLogradouro(requestDTO.getLogradouro());
        existingEndereco.setNumero(requestDTO.getNumero());
        existingEndereco.setComplemento(requestDTO.getComplemento());
        existingEndereco.setBairro(requestDTO.getBairro());
        existingEndereco.setCidade(requestDTO.getCidade());
        existingEndereco.setEstado(requestDTO.getEstado());
        existingEndereco.setCep(requestDTO.getCep());
        existingEndereco.setPais(requestDTO.getPais());
        existingEndereco.setTipoEndereco(requestDTO.getTipoEndereco());

        Endereco updatedEndereco = repositorioEndereco.save(existingEndereco);
        return enderecoMapper.toResponseDTO(updatedEndereco);
    }

    /**
     * @brief Exclui um Endereco pelo ID.
     * @param id ID do Endereco a ser excluído.
     * @throws BusinessException Se o Endereco não for encontrado.
     */
    @Transactional
    public void excluirEndereco(UUID id) {
        if (!repositorioEndereco.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Endereço com ID " + id + " não encontrado para exclusão.");
        }
        repositorioEndereco.deleteById(id);
    }
}
```
```java
// br/com/legalconnect/service/ServicoPessoa.java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier; // Importar Qualifier
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException;
import br.com.legalconnect.common.exception.ErrorCode;
import br.com.legalconnect.dto.PessoaResponseDTO;
import br.com.legalconnect.entity.Pessoa;
import br.com.legalconnect.mapper.PessoaMapper;
import br.com.legalconnect.repository.RepositorioPessoa;

/**
 * @class ServicoPessoa
 * @brief Serviço de domínio para operações genéricas relacionadas a Pessoas.
 *        Como Pessoa é uma entidade base abstrata, este serviço lida com
 *        operações
 *        que podem ser comuns a todas as subclasses (Profissional, Cliente,
 *        Administrador).
 *        Operações de criação/atualização específicas devem ser tratadas nos
 *        serviços das subclasses.
 */
@Service
public class ServicoPessoa {

    private final RepositorioPessoa repositorioPessoa;
    private final PessoaMapper pessoaMapper;

    @Autowired
    public ServicoPessoa(RepositorioPessoa repositorioPessoa,
            @Qualifier("pessoaMapperImpl") PessoaMapper pessoaMapper) {
        this.repositorioPessoa = repositorioPessoa;
        this.pessoaMapper = pessoaMapper;
    }

    /**
     * @brief Busca uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser buscada.
     * @return DTO com os dados da Pessoa encontrada.
     * @throws BusinessException Se a Pessoa não for encontrada.
     */
    @Transactional(readOnly = true)
    public PessoaResponseDTO buscarPessoaPorId(UUID id) {
        Pessoa pessoa = repositorioPessoa.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Pessoa com ID " + id + " não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * @brief Lista todas as Pessoas.
     * @return Lista de DTOs de Pessoas.
     */
    @Transactional(readOnly = true)
    public List<PessoaResponseDTO> listarTodasPessoas() {
        return repositorioPessoa.findAll().stream()
                .map(pessoaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Exclui uma Pessoa pelo ID.
     * @param id ID da Pessoa a ser excluída.
     * @throws BusinessException Se a Pessoa não for encontrada.
     *                           **Nota:** A exclusão de Pessoa deve ser feita com
     *                           cautela, pois pode
     *                           impactar subclasses (Profissional, Cliente,
     *                           Administrador) e o User associado.
     *                           Idealmente, a exclusão de subclasses deveria ser o
     *                           ponto de entrada.
     */
    @Transactional
    public void excluirPessoa(UUID id) {
        if (!repositorioPessoa.existsById(id)) {
            throw new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                    "Pessoa com ID " + id + " não encontrada para exclusão.");
        }
        repositorioPessoa.deleteById(id);
    }
}

```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.PlanoResponseDTO;
import br.com.legalconnect.entity.Plano;
import br.com.legalconnect.mapper.ProfissionalMapper; // Reutilizando mapper de profissional para plano
import br.com.legalconnect.repository.RepositorioPlano;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoPlano
 * @brief Serviço de domínio para gerenciar operações relacionadas a Planos.
 *        **Nota:** Este serviço é um placeholder. Em uma arquitetura de
 *        microsserviços real,
 *        a gestão de planos seria feita em um microsserviço dedicado (ex:
 *        marketplace ou assinatura).
 *        Aqui, ele apenas fornece métodos de busca para que outros serviços
 *        possam referenciar planos.
 */
@Service
@RequiredArgsConstructor
public class ServicoPlano {

    private final RepositorioPlano repositorioPlano;
    private final ProfissionalMapper profissionalMapper;

    /**
     * @brief Busca um Plano pelo ID.
     * @param id ID do Plano a ser buscado.
     * @return DTO com os dados do Plano encontrado.
     * @throws BusinessException Se o Plano não for encontrado.
     */
    @Transactional(readOnly = true)
    public PlanoResponseDTO buscarPlanoPorId(UUID id) {
        Plano plano = repositorioPlano.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.RESOURCE_NOT_FOUND,
                        "Plano com ID " + id + " não encontrado."));
        return profissionalMapper.toPlanoResponseDTO(plano);
    }

    /**
     * @brief Lista todos os Planos disponíveis.
     * @return Lista de DTOs de Planos.
     */
    @Transactional(readOnly = true)
    public List<PlanoResponseDTO> listarTodosPlanos() {
        return repositorioPlano.findAll().stream()
                .map(profissionalMapper::toPlanoResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para cadastrar, atualizar e excluir planos não são implementados
    // aqui,
    // pois seriam responsabilidade do microsserviço de marketplace/assinatura.
}
```
```java
package br.com.legalconnect.service;

import java.util.List;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import br.com.legalconnect.common.exception.BusinessException; // Importa da common-lib
import br.com.legalconnect.common.exception.ErrorCode; // Importa da common-lib
import br.com.legalconnect.dto.UserResponseDTO;
import br.com.legalconnect.entity.User;
import br.com.legalconnect.mapper.UserMapper;
import br.com.legalconnect.repository.RepositorioUser;
import lombok.RequiredArgsConstructor;

/**
 * @class ServicoUser
 * @brief Serviço de domínio para gerenciar operações relacionadas a Users.
 *        **Nota:** Este serviço é primariamente para busca e validação de Users
 *        existentes
 *        para associação com entidades Pessoa (Profissional, Cliente,
 *        Administrador).
 *        A criação e gestão principal de Users é responsabilidade de outro
 *        microsserviço (ex: auth-service).
 */
@Service
@RequiredArgsConstructor
public class ServicoUser {

    private final RepositorioUser repositorioUser;
    private final UserMapper userMapper;

    /**
     * @brief Busca um User pelo ID.
     * @param id ID do User a ser buscado.
     * @return DTO com os dados do User encontrado.
     * @throws BusinessException Se o User não for encontrado.
     */
    @Transactional(readOnly = true)
    public UserResponseDTO buscarUserPorId(UUID id) {
        User user = repositorioUser.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND,
                        "Usuário com ID " + id + " não encontrado."));
        return userMapper.toResponseDTO(user);
    }

    /**
     * @brief Lista todos os Users.
     * @return Lista de DTOs de Users.
     */
    @Transactional(readOnly = true)
    public List<UserResponseDTO> listarTodosUsers() {
        return repositorioUser.findAll().stream()
                .map(userMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * @brief Verifica se um User existe pelo ID.
     * @param id ID do User a ser verificado.
     * @return true se o User existe, false caso contrário.
     */
    @Transactional(readOnly = true)
    public boolean userExiste(UUID id) {
        return repositorioUser.existsById(id);
    }

    /**
     * @brief Busca um User pelo CPF.
     * @param cpf O CPF do usuário.
     * @return Um Optional contendo o DTO do User, se encontrado.
     */
    @Transactional(readOnly = true)
    public Optional<UserResponseDTO> buscarUserPorCpf(String cpf) {
        return repositorioUser.findByCpf(cpf)
                .map(userMapper::toResponseDTO);
    }
}
```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*


server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db

# Nome de usuário do banco de dados
spring.datasource.username=jususer

# Senha do banco de dados
spring.datasource.password=juspassword

# Driver JDBC para PostgreSQL
spring.datasource.driver-class-name=org.postgresql.Driver

# Configurações do pool de conexões (HikariCP é o padrão no Spring Boot)
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

# Dialeto do Hibernate para PostgreSQL
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

# Exibir queries SQL no console (para desenvolvimento)
# Desabilita a geração automática de DDL pelo Hibernate na inicialização principal.
# A criação de DDL para os esquemas de tenant será feita programaticamente pelo TenantSchemaService.
spring.jpa.hibernate.ddl-auto=none
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,put
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
<!DOCTYPE html>
<html lang="pt-BR" xmlns:th="http://www.thymeleaf.org">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title th:text="${subject}">Bem-vindo!</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f4f4f4;
        margin: 0;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: 0 auto;
        background: #fff;
        padding: 30px;
        border-radius: 8px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
      .header {
        text-align: center;
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .header h1 {
        color: #007bff;
      }
      .content {
        padding: 20px 0;
      }
      .footer {
        text-align: center;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 0.9em;
        color: #777;
      }
      .button {
        display: inline-block;
        background-color: #007bff;
        color: #ffffff;
        padding: 10px 20px;
        text-decoration: none;
        border-radius: 5px;
        margin-top: 20px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1 th:text="${title}">Olá!</h1>
      </div>
      <div class="content">
        <p>
          Prezado(a) <strong th:text="${userName}">Nome do Usuário</strong>,
        </p>
        <p>
          É com grande prazer que confirmamos seu cadastro em nossa plataforma.
        </p>
        <p>
          Seu e-mail de acesso é:
          <strong th:text="${userEmail}">email@example.com</strong>
        </p>
        <p th:text="${message}">
          Aproveite todas as funcionalidades que oferecemos!
        </p>

        <p style="text-align: center">
          <a
            th:href="${callToActionLink}"
            class="button"
            th:text="${callToActionText}"
            >Acessar Plataforma</a
          >
        </p>
      </div>
      <div class="footer">
        <p>
          Este é um e-mail de notificação automático. Por favor, não responda.
        </p>
        <p>
          &copy; <span th:text="${currentYear}">2025</span> Sua Empresa. Todos
          os direitos reservados.
        </p>
      </div>
    </div>
  </body>
</html>

```
```java
package br.com.legalconnect.auth.auth_service;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class AuthServiceApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Estágio de Build
# Usamos uma imagem base que já inclui o Maven e o JDK 17.
# maven:3.9.6-eclipse-temurin-17-focal é uma boa escolha.
FROM maven:3.9.6-eclipse-temurin-17-focal AS build

# Define o diretório de trabalho dentro do contêiner.
WORKDIR /app

# Copia o arquivo pom.xml para que as dependências sejam cacheadas.
# Isso evita que o Maven precise baixar todas as dependências novamente
# se apenas o código-fonte for alterado.
COPY pom.xml .

# Copia o código-fonte da aplicação.
COPY src ./src

# Constrói a aplicação usando Maven.
# -Dmaven.test.skip=true pula os testes para um build mais rápido no Docker.
# 'install' é adicionado para garantir que o projeto seja instalado no repositório Maven local do contêiner,
# o que pode ser útil para projetos multi-módulos, embora 'package' seja suficiente para este caso.
RUN mvn clean install package -Dmaven.test.skip=true

# Estágio de Runtime
# Usamos uma imagem base com JRE (Runtime Environment) para rodar a aplicação.
# JRE é menor que JDK, resultando em uma imagem final mais leve.
FROM eclipse-temurin:17-jre-focal

# Define o diretório de trabalho dentro do contêiner.
WORKDIR /app

# Copia o JAR executável gerado no estágio de build para o estágio de runtime.
# O nome do JAR é baseado no artifactId e version do pom.xml.
COPY --from=build /app/target/eureka-server-0.0.1-SNAPSHOT.jar eureka-server.jar

# Expõe a porta em que o Eureka Server será executado.
# Conforme o application.properties, a porta padrão é 8761.
EXPOSE 8761

# Define o comando de entrada que será executado quando o contêiner iniciar.
# Isso executa o JAR do Spring Boot.
ENTRYPOINT ["java", "-jar", "eureka-server.jar"]


```
```java
# Read Me First

The following was discovered as part of building this project:

- The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation

For further reference, please consider the following sections:

- [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
- [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
- [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
- [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
- [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.

If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.

docker build -t legalconnect-eureka-server:latest -f microservices/legal-eureka/Dockerfile .

docker build -t legalconnect-eureka-server:latest .

docker run --name eureka-server -p 8761:8761 -d legalconnect-eureka-server:latest

docker run -d --name eureka-server --network legalconnect-network -p 8761:8761 legalconnect-eureka-server:latest

docker network create legalconnect-app-network

docker run -d --name eureka-server-instance --network legalconnect-app-network -p 8761:8761 -e EUREKA_SERVER_HOSTNAME=eureka-server-instance -e SERVER_PORT=8761 legalconnect-eureka-server:latest
```
```java
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version> <!-- Versão estável do Spring Boot 3 -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>eureka-server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>legalconnect-eureka-server</name>
	<description>Eureka Server for LegalConnect Microservices</description>

	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.1</spring-cloud.version> <!-- Versão compatível com Spring Boot
		3.2.x -->
	</properties>

	<dependencies>
		<!-- Spring Boot Starter para aplicações web (necessário para o Eureka Server) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!-- Spring Cloud Eureka Server para habilitar a funcionalidade de servidor de descoberta -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
		<!-- Lombok para reduzir boilerplate code (getters, setters, construtores, etc.) -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<!-- Spring Boot Starter para testes -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-EurekaServerApplication<eureka-server>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.eurekaserver.EurekaServerApplication",
      "projectName": "eureka-server",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
package br.com.legalconnect.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Classe principal da aplicação Spring Boot para o Eureka Server.
 * <p>
 * Anotada com {@code @SpringBootApplication} para habilitar a configuração
 * automática do Spring Boot,
 * varredura de componentes e configurações de beans.
 * <p>
 * Anotada com {@code @EnableEurekaServer} para habilitar este microsserviço
 * como um servidor de descoberta
 * de serviços Eureka. Ele será responsável por registrar e fornecer informações
 * sobre outros microsserviços
 * que se conectarem a ele.
 */
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

    /**
     * Método principal que inicia a aplicação Spring Boot do Eureka Server.
     *
     * @param args Argumentos de linha de comando passados para a aplicação.
     */
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }

}

```
```java
# Configurações do Servidor
server.port=8761

# Nome da aplicação Spring Boot, usado para registro no Eureka.
spring.application.name=eureka-server

# Configurações do Eureka Server
# Desabilita o registro do próprio Eureka Server como cliente (ele é o servidor).
eureka.client.register-with-eureka=false
# Desabilita a busca de outros serviços pelo próprio Eureka Server (ele não precisa de outros).
eureka.client.fetch-registry=false
# Define a URL do serviço Eureka (aponta para si mesmo).
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância do Eureka Server
# Define o hostname da instância do Eureka Server.
eureka.instance.hostname=localhost
# Desabilita a funcionalidade de renovação de aluguéis para o próprio servidor Eureka.
eureka.server.enable-self-preservation=false
# Define o tempo de expiração do cache de renovação de aluguéis.
eureka.server.eviction-interval-timer-in-ms=10000

eureka.client.registerWithEureka=false
eureka.client.fetchRegistry=false 
```
```java
package br.com.legalconnect.common.common_lib;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CommonLibApplicationTests {

	@Test
	void contextLoads() {
	}

}

```
```java
# Configurações do Servidor
server.port=8761

# Nome da aplicação Spring Boot, usado para registro no Eureka.
spring.application.name=eureka-server

# Configurações do Eureka Server
# Desabilita o registro do próprio Eureka Server como cliente (ele é o servidor).
eureka.client.register-with-eureka=false
# Desabilita a busca de outros serviços pelo próprio Eureka Server (ele não precisa de outros).
eureka.client.fetch-registry=false
# Define a URL do serviço Eureka (aponta para si mesmo).
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/

# Configurações de instância do Eureka Server
# Define o hostname da instância do Eureka Server.
eureka.instance.hostname=localhost
# Desabilita a funcionalidade de renovação de aluguéis para o próprio servidor Eureka.
eureka.server.enable-self-preservation=false
# Define o tempo de expiração do cache de renovação de aluguéis.
eureka.server.eviction-interval-timer-in-ms=10000

eureka.client.registerWithEureka=false
eureka.client.fetchRegistry=false 
```
```java
Êþº¾   =   8br/com/legalconnect/eurekaserver/EurekaServerApplication  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this :Lbr/com/legalconnect/eurekaserver/EurekaServerApplication; main ([Ljava/lang/String;)V
    *org/springframework/boot/SpringApplication   run b(Ljava/lang/Class;[Ljava/lang/String;)Lorg/springframework/context/ConfigurableApplicationContext; args [Ljava/lang/String; MethodParameters 
SourceFile EurekaServerApplication.java RuntimeVisibleAnnotations >Lorg/springframework/boot/autoconfigure/SpringBootApplication; DLorg/springframework/cloud/netflix/eureka/server/EnableEurekaServer; !               /     *· ±    
                 
   	       6     *¸ W±    
   
                                   
       
```
```java
Êþº¾   =   ?br/com/legalconnect/common/common_lib/CommonLibApplicationTests  java/lang/Object <init> ()V Code
  	   LineNumberTable LocalVariableTable this ALbr/com/legalconnect/common/common_lib/CommonLibApplicationTests; contextLoads RuntimeVisibleAnnotations Lorg/junit/jupiter/api/Test; 
SourceFile CommonLibApplicationTests.java 6Lorg/springframework/boot/test/context/SpringBootTest;                  /     *· ±    
                 
                   +      ±    
                 
                
```
```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version> <!-- Versão estável do Spring Boot 3 -->
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>eureka-server</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>legalconnect-eureka-server</name>
	<description>Eureka Server for LegalConnect Microservices</description>

	<properties>
		<java.version>17</java.version>
		<spring-cloud.version>2023.0.1</spring-cloud.version> <!-- Versão compatível com Spring Boot
		3.2.x -->
	</properties>

	<dependencies>
		<!-- Spring Boot Starter para aplicações web (necessário para o Eureka Server) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<!-- Spring Cloud Eureka Server para habilitar a funcionalidade de servidor de descoberta -->
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
		<!-- Lombok para reduzir boilerplate code (getters, setters, construtores, etc.) -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<!-- Spring Boot Starter para testes -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
{
  "configurations": [
    {
      "type": "java",
      "name": "Spring Boot-EurekaServerApplication<eureka-server>",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "mainClass": "br.com.legalconnect.eurekaserver.EurekaServerApplication",
      "projectName": "eureka-server",
      "args": "",
      "envFile": "${workspaceFolder}/.env"
    }
  ]
}

```
```java
package br.com.legalconnect.eurekaserver;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

/**
 * Classe principal da aplicação Spring Boot para o Eureka Server.
 * <p>
 * Anotada com {@code @SpringBootApplication} para habilitar a configuração
 * automática do Spring Boot,
 * varredura de componentes e configurações de beans.
 * <p>
 * Anotada com {@code @EnableEurekaServer} para habilitar este microsserviço
 * como um servidor de descoberta
 * de serviços Eureka. Ele será responsável por registrar e fornecer informações
 * sobre outros microsserviços
 * que se conectarem a ele.
 */
@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication {

    /**
     * Método principal que inicia a aplicação Spring Boot do Eureka Server.
     *
     * @param args Argumentos de linha de comando passados para a aplicação.
     */
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class, args);
    }

}

```
```java
# Configurações do Servidor
server.port=8761

# Nome da aplicação Spring Boot, usado para registro no Eureka.
spring.application.name=eureka-server

# Configurações do Eureka Server
# Desabilita o registro do próprio Eureka Server como cliente (ele é o servidor).
eureka.client.register-with-eureka=false
# Desabilita a busca de outros serviços pelo próprio Eureka Server (ele não precisa de outros).
eureka.client.fetch-registry=false
# Define a URL do serviço Eureka (aponta para si mesmo).
# Usará variável de ambiente para hostname e porta para comunicação interna no Docker.
eureka.client.serviceUrl.defaultZone=http://${EUREKA_SERVER_HOSTNAME}:${SERVER_PORT}/eureka/

# Configurações de instância do Eureka Server
# Define o hostname da instância do Eureka Server. Agora lida por variável de ambiente.
eureka.instance.hostname=${EUREKA_SERVER_HOSTNAME:localhost}
# Desabilita a funcionalidade de renovação de aluguéis para o próprio servidor Eureka.
eureka.server.enable-self-preservation=false
# Define o tempo de expiração do cache de renovação de aluguéis.
eureka.server.eviction-interval-timer-in-ms=10000

# Duplicadas, mas mantidas para consistência com o arquivo original
eureka.client.registerWithEureka=false
eureka.client.fetchRegistry=false

```
```java
package br.com.legalconnect.eurekaserver;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class EurekaServerApplication {

    @Test
    void contextLoads() {
    }

}

```
```java
/mvnw text eol=lf
*.cmd text eol=crlf

```
```java
HELP.md
target/
.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/

```
```java
# Read Me First
The following was discovered as part of building this project:

* The original package name 'br.com.legalconnect.common.common-lib' is invalid and this project uses 'br.com.legalconnect.common.common_lib' instead.

# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.3/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.3/maven-plugin/build-image.html)
* [Flyway Migration](https://docs.spring.io/spring-boot/3.5.3/how-to/data-initialization.html#howto.data-initialization.migration-tool.flyway)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.3/reference/using/devtools.html)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.


```
```java
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.2
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "$1"; }
case "$(uname)" in
CYGWIN* | MINGW*)
  [ -z "${JAVA_HOME-}" ] || JAVA_HOME="$(cygpath --unix "$JAVA_HOME")"
  native_path() { cygpath --path --windows "$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "${JAVA_HOME-}" ]; then
    if [ -x "$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
      JAVACCMD="$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="$JAVA_HOME/bin/java"
      JAVACCMD="$JAVA_HOME/bin/javac"

      if [ ! -x "$JAVACMD" ] || [ ! -x "$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"$JAVA_HOME\", but \"\$JAVA_HOME/bin/java\" or \"\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "${JAVACMD-}" ] || [ ! -x "${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="${1:-}" h=0
  while [ -n "$str" ]; do
    char="${str%"${str#?}"}"
    h=$(((h * 31 + $(LC_CTYPE=C printf %d "'$char")) % 4294967296))
    str="${str#?}"
  done
  printf %x\\n $h
}

verbose() { :; }
[ "${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "${1-}"; }

die() {
  printf %s\\n "$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "${1}" | tr -d '[:space:]'
}

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "${key-}" in
  distributionUrl) distributionUrl=$(trim "${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=$(trim "${value-}") ;;
  esac
done <"${0%/*}/.mvn/wrapper/maven-wrapper.properties"
[ -n "${distributionUrl-}" ] || die "cannot read distributionUrl property in ${0%/*}/.mvn/wrapper/maven-wrapper.properties"

case "${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "${PROCESSOR_ARCHITECTURE-}${PROCESSOR_ARCHITEW6432-}:$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on $(uname)-$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="${distributionUrl%-bin.*}-$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn${0##*/mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "${MVNW_REPOURL-}" ] || distributionUrl="$MVNW_REPOURL$_MVNW_REPO_PATTERN${distributionUrl#*"$_MVNW_REPO_PATTERN"}"
distributionUrlName="${distributionUrl##*/}"
distributionUrlNameMain="${distributionUrlName%.*}"
distributionUrlNameMain="${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="${MAVEN_USER_HOME:-${HOME}/.m2}"
MAVEN_HOME="${MAVEN_USER_HOME}/wrapper/dists/${distributionUrlNameMain-}/$(hash_string "$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "$MAVEN_HOME/bin/$MVN_CMD" "$@" || die "cannot exec $MAVEN_HOME/bin/$MVN_CMD"
}

if [ -d "$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  exec_maven "$@"
fi

case "${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="$(mktemp -d)" && [ -d "$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: $distributionUrl"
verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="${distributionUrl%.zip}.tar.gz"
  distributionUrlName="${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget ${__MVNW_QUIET_WGET:+"$__MVNW_QUIET_WGET"} "$distributionUrl" -O "$TMP_DOWNLOAD_DIR/$distributionUrlName" || die "wget: Failed to fetch $distributionUrl"
elif [ -z "${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl ${__MVNW_QUIET_CURL:+"$__MVNW_QUIET_CURL"} -f -L -o "$TMP_DOWNLOAD_DIR/$distributionUrlName" "$distributionUrl" || die "curl: Failed to fetch $distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="$TMP_DOWNLOAD_DIR/$distributionUrlName"
  cat >"$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "$(native_path "$JAVACCMD")" "$(native_path "$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "$(native_path "$JAVACMD")" -cp "$(native_path "$TMP_DOWNLOAD_DIR")" Downloader "$distributionUrl" "$(native_path "$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | sha256sum -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "$distributionSha256Sum  $TMP_DOWNLOAD_DIR/$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ $distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip ${__MVNW_QUIET_UNZIP:+"$__MVNW_QUIET_UNZIP"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -d "$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf${__MVNW_QUIET_TAR:+"$__MVNW_QUIET_TAR"} "$TMP_DOWNLOAD_DIR/$distributionUrlName" -C "$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi
printf %s\\n "$distributionUrl" >"$TMP_DOWNLOAD_DIR/$distributionUrlNameMain/mvnw.url"
mv -- "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" "$MAVEN_HOME" || [ -d "$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "$@"

```
```java
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {$scriptDir='%~dp0'; $script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

$ErrorActionPreference = "Stop"
if ($env:MVNW_VERBOSE -eq "true") {
  $VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
$distributionUrl = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!$distributionUrl) {
  Write-Error "cannot read distributionUrl property in $scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( $($distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    $USE_MVND = $true
    $distributionUrl = $distributionUrl -replace '-bin\.[^.]*$',"-windows-amd64.zip"
    $MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    $USE_MVND = $false
    $MVN_CMD = $script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if ($env:MVNW_REPOURL) {
  $MVNW_REPO_PATTERN = if ($USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  $distributionUrl = "$env:MVNW_REPOURL$MVNW_REPO_PATTERN$($distributionUrl -replace '^.*'+$MVNW_REPO_PATTERN,'')"
}
$distributionUrlName = $distributionUrl -replace '^.*/',''
$distributionUrlNameMain = $distributionUrlName -replace '\.[^.]*$','' -replace '-bin$',''
$MAVEN_HOME_PARENT = "$HOME/.m2/wrapper/dists/$distributionUrlNameMain"
if ($env:MAVEN_USER_HOME) {
  $MAVEN_HOME_PARENT = "$env:MAVEN_USER_HOME/wrapper/dists/$distributionUrlNameMain"
}
$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]$distributionUrl) | ForEach-Object {$_.ToString("x2")}) -join ''
$MAVEN_HOME = "$MAVEN_HOME_PARENT/$MAVEN_HOME_NAME"

if (Test-Path -Path "$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at $MAVEN_HOME"
  Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"
  exit $?
}

if (! $distributionUrlNameMain -or ($distributionUrlName -eq $distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found $distributionUrl"
}

# prepare tmp dir
$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "$TMP_DOWNLOAD_DIR_HOLDER.dir"
$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if ($TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: $distributionUrl"
Write-Verbose "Downloading to: $TMP_DOWNLOAD_DIR/$distributionUrlName"

$webclient = New-Object System.Net.WebClient
if ($env:MVNW_USERNAME -and $env:MVNW_PASSWORD) {
  $webclient.Credentials = New-Object System.Net.NetworkCredential($env:MVNW_USERNAME, $env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$webclient.DownloadFile($distributionUrl, "$TMP_DOWNLOAD_DIR/$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
$distributionSha256Sum = (Get-Content -Raw "$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if ($distributionSha256Sum) {
  if ($USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module $PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "$TMP_DOWNLOAD_DIR/$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne $distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "$TMP_DOWNLOAD_DIR/$distributionUrlName" -DestinationPath "$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "$TMP_DOWNLOAD_DIR/$distributionUrlNameMain" -NewName $MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "$TMP_DOWNLOAD_DIR/$MAVEN_HOME_NAME" -Destination $MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item $TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove $TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=$MAVEN_HOME/bin/$MVN_CMD"

```
```java
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.1.0</version>
		<relativePath /> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com.legalconnect</groupId>
	<artifactId>shared-configs</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>shared-configs</name>
	<description>Módulo de configurações compartilhadas para microsserviços LegalConnect</description>
	<packaging>jar</packaging> <!-- Define como um módulo JAR, não uma aplicação executável -->

	<properties>
		<java.version>17</java.version>
		<springdoc.version>2.1.0</springdoc.version> <!-- Versão do Springdoc OpenAPI -->
	</properties>

	<dependencies>
		<!-- Spring Boot Starter para funcionalidades básicas do Spring (necessário para
		@Configuration, @Bean) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter</artifactId>
		</dependency>
		<!-- Spring Boot Starter Web para funcionalidades web (necessário para CORS e
		WebMvcConfigurer) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<!-- Springdoc OpenAPI Starter WebMVC UI para documentação Swagger/OpenAPI -->
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>${springdoc.version}</version>
		</dependency>

		<!-- Lombok para reduzir boilerplate code (Getters, Setters, etc.) -->
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>

		<!-- Spring Boot Test para testes (opcional para um módulo de configuração, mas boa prática) -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<!-- Plugin Maven para compilação -->
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<configuration>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>${lombok.version}</version>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>
			<!-- Não incluir spring-boot-maven-plugin aqui, pois não é uma aplicação executável -->
		</plugins>
	</build>

</project>
```
```java
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
wrapperVersion=3.3.2
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.10/apache-maven-3.9.10-bin.zip

```
```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SharedConfigsApplication {

	public static void main(String[] args) {
		SpringApplication.run(SharedConfigsApplication.class, args);
	}

}

```
```java

// shared-configs/src/main/java/br/com/legalconnect/common/config/OpenApiConfig.java
package br.com.legalconnect.common.config;

import java.util.List;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.servers.Server;

/**
 * @class OpenApiConfig
 * @brief Configuração do OpenAPI (Swagger) para documentação da API.
 *
 *        Esta classe define os metadados da API, como título, descrição,
 *        versão,
 *        informações de contato e licença. Também configura os servidores para
 *        a documentação, o que é útil em ambientes com API Gateways como Nginx.
 *
 *        A documentação estará disponível em:
 *        - Swagger UI: /swagger-ui.html
 *        - OpenAPI JSON: /v3/api-docs
 */
@Configuration
public class OpenApiConfig {

    /**
     * @brief Configura o bean principal do OpenAPI.
     * @return Uma instância de OpenAPI com as informações da API.
     */
    @Bean
    public OpenAPI myOpenAPI() {
        // Configuração do servidor de desenvolvimento
        Server devServer = new Server();
        devServer.setUrl("http://localhost:8080"); // URL para ambiente de desenvolvimento
        devServer.setDescription("URL do Servidor de Desenvolvimento");

        // Configuração do servidor de produção (exemplo, ajuste conforme seu
        // Nginx/domínio)
        Server prodServer = new Server();
        // Em um cenário real com Nginx, esta seria a URL do seu API Gateway
        prodServer.setUrl("https://api.legalconnect.com.br");
        prodServer.setDescription("URL do Servidor de Produção (via Nginx API Gateway)");

        // Informações de contato
        Contact contact = new Contact();
        contact.setEmail("contato@legalconnect.com.br");
        contact.setName("LegalConnect Suporte");
        contact.setUrl("https://www.legalconnect.com.br");

        // Informações de licença
        License mitLicense = new License().name("MIT License").url("https://choosealicense.com/licenses/mit/");

        // Informações gerais da API
        Info info = new Info()
                .title("LegalConnect - Microsserviço de Autenticação API")
                .version("1.0")
                .contact(contact)
                .description(
                        "Documentação da API do microsserviço de autenticação e autorização da plataforma LegalConnect.")
                .termsOfService("https://www.legalconnect.com.br/terms")
                .license(mitLicense);

        // Retorna o objeto OpenAPI completo com informações e servidores
        return new OpenAPI()
                .info(info)
                .servers(List.of(devServer, prodServer)); // Adiciona múltiplos servidores
    }
}
```
```java

// shared-configs/src/main/java/br/com/legalconnect/common/config/WebConfig.java
package br.com.legalconnect.common.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @class WebConfig
 * @brief Configuração global de CORS (Cross-Origin Resource Sharing) para a
 *        aplicação.
 *
 *        Esta classe implementa `WebMvcConfigurer` para personalizar o
 *        comportamento
 *        do Spring MVC, especificamente para permitir requisições CORS de
 *        origens
 *        configuradas. Em um ambiente de produção com Nginx como API Gateway,
 *        o CORS pode ser configurado tanto no Nginx quanto na aplicação.
 *        É uma boa prática ter uma camada de CORS na aplicação também, como
 *        fallback ou para desenvolvimento.
 */
@Configuration
@EnableWebMvc // Habilita a configuração do Spring MVC via Java
public class WebConfig implements WebMvcConfigurer {

    /**
     * @brief Configura as regras de CORS.
     *
     *        Permite requisições de origens específicas, com métodos HTTP
     *        permitidos,
     *        cabeçalhos e credenciais.
     *
     * @param registry O CorsRegistry para adicionar as configurações de CORS.
     */
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // Aplica a configuração a todos os endpoints
                .allowedOrigins(
                        "http://localhost:3000", // Exemplo: Frontend em desenvolvimento
                        "http://localhost:4200", // Exemplo: Outro frontend em desenvolvimento
                        "https://app.legalconnect.com.br", // Exemplo: Frontend em produção
                        "https://admin.legalconnect.com.br" // Exemplo: Painel administrativo em produção
                ) // Permite requisições destas origens
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD") // Métodos HTTP permitidos
                .allowedHeaders("*") // Permite todos os cabeçalhos
                .allowCredentials(true) // Permite o envio de cookies e cabeçalhos de autorização
                .maxAge(3600); // Tempo máximo em segundos que as informações de preflight CORS podem ser
                               // cacheadas
    }
}
```
```java
spring.application.name=common-lib

```
```java
package br.com.legalconnect.common.common_lib;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class CommonLibApplicationTests {

	@Test
	void contextLoads() {
	}

}

```