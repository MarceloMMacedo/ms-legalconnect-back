```java
package br.com.legalconnect;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class LegalUsuarioApplication {
	// @Value("${application.tenant.default-id}")
	// private String defaultTenantId;

	// @Autowired
	// private TenantMigrationService tenantMigrationService;

	public static void main(String[] args) {
		SpringApplication.run(LegalUsuarioApplication.class, args);
	}
}
// @Bean
// boolean inicio() {
// tenantMigrationService.migrateTenant(defaultTenantId);
// return true;
// }
// }

```
```java
package br.com.legalconnect.advogado.application.dto.enums;

/**
 * Enumeração para os tipos de documentos de um Profissional (Advogado).
 * 
 */
public enum DocumentoTipo {
    OAB, // Ordem dos Advogados do Brasil
    RG, // Registro Geral (identidade)
    CPF, // Cadastro de Pessoas Físicas
    COMPROVANTE_ENDERECO, // Comprovante de residência
    OUTRO // Outros tipos de documentos não listados explicitamente
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class CertificacaoRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome da certificação é obrigatório.")
    @Size(max = 255, message = "O nome da certificação deve ter no máximo 255 caracteres.")
    private String nome;

    @Size(max = 255, message = "A instituição da certificação deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da certificação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da certificação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import br.com.legalconnect.advogado.application.dto.enums.DocumentoTipo;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de upload de documento.
 * O campo 'tipoDocumento' foi alterado de String para o enum DocumentoTipo
 * para garantir tipagem segura e validação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoUploadRequest {
    @NotBlank(message = "O nome do arquivo é obrigatório.")
    @Size(max = 255, message = "O nome do arquivo deve ter no máximo 255 caracteres.")
    private String nomeArquivo;

    // Alterado de String para o enum DocumentoTipo para tipagem segura
    @NotNull(message = "O tipo do documento é obrigatório.")
    private DocumentoTipo tipoDocumento;

    @NotBlank(message = "O conteúdo do arquivo em Base64 é obrigatório.")
    private String arquivoBase64;

    @NotBlank(message = "O tipo MIME do arquivo é obrigatório.")
    @Size(max = 100, message = "O tipo MIME do arquivo deve ter no máximo 100 caracteres.")
    private String mimeType;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalRequestDTO {
    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O cargo da experiência é obrigatório.")
    @Size(max = 255, message = "O cargo da experiência deve ter no máximo 255 caracteres.")
    private String cargo;

    @NotBlank(message = "O nome da empresa da experiência é obrigatório.")
    @Size(max = 255, message = "O nome da empresa da experiência deve ter no máximo 255 caracteres.")
    private String empresa;

    @NotNull(message = "A data de início da experiência é obrigatória.")
    @PastOrPresent(message = "A data de início da experiência não pode ser uma data futura.")
    private LocalDate dataInicio;

    @PastOrPresent(message = "A data de fim da experiência não pode ser uma data futura.")
    private LocalDate dataFim; // Pode ser nulo se for a experiência atual

    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.time.LocalDate;
import java.util.UUID;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaRequestDTO {

    private UUID id; // Para identificação em operações de atualização/deleção

    @NotBlank(message = "O nome do curso é obrigatório.")
    @Size(max = 255, message = "O nome do curso deve ter no máximo 255 caracteres.")
    private String curso;

    @NotBlank(message = "O nome da instituição é obrigatório.")
    @Size(max = 255, message = "O nome da instituição deve ter no máximo 255 caracteres.")
    private String instituicao;

    @NotNull(message = "A data de conclusão da formação é obrigatória.")
    @PastOrPresent(message = "A data de conclusão da formação não pode ser uma data futura.")
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para criação de um novo Profissional.
 * Este DTO agora compõe um PessoaRequestDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ProfissionalCreateRequest extends PessoaRequestDTO {

    @NotBlank(message = "O número da OAB é obrigatório.")
    @Size(min = 5, max = 50, message = "O número da OAB deve ter entre 5 e 50 caracteres.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    @NotNull(message = "O ID do plano é obrigatório.")
    private UUID planoId;

    @NotNull(message = "O ID do tenant é obrigatório.")
    private UUID tenantId;

    // Relacionamentos para dados mestres que podem ser definidos na criação
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // DTOs para certificações, experiências e formações na criação (opcional)
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.application.dto.request;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO; // Importar PessoaRequestDTO
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para atualização de um Profissional.
 * Permite a atualização dos dados da Pessoa associada e dos campos específicos
 * de Profissional,
 * bem como de listas aninhadas.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalUpdateRequest {
    @NotNull(message = "O ID do profissional é obrigatório para atualização.")
    private UUID id;

    @Valid
    // A PessoaRequestDTO interna deve ter seu próprio ID se for uma atualização de
    // pessoa existente
    private PessoaRequestDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    @NotBlank(message = "O número da OAB do profissional é obrigatório para atualização.")
    private String numeroOab;

    @NotNull(message = "A indicação de uso do marketplace é obrigatória.")
    private Boolean usaMarketplace;

    private UUID empresaId; // Pode ser nulo se não houver empresa associada ou se for desvinculada

    private UUID planoId; // Pode ser nulo se o plano não for alterado

    // Listas de UUIDs para dados mestres
    private List<UUID> locaisAtuacaoIds;
    private List<UUID> areaAtuacaoIds;
    private List<UUID> idiomaIds;
    private List<UUID> tipoAtendimentoIds;

    // Listas de DTOs aninhados para certificações, experiências, formações
    // O ID em cada DTO aninhado indicará se é uma criação, atualização ou remoção.
    @Valid
    private List<CertificacaoRequestDTO> certificacoes;
    @Valid
    private List<ExperienciaProfissionalRequestDTO> experiencias;
    @Valid
    private List<FormacaoAcademicaRequestDTO> formacoes;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Área de Atuação.
 * Usado para retornar detalhes completos da Área de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class AreaAtuacaoResponseDTO {
    private UUID id;
    private String nome;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Certificação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class CertificacaoResponseDTO {
    private UUID id;
    private String nome;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Documento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class DocumentoResponseDTO {
    private UUID id;
    private String nomeArquivo;
    private String urlS3;
    private String tipoDocumento;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Experiência Profissional.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ExperienciaProfissionalResponseDTO {
    private UUID id;
    private String cargo;
    private String empresa;
    private LocalDate dataInicio;
    private LocalDate dataFim;
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.time.LocalDate;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Formação Acadêmica.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class FormacaoAcademicaResponseDTO {
    private UUID id;
    private String curso;
    private String instituicao;
    private LocalDate dataConclusao;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Idioma.
 * Usado para retornar detalhes completos do Idioma.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class IdiomaResponseDTO {
    private UUID id;
    private String nome;
    private String codigo;
    private String nivel;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Local de Atuação.
 * Usado para retornar detalhes completos do Local de Atuação.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class LocalAtuacaoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.List;
import java.util.UUID;

import br.com.legalconnect.commom.dto.response.PessoaResponseDTO; // Importar PessoaResponseDTO
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO de resposta detalhada para um Profissional.
 * Agora compõe um PessoaResponseDTO para os dados de Pessoa e Usuário.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ProfissionalResponseDTO {
    private UUID id; // ID do Profissional

    private PessoaResponseDTO pessoa; // Composição: Profissional 'tem uma' Pessoa

    private String numeroOab;
    private String statusProfissional;
    private Boolean usaMarketplace;
    private Boolean fazParteDePlano;

    // IDs de entidades relacionadas
    private UUID empresaId;
    private UUID planoId;
    private UUID tenantId;

    // Listas de DTOs aninhados
    private List<CertificacaoResponseDTO> certificacoes;
    private List<DocumentoResponseDTO> documentos;
    private List<ExperienciaProfissionalResponseDTO> experiencias;
    private List<FormacaoAcademicaResponseDTO> formacoes;

    // Listas de DTOs de dados mestres (detalhados)
    private List<LocalAtuacaoResponseDTO> locaisAtuacao;
    private List<AreaAtuacaoResponseDTO> areasAtuacao;
    private List<IdiomaResponseDTO> idiomas;
    private List<TipoAtendimentoResponseDTO> tiposAtendimento;
    private List<RoleProfissionalResponseDTO> rolesProfissional; // DTO para Role do Profissional
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Role de Profissional.
 * Usado para retornar detalhes completos da Role.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class RoleProfissionalResponseDTO {
    private UUID id;
    private String name;
    // O tenantId pode ser incluído se for relevante para o frontend
    // private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.application.dto.response;

import java.util.UUID;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Tipo de Atendimento.
 * Usado para retornar detalhes completos do Tipo de Atendimento.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TipoAtendimentoResponseDTO {
    private UUID id;
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacao;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade AreaAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface AreaAtuacaoMapper {
    AreaAtuacaoMapper INSTANCE = Mappers.getMapper(AreaAtuacaoMapper.class);

    /**
     * Mapeia uma entidade AreaAtuacao para um AreaAtuacaoResponseDTO.
     * @param entity A entidade AreaAtuacao.
     * @return O DTO de resposta correspondente.
     */
    AreaAtuacaoResponseDTO toResponseDTO(AreaAtuacao entity);

    /**
     * Mapeia um AreaAtuacaoResponseDTO para uma entidade AreaAtuacao.
     * Útil para cenários de re-conversão ou testes, embora a criação normalmente venha de um RequestDTO.
     * @param dto O DTO de resposta.
     * @return A entidade AreaAtuacao correspondente.
     */
    AreaAtuacao toEntity(AreaAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.Certificacao;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade Certificacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface CertificacaoMapper {
    CertificacaoMapper INSTANCE = Mappers.getMapper(CertificacaoMapper.class);

    /**
     * Mapeia um CertificacaoRequestDTO para uma entidade Certificacao.
     * O campo 'profissional' e 'tenantId' na entidade devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Certificacao correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    Certificacao toEntity(CertificacaoRequestDTO dto);

    /**
     * Mapeia uma entidade Certificacao para um CertificacaoResponseDTO.
     *
     * @param entity A entidade Certificacao.
     * @return O DTO de resposta correspondente.
     */
    CertificacaoResponseDTO toResponseDTO(Certificacao entity);

    /**
     * Atualiza uma entidade Certificacao existente com os dados de um CertificacaoRequestDTO.
     * O campo 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto O DTO de requisição com os dados para atualização.
     * @param entity A entidade Certificacao a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(CertificacaoRequestDTO dto, @MappingTarget Certificacao entity);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.application.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.application.dto.enums.DocumentoTipo;
import br.com.legalconnect.advogado.domain.modal.entity.Documento;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade Documento e seus DTOs.
 * Gerencia a conversão entre DocumentoUploadRequest, Documento e DocumentoResponseDTO.
 */
@Mapper(componentModel = "spring")
public interface DocumentoMapper {
    DocumentoMapper INSTANCE = Mappers.getMapper(DocumentoMapper.class);

    /**
     * Mapeia um DocumentoUploadRequest para uma entidade Documento.
     * Ignora 'arquivoBase64' e 'mimeType' (dados para upload, não persistentes na entidade).
     * 'urlS3', 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição para upload de documento.
     * @return A entidade Documento correspondente.
     */
    @Mapping(target = "urlS3", ignore = true) // Preenchido após o upload bem-sucedido
    @Mapping(target = "profissional", ignore = true) // Relacionamento com Profissional, preenchido no serviço
    @Mapping(target = "tenantId", ignore = true) // TenantId, preenchido no serviço
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    Documento toEntity(DocumentoUploadRequest dto);

    /**
     * Mapeia uma entidade Documento para um DocumentoResponseDTO.
     *
     * @param entity A entidade Documento.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "tipoDocumento", target = "tipoDocumento") // Mapeamento direto de String para String
    DocumentoResponseDTO toResponseDTO(Documento entity);

    /**
     * Atualiza uma entidade Documento existente com os dados de um DocumentoUploadRequest.
     * Campos ignorados: 'id', 'urlS3', 'profissional', 'tenantId'.
     *
     * @param dto O DTO de requisição.
     * @param entity A entidade Documento a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "urlS3", ignore = true)
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    @Mapping(source = "tipoDocumento", target = "tipoDocumento", qualifiedByName = "mapDocumentoTipoToString")
    void updateEntityFromDto(DocumentoUploadRequest dto, @MappingTarget Documento entity);

    /**
     * Converte um enum DocumentoTipo para sua representação em String.
     * Usado para mapear de DTO (enum) para Entidade (String).
     *
     * @param tipo O enum DocumentoTipo.
     * @return A representação em String do enum.
     */
    @Named("mapDocumentoTipoToString")
    default String mapDocumentoTipoToString(DocumentoTipo tipo) {
        return tipo != null ? tipo.name() : null;
    }
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissional;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade ExperienciaProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface ExperienciaProfissionalMapper {
    ExperienciaProfissionalMapper INSTANCE = Mappers.getMapper(ExperienciaProfissionalMapper.class);

    /**
     * Mapeia um ExperienciaProfissionalRequestDTO para uma entidade ExperienciaProfissional.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade ExperienciaProfissional correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    ExperienciaProfissional toEntity(ExperienciaProfissionalRequestDTO dto);

    /**
     * Mapeia uma entidade ExperienciaProfissional para um ExperienciaProfissionalResponseDTO.
     *
     * @param entity A entidade ExperienciaProfissional.
     * @return O DTO de resposta correspondente.
     */
    ExperienciaProfissionalResponseDTO toResponseDTO(ExperienciaProfissional entity);

    /**
     * Atualiza uma entidade ExperienciaProfissional existente com os dados de um ExperienciaProfissionalRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto O DTO de requisição com os dados para atualização.
     * @param entity A entidade ExperienciaProfissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(ExperienciaProfissionalRequestDTO dto, @MappingTarget ExperienciaProfissional entity);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademica;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade FormacaoAcademica e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface FormacaoAcademicaMapper {
    FormacaoAcademicaMapper INSTANCE = Mappers.getMapper(FormacaoAcademicaMapper.class);

    /**
     * Mapeia um FormacaoAcademicaRequestDTO para uma entidade FormacaoAcademica.
     * Os campos 'profissional' e 'tenantId' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade FormacaoAcademica correspondente.
     */
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    FormacaoAcademica toEntity(FormacaoAcademicaRequestDTO dto);

    /**
     * Mapeia uma entidade FormacaoAcademica para um FormacaoAcademicaResponseDTO.
     *
     * @param entity A entidade FormacaoAcademica.
     * @return O DTO de resposta correspondente.
     */
    FormacaoAcademicaResponseDTO toResponseDTO(FormacaoAcademica entity);

    /**
     * Atualiza uma entidade FormacaoAcademica existente com os dados de um FormacaoAcademicaRequestDTO.
     * Os campos 'profissional' e 'tenantId' não são atualizados via DTO.
     *
     * @param dto O DTO de requisição com os dados para atualização.
     * @param entity A entidade FormacaoAcademica a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "profissional", ignore = true)
    @Mapping(target = "tenantId", ignore = true)
    void updateEntityFromDto(FormacaoAcademicaRequestDTO dto, @MappingTarget FormacaoAcademica entity);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.Idioma;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade Idioma e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface IdiomaMapper {
    IdiomaMapper INSTANCE = Mappers.getMapper(IdiomaMapper.class);

    /**
     * Mapeia uma entidade Idioma para um IdiomaResponseDTO.
     * @param entity A entidade Idioma.
     * @return O DTO de resposta correspondente.
     */
    IdiomaResponseDTO toResponseDTO(Idioma entity);

    /**
     * Mapeia um IdiomaResponseDTO para uma entidade Idioma.
     * @param dto O DTO de resposta.
     * @return A entidade Idioma correspondente.
     */
    Idioma toEntity(IdiomaResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacao;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade LocalAtuacao e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface LocalAtuacaoMapper {
    LocalAtuacaoMapper INSTANCE = Mappers.getMapper(LocalAtuacaoMapper.class);

    /**
     * Mapeia uma entidade LocalAtuacao para um LocalAtuacaoResponseDTO.
     * @param entity A entidade LocalAtuacao.
     * @return O DTO de resposta correspondente.
     */
    LocalAtuacaoResponseDTO toResponseDTO(LocalAtuacao entity);

    /**
     * Mapeia um LocalAtuacaoResponseDTO para uma entidade LocalAtuacao.
     * @param dto O DTO de resposta.
     * @return A entidade LocalAtuacao correspondente.
     */
    LocalAtuacao toEntity(LocalAtuacaoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.advogado.application.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.application.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.application.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.commom.mapper.PessoaMapper;

/**
 * Mapper MapStruct para a entidade Profissional e seus DTOs de requisição e
 * resposta.
 * Lida com mapeamentos complexos e aninhados, delegando para outros mappers
 * quando necessário.
 */
@Mapper(componentModel = "spring", uses = {
        PessoaMapper.class,
        CertificacaoMapper.class,
        DocumentoMapper.class,
        ExperienciaProfissionalMapper.class,
        FormacaoAcademicaMapper.class,
        RoleProfissionalMapper.class
        // Mappers para AreaAtuacao, Idioma, LocalAtuacao, TipoAtendimento NÃO são
        // usados diretamente aqui
        // para mapear UUIDs para DTOs completos, pois isso é responsabilidade do
        // serviço.
})
public interface ProfissionalMapper {
    ProfissionalMapper INSTANCE = Mappers.getMapper(ProfissionalMapper.class);

    /**
     * Mapeia um ProfissionalCreateRequest para uma nova entidade Profissional.
     *
     * @param dto O DTO de requisição para criação.
     * @return A nova entidade Profissional.
     */
    // @Mapping(source = "pessoa.user", target = "usuario") // Mapeia o
    // PessoaRequestDTO (que é 'pessoa') para a superclasse 'usuario'
    @Mapping(target = "id", ignore = true) // ID do Profissional será gerado
    @Mapping(target = "pessoaId", ignore = true) // Será preenchido no serviço após a persistência da Pessoa
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "documentos", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "experiencias", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "formacoes", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Coleções aninhadas gerenciadas no serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    Profissional toEntity(ProfissionalCreateRequest dto);

    /**
     * Atualiza uma entidade Profissional existente com os dados de um
     * ProfissionalUpdateRequest.
     *
     * @param dto    O DTO de requisição para atualização.
     * @param entity A entidade Profissional a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID da entidade não deve ser alterado pelo DTO
    @Mapping(source = "pessoa.usuario", target = "usuario") // Mapeia o DTO 'pessoa.usuario' para a superclasse
                                                            // 'usuario'
    @Mapping(target = "pessoaId", ignore = true) // Gerenciado pelo sistema
    @Mapping(target = "statusProfissional", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "fazParteDePlano", ignore = true) // Definido pela lógica de negócio
    @Mapping(target = "certificacoes", ignore = true) // Gerenciado pelo serviço (criação/atualização/remoção)
    @Mapping(target = "documentos", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "experiencias", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "formacoes", ignore = true) // Gerenciado pelo serviço
    @Mapping(target = "roleProfissionals", ignore = true) // Gerenciado pelo serviço
    @Mapping(source = "locaisAtuacaoIds", target = "locaisAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "areaAtuacaoIds", target = "areaAtuacaoIds") // List<UUID> para Set<UUID>
    @Mapping(source = "idiomaIds", target = "idiomaIds") // List<UUID> para Set<UUID>
    @Mapping(source = "tipoAtendimentoIds", target = "tipoAtendimentoIds") // List<UUID> para Set<UUID>
    void updateEntityFromDto(ProfissionalUpdateRequest dto, @MappingTarget Profissional entity);

    /**
     * Mapeia uma entidade Profissional para um ProfissionalResponseDTO.
     * Campos de dados mestres (locaisAtuacao, areasAtuacao, idiomas,
     * tiposAtendimento)
     * são ignorados aqui e devem ser populados pela camada de serviço,
     * pois a entidade Profissional armazena apenas os IDs dessas relações.
     *
     * @param entity A entidade Profissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(source = "usuario", target = "pessoa") // Mapeia a superclasse 'usuario' para 'pessoa' no DTO
    @Mapping(target = "locaisAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "areasAtuacao", ignore = true) // Populado pelo serviço
    @Mapping(target = "idiomas", ignore = true) // Populado pelo serviço
    @Mapping(target = "tiposAtendimento", ignore = true) // Populado pelo serviço
    @Mapping(source = "roleProfissionals", target = "rolesProfissional") // Mapeia Set<RoleProfissional> para
                                                                         // List<RoleProfissionalResponseDTO>
    ProfissionalResponseDTO toResponseDTO(Profissional entity);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.response.RoleProfissionalResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.RoleProfissional;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade RoleProfissional e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface RoleProfissionalMapper {
    RoleProfissionalMapper INSTANCE = Mappers.getMapper(RoleProfissionalMapper.class);

    /**
     * Mapeia uma entidade RoleProfissional para um RoleProfissionalResponseDTO.
     * Ignora 'tenantId' na resposta se não for relevante para o frontend.
     *
     * @param entity A entidade RoleProfissional.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id")
    @Mapping(target = "name", source = "name")
    RoleProfissionalResponseDTO toResponseDTO(RoleProfissional entity);

    /**
     * Mapeia um RoleProfissionalResponseDTO para uma entidade RoleProfissional.
     * 'tenantId' deve ser definido pelo serviço.
     *
     * @param dto O DTO de resposta.
     * @return A entidade RoleProfissional correspondente.
     */
    @Mapping(target = "tenantId", ignore = true)
    RoleProfissional toEntity(RoleProfissionalResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.application.mapper;

import br.com.legalconnect.advogado.application.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimento;
import org.mapstruct.Mapper;
import org.mapstruct.factory.Mappers;

/**
 * Mapper MapStruct para a entidade TipoAtendimento e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface TipoAtendimentoMapper {
    TipoAtendimentoMapper INSTANCE = Mappers.getMapper(TipoAtendimentoMapper.class);

    /**
     * Mapeia uma entidade TipoAtendimento para um TipoAtendimentoResponseDTO.
     * @param entity A entidade TipoAtendimento.
     * @return O DTO de resposta correspondente.
     */
    TipoAtendimentoResponseDTO toResponseDTO(TipoAtendimento entity);

    /**
     * Mapeia um TipoAtendimentoResponseDTO para uma entidade TipoAtendimento.
     * @param dto O DTO de resposta.
     * @return A entidade TipoAtendimento correspondente.
     */
    TipoAtendimento toEntity(TipoAtendimentoResponseDTO dto);
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.EmailService; // Para enviar e-mails de confirmação
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;
import lombok.extern.slf4j.Slf4j;

/**
 * Serviço responsável pela lógica de agendamento de consultas no Marketplace.
 */
@Slf4j
@Service
public class AgendamentoService {

    private final ProfissionalRepository profissionalRepository;
    private final GoogleCalendarService googleCalendarService;
    private final EmailService emailService;
    // Repositório de agendamentos (assumindo a entidade Agendamento)
    // private final AgendamentoRepository agendamentoRepository;

    @Autowired
    public AgendamentoService(ProfissionalRepository profissionalRepository,
            GoogleCalendarService googleCalendarService,
            EmailService emailService) {
        this.profissionalRepository = profissionalRepository;
        this.googleCalendarService = googleCalendarService;
        this.emailService = emailService;
        // this.agendamentoRepository = agendamentoRepository;
    }

    /**
     * Realiza o agendamento de uma consulta entre um cliente e um profissional.
     * Regras de Negócio:
     * - Verifica a disponibilidade do profissional na data/hora solicitada.
     * - Garante que o profissional existe e está ativo no marketplace.
     * - Integra com Google Calendar para adicionar o evento na agenda do
     * profissional.
     * - Envia e-mails de confirmação para cliente e profissional.
     *
     * @param profissionalId     ID do profissional.
     * @param clienteId          ID do cliente.
     * @param horarioAgendamento Horário da consulta.
     * @param tipoServico        Tipo de serviço agendado.
     * @return Sucesso do agendamento.
     * @throws BusinessException se o profissional não estiver disponível ou outras
     *                           regras de negócio forem violadas.
     */
    @Transactional
    public boolean agendarConsulta(UUID profissionalId, UUID clienteId, LocalDateTime horarioAgendamento,
            String tipoServico) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // O agendamento ocorre dentro do contexto de um tenant

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Profissional deve estar ativo e usar marketplace
        if (!profissional.getUsaMarketplace() || !profissional.getStatusProfissional().equals("ACTIVE")) { // Assuming
                                                                                                           // "ACTIVE"
                                                                                                           // status
            throw new BusinessException(ErrorCode.ADVOCATE_NOT_AVAILABLE, HttpStatus.BAD_REQUEST,
                    "Profissional não disponível para agendamento.");
        }

        // Regra de Negócio: Verificar disponibilidade real do profissional (com Google
        // Calendar)
        boolean isAvailable = googleCalendarService.checkAvailability(profissional.getUsuario().getEmail(),
                horarioAgendamento);
        if (!isAvailable) {
            throw new BusinessException(ErrorCode.APPOINTMENT_CONFLICT, HttpStatus.CONFLICT,
                    "Horário indisponível para o profissional.");
        }

        // Regra de Negócio: Criar o registro de agendamento no banco de dados (se
        // houver entidade Agendamento)
        // Agendamento newAppointment = Agendamento.builder()
        // .profissional(profissional)
        // .clienteId(clienteId)
        // .horario(horarioAgendamento)
        // .tipoServico(tipoServico)
        // .tenantId(tenantId)
        // .build();
        // agendamentoRepository.save(newAppointment);

        // Funcionalidade Completa: Adicionar evento ao Google Calendar do profissional
        googleCalendarService.addEvent(
                profissional.getUsuario().getEmail(),
                "Consulta: " + tipoServico + " com Cliente " + clienteId, // Supondo que você pode obter o nome do
                                                                          // cliente
                horarioAgendamento,
                horarioAgendamento.plusHours(1) // Consulta de 1 hora
        );

        // Funcionalidade Completa: Enviar e-mails de confirmação
        emailService.sendAppointmentConfirmationEmail(
                profissional.getUsuario().getEmail(),
                "Você tem uma nova consulta agendada com o cliente " + clienteId + " para " + horarioAgendamento);
        // emailService.sendAppointmentConfirmationEmail(
        // clienteService.findById(clienteId).getEmail(), // Supondo um clienteService
        // "Sua consulta com " + profissional.getNomeCompleto() + " foi confirmada para
        // " + horarioAgendamento
        // );

        return true;
    }

    /**
     * Simula a avaliação de uma consulta pelo cliente.
     * Regras de Negócio:
     * - Associa a avaliação ao agendamento e ao profissional.
     * - Atualiza a média de avaliação do profissional (lógica simplificada).
     *
     * @param agendamentoId ID do agendamento avaliado.
     * @param clienteId     ID do cliente que avaliou.
     * @param rating        Nota da avaliação (1-5).
     * @param comentario    Comentário opcional.
     * @return Sucesso da avaliação.
     */
    @Transactional
    public boolean avaliarConsulta(UUID agendamentoId, UUID clienteId, int rating, String comentario) {
        // Lógica para encontrar o agendamento e associar a avaliação.
        // Agendamento agendamento =
        // agendamentoRepository.findById(agendamentoId).orElseThrow(...)
        // Criar uma entidade Avaliacao.
        // Atualizar a média de avaliação do Profissional.

        // Simulação: Apenas loga a avaliação
        log.info("Cliente {} avaliou agendamento {} com nota {} e comentário: {}", clienteId, agendamentoId, rating,
                comentario);

        // Para fins de demonstração, vamos considerar um sucesso
        return true;
    }

    // Outras funcionalidades como reagendamento, cancelamento, busca de
    // agendamentos
    // seriam implementadas aqui.
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.response.AreaAtuacaoResponseDTO;
import br.com.legalconnect.advogado.application.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacao;
import br.com.legalconnect.advogado.domain.repository.AreaAtuacaoRepository;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;

/**
 * Serviço para gestão de Áreas de Atuação (dados mestre).
 * Essas entidades são consideradas globais ou de um tenant específico da
 * plataforma,
 * mas para este módulo, o acesso é simplificado como dados mestre.
 */
@Service
public class AreaAtuacaoService {

    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;

    @Autowired
    public AreaAtuacaoService(AreaAtuacaoRepository areaAtuacaoRepository, AreaAtuacaoMapper areaAtuacaoMapper) {
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
    }

    /**
     * Busca uma Área de Atuação pelo ID.
     *
     * @param id ID da Área de Atuação.
     * @return DTO da Área de Atuação.
     * @throws BusinessException se a Área de Atuação não for encontrada.
     */
    public AreaAtuacaoResponseDTO findAreaAtuacaoById(UUID id) {
        AreaAtuacao areaAtuacao = areaAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Área de Atuação não encontrada."));
        return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
    }

    /**
     * Lista todas as Áreas de Atuação.
     *
     * @return Lista de DTOs de Áreas de Atuação.
     */
    public List<AreaAtuacaoResponseDTO> findAllAreasAtuacao() {
        return areaAtuacaoRepository.findAll().stream()
                .map(areaAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    // Métodos para criar, atualizar e deletar podem ser adicionados
    // se essas entidades mestre forem gerenciáveis via API
    // Por exemplo, por um ADMIN da plataforma.
    // Ex:
    /*
     * @Transactional
     * public AreaAtuacaoResponseDTO createAreaAtuacao(AreaAtuacaoRequestDTO
     * requestDTO) {
     * if (areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * AreaAtuacao areaAtuacao = areaAtuacaoMapper.toEntity(requestDTO);
     * areaAtuacao = areaAtuacaoRepository.save(areaAtuacao);
     * return areaAtuacaoMapper.toResponseDTO(areaAtuacao);
     * }
     * 
     * @Transactional
     * public AreaAtuacaoResponseDTO updateAreaAtuacao(UUID id,
     * AreaAtuacaoRequestDTO requestDTO) {
     * AreaAtuacao existing = areaAtuacaoRepository.findById(id)
     * .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada."));
     * if (!existing.getNome().equalsIgnoreCase(requestDTO.getNome()) &&
     * areaAtuacaoRepository.findByNome(requestDTO.getNome()).isPresent()) {
     * throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.CONFLICT,
     * "Área de Atuação com este nome já existe.");
     * }
     * areaAtuacaoMapper.updateEntityFromDto(requestDTO, existing); // Supondo um
     * updateEntityFromDto no mapper
     * existing = areaAtuacaoRepository.save(existing);
     * return areaAtuacaoMapper.toResponseDTO(existing);
     * }
     * 
     * @Transactional
     * public void deleteAreaAtuacao(UUID id) {
     * if (!areaAtuacaoRepository.existsById(id)) {
     * throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
     * HttpStatus.NOT_FOUND, "Área de Atuação não encontrada para deleção.");
     * }
     * // Regra de Negócio: Verificar se está em uso por algum Profissional antes de
     * deletar
     * // if (profissionalRepository.existsByAreaAtuacaoId(id)) { ... }
     * areaAtuacaoRepository.deleteById(id);
     * }
     */
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.request.CertificacaoRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.CertificacaoResponseDTO;
import br.com.legalconnect.advogado.application.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.Certificacao;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das certificações de um Profissional.
 * Este serviço é granular e pode ser usado para operações diretas em
 * certificações,
 * embora o ProfissionalService orquestre a maioria.
 */
@Service
public class CertificacaoService {

    private final CertificacaoRepository certificacaoRepository;
    private final CertificacaoMapper certificacaoMapper;
    private final ProfissionalRepository profissionalRepository;

    @Autowired
    public CertificacaoService(CertificacaoRepository certificacaoRepository,
            CertificacaoMapper certificacaoMapper,
            ProfissionalRepository profissionalRepository) {
        this.certificacaoRepository = certificacaoRepository;
        this.certificacaoMapper = certificacaoMapper;
        this.profissionalRepository = profissionalRepository;
    }

    /**
     * Cria uma nova certificação para um profissional específico.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - A certificação é associada ao profissional e ao tenant.
     *
     * @param profissionalId ID do profissional.
     * @param requestDTO     DTO com os dados da certificação.
     * @return DTO da certificação criada.
     */
    @Transactional
    public CertificacaoResponseDTO createCertificacao(UUID profissionalId, CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        Certificacao certificacao = certificacaoMapper.toEntity(requestDTO);
        certificacao.setProfissional(profissional);
        certificacao.setTenantId(tenantId);

        certificacao = certificacaoRepository.save(certificacao); // profissionalId é passado para o
                                                                  // save no repositório customizado
        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Atualiza uma certificação existente de um profissional.
     * Regras de Negócio:
     * - A certificação deve existir e pertencer ao profissional e tenant corretos.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @param requestDTO     DTO com os dados para atualização.
     * @return DTO da certificação atualizada.
     */
    @Transactional
    public CertificacaoResponseDTO updateCertificacao(UUID profissionalId, UUID certificacaoId,
            CertificacaoRequestDTO requestDTO) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant ou profissional.");
        }

        certificacaoMapper.updateEntityFromDto(requestDTO, existingCertificacao);
        existingCertificacao = certificacaoRepository.save(existingCertificacao);
        return certificacaoMapper.toResponseDTO(existingCertificacao);
    }

    /**
     * Busca uma certificação pelo ID do profissional e da certificação.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação.
     * @return DTO da certificação.
     */
    public CertificacaoResponseDTO findCertificacaoById(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Certificacao certificacao = certificacaoRepository.findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para este profissional."));

        if (!certificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        return certificacaoMapper.toResponseDTO(certificacao);
    }

    /**
     * Lista todas as certificações de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de certificações.
     */
    public List<CertificacaoResponseDTO> findAllCertificacoesByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se o profissional existe e pertence ao tenant
        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return certificacaoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(certificacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta uma certificação de um profissional.
     *
     * @param profissionalId ID do profissional.
     * @param certificacaoId ID da certificação a ser deletada.
     */
    @Transactional
    public void deleteCertificacao(UUID profissionalId, UUID certificacaoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        // Verificar se a certificação existe e pertence ao profissional e tenant
        Certificacao existingCertificacao = certificacaoRepository
                .findByIdAndProfissionalId(certificacaoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Certificação não encontrada para deleção."));

        if (!existingCertificacao.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Certificação pertence a outro tenant.");
        }

        certificacaoRepository.deleteByIdAndProfissionalId(certificacaoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.Base64; // Para decodificar Base64
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.request.DocumentoUploadRequest;
import br.com.legalconnect.advogado.application.dto.response.DocumentoResponseDTO;
import br.com.legalconnect.advogado.application.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.Documento;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.DocumentoRepository;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.S3Service;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão de documentos de um Profissional.
 * Inclui o upload de arquivos para o S3 e o armazenamento dos metadados no
 * banco de dados.
 */
@Service
public class DocumentoService {

    private final DocumentoRepository documentoRepository;
    private final DocumentoMapper documentoMapper;
    private final ProfissionalRepository profissionalRepository;
    private final S3Service s3Service; // Serviço para integração com S3

    @Autowired
    public DocumentoService(DocumentoRepository documentoRepository,
            DocumentoMapper documentoMapper,
            ProfissionalRepository profissionalRepository,
            S3Service s3Service) {
        this.documentoRepository = documentoRepository;
        this.documentoMapper = documentoMapper;
        this.profissionalRepository = profissionalRepository;
        this.s3Service = s3Service;
    }

    /**
     * Realiza o upload de um documento para o S3 e persiste seus metadados.
     * Regras de Negócio:
     * - O profissional deve existir e pertencer ao tenant atual.
     * - O conteúdo do arquivo em Base64 é decodificado e enviado ao S3.
     * - A URL do S3 é armazenada no banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param request        DTO com os dados do documento e o arquivo em Base64.
     * @return DTO do documento criado.
     * @throws BusinessException em caso de falha no upload ou se o profissional não
     *                           for encontrado.
     */
    @Transactional
    public DocumentoResponseDTO uploadDocumento(UUID profissionalId, DocumentoUploadRequest request) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para upload de documento."));

        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Decodificar Base64 e fazer upload para S3
        byte[] fileBytes;
        try {
            fileBytes = Base64.getDecoder().decode(request.getArquivoBase64());
        } catch (IllegalArgumentException e) {
            throw new BusinessException(ErrorCode.INVALID_DOCUMENT_FORMAT, HttpStatus.BAD_REQUEST,
                    "Conteúdo do arquivo em Base64 inválido.");
        }

        String s3Key = "profissionais/" + profissionalId + "/documentos/" + UUID.randomUUID() + "/"
                + request.getNomeArquivo();
        String fileUrl = s3Service.uploadFile(fileBytes, s3Key, request.getMimeType());

        if (fileUrl == null) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao fazer upload do documento para o S3.");
        }

        Documento documento = documentoMapper.toEntity(request);
        documento.setUrlS3(fileUrl);
        documento.setProfissional(profissional);
        documento.setTenantId(tenantId);

        documento = documentoRepository.save(documento);
        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Busca um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento deve pertencer ao profissional e ao tenant correto.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento.
     * @return DTO do documento encontrado.
     * @throws BusinessException se o documento não for encontrado.
     */
    public DocumentoResponseDTO findDocumentoById(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento documento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para este profissional."));

        if (!documento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant ou profissional.");
        }

        return documentoMapper.toResponseDTO(documento);
    }

    /**
     * Lista todos os documentos de um profissional.
     * Regras de Negócio:
     * - Apenas documentos do tenant atual são retornados.
     *
     * @param profissionalId ID do profissional.
     * @return Lista de DTOs de documentos.
     */
    public List<DocumentoResponseDTO> findAllDocumentosByProfissionalId(UUID profissionalId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return documentoRepository.findAllByProfissionalId(profissionalId).stream()
                .map(documentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um documento pelo seu ID e pelo ID do profissional.
     * Regras de Negócio:
     * - O documento é removido do S3 antes de ser deletado do banco de dados.
     *
     * @param profissionalId ID do profissional.
     * @param documentoId    ID do documento a ser deletado.
     * @throws BusinessException se o documento não for encontrado ou falha na
     *                           deleção do S3.
     */
    @Transactional
    public void deleteDocumento(UUID profissionalId, UUID documentoId) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Documento existingDocumento = documentoRepository.findByIdAndProfissionalId(documentoId, profissionalId)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Documento não encontrado para deleção."));

        if (!existingDocumento.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Documento pertence a outro tenant.");
        }

        // Deletar do S3 primeiro
        try {
            s3Service.deleteFile(existingDocumento.getUrlS3());
        } catch (Exception e) {
            throw new BusinessException(ErrorCode.ERRO_INTERNO_SERVIDOR, HttpStatus.INTERNAL_SERVER_ERROR,
                    "Falha ao deletar o documento do S3: " + e.getMessage());
        }

        documentoRepository.deleteByIdAndProfissionalId(documentoId, profissionalId);
    }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.request.ExperienciaProfissionalRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.ExperienciaProfissionalResponseDTO;
import br.com.legalconnect.advogado.application.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das experiências profissionais de um
 * Profissional.
 */
@Service
public class ExperienciaProfissionalService {

        private final ExperienciaRepository experienciaRepository;
        private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public ExperienciaProfissionalService(ExperienciaRepository experienciaRepository,
                        ExperienciaProfissionalMapper experienciaProfissionalMapper,
                        ProfissionalRepository profissionalRepository) {
                this.experienciaRepository = experienciaRepository;
                this.experienciaProfissionalMapper = experienciaProfissionalMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova experiência profissional para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A experiência é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da experiência.
         * @return DTO da experiência criada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO createExperienciaProfissional(UUID profissionalId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                ExperienciaProfissional experiencia = experienciaProfissionalMapper.toEntity(requestDTO);
                experiencia.setProfissional(profissional);
                experiencia.setTenantId(tenantId);

                experiencia = experienciaRepository.save(experiencia);
                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Atualiza uma experiência profissional existente de um profissional.
         * Regras de Negócio:
         * - A experiência deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da experiência atualizada.
         */
        @Transactional
        public ExperienciaProfissionalResponseDTO updateExperienciaProfissional(UUID profissionalId, UUID experienciaId,
                        ExperienciaProfissionalRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant ou profissional.");
                }

                experienciaProfissionalMapper.updateEntityFromDto(requestDTO, existingExperiencia);
                existingExperiencia = experienciaRepository.save(existingExperiencia);
                return experienciaProfissionalMapper.toResponseDTO(existingExperiencia);
        }

        /**
         * Busca uma experiência profissional pelo ID do profissional e da experiência.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência.
         * @return DTO da experiência.
         */
        public ExperienciaProfissionalResponseDTO findExperienciaProfissionalById(UUID profissionalId,
                        UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional experiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para este profissional."));

                if (!experiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                return experienciaProfissionalMapper.toResponseDTO(experiencia);
        }

        /**
         * Lista todas as experiências profissionais de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de experiências.
         */
        public List<ExperienciaProfissionalResponseDTO> findAllExperienciasProfissionaisByProfissionalId(
                        UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return experienciaRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(experienciaProfissionalMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma experiência profissional de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param experienciaId  ID da experiência a ser deletada.
         */
        @Transactional
        public void deleteExperienciaProfissional(UUID profissionalId, UUID experienciaId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                ExperienciaProfissional existingExperiencia = experienciaRepository
                                .findByIdAndProfissionalId(experienciaId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Experiência profissional não encontrada para deleção."));

                if (!existingExperiencia.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Experiência pertence a outro tenant.");
                }

                experienciaRepository.deleteByIdAndProfissionalId(experienciaId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.request.FormacaoAcademicaRequestDTO;
import br.com.legalconnect.advogado.application.dto.response.FormacaoAcademicaResponseDTO;
import br.com.legalconnect.advogado.application.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.FormacaoRepository;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.commom.service.TenantContext;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das formações acadêmicas de um Profissional.
 */
@Service
public class FormacaoAcademicaService {

        private final FormacaoRepository formacaoRepository;
        private final FormacaoAcademicaMapper formacaoAcademicaMapper;
        private final ProfissionalRepository profissionalRepository;

        @Autowired
        public FormacaoAcademicaService(FormacaoRepository formacaoRepository,
                        FormacaoAcademicaMapper formacaoAcademicaMapper,
                        ProfissionalRepository profissionalRepository) {
                this.formacaoRepository = formacaoRepository;
                this.formacaoAcademicaMapper = formacaoAcademicaMapper;
                this.profissionalRepository = profissionalRepository;
        }

        /**
         * Cria uma nova formação acadêmica para um profissional específico.
         * Regras de Negócio:
         * - O profissional deve existir e pertencer ao tenant atual.
         * - A formação é associada ao profissional e ao tenant.
         *
         * @param profissionalId ID do profissional.
         * @param requestDTO     DTO com os dados da formação.
         * @return DTO da formação criada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO createFormacaoAcademica(UUID profissionalId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));

                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                FormacaoAcademica formacao = formacaoAcademicaMapper.toEntity(requestDTO);
                formacao.setProfissional(profissional);
                formacao.setTenantId(tenantId);

                formacao = formacaoRepository.save(formacao);
                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Atualiza uma formação acadêmica existente de um profissional.
         * Regras de Negócio:
         * - A formação deve existir e pertencer ao profissional e tenant corretos.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @param requestDTO     DTO com os dados para atualização.
         * @return DTO da formação atualizada.
         */
        @Transactional
        public FormacaoAcademicaResponseDTO updateFormacaoAcademica(UUID profissionalId, UUID formacaoId,
                        FormacaoAcademicaRequestDTO requestDTO) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant ou profissional.");
                }

                formacaoAcademicaMapper.updateEntityFromDto(requestDTO, existingFormacao);
                existingFormacao = formacaoRepository.save(existingFormacao);
                return formacaoAcademicaMapper.toResponseDTO(existingFormacao);
        }

        /**
         * Busca uma formação acadêmica pelo ID do profissional e da formação.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação.
         * @return DTO da formação.
         */
        public FormacaoAcademicaResponseDTO findFormacaoAcademicaById(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica formacao = formacaoRepository.findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para este profissional."));

                if (!formacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                return formacaoAcademicaMapper.toResponseDTO(formacao);
        }

        /**
         * Lista todas as formações acadêmicas de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @return Lista de DTOs de formações.
         */
        public List<FormacaoAcademicaResponseDTO> findAllFormacoesAcademicasByProfissionalId(UUID profissionalId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                Profissional profissional = profissionalRepository.findById(profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO,
                                                HttpStatus.NOT_FOUND,
                                                "Profissional não encontrado."));
                if (!profissional.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Profissional pertence a outro tenant.");
                }

                return formacaoRepository.findAllByProfissionalId(profissionalId).stream()
                                .map(formacaoAcademicaMapper::toResponseDTO)
                                .collect(Collectors.toList());
        }

        /**
         * Deleta uma formação acadêmica de um profissional.
         *
         * @param profissionalId ID do profissional.
         * @param formacaoId     ID da formação a ser deletada.
         */
        @Transactional
        public void deleteFormacaoAcademica(UUID profissionalId, UUID formacaoId) {
                UUID tenantId = TenantContext.getCurrentTenantId();

                FormacaoAcademica existingFormacao = formacaoRepository
                                .findByIdAndProfissionalId(formacaoId, profissionalId)
                                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
                                                HttpStatus.NOT_FOUND,
                                                "Formação acadêmica não encontrada para deleção."));

                if (!existingFormacao.getTenantId().equals(tenantId)) {
                        throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                                        "Acesso negado. Formação pertence a outro tenant.");
                }

                formacaoRepository.deleteByIdAndProfissionalId(formacaoId, profissionalId);
        }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.time.LocalDateTime;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço de integração simulada com a Google Calendar API.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a
 * Google Calendar API
 * utilizando as credenciais OAuth2 do aplicativo.
 */
@Service
public class GoogleCalendarService {

    private static final Logger log = LoggerFactory.getLogger(GoogleCalendarService.class);

    /**
     * Simula a adição de um evento à agenda do Google Calendar de um usuário.
     *
     * @param userEmail    O e-mail do usuário cuja agenda será atualizada.
     * @param eventSummary O título do evento.
     * @param startTime    A data e hora de início do evento.
     * @param endTime      A data e hora de fim do evento.
     * @return true se o evento foi "adicionado" com sucesso, false caso contrário.
     */
    public boolean addEvent(String userEmail, String eventSummary, LocalDateTime startTime, LocalDateTime endTime) {
        log.info("Simulando adição de evento ao Google Calendar para {}:", userEmail);
        log.info("  Sumário: {}", eventSummary);
        log.info("  Início: {}", startTime);
        log.info("  Fim: {}", endTime);
        // Lógica real de integração com Google Calendar API seria aqui, por exemplo:
        // Event event = new Event()
        // .setSummary(eventSummary)
        // .setDescription("Agendamento via LegalConnect");
        // DateTime startDateTime = new DateTime(startTime.toString());
        // EventDateTime start = new
        // EventDateTime().setDateTime(startDateTime).setTimeZone("America/Sao_Paulo");
        // event.setStart(start);
        // ...
        // Calendar service = new Calendar.Builder(...).build();
        // service.events().insert(userEmail, event).execute();
        log.info("Evento simulado adicionado com sucesso ao Google Calendar.");
        return true;
    }

    /**
     * Simula a verificação de disponibilidade na agenda do Google Calendar de um
     * usuário.
     *
     * @param userEmail    O e-mail do usuário.
     * @param proposedTime O horário a ser verificado.
     * @return true se o horário estiver disponível, false caso contrário.
     */
    public boolean checkAvailability(String userEmail, LocalDateTime proposedTime) {
        log.info("Simulando verificação de disponibilidade para {} no horário {}", userEmail, proposedTime);
        // Em um cenário real, você consultaria a API do Google Calendar para Free/Busy
        // Por simplicidade, vamos simular que o horário está sempre disponível, a menos
        // que seja um horário "proibido"
        if (proposedTime.getHour() == 13) { // Exemplo de regra de negócio: almoço indisponível
            log.info("Horário indisponível (simulado).");
            return false;
        }
        log.info("Horário disponível (simulado).");
        return true;
    }

    // Outros métodos como updateEvent, deleteEvent, listEvents podem ser
    // adicionados.
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.response.IdiomaResponseDTO;
import br.com.legalconnect.advogado.application.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.domain.modal.entity.Idioma;
import br.com.legalconnect.advogado.domain.repository.IdiomaRepository;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;

/**
 * Serviço para gestão de Idiomas (dados mestre).
 */
@Service
public class IdiomaService {

    private final IdiomaRepository idiomaRepository;
    private final IdiomaMapper idiomaMapper;

    @Autowired
    public IdiomaService(IdiomaRepository idiomaRepository, IdiomaMapper idiomaMapper) {
        this.idiomaRepository = idiomaRepository;
        this.idiomaMapper = idiomaMapper;
    }

    /**
     * Busca um Idioma pelo ID.
     *
     * @param id ID do Idioma.
     * @return DTO do Idioma.
     * @throws BusinessException se o Idioma não for encontrado.
     */
    public IdiomaResponseDTO findIdiomaById(UUID id) {
        Idioma idioma = idiomaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Idioma não encontrado."));
        return idiomaMapper.toResponseDTO(idioma);
    }

    /**
     * Lista todos os Idiomas.
     *
     * @return Lista de DTOs de Idiomas.
     */
    public List<IdiomaResponseDTO> findAllIdiomas() {
        return idiomaRepository.findAll().stream()
                .map(idiomaMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.response.LocalAtuacaoResponseDTO;
import br.com.legalconnect.advogado.application.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacao;
import br.com.legalconnect.advogado.domain.repository.LocalAtuacaoRepository;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;

/**
 * Serviço para gestão de Locais de Atuação (dados mestre).
 */
@Service
public class LocalAtuacaoService {

    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final LocalAtuacaoMapper localAtuacaoMapper;

    @Autowired
    public LocalAtuacaoService(LocalAtuacaoRepository localAtuacaoRepository, LocalAtuacaoMapper localAtuacaoMapper) {
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.localAtuacaoMapper = localAtuacaoMapper;
    }

    /**
     * Busca um Local de Atuação pelo ID.
     *
     * @param id ID do Local de Atuação.
     * @return DTO do Local de Atuação.
     * @throws BusinessException se o Local de Atuação não for encontrado.
     */
    public LocalAtuacaoResponseDTO findLocalAtuacaoById(UUID id) {
        LocalAtuacao localAtuacao = localAtuacaoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Local de Atuação não encontrado."));
        return localAtuacaoMapper.toResponseDTO(localAtuacao);
    }

    /**
     * Lista todos os Locais de Atuação.
     *
     * @return Lista de DTOs de Locais de Atuação.
     */
    public List<LocalAtuacaoResponseDTO> findAllLocaisAtuacao() {
        return localAtuacaoRepository.findAll().stream()
                .map(localAtuacaoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import org.springframework.stereotype.Service;

// Assumindo a existência dessas classes de DTO, Entidade e Repositório
// import br.com.legalconnect.office.application.dto.request.ProcessoRequestDTO;
// import br.com.legalconnect.office.application.dto.response.ProcessoResponseDTO;
// import br.com.legalconnect.office.domain.modal.entity.Processo;
// import br.com.legalconnect.office.domain.repository.ProcessoRepository;
// import br.com.legalconnect.office.application.mapper.ProcessoMapper;

/**
 * Serviço responsável pela gestão de Processos Judiciais e Administrativos no
 * módulo de Gestão de Escritório.
 */
@Service
public class ProcessoService {

    // private final ProcessoRepository processoRepository;
    // private final ProcessoMapper processoMapper;
    // private final AIService aiService; // Para geração de petições com IA
    // private final S3Service s3Service; // Para anexos de documentos

    // @Autowired
    // public ProcessoService(ProcessoRepository processoRepository,
    // ProcessoMapper processoMapper,
    // AIService aiService,
    // S3Service s3Service) {
    // this.processoRepository = processoRepository;
    // this.processoMapper = processoMapper;
    // this.aiService = aiService;
    // this.s3Service = s3Service;
    // }

    /**
     * Cria um novo processo judicial ou administrativo.
     * Regras de Negócio:
     * - Associa o processo ao tenant atual.
     * - Define o status inicial do processo.
     *
     * @param requestDTO DTO com os dados do processo.
     * @return DTO do processo criado.
     */
    // @Transactional
    // public ProcessoResponseDTO createProcesso(ProcessoRequestDTO requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoMapper.toEntity(requestDTO);
    // processo.setTenantId(tenantId);
    // processo.setStatus("INICIADO"); // Regra de Negócio: Status inicial
    //
    // processo = processoRepository.save(processo);
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Atualiza um processo existente.
     * Regras de Negócio:
     * - O processo deve existir e pertencer ao tenant atual.
     *
     * @param id         ID do processo.
     * @param requestDTO DTO com os dados para atualização.
     * @return DTO do processo atualizado.
     */
    // @Transactional
    // public ProcessoResponseDTO updateProcesso(UUID id, ProcessoRequestDTO
    // requestDTO) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // processoMapper.updateEntityFromDto(requestDTO, existingProcesso);
    // existingProcesso = processoRepository.save(existingProcesso);
    // return processoMapper.toResponseDTO(existingProcesso);
    // }

    /**
     * Busca um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo.
     * @return DTO do processo.
     */
    // public ProcessoResponseDTO findProcessoById(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo processo = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // return processoMapper.toResponseDTO(processo);
    // }

    /**
     * Lista todos os processos de um tenant.
     *
     * @return Lista de DTOs de processos.
     */
    // public List<ProcessoResponseDTO> findAllProcessos() {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // return processoRepository.findAllByTenantId(tenantId).stream()
    // .map(processoMapper::toResponseDTO)
    // .collect(Collectors.toList());
    // }

    /**
     * Deleta um processo pelo ID.
     * Regras de Negócio:
     * - O processo deve pertencer ao tenant atual.
     *
     * @param id ID do processo a ser deletado.
     */
    // @Transactional
    // public void deleteProcesso(UUID id) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    //
    // Processo existingProcesso = processoRepository.findById(id)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para deleção."));
    //
    // if (!existingProcesso.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Regra de Negócio: Verificar se o processo pode ser deletado (ex: não tem
    // atividades pendentes)
    // // if (hasPendingActivities(existingProcesso)) {
    // // throw new BusinessException(ErrorCode.RECURSO_EM_USO, HttpStatus.CONFLICT,
    // "Processo possui atividades pendentes e não pode ser deletado.");
    // // }
    //
    // processoRepository.deleteById(id);
    // }

    /**
     * Gera um rascunho de petição utilizando IA (OpenAI GPT).
     * Regras de Negócio:
     * - O profissional deve ter permissão e estar em um plano que suporte IA.
     * - A IA gera um texto baseado nas informações do processo.
     *
     * @param processoId ID do processo para o qual a petição será gerada.
     * @param prompt     Instruções adicionais para a IA.
     * @return O rascunho da petição gerado pela IA.
     */
    // public String generatePeticaoWithAI(UUID processoId, String prompt) {
    // UUID tenantId = TenantContext.getCurrentTenantId();
    // // Verifica se o usuário logado tem permissão e plano para usar IA
    // // Profissional profissional =
    // profissionalService.findProfissionalById(userIdFromSecurityContext);
    // // if (!profissional.getPlano().supportsAI()) { ... }
    //
    // Processo processo = processoRepository.findById(processoId)
    // .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA,
    // HttpStatus.NOT_FOUND, "Processo não encontrado para geração de petição."));
    //
    // if (!processo.getTenantId().equals(tenantId)) {
    // throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
    // "Acesso negado. Processo pertence a outro tenant.");
    // }
    //
    // // Montar o prompt completo para a IA com base nos dados do processo
    // String fullPrompt = String.format("Crie um rascunho de petição para o
    // processo '%s' (Tipo: %s, Partes: %s). Contexto: %s. %s",
    // processo.getNumero(), processo.getTipo(), processo.getPartes(),
    // processo.getDescricao(), prompt);
    //
    // // Chamada ao serviço de IA
    // String generatedText = aiService.generateText(fullPrompt);
    //
    // return generatedText;
    // }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.request.ProfissionalCreateRequest;
import br.com.legalconnect.advogado.application.dto.request.ProfissionalUpdateRequest;
import br.com.legalconnect.advogado.application.dto.response.ProfissionalResponseDTO;
import br.com.legalconnect.advogado.application.mapper.AreaAtuacaoMapper;
import br.com.legalconnect.advogado.application.mapper.CertificacaoMapper;
import br.com.legalconnect.advogado.application.mapper.DocumentoMapper;
import br.com.legalconnect.advogado.application.mapper.ExperienciaProfissionalMapper;
import br.com.legalconnect.advogado.application.mapper.FormacaoAcademicaMapper;
import br.com.legalconnect.advogado.application.mapper.IdiomaMapper;
import br.com.legalconnect.advogado.application.mapper.LocalAtuacaoMapper;
import br.com.legalconnect.advogado.application.mapper.ProfissionalMapper;
import br.com.legalconnect.advogado.application.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.Certificacao;
import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissional;
import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademica;
import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import br.com.legalconnect.advogado.domain.repository.AreaAtuacaoRepository;
import br.com.legalconnect.advogado.domain.repository.CertificacaoRepository;
import br.com.legalconnect.advogado.domain.repository.DocumentoRepository;
import br.com.legalconnect.advogado.domain.repository.ExperienciaRepository;
import br.com.legalconnect.advogado.domain.repository.FormacaoRepository;
import br.com.legalconnect.advogado.domain.repository.IdiomaRepository;
import br.com.legalconnect.advogado.domain.repository.LocalAtuacaoRepository;
import br.com.legalconnect.advogado.domain.repository.ProfissionalRepository;
import br.com.legalconnect.advogado.domain.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.service.PessoaService;
import br.com.legalconnect.commom.service.S3Service; // Assumindo S3Service para upload de documentos
import br.com.legalconnect.commom.service.TenantContext; // Assumindo TenantContext para multitenancy
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão completa do Profissional (Advogado).
 * Inclui operações de CRUD, validações de negócio e orquestração com serviços
 * de entidades aninhadas
 * e dados mestre. Gerencia também o upload de documentos e a associação com o
 * tenant.
 */
@Service
public class ProfissionalService {

    private final ProfissionalRepository profissionalRepository;
    private final ProfissionalMapper profissionalMapper;
    private final PessoaService pessoaService; // Para gerenciar a entidade Pessoa
    private final CertificacaoMapper certificacaoMapper;
    private final ExperienciaProfissionalMapper experienciaProfissionalMapper;
    private final FormacaoAcademicaMapper formacaoAcademicaMapper;
    private final DocumentoMapper documentoMapper;
    private final CertificacaoRepository certificacaoRepository;
    private final ExperienciaRepository experienciaRepository;
    private final FormacaoRepository formacaoRepository;
    private final DocumentoRepository documentoRepository;
    private final S3Service s3Service; // Serviço para integração com S3
    private final AreaAtuacaoRepository areaAtuacaoRepository;
    private final IdiomaRepository idiomaRepository;
    private final LocalAtuacaoRepository localAtuacaoRepository;
    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final AreaAtuacaoMapper areaAtuacaoMapper;
    private final IdiomaMapper idiomaMapper;
    private final LocalAtuacaoMapper localAtuacaoMapper;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public ProfissionalService(ProfissionalRepository profissionalRepository,
            ProfissionalMapper profissionalMapper,
            PessoaService pessoaService,
            CertificacaoMapper certificacaoMapper,
            ExperienciaProfissionalMapper experienciaProfissionalMapper,
            FormacaoAcademicaMapper formacaoAcademicaMapper,
            DocumentoMapper documentoMapper,
            CertificacaoRepository certificacaoRepository,
            ExperienciaRepository experienciaRepository,
            FormacaoRepository formacaoRepository,
            DocumentoRepository documentoRepository,
            S3Service s3Service,
            AreaAtuacaoRepository areaAtuacaoRepository,
            IdiomaRepository idiomaRepository,
            LocalAtuacaoRepository localAtuacaoRepository,
            TipoAtendimentoRepository tipoAtendimentoRepository,
            AreaAtuacaoMapper areaAtuacaoMapper,
            IdiomaMapper idiomaMapper,
            LocalAtuacaoMapper localAtuacaoMapper,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.profissionalRepository = profissionalRepository;
        this.profissionalMapper = profissionalMapper;
        this.pessoaService = pessoaService;
        this.certificacaoMapper = certificacaoMapper;
        this.experienciaProfissionalMapper = experienciaProfissionalMapper;
        this.formacaoAcademicaMapper = formacaoAcademicaMapper;
        this.documentoMapper = documentoMapper;
        this.certificacaoRepository = certificacaoRepository;
        this.experienciaRepository = experienciaRepository;
        this.formacaoRepository = formacaoRepository;
        this.documentoRepository = documentoRepository;
        this.s3Service = s3Service;
        this.areaAtuacaoRepository = areaAtuacaoRepository;
        this.idiomaRepository = idiomaRepository;
        this.localAtuacaoRepository = localAtuacaoRepository;
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.areaAtuacaoMapper = areaAtuacaoMapper;
        this.idiomaMapper = idiomaMapper;
        this.localAtuacaoMapper = localAtuacaoMapper;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Cria um novo Profissional no sistema.
     * Regras de Negócio:
     * - Valida a unicidade do número da OAB.
     * - Associa o Profissional a um Tenant (obtido do contexto de segurança).
     * - Cria a entidade Pessoa associada através do PessoaService.
     * - Gerencia a criação de certificações, experiências e formações aninhadas.
     * - Define o status inicial do profissional.
     * - Valida a existência do plano.
     *
     * @param createRequest DTO com os dados para criação do Profissional.
     * @return DTO do Profissional criado.
     * @throws BusinessException se a OAB já estiver cadastrada, ou se o
     *                           plano/tenant não existirem.
     */
    @Transactional
    public ProfissionalResponseDTO createProfissional(ProfissionalCreateRequest createRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo que o tenantId vem do contexto de segurança

        // Regra de Negócio: Validar unicidade da OAB
        if (profissionalRepository.existsByNumeroOab(createRequest.getNumeroOab())) {
            throw new BusinessException(ErrorCode.OAB_DUPLICADA, HttpStatus.CONFLICT, createRequest.getNumeroOab());
        }

        // Regra de Negócio: Validar unicidade da Pessoa (CPF/Email) antes de criar o
        // Profissional
        if (pessoaService.findPessoaByCpf(createRequest.getCpf()).isPresent()) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, createRequest.getCpf());
        }
        if (pessoaService.findPessoaByEmail(createRequest.getUsuario().getEmail()).isPresent()) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    createRequest.getUsuario().getEmail());
        }

        // Criar a Pessoa associada primeiro, pois Profissional estende Pessoa
        PessoaRequestDTO pessoaRequestDTO = new PessoaRequestDTO();
        pessoaRequestDTO.setUsuario(createRequest.getUsuario());
        pessoaRequestDTO.setNomeCompleto(createRequest.getNomeCompleto());
        pessoaRequestDTO.setCpf(createRequest.getCpf());
        pessoaRequestDTO.setDataNascimento(createRequest.getDataNascimento());
        pessoaRequestDTO.setTelefones(createRequest.getTelefones());
        pessoaRequestDTO.setEnderecos(createRequest.getEnderecos());

        Pessoa newPessoa = pessoaService.createPessoa(pessoaRequestDTO);

        // Regra de Negócio: Validar que o planoId existe (assumindo um PlanoService ou
        // repositório de Plano)
        // if (!planoService.existsById(createRequest.getPlanoId())) {
        // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
        // HttpStatus.NOT_FOUND);
        // }

        Profissional profissional = profissionalMapper.toEntity(createRequest);
        profissional.setPessoaId(newPessoa.getId()); // Associa o ID da Pessoa recém-criada
        profissional.setUsuario(newPessoa.getUsuario()); // Garante que o usuário de Pessoa esteja associado
        profissional.setTenantId(tenantId); // Regra de Negócio: Define o tenant do profissional
        profissional.setStatusProfissional("PENDING_APPROVAL"); // Regra de Negócio: Status inicial

        // Relacionamentos muitos-para-muitos (apenas IDs aqui)
        if (createRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            profissional.setLocaisAtuacaoIds(createRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(createRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            profissional.setAreaAtuacaoIds(createRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(createRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            profissional.setIdiomaIds(createRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (createRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(createRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            profissional
                    .setTipoAtendimentoIds(createRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        profissional = profissionalRepository.save(profissional);

        // Gerenciar certificações, experiências e formações
        manageNestedEntities(profissional, createRequest);

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Atualiza um Profissional existente.
     * Regras de Negócio:
     * - Valida a existência do Profissional e do Tenant.
     * - Permite a atualização de dados da Pessoa associada.
     * - Gerencia a adição, atualização e remoção de certificações, experiências e
     * formações.
     * - Atualiza relacionamentos com dados mestre.
     *
     * @param id            ID do Profissional a ser atualizado.
     * @param updateRequest DTO com os dados para atualização.
     * @return DTO do Profissional atualizado.
     * @throws BusinessException se o Profissional não for encontrado, ou por outras
     *                           violações de negócio.
     */
    @Transactional
    public ProfissionalResponseDTO updateProfissional(UUID id, ProfissionalUpdateRequest updateRequest) {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Assumindo tenantId do contexto de segurança

        Profissional existingProfissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para atualização."));

        // Regra de Negócio: O profissional só pode ser atualizado pelo seu próprio
        // tenant
        if (!existingProfissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Atualiza os dados da Pessoa associada (se fornecidos)
        if (updateRequest.getPessoa() != null) {
            pessoaService.updatePessoa(existingProfissional.getPessoaId(), updateRequest.getPessoa());
        }

        // Mapeia os campos atualizáveis para a entidade Profissional
        profissionalMapper.updateEntityFromDto(updateRequest, existingProfissional);

        // Regra de Negócio: Validar que o planoId existe se for alterado
        if (updateRequest.getPlanoId() != null
                && !existingProfissional.getPlanoId().equals(updateRequest.getPlanoId())) {
            // if (!planoService.existsById(updateRequest.getPlanoId())) {
            // throw new BusinessException(ErrorCode.PLANO_NAO_ENCONTRADO,
            // HttpStatus.NOT_FOUND);
            // }
            existingProfissional.setPlanoId(updateRequest.getPlanoId());
        }

        // Atualiza relacionamentos muitos-para-muitos
        if (updateRequest.getLocaisAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getLocaisAtuacaoIds(), localAtuacaoRepository::findById,
                    "Local de Atuação");
            existingProfissional
                    .setLocaisAtuacaoIds(updateRequest.getLocaisAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getAreaAtuacaoIds() != null) {
            validateMasterDataExistence(updateRequest.getAreaAtuacaoIds(), areaAtuacaoRepository::findById,
                    "Área de Atuação");
            existingProfissional
                    .setAreaAtuacaoIds(updateRequest.getAreaAtuacaoIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getIdiomaIds() != null) {
            validateMasterDataExistence(updateRequest.getIdiomaIds(), idiomaRepository::findById, "Idioma");
            existingProfissional.setIdiomaIds(updateRequest.getIdiomaIds().stream().collect(Collectors.toSet()));
        }
        if (updateRequest.getTipoAtendimentoIds() != null) {
            validateMasterDataExistence(updateRequest.getTipoAtendimentoIds(), tipoAtendimentoRepository::findById,
                    "Tipo de Atendimento");
            existingProfissional
                    .setTipoAtendimentoIds(updateRequest.getTipoAtendimentoIds().stream().collect(Collectors.toSet()));
        }

        // Gerenciar coleções aninhadas (certificações, experiências, formações)
        manageNestedEntities(existingProfissional, updateRequest);

        existingProfissional = profissionalRepository.save(existingProfissional);
        return mapToResponseDTOWithDetails(existingProfissional);
    }

    /**
     * Busca um Profissional pelo ID.
     * Regras de Negócio:
     * - Garante que o Profissional pertence ao Tenant do contexto de segurança.
     * - Popula os dados mestre relacionados.
     *
     * @param id ID do Profissional.
     * @return DTO do Profissional com detalhes.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    public ProfissionalResponseDTO findProfissionalById(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        return mapToResponseDTOWithDetails(profissional);
    }

    /**
     * Busca todos os Profissionais de um determinado Tenant.
     *
     * @return Lista de DTOs de Profissionais.
     */
    public List<ProfissionalResponseDTO> findAllProfissionais() {
        UUID tenantId = TenantContext.getCurrentTenantId(); // Filtra por tenant

        List<Profissional> profissionais = profissionalRepository.findAllByTenantId(tenantId);
        return profissionais.stream()
                .map(this::mapToResponseDTOWithDetails)
                .collect(Collectors.toList());
    }

    /**
     * Deleta um Profissional pelo ID.
     * Regras de Negócio:
     * - Apenas o proprietário do tenant pode deletar.
     * - Orquestra a deleção de entidades aninhadas (Certificações, Experiências,
     * Formações, Documentos).
     * - Deleção da Pessoa associada.
     *
     * @param id ID do Profissional a ser deletado.
     * @throws BusinessException se o Profissional não for encontrado ou não
     *                           pertencer ao tenant.
     */
    @Transactional
    public void deleteProfissional(UUID id) {
        UUID tenantId = TenantContext.getCurrentTenantId();

        Profissional profissional = profissionalRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.PROFISSIONAL_NAO_ENCONTRADO, HttpStatus.NOT_FOUND,
                        "Profissional não encontrado para deleção."));

        // Regra de Negócio: Acesso restrito ao tenant
        if (!profissional.getTenantId().equals(tenantId)) {
            throw new BusinessException(ErrorCode.FORBIDDEN_ACCESS, HttpStatus.FORBIDDEN,
                    "Acesso negado. Profissional pertence a outro tenant.");
        }

        // Deleta entidades aninhadas (cascade pode fazer isso, mas explicitar é bom
        // para clareza)
        certificacaoRepository.findAllByProfissionalId(id)
                .forEach(c -> certificacaoRepository.deleteByIdAndProfissionalId(c.getId(), id));
        experienciaRepository.findAllByProfissionalId(id)
                .forEach(e -> experienciaRepository.deleteByIdAndProfissionalId(e.getId(), id));
        formacaoRepository.findAllByProfissionalId(id)
                .forEach(f -> formacaoRepository.deleteByIdAndProfissionalId(f.getId(), id));
        documentoRepository.findAllByProfissionalId(id).forEach(d -> {
            s3Service.deleteFile(d.getUrlS3()); // Deleta arquivo do S3
            documentoRepository.deleteByIdAndProfissionalId(d.getId(), id);
        });

        // Deleta o profissional
        profissionalRepository.deleteById(id);

        // Deleta a pessoa associada
        pessoaService.deletePessoa(profissional.getPessoaId());
    }

    /**
     * Método auxiliar para gerenciar a adição, atualização e remoção de entidades
     * aninhadas
     * (certificações, experiências, formações) para um Profissional.
     *
     * @param profissional O Profissional pai.
     * @param request      O DTO de requisição (Create ou Update) contendo as listas
     *                     aninhadas.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalCreateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Remover certificações que não estão mais no DTO
            profissional.getCertificacoes().removeIf(existingCert -> request.getCertificacoes().stream()
                    .noneMatch(dto -> existingCert.getId().equals(dto.getId())));
            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        }

        // Experiências Profissionais
        if (request.getExperiencias() != null) {
            profissional.getExperiencias().removeIf(existingExp -> request.getExperiencias().stream()
                    .noneMatch(dto -> existingExp.getId().equals(dto.getId())));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) { // Nova experiência
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else { // Atualizar experiência existente
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        }

        // Formações Acadêmicas
        if (request.getFormacoes() != null) {
            profissional.getFormacoes().removeIf(existingForm -> request.getFormacoes().stream()
                    .noneMatch(dto -> existingForm.getId().equals(dto.getId())));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova formação
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else { // Atualizar formação existente
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        }
    }

    /**
     * Sobrecarga para o método de gerenciamento de entidades aninhadas para
     * ProfissionalUpdateRequest.
     */
    private void manageNestedEntities(Profissional profissional, ProfissionalUpdateRequest request) {
        UUID tenantId = profissional.getTenantId();

        // Certificações
        if (request.getCertificacoes() != null) {
            // Coleta IDs das certificações no DTO para identificar as que serão removidas
            Set<UUID> dtoCertIds = request.getCertificacoes().stream()
                    .map(c -> c.getId())
                    .collect(Collectors.toSet());

            // Remove certificações que existem na entidade mas não no DTO (deleção)
            profissional.getCertificacoes().removeIf(
                    existingCert -> existingCert.getId() != null && !dtoCertIds.contains(existingCert.getId()));

            request.getCertificacoes().forEach(dto -> {
                if (dto.getId() == null) { // Nova certificação (ID nulo indica novo)
                    Certificacao newCert = certificacaoMapper.toEntity(dto);
                    newCert.setProfissional(profissional);
                    newCert.setTenantId(tenantId);
                    profissional.getCertificacoes().add(newCert);
                } else { // Atualizar certificação existente
                    profissional.getCertificacoes().stream()
                            .filter(c -> c.getId() != null && c.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(c -> certificacaoMapper.updateEntityFromDto(dto, c));
                }
            });
        } else {
            // Se a lista no DTO for nula, assume-se que todas as certificações devem ser
            // removidas
            profissional.getCertificacoes().clear();
        }

        // Experiências Profissionais (lógica similar às certificações)
        if (request.getExperiencias() != null) {
            Set<UUID> dtoExpIds = request.getExperiencias().stream()
                    .map(e -> e.getId())
                    .collect(Collectors.toSet());
            profissional.getExperiencias()
                    .removeIf(existingExp -> existingExp.getId() != null && !dtoExpIds.contains(existingExp.getId()));
            request.getExperiencias().forEach(dto -> {
                if (dto.getId() == null) {
                    ExperienciaProfissional newExp = experienciaProfissionalMapper.toEntity(dto);
                    newExp.setProfissional(profissional);
                    newExp.setTenantId(tenantId);
                    profissional.getExperiencias().add(newExp);
                } else {
                    profissional.getExperiencias().stream()
                            .filter(e -> e.getId() != null && e.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> experienciaProfissionalMapper.updateEntityFromDto(dto, e));
                }
            });
        } else {
            profissional.getExperiencias().clear();
        }

        // Formações Acadêmicas (lógica similar às certificações)
        if (request.getFormacoes() != null) {
            Set<UUID> dtoFormIds = request.getFormacoes().stream()
                    .map(f -> f.getId())
                    .collect(Collectors.toSet());
            profissional.getFormacoes().removeIf(
                    existingForm -> existingForm.getId() != null && !dtoFormIds.contains(existingForm.getId()));
            request.getFormacoes().forEach(dto -> {
                if (dto.getId() == null) {
                    FormacaoAcademica newForm = formacaoAcademicaMapper.toEntity(dto);
                    newForm.setProfissional(profissional);
                    newForm.setTenantId(tenantId);
                    profissional.getFormacoes().add(newForm);
                } else {
                    profissional.getFormacoes().stream()
                            .filter(f -> f.getId() != null && f.getId().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(f -> formacaoAcademicaMapper.updateEntityFromDto(dto, f));
                }
            });
        } else {
            profissional.getFormacoes().clear();
        }
    }

    /**
     * Mapeia um Profissional para ProfissionalResponseDTO e popula os dados mestre
     * relacionados.
     * Esta é uma funcionalidade completa para apresentar o perfil do advogado.
     *
     * @param profissional A entidade Profissional.
     * @return O DTO de resposta detalhado.
     */
    private ProfissionalResponseDTO mapToResponseDTOWithDetails(Profissional profissional) {
        ProfissionalResponseDTO responseDTO = profissionalMapper.toResponseDTO(profissional);

        // Popula listas de DTOs de dados mestre
        responseDTO.setLocaisAtuacao(
                localAtuacaoRepository.findAllById(profissional.getLocaisAtuacaoIds())
                        .stream()
                        .map(localAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setAreasAtuacao(
                areaAtuacaoRepository.findAllById(profissional.getAreaAtuacaoIds())
                        .stream()
                        .map(areaAtuacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setIdiomas(
                idiomaRepository.findAllById(profissional.getIdiomaIds())
                        .stream()
                        .map(idiomaMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setTiposAtendimento(
                tipoAtendimentoRepository.findAllById(profissional.getTipoAtendimentoIds())
                        .stream()
                        .map(tipoAtendimentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Popula as coleções aninhadas
        responseDTO.setCertificacoes(
                profissional.getCertificacoes().stream()
                        .map(certificacaoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setDocumentos(
                profissional.getDocumentos().stream()
                        .map(documentoMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setExperiencias(
                profissional.getExperiencias().stream()
                        .map(experienciaProfissionalMapper::toResponseDTO)
                        .collect(Collectors.toList()));
        responseDTO.setFormacoes(
                profissional.getFormacoes().stream()
                        .map(formacaoAcademicaMapper::toResponseDTO)
                        .collect(Collectors.toList()));

        // Define se faz parte de plano com base no planoId (regra de negócio)
        responseDTO.setFazParteDePlano(profissional.getPlanoId() != null); // Simplificado

        return responseDTO;
    }

    /**
     * Valida a existência de entidades de dados mestre.
     *
     * @param ids        Lista de UUIDs a serem validados.
     * @param finder     Função para encontrar a entidade por ID.
     * @param entityName Nome da entidade para mensagens de erro.
     * @param <T>        Tipo da entidade.
     */
    private <T> void validateMasterDataExistence(List<UUID> ids,
            java.util.function.Function<UUID, java.util.Optional<T>> finder, String entityName) {
        for (UUID id : ids) {
            if (finder.apply(id).isEmpty()) {
                throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        entityName + " com ID " + id + " não encontrado(a).");
            }
        }
    }
}
```
```java
package br.com.legalconnect.advogado.application.service;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.application.dto.response.TipoAtendimentoResponseDTO;
import br.com.legalconnect.advogado.application.mapper.TipoAtendimentoMapper;
import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimento;
import br.com.legalconnect.advogado.domain.repository.TipoAtendimentoRepository;
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;

/**
 * Serviço para gestão de Tipos de Atendimento (dados mestre).
 */
@Service
public class TipoAtendimentoService {

    private final TipoAtendimentoRepository tipoAtendimentoRepository;
    private final TipoAtendimentoMapper tipoAtendimentoMapper;

    @Autowired
    public TipoAtendimentoService(TipoAtendimentoRepository tipoAtendimentoRepository,
            TipoAtendimentoMapper tipoAtendimentoMapper) {
        this.tipoAtendimentoRepository = tipoAtendimentoRepository;
        this.tipoAtendimentoMapper = tipoAtendimentoMapper;
    }

    /**
     * Busca um Tipo de Atendimento pelo ID.
     *
     * @param id ID do Tipo de Atendimento.
     * @return DTO do Tipo de Atendimento.
     * @throws BusinessException se o Tipo de Atendimento não for encontrado.
     */
    public TipoAtendimentoResponseDTO findTipoAtendimentoById(UUID id) {
        TipoAtendimento tipoAtendimento = tipoAtendimentoRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Tipo de Atendimento não encontrado."));
        return tipoAtendimentoMapper.toResponseDTO(tipoAtendimento);
    }

    /**
     * Lista todos os Tipos de Atendimento.
     *
     * @return Lista de DTOs de Tipos de Atendimento.
     */
    public List<TipoAtendimentoResponseDTO> findAllTiposAtendimento() {
        return tipoAtendimentoRepository.findAll().stream()
                .map(tipoAtendimentoMapper::toResponseDTO)
                .collect(Collectors.toList());
    }
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_area_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class AreaAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_certificacao_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Certificacao extends BaseEntity {

    @Column(name = "nome", nullable = false, length = 255)
    private String nome;

    @Column(name = "instituicao", length = 255)
    private String instituicao;

    @Column(name = "data_conclusao")
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional; // Referência à entidade JPA ProfissionalEntity

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_documento_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Documento extends BaseEntity {

    @Column(name = "nome_arquivo", nullable = false, length = 255)
    private String nomeArquivo;

    @Column(name = "url_s3", nullable = false, length = 500)
    private String urlS3;

    @Column(name = "tipo_documento", nullable = false, length = 100)
    private String tipoDocumento; // Mapeia o enum DocumentoTipo como String

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_experiencia_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class ExperienciaProfissional extends BaseEntity {

    @Column(name = "cargo", nullable = false, length = 255)
    private String cargo;

    @Column(name = "empresa", nullable = false, length = 255)
    private String empresa;

    @Column(name = "data_inicio", nullable = false)
    private LocalDate dataInicio;

    @Column(name = "data_fim")
    private LocalDate dataFim;

    @Column(name = "descricao", columnDefinition = "TEXT")
    private String descricao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.time.LocalDate;
import java.util.UUID;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_formacao_academica")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class FormacaoAcademica extends BaseEntity {

    @Column(name = "curso", nullable = false, length = 255)
    private String curso;

    @Column(name = "instituicao", nullable = false, length = 255)
    private String instituicao;

    @Column(name = "data_conclusao", nullable = false)
    private LocalDate dataConclusao;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "profissional_id", nullable = false)
    private Profissional profissional;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_idioma")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Idioma extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 100)
    private String nome;

    @Column(name = "codigo", nullable = false, unique = true, length = 10)
    private String codigo; // Ex: "pt-BR", "en-US"

    @Column(name = "nivel", length = 50)
    private String nivel; // Mapeia o enum NivelIdioma como String
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_local_atuacao")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class LocalAtuacao extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.HashSet;
import java.util.Set;
import java.util.UUID;

import br.com.legalconnect.commom.model.Pessoa;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.JoinTable;
import jakarta.persistence.ManyToMany;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Profissional extends Pessoa {

    @Column(name = "numero_oab", nullable = false, unique = true, length = 50)
    private String numeroOab;

    @Column(name = "status_profissional", nullable = false, length = 50)
    private String statusProfissional; // Mapeia o enum do domínio (StatusProfissional) como String

    @Column(name = "usa_marketplace", nullable = false)
    private Boolean usaMarketplace = false;

    @Column(name = "faz_parte_de_plano", nullable = false)
    private Boolean fazParteDePlano = false;

    @Column(name = "pessoa_id", nullable = false, unique = true)
    private UUID pessoaId; // Referência ao ID da Pessoa (do Person Service)

    @Column(name = "empresa_id")
    private UUID empresaId; // Referência ao ID da Empresa (do Company Service)

    @Column(name = "plano_id", nullable = false)
    private UUID planoId; // Referência ao ID do Plano (do Subscription Service)

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId; // Para isolamento de dados por tenant

    // Relacionamentos com entidades que residem no mesmo Professional Service
    // (infraestrutura)
    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Certificacao> certificacoes = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Documento> documentos = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<ExperienciaProfissional> experiencias = new HashSet<>();

    @OneToMany(mappedBy = "profissional", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<FormacaoAcademica> formacoes = new HashSet<>();

    // Tabela de junção para locais de atuação (muitos-para-muitos com IDs de Master
    // Data)
    // Se LocalAtuacao for um serviço separado, esta é a forma correta de
    // referenciar por ID.
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_local_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "local_atuacao_id", nullable = false)
    private Set<UUID> locaisAtuacaoIds = new HashSet<>();

    // Tabela de junção para áreas de atuação (muitos-para-muitos com IDs de Master
    // Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_area_atuacao", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "area_atuacao_id", nullable = false)
    private Set<UUID> areaAtuacaoIds = new HashSet<>();

    // Tabela de junção para idiomas (muitos-para-muitos com IDs de Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_idioma", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "idioma_id", nullable = false)
    private Set<UUID> idiomaIds = new HashSet<>();

    // Tabela de junção para tipos de atendimento (muitos-para-muitos com IDs de
    // Master Data)
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_profissional_tipo_atendimento", joinColumns = @JoinColumn(name = "profissional_id"))
    @Column(name = "tipo_atendimento_id", nullable = false)
    private Set<UUID> tipoAtendimentoIds = new HashSet<>();

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(name = "tb_profissional_roles", joinColumns = @JoinColumn(name = "profissional_id"), inverseJoinColumns = @JoinColumn(name = "role_profissional_id"))
    private Set<RoleProfissional> roleProfissionals = new HashSet<>();
}
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import java.util.UUID;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_role_profissional")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class RoleProfissional extends BaseEntity {

    @Column(name = "name", nullable = false, unique = true, length = 50)
    private String name;

    @Column(name = "tenant_id", nullable = false)
    private UUID tenantId;
}

// --- Entidades de Dados Mestres (se gerenciadas localmente no Professional
// Service) ---
// NOTA: Se estas entidades residirem em um "Master Data Service" separado e o
// Professional Service
// apenas referenciar seus IDs, então estas classes de entidade não estariam
// aqui.
// Elas são incluídas assumindo que o Professional Service pode ter uma cópia
// local ou gerenciar
// essas entidades para seu próprio contexto.
```
```java
package br.com.legalconnect.advogado.domain.modal.entity;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

@Entity
@Table(name = "tb_tipo_atendimento")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class TipoAtendimento extends BaseEntity {

    @Column(name = "nome", nullable = false, unique = true, length = 255)
    private String nome;
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.modal.entity.AreaAtuacao;

@Repository
public interface AreaAtuacaoRepository extends JpaRepository<AreaAtuacao, UUID> {

    /**
     * Busca uma Área de Atuação pelo nome.
     *
     * @param nome O nome da área de atuação.
     * @return Um Optional contendo a Área de Atuação, se encontrada.
     */
    Optional<AreaAtuacao> findByNome(String nome);

    /**
     * 
     * Busca todas as Áreas de Atuação por uma lista de IDs.
     * 
     * @param ids Lista de IDs das áreas de atuação.
     * 
     * @return Uma lista de Áreas de Atuação.
     */
    List<AreaAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.modal.entity.Certificacao;

/**
 * Repositório para a entidade {@link Certificacao}.
 * Gerencia operações de persistência para as certificações de um profissional.
 */
@Repository
public interface CertificacaoRepository extends JpaRepository<Certificacao, UUID> {

    /**
     * Busca uma Certificação pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Certificação, se encontrada.
     */
    Optional<Certificacao> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Certificações de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Certificações.
     */
    List<Certificacao> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Certificação pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da certificação.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.Documento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Documento}.
 * Gerencia operações de persistência para os documentos de um profissional.
 */
@Repository
public interface DocumentoRepository extends JpaRepository<Documento, UUID> {

    /**
     * Busca um Documento pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id O ID do documento.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo o Documento, se encontrado.
     */
    Optional<Documento> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todos os Documentos de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Documentos.
     */
    List<Documento> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta um Documento pelo seu ID e pelo ID do Profissional.
     *
     * @param id O ID do documento.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissional;

/**
 * Repositório para a entidade {@link ExperienciaProfissional}.
 * Gerencia operações de persistência para as experiências profissionais de um
 * profissional.
 * O método 'save' é automaticamente fornecido por JpaRepository, não deve ser
 * declarado explicitamente aqui com parâmetros extras.
 */
@Repository
public interface ExperienciaProfissionalRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    /**
     * Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional
     * associado.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Experiência Profissional, se encontrada.
     */
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Experiências Profissionais de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Experiências Profissionais.
     */
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
     *
     * @param id             O ID da experiência profissional.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);

    // IMPORTANTE: NÃO HÁ MÉTODO 'save' EXPLICITAMENTE DECLARADO AQUI.
    // Ele é herdado de JpaRepository e tem a assinatura: S save(S entity);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.modal.entity.ExperienciaProfissional;

@Repository
public interface ExperienciaRepository extends JpaRepository<ExperienciaProfissional, UUID> {

    // Busca uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    Optional<ExperienciaProfissional> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Experiências Profissionais de um Profissional.
    List<ExperienciaProfissional> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Experiência Profissional pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademica;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link FormacaoAcademica}.
 * Gerencia operações de persistência para as formações acadêmicas de um profissional.
 */
@Repository
public interface FormacaoAcademicaRepository extends JpaRepository<FormacaoAcademica, UUID> {

    /**
     * Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional associado.
     *
     * @param id O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     * @return Um Optional contendo a Formação Acadêmica, se encontrada.
     */
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    /**
     * Busca todas as Formações Acadêmicas de um Profissional.
     *
     * @param profissionalId O ID do profissional.
     * @return Uma lista de Formações Acadêmicas.
     */
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    /**
     * Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
     *
     * @param id O ID da formação acadêmica.
     * @param profissionalId O ID do profissional.
     */
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import br.com.legalconnect.advogado.domain.modal.entity.FormacaoAcademica;

@Repository
public interface FormacaoRepository extends JpaRepository<FormacaoAcademica, UUID> {

    // Busca uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    Optional<FormacaoAcademica> findByIdAndProfissionalId(UUID id, UUID profissionalId);

    // Busca todas as Formações Acadêmicas de um Profissional.
    List<FormacaoAcademica> findAllByProfissionalId(UUID profissionalId);

    // Deleta uma Formação Acadêmica pelo seu ID e pelo ID do Profissional.
    void deleteByIdAndProfissionalId(UUID id, UUID profissionalId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.Idioma;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link Idioma}.
 * Gerencia operações de persistência para os idiomas disponíveis.
 */
@Repository
public interface IdiomaRepository extends JpaRepository<Idioma, UUID> {

    /**
     * Busca um Idioma pelo nome.
     *
     * @param nome O nome do idioma.
     * @return Um Optional contendo o Idioma, se encontrado.
     */
    Optional<Idioma> findByNome(String nome);

    /**
     * Busca todos os Idiomas por uma lista de IDs.
     * @param ids Lista de IDs dos idiomas.
     * @return Uma lista de Idiomas.
     */
    List<Idioma> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacao;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link LocalAtuacao}.
 * Gerencia operações de persistência para os locais de atuação dos profissionais.
 */
@Repository
public interface LocalAtuacaoRepository extends JpaRepository<LocalAtuacao, UUID> {

    /**
     * Busca um Local de Atuação pelo nome.
     *
     * @param nome O nome do local de atuação.
     * @return Um Optional contendo o Local de Atuação, se encontrado.
     */
    Optional<LocalAtuacao> findByNome(String nome);

    /**
     * Busca todos os Locais de Atuação por uma lista de IDs.
     * @param ids Lista de IDs dos locais de atuação.
     * @return Uma lista de Locais de Atuação.
     */
    List<LocalAtuacao> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.Profissional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Profissional}.
 * Gerencia operações de persistência para os profissionais (advogados).
 */
@Repository
public interface ProfissionalRepository extends JpaRepository<Profissional, UUID> {

    /**
     * Busca um Profissional pelo número da OAB.
     *
     * @param numeroOab O número da OAB do profissional.
     * @return Um Optional contendo o Profissional, se encontrado.
     */
    Optional<Profissional> findByNumeroOab(String numeroOab);

    /**
     * Busca todos os Profissionais associados a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de Profissionais.
     */
    List<Profissional> findAllByTenantId(UUID tenantId);

    /**
     * Verifica se um Profissional existe pelo número da OAB.
     * Regra de Negócio: Garante a unicidade do número da OAB.
     *
     * @param numeroOab O número da OAB a ser verificado.
     * @return true se um Profissional com a OAB já existe, false caso contrário.
     */
    boolean existsByNumeroOab(String numeroOab);

    /**
     * Verifica se um Profissional existe pelo ID da pessoa associada.
     *
     * @param pessoaId O ID da pessoa.
     * @return true se um Profissional com o ID da pessoa existe, false caso contrário.
     */
    boolean existsByPessoaId(UUID pessoaId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.RoleProfissional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link RoleProfissional}.
 * Gerencia operações de persistência para os papéis (roles) dos profissionais.
 */
@Repository
public interface RoleProfissionalRepository extends JpaRepository<RoleProfissional, UUID> {

    /**
     * Busca uma Role de Profissional pelo nome.
     *
     * @param name O nome da role.
     * @return Um Optional contendo a RoleProfissional, se encontrada.
     */
    Optional<RoleProfissional> findByName(String name);

    /**
     * Busca todas as Roles de Profissional associadas a um determinado tenant.
     *
     * @param tenantId O ID do tenant.
     * @return Uma lista de RoleProfissional.
     */
    List<RoleProfissional> findAllByTenantId(UUID tenantId);
}
```
```java
package br.com.legalconnect.advogado.domain.repository;

import br.com.legalconnect.advogado.domain.modal.entity.TipoAtendimento;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;
import java.util.List;

/**
 * Repositório para a entidade {@link TipoAtendimento}.
 * Gerencia operações de persistência para os tipos de atendimento disponíveis.
 */
@Repository
public interface TipoAtendimentoRepository extends JpaRepository<TipoAtendimento, UUID> {

    /**
     * Busca um Tipo de Atendimento pelo nome.
     *
     * @param nome O nome do tipo de atendimento.
     * @return Um Optional contendo o TipoAtendimento, se encontrado.
     */
    Optional<TipoAtendimento> findByNome(String nome);

    /**
     * Busca todos os Tipos de Atendimento por uma lista de IDs.
     * @param ids Lista de IDs dos tipos de atendimento.
     * @return Uma lista de Tipos de Atendimento.
     */
    List<TipoAtendimento> findAllByIdIn(List<UUID> ids);
}
```
```java
package br.com.legalconnect.commom.dto.request; // Assumindo um pacote common.dto.request para entidades comuns

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoRequestDTO {
    // ID é opcional para atualização (usado em PUT/PATCH)
    private String id; // Pode ser UUID ou String, dependendo da BaseEntity

    @NotBlank(message = "O logradouro é obrigatório.")
    @Size(max = 255, message = "O logradouro deve ter no máximo 255 caracteres.")
    private String logradouro;

    @NotBlank(message = "O número é obrigatório.")
    @Size(max = 20, message = "O número deve ter no máximo 20 caracteres.")
    private String numero;

    @Size(max = 255, message = "O complemento deve ter no máximo 255 caracteres.")
    private String complemento;

    @NotBlank(message = "O bairro é obrigatório.")
    @Size(max = 100, message = "O bairro deve ter no máximo 100 caracteres.")
    private String bairro;

    @NotBlank(message = "A cidade é obrigatória.")
    @Size(max = 100, message = "A cidade deve ter no máximo 100 caracteres.")
    private String cidade;

    @NotBlank(message = "O estado é obrigatório.")
    @Size(max = 2, message = "O estado deve ter 2 caracteres (UF).")
    private String estado;

    @NotBlank(message = "O CEP é obrigatório.")
    @Size(max = 9, message = "O CEP deve ter no máximo 9 caracteres.") // Com ou sem máscara
    private String cep;

    @Size(max = 50, message = "O país deve ter no máximo 50 caracteres.")
    private String pais; // Valor padrão "Brasil" pode ser setado no serviço

    @NotNull(message = "O tipo de endereço é obrigatório.")
    private TipoEndereco tipoEndereco; // Usando o enum da entidade
}
```
```java
package br.com.legalconnect.commom.dto.request;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PastOrPresent;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * DTO para requisição de criação ou atualização de uma Pessoa.
 * Inclui campos de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class PessoaRequestDTO {
    // ID é opcional para atualização (usado em PUT/PATCH para identificar a Pessoa)
    private UUID id;

    @Valid
    @NotNull(message = "As informações do usuário são obrigatórias.")
    private UserRequestDTO usuario; // Informações de login e contato do usuário

    @NotBlank(message = "O nome completo da pessoa é obrigatório.")
    @Size(max = 255, message = "O nome completo da pessoa deve ter no máximo 255 caracteres.")
    private String nomeCompleto;

    @NotBlank(message = "O CPF da pessoa é obrigatório.")
    @Size(min = 11, max = 14, message = "O CPF deve ter entre 11 e 14 caracteres (com ou sem formatação).")
    @Pattern(regexp = "^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$|^\\d{11}$", message = "Formato de CPF inválido. Use '000.000.000-00' ou apenas dígitos.")
    private String cpf;

    @NotNull(message = "A data de nascimento da pessoa é obrigatória.")
    @PastOrPresent(message = "A data de nascimento não pode ser uma data futura.")
    private LocalDate dataNascimento;

    @Size(max = 10, message = "A lista de telefones não pode exceder 10 itens.")
    private List<String> telefones;

    @Valid
    private List<EnderecoRequestDTO> enderecos; // Lista de endereços associados à pessoa
}
```
```java
package br.com.legalconnect.commom.dto.request;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para requisição de criação ou atualização de um usuário.
 *
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserRequestDTO {
    // ID é opcional para atualização (usado em PUT/PATCH)
    private String id;

    @NotBlank(message = "O e-mail do usuário é obrigatório.")
    @Email(message = "Formato de e-mail inválido.")
    @Size(max = 255, message = "O e-mail do usuário deve ter no máximo 255 caracteres.")
    private String email;

    @Size(min = 8, max = 255, message = "A senha do usuário deve ter no mínimo 8 caracteres.")
    // @NotBlank(message = "A senha do usuário é obrigatória.") // Pode ser @NotBlank apenas na criação
    private String senha; // Em requisições, a senha é enviada em texto limpo para ser hashed no backend

    @Size(max = 255, message = "O nome completo do usuário deve ter no máximo 255 caracteres.")
    private String nomeCompleto; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 14, message = "O CPF deve ter no máximo 14 caracteres.")
    private String cpf; // Campo duplicado com Pessoa, se Pessoa for a principal

    @Size(max = 20, message = "O telefone do usuário deve ter no máximo 20 caracteres.")
    private String telefone; // Campo duplicado com Pessoa, se Pessoa for a principal

    private String fotoUrl; // URL para a foto de perfil
}
```
```java
package br.com.legalconnect.commom.dto.response; // Assumindo um pacote common.dto.response para entidades comuns

import java.util.UUID;

import br.com.legalconnect.commom.model.Endereco.TipoEndereco; // Importar o enum TipoEndereco da entidade Endereco
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de Endereço.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class EnderecoResponseDTO {
    private UUID id;

    private String logradouro;

    private String numero;

    private String complemento;

    private String bairro;

    private String cidade;

    private String estado;

    private String cep;

    private String pais;

    private TipoEndereco tipoEndereco;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de uma Pessoa.
 * Inclui informações de User e uma lista de Endereços.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class PessoaResponseDTO {
    private UUID id;

    private UserResponseDTO usuario;

    private String nomeCompleto;

    private String cpf;

    private LocalDate dataNascimento;

    private List<String> telefones;

    private List<EnderecoResponseDTO> enderecos;
}
```
```java
package br.com.legalconnect.commom.dto.response;

import java.util.UUID;

import br.com.legalconnect.commom.model.User.UserStatus; // Importar o enum UserStatus da entidade User
import br.com.legalconnect.commom.model.User.UserType; // Importar o enum UserType da entidade User
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

/**
 * DTO para resposta de um usuário.
 * Não inclui a senha hash por questões de segurança.
 * 
 */
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class UserResponseDTO {
    private UUID id;
    private String nomeCompleto;
    private String email;
    private String cpf;
    private String telefone;
    private String fotoUrl;
    private UserType userType; // Tipo de usuário (CLIENTE, ADVOGADO, etc.)
    private UserStatus userStatus; // Status da conta do usuário
}
```
```java
package br.com.legalconnect.commom.mapper;

import br.com.legalconnect.commom.dto.request.EnderecoRequestDTO;
import br.com.legalconnect.commom.dto.response.EnderecoResponseDTO;
import br.com.legalconnect.commom.model.Endereco;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.Named;
import org.mapstruct.factory.Mappers;

import java.util.UUID;

/**
 * Mapper MapStruct para a entidade Endereco e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface EnderecoMapper {
    EnderecoMapper INSTANCE = Mappers.getMapper(EnderecoMapper.class);

    /**
     * Mapeia um EnderecoRequestDTO para uma entidade Endereco.
     * Os campos 'pessoa' e 'empresa' devem ser setados no serviço.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Endereco correspondente.
     */
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true) // Descomente se Empresa for relevante e existir
    @Mapping(target = "id", source = "id", qualifiedByName = "mapStringToUuid")
    Endereco toEntity(EnderecoRequestDTO dto);

    /**
     * Mapeia uma entidade Endereco para um EnderecoResponseDTO.
     *
     * @param entity A entidade Endereco.
     * @return O DTO de resposta correspondente.
     */
    @Mapping(target = "id", source = "id", qualifiedByName = "mapUuidToString")
    EnderecoResponseDTO toResponseDTO(Endereco entity);

    /**
     * Atualiza uma entidade Endereco existente com os dados de um EnderecoRequestDTO.
     * O campo 'pessoa' e 'empresa' não são atualizados via DTO. O ID não deve ser atualizado.
     *
     * @param dto O DTO de requisição com os dados para atualização.
     * @param entity A entidade Endereco a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(target = "pessoa", ignore = true)
    // @Mapping(target = "empresa", ignore = true)
    void updateEntityFromDto(EnderecoRequestDTO dto, @MappingTarget Endereco entity);

    /**
     * Converte uma String (ID do DTO) para um UUID (ID da Entidade).
     * @param id A string representando o UUID.
     * @return O objeto UUID.
     */
    @Named("mapStringToUuid")
    default UUID mapStringToUuid(String id) {
        return id != null ? (id) : null;
    }

    /**
     * Converte um UUID (ID da Entidade) para uma String (ID do DTO).
     * @param id O objeto UUID.
     * @return A string representando o UUID.
     */
    @Named("mapUuidToString")
    default String mapUuidToString(UUID id) {
        return id != null ? id.toString() : null;
    }
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.model.Pessoa;

/**
 * Mapper MapStruct para a entidade Pessoa e seus DTOs.
 * Utiliza UserMapper e EnderecoMapper para mapeamentos aninhados.
 */
@Mapper(componentModel = "spring", uses = { UserMapper.class, EnderecoMapper.class })
public interface PessoaMapper {
    PessoaMapper INSTANCE = Mappers.getMapper(PessoaMapper.class);

    /**
     * Mapeia um PessoaRequestDTO para uma entidade Pessoa.
     * Os campos 'usuario' e 'enderecos' serão mapeados pelos mappers especificados
     * em 'uses'.
     * A conversão de List para Set para 'telefones' é feita automaticamente pelo
     * MapStruct.
     *
     * @param dto O DTO de requisição.
     * @return A entidade Pessoa correspondente.
     */
    // @Mapping(target = "id", ignore = true) // ID da Pessoa será gerado na criação
    // Pessoa toEntity(PessoaRequestDTO dto);

    /**
     * Mapeia uma entidade Pessoa para um PessoaResponseDTO.
     *
     * @param entity A entidade Pessoa.
     * @return O DTO de resposta correspondente.
     */
    PessoaResponseDTO toResponseDTO(Pessoa entity);

    /**
     * Atualiza uma entidade Pessoa existente com os dados de um PessoaRequestDTO.
     * O 'id' da Pessoa não deve ser atualizado.
     * A atualização de 'usuario' e 'enderecos' deve ser orquestrada no serviço,
     * pois o MapStruct pode não ter o contexto para atualizar entidades aninhadas
     * existentes.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade Pessoa a ser atualizada.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "usuario", ignore = true) // O serviço deve gerenciar a atualização do User associado
    @Mapping(target = "enderecos", ignore = true) // O serviço deve gerenciar a atualização dos Enderecos associados
    @Mapping(source = "telefones", target = "telefones") // Converte List<String> para Set<String>
    void updateEntityFromDto(PessoaRequestDTO dto, @MappingTarget Pessoa entity);
}
```
```java
package br.com.legalconnect.commom.mapper;

import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.factory.Mappers;

import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.UserResponseDTO;
import br.com.legalconnect.commom.model.User;

/**
 * Mapper MapStruct para a entidade User e seus DTOs.
 */
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserMapper INSTANCE = Mappers.getMapper(UserMapper.class);

    /**
     * Mapeia um UserRequestDTO para uma entidade User.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' são definidos pela lógica de negócio e ignorados
     * aqui.
     *
     * @param dto O DTO de requisição.
     * @return A entidade User correspondente.
     */
    @Mapping(source = "senha", target = "senhaHash") // Mapeia a senha do DTO para senhaHash na entidade
    // @Mapping(target = "userType", ignore = true) // Definido pela lógica de
    // negócio
    // @Mapping(target = "userStatus", ignore = true) // Definido pela lógica de
    // negócio
    User toEntity(UserRequestDTO dto);

    /**
     * Mapeia uma entidade User para um UserResponseDTO.
     * 'senhaHash' é ignorado na resposta por segurança.
     *
     * @param entity A entidade User.
     * @return O DTO de resposta correspondente.
     */
    // @Mapping(target = "senha", ignore = true) // 'senhaHash' é um campo interno
    // da entidade, não deve ser exposto no DTO de resposta
    UserResponseDTO toResponseDTO(User entity);

    /**
     * Atualiza uma entidade User existente com os dados de um UserRequestDTO.
     * A senha do DTO é mapeada para 'senhaHash' na entidade.
     * 'userType' e 'userStatus' não são atualizados via DTO.
     *
     * @param dto    O DTO de requisição com os dados para atualização.
     * @param entity A entidade User a ser atualizada.
     */
    @Mapping(target = "id", ignore = true) // ID não deve ser atualizado pelo DTO
    @Mapping(source = "senha", target = "senhaHash")
    // @Mapping(target = "userType", ignore = true)
    // @Mapping(target = "userStatus", ignore = true)
    void updateEntityFromDto(UserRequestDTO dto, @MappingTarget User entity);
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.FetchType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Endereco
 * @brief Entidade que representa um endereço detalhado.
 *        Pode ser associada a Pessoas ou Empresas.
 *        Mapeada para a tabela 'tb_endereco'.
 */
@Entity
@Table(name = "tb_endereco")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Endereco extends BaseEntity {

    @Column(name = "logradouro", nullable = false, length = 255)
    private String logradouro; // Nome da rua, avenida, etc.

    @Column(name = "numero", nullable = false, length = 20)
    private String numero; // Número do imóvel

    @Column(name = "complemento", length = 255)
    private String complemento; // Complemento (ex: apto, sala, bloco)

    @Column(name = "bairro", nullable = false, length = 100)
    private String bairro; // Bairro

    @Column(name = "cidade", nullable = false, length = 100)
    private String cidade; // Cidade

    @Column(name = "estado", nullable = false, length = 2)
    private String estado; // Estado (UF)

    @Column(name = "cep", nullable = false, length = 9) // CEP com máscara
    private String cep; // Código de Endereçamento Postal

    @Column(name = "pais", nullable = false, length = 50)
    private String pais = "Brasil"; // País (valor padrão "Brasil")

    @Enumerated(EnumType.STRING)
    @Column(name = "tipo_endereco", nullable = false, length = 50)
    private TipoEndereco tipoEndereco; // Tipo de endereço (ex: RESIDENCIAL, COMERCIAL, ESCRITORIO)

    /**
     * @brief Relacionamento muitos-para-um com a entidade Pessoa (opcional).
     *        Um endereço pode pertencer a uma pessoa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "pessoa_id")
    private Pessoa pessoa;

    /**
     * @brief Relacionamento muitos-para-um com a entidade Empresa (opcional).
     *        Um endereço pode pertencer a uma empresa.
     *        Somente um dos campos (pessoa ou empresa) deve ser preenchido.
     */
    // @ManyToOne(fetch = FetchType.LAZY)
    // @JoinColumn(name = "empresa_id")
    // private Empresa empresa;

    /**
     * @enum TipoEndereco
     * @brief Enumeração para representar o tipo de endereço.
     */
    public enum TipoEndereco {
        RESIDENCIAL,
        COMERCIAL,
        ESCRITORIO,
        COBRANCA,
        ENTREGA,
        OUTRO
    }
}
```
```java
package br.com.legalconnect.commom.model;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.CascadeType;
import jakarta.persistence.CollectionTable;
import jakarta.persistence.Column;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToMany;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class Pessoa
 * @brief Entidade base abstrata para todas as pessoas no sistema (Profissional,
 *        Cliente, Administrador).
 *        Contém dados comuns a todos os tipos de pessoas e um relacionamento
 *        OneToOne com a entidade User.
 *        Utiliza estratégia de herança JOINED para mapear subclasses em tabelas
 *        separadas.
 */
@Entity
@Table(name = "tb_pessoa")
@Inheritance(strategy = InheritanceType.JOINED)
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
public class Pessoa extends BaseEntity {

    /**
     * @brief Relacionamento um-para-um com a entidade User.
     *        Este lado é o dono do relacionamento, e a coluna 'user_id' será criada
     *        em 'tb_pessoa'.
     *        O CascadeType.ALL garante que operações no User (como deleção) se
     *        propaguem para Pessoa.
     */
    @OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false, unique = true)
    private User usuario; // O usuário associado a esta pessoa

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo da pessoa

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física (CPF), único por pessoa

    @Column(name = "data_nascimento")
    private LocalDate dataNascimento; // Data de nascimento da pessoa

    /**
     * @brief Relacionamento um-para-muitos com a entidade Endereco.
     *        Uma pessoa pode ter múltiplos endereços (residencial, comercial,
     *        etc.).
     *        CascadeType.ALL garante que operações nos Enderecos se propaguem para
     *        Pessoa.
     *        mappedBy indica que o relacionamento é gerenciado pelo campo 'pessoa'
     *        na entidade Endereco.
     */
    @OneToMany(mappedBy = "pessoa", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    private Set<Endereco> enderecos = new HashSet<>(); // Conjunto de endereços da pessoa

    /**
     * @brief Coleção de strings para armazenar múltiplos números de telefone.
     *        Será mapeada para uma tabela separada 'tb_pessoa_telefones'.
     */
    @ElementCollection(fetch = FetchType.LAZY)
    @CollectionTable(name = "tb_pessoa_telefones", joinColumns = @JoinColumn(name = "pessoa_id"))
    @Column(name = "numero_telefone", length = 20)
    private Set<String> telefones = new HashSet<>();
}
```
```java
package br.com.legalconnect.commom.model;

import br.com.legalconnect.commom.tmp.dto.BaseEntity;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class User
 * @brief Entidade base para todos os usuários (clientes, advogados,
 *        administradores de tenant, etc.).
 *
 *        Esta entidade representa um usuário na plataforma e está associada a
 *        um tenant
 *        específico. A tabela de usuário reside nos schemas de tenant.
 */
@Entity
@Table(name = "tb_user") // A tabela tb_user agora reside no schema do tenant
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@SuperBuilder
@EqualsAndHashCode(callSuper = true)
public class User extends BaseEntity { // Implementa UserDetails

    @Column(name = "nome_completo", nullable = false, length = 255)
    private String nomeCompleto; // Nome completo do usuário

    @Column(name = "email", nullable = false, unique = true, length = 255)
    private String email; // Endereço de e-mail principal do usuário (único por schema de tenant)

    @Column(name = "cpf", nullable = false, unique = true, length = 14)
    private String cpf; // Número do Cadastro de Pessoa Física do usuário (único por schema de tenant)

    @Column(name = "telefone", length = 20)
    private String telefone; // Número de telefone de contato do usuário

    @Column(name = "senha_hash", nullable = false, columnDefinition = "TEXT")
    private String senhaHash; // Representação criptografada (hashed) da senha do usuário

    @Column(name = "foto_url", columnDefinition = "TEXT")
    private String fotoUrl; // URL da foto de perfil do usuário no S3

    /**
     * @enum UserType
     * @brief Enumeração para categorizar o tipo principal de um usuário.
     *        Define se o usuário é um cliente, advogado ou administrador da
     *        plataforma.
     */
    public enum UserType {
        CLIENTE, // Usuário final que busca serviços jurídicos
        ADVOGADO, // Profissional do direito que oferece serviços
        PLATAFORMA_ADMIN, // Administrador da plataforma com privilégios totais
        SOCIO
    }

    /**
     * @enum UserStatus
     * @brief Enumeração para representar o status atual da conta de um usuário.
     *        Define o estado operacional da conta do usuário na plataforma.
     */
    public enum UserStatus {
        ACTIVE, INACTIVE, PENDING_APPROVAL, REJECTED, PENDING
    }

    // --- Implementação de UserDetails ---

}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.Pessoa;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link Pessoa}.
 * Gerencia operações de persistência para informações de pessoas no sistema.
 */
@Repository
public interface PessoaRepository extends JpaRepository<Pessoa, UUID> {

    /**
     * Verifica se existe uma Pessoa com o CPF fornecido.
     * Regra de Negócio: Garante a unicidade do CPF no sistema.
     *
     * @param cpf O CPF a ser verificado.
     * @return true se uma Pessoa com o CPF já existe, false caso contrário.
     */
    boolean existsByCpf(String cpf);

    /**
     * Busca uma Pessoa pelo ID do usuário associado.
     *
     * @param userId O ID do usuário.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByUsuarioId(UUID userId);

    /**
     * Busca uma Pessoa pelo CPF.
     *
     * @param cpf O CPF da Pessoa.
     * @return Um Optional contendo a Pessoa, se encontrada.
     */
    Optional<Pessoa> findByCpf(String cpf);
}
```
```java
package br.com.legalconnect.commom.repository;

import br.com.legalconnect.commom.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.UUID;

/**
 * Repositório para a entidade {@link User}.
 * Gerencia operações de persistência para informações de usuários no sistema.
 */
@Repository
public interface UserRepository extends JpaRepository<User, UUID> {

    /**
     * Busca um usuário pelo seu endereço de e-mail.
     * Regra de Negócio: O e-mail é único para cada usuário dentro de um tenant.
     *
     * @param email O endereço de e-mail do usuário.
     * @return Um Optional contendo o User, se encontrado.
     */
    Optional<User> findByEmail(String email);

    /**
     * Verifica se um usuário com o endereço de e-mail fornecido já existe.
     * Regra de Negócio: Garante a unicidade do e-mail no sistema.
     *
     * @param email O endereço de e-mail a ser verificado.
     * @return true se um usuário com o e-mail já existe, false caso contrário.
     */
    boolean existsByEmail(String email);
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/**
 * Serviço simulado para envio de e-mails.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com um provedor de e-mails
 * como SendGrid, Amazon SES, ou o serviço de e-mail do Spring Boot.
 */
@Service
public class EmailService {

    private static final Logger log = LoggerFactory.getLogger(EmailService.class);

    /**
     * Simula o envio de um e-mail de ativação de conta.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param activationLink O link de ativação da conta.
     */
    public void sendActivationEmail(String toEmail, String activationLink) {
        log.info("Simulando envio de e-mail de ativação para: {}", toEmail);
        log.info("Link de Ativação: {}", activationLink);
        // Lógica real de envio de e-mail seria aqui, por exemplo:
        // MimeMessage message = mailSender.createMimeMessage();
        // MimeMessageHelper helper = new MimeMessageHelper(message, true);
        // helper.setTo(toEmail);
        // helper.setSubject("Ative sua conta na LegalConnect!");
        // helper.setText("Olá! Clique no link para ativar sua conta: " + activationLink, true);
        // mailSender.send(message);
        log.info("E-mail de ativação simulado enviado com sucesso.");
    }

    /**
     * Simula o envio de um e-mail de confirmação de agendamento.
     *
     * @param toEmail O endereço de e-mail do destinatário.
     * @param details Detalhes do agendamento.
     */
    public void sendAppointmentConfirmationEmail(String toEmail, String details) {
        log.info("Simulando envio de e-mail de confirmação de agendamento para: {}", toEmail);
        log.info("Detalhes do Agendamento: {}", details);
        log.info("E-mail de confirmação de agendamento simulado enviado com sucesso.");
    }

    // Outros métodos de envio de e-mail podem ser adicionados conforme a necessidade
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.advogado.domain.modal.entity.LocalAtuacao;
import br.com.legalconnect.commom.dto.request.PessoaRequestDTO;
import br.com.legalconnect.commom.dto.request.UserRequestDTO;
import br.com.legalconnect.commom.dto.response.PessoaResponseDTO;
import br.com.legalconnect.commom.mapper.PessoaMapper;
import br.com.legalconnect.commom.mapper.UserMapper;
import br.com.legalconnect.commom.model.Endereco;
import br.com.legalconnect.commom.model.Pessoa;
import br.com.legalconnect.commom.model.User;
import br.com.legalconnect.commom.repository.PessoaRepository; // Assumindo a existência de PessoaRepository
import br.com.legalconnect.commom.repository.UserRepository; // Assumindo a existência de UserRepository
import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;
import jakarta.transaction.Transactional;

/**
 * Serviço responsável pela gestão das entidades Pessoa e User.
 * Centraliza a lógica de negócio para criação, atualização e busca de Pessoas
 * e seus usuários associados, incluindo validações de unicidade e criptografia
 * de senha.
 */
@Service
public class PessoaService {

    private final PessoaRepository pessoaRepository;
    private final UserRepository userRepository;
    private final PessoaMapper pessoaMapper;
    private final UserMapper userMapper;
    // Assumindo um EnderecoMapper se EnderecoRequestDTO for mapeado para Endereco
    // aqui
    // private final EnderecoMapper enderecoMapper;

    @Autowired
    public PessoaService(PessoaRepository pessoaRepository, UserRepository userRepository,
            PessoaMapper pessoaMapper, UserMapper userMapper) {
        this.pessoaRepository = pessoaRepository;
        this.userRepository = userRepository;
        this.pessoaMapper = pessoaMapper;
        this.userMapper = userMapper;
    }

    /**
     * Cria uma nova Pessoa e seu User associado.
     * Regras de Negócio:
     * - Garante que o CPF e o e-mail do usuário sejam únicos no sistema.
     * - Criptografa a senha antes de salvar.
     * - Define o status inicial do usuário como PENDING para aguardar ativação.
     *
     * @param pessoaRequestDTO DTO com os dados da Pessoa e do User.
     * @return DTO da Pessoa criada.
     * @throws BusinessException se o CPF ou e-mail já estiverem cadastrados.
     */
    @Transactional
    public Pessoa createPessoa(PessoaRequestDTO pessoaRequestDTO) {
        // Regra de Negócio: Validar unicidade de CPF
        if (pessoaRepository.existsByCpf(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.CPF_DUPLICADO, HttpStatus.CONFLICT, pessoaRequestDTO.getCpf());
        }

        // Regra de Negócio: Validar unicidade de e-mail para o usuário
        if (userRepository.existsByEmail(pessoaRequestDTO.getUsuario().getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT,
                    pessoaRequestDTO.getUsuario().getEmail());
        }

        // Cria e criptografa o usuário

        // Persiste o usuário
        var newUser = new User();
        newUser.setId((pessoaRequestDTO.getUsuario().getId()));

        // Cria a Pessoa e associa o usuário
        Pessoa newPessoa = Pessoa.builder()
                .usuario(newUser)
                .nomeCompleto(pessoaRequestDTO.getNomeCompleto())
                .cpf(pessoaRequestDTO.getCpf())
                .dataNascimento(pessoaRequestDTO.getDataNascimento())
                .telefones(new HashSet<>(pessoaRequestDTO.getTelefones()))
                .build();

        // Adiciona endereços
        if (pessoaRequestDTO.getEnderecos() != null && !pessoaRequestDTO.getEnderecos().isEmpty()) {
            Set<Endereco> enderecos = pessoaRequestDTO.getEnderecos().stream()
                    .map(dto -> {
                        Endereco endereco = new Endereco(); // Ou use enderecoMapper.toEntity(dto) se existir
                        endereco.setLogradouro(dto.getLogradouro());
                        endereco.setNumero(dto.getNumero());
                        endereco.setComplemento(dto.getComplemento());
                        endereco.setBairro(dto.getBairro());
                        endereco.setCidade(dto.getCidade());
                        endereco.setEstado(dto.getEstado());
                        endereco.setCep(dto.getCep());
                        endereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil"); // Define país padrão
                        endereco.setTipoEndereco(dto.getTipoEndereco());
                        endereco.setPessoa(newPessoa); // Associa o endereço à Pessoa
                        return endereco;
                    }).collect(Collectors.toSet());
            newPessoa.setEnderecos(enderecos);
        }
        // Reassigning to make it effectively final
        return (pessoaRepository.save(newPessoa));
    }

    /**
     * Busca uma Pessoa pelo ID.
     *
     * @param id ID da Pessoa.
     * @return DTO da Pessoa encontrada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    public PessoaResponseDTO findPessoaById(UUID id) {
        Pessoa pessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada."));
        return pessoaMapper.toResponseDTO(pessoa);
    }

    /**
     * Atualiza os dados de uma Pessoa existente.
     * Regras de Negócio:
     * - Permite a atualização de informações da Pessoa e do User associado.
     * - Valida a unicidade do e-mail se for alterado.
     * - Não permite a alteração do CPF.
     *
     * @param id               ID da Pessoa a ser atualizada.
     * @param pessoaRequestDTO DTO com os dados para atualização.
     * @return DTO da Pessoa atualizada.
     * @throws BusinessException se a Pessoa não for encontrada, ou se o e-mail já
     *                           estiver cadastrado.
     */
    @Transactional
    public PessoaResponseDTO updatePessoa(UUID id, PessoaRequestDTO pessoaRequestDTO) {
        Pessoa existingPessoa = pessoaRepository.findById(id)
                .orElseThrow(() -> new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                        "Pessoa não encontrada para atualização."));

        // Não permitir alteração de CPF (Regra de Negócio)
        if (!existingPessoa.getCpf().equals(pessoaRequestDTO.getCpf())) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "Não é permitido alterar o CPF de uma pessoa existente.");
        }

        // Atualiza o User associado
        User existingUser = existingPessoa.getUsuario();
        UserRequestDTO userRequestDTO = pessoaRequestDTO.getUsuario();

        // Valida unicidade de e-mail se o e-mail for alterado
        if (!existingUser.getEmail().equals(userRequestDTO.getEmail())
                && userRepository.existsByEmail(userRequestDTO.getEmail())) {
            throw new BusinessException(ErrorCode.EMAIL_DUPLICADO, HttpStatus.CONFLICT, userRequestDTO.getEmail());
        }

        userMapper.updateEntityFromDto(userRequestDTO, existingUser);
        userRepository.save(existingUser); // Salva as alterações no User

        // Atualiza os dados da Pessoa (exceto usuário e endereços que são gerenciados
        // separadamente)
        pessoaMapper.updateEntityFromDto(pessoaRequestDTO, existingPessoa);

        // Lógica para gerenciar Endereços: Adicionar, Atualizar, Remover
        // Isso pode ser complexo e requer lógica manual, pois EndereçoRequestDTO tem ID
        // opcional
        // Para simplificar, vou redefinir os endereços ou adicionar lógica de
        // diferenciação.
        // Uma abordagem mais robusta seria comparar listas e fazer operações de CRUD
        // individualmente.
        if (pessoaRequestDTO.getEnderecos() != null) {
            // Removendo endereços que não estão no DTO
            existingPessoa.getEnderecos().removeIf(existingEndereco -> pessoaRequestDTO.getEnderecos().stream()
                    .noneMatch(dto -> dto.getId() != null && dto.getId().equals(existingEndereco.getId().toString())));

            // Adicionando ou atualizando endereços
            for (br.com.legalconnect.commom.dto.request.EnderecoRequestDTO dto : pessoaRequestDTO.getEnderecos()) {
                if (dto.getId() == null) {
                    // Novo endereço
                    Endereco newEndereco = new Endereco();
                    newEndereco.setLogradouro(dto.getLogradouro());
                    newEndereco.setNumero(dto.getNumero());
                    newEndereco.setComplemento(dto.getComplemento());
                    newEndereco.setBairro(dto.getBairro());
                    newEndereco.setCidade(dto.getCidade());
                    newEndereco.setEstado(dto.getEstado());
                    newEndereco.setCep(dto.getCep());
                    newEndereco.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                    newEndereco.setTipoEndereco(dto.getTipoEndereco());
                    newEndereco.setPessoa(existingPessoa);
                    existingPessoa.getEnderecos().add(newEndereco);
                } else {
                    // Atualizar endereço existente
                    existingPessoa.getEnderecos().stream()
                            .filter(e -> e.getId().toString().equals(dto.getId()))
                            .findFirst()
                            .ifPresent(e -> {
                                e.setLogradouro(dto.getLogradouro());
                                e.setNumero(dto.getNumero());
                                e.setComplemento(dto.getComplemento());
                                e.setBairro(dto.getBairro());
                                e.setCidade(dto.getCidade());
                                e.setEstado(dto.getEstado());
                                e.setCep(dto.getCep());
                                e.setPais(dto.getPais() != null ? dto.getPais() : "Brasil");
                                e.setTipoEndereco(dto.getTipoEndereco());
                            });
                }
            }
        }

        existingPessoa = pessoaRepository.save(existingPessoa);
        return pessoaMapper.toResponseDTO(existingPessoa);
    }

    /**
     * Deleta uma Pessoa pelo ID.
     * Regras de Negócio:
     * - Também deleta o User associado devido ao CascadeType.ALL na Pessoa.
     *
     * @param id ID da Pessoa a ser deletada.
     * @throws BusinessException se a Pessoa não for encontrada.
     */
    @Transactional
    public void deletePessoa(UUID id) {
        if (!pessoaRepository.existsById(id)) {
            throw new BusinessException(ErrorCode.ENTIDADE_NAO_ENCONTRADA, HttpStatus.NOT_FOUND,
                    "Pessoa não encontrada para deleção.");
        }
        pessoaRepository.deleteById(id);
    }

    public Optional<LocalAtuacao> findPessoaByCpf(String cpf) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByCpf'");
    }

    public Optional<LocalAtuacao> findPessoaByEmail(String email) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'findPessoaByEmail'");
    }
}
```
```java
package br.com.legalconnect.commom.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;

import br.com.legalconnect.commom.tmp.exception.BusinessException;
import br.com.legalconnect.commom.tmp.exception.ErrorCode;

/**
 * Serviço de integração simulada com AWS S3 para upload e deleção de arquivos.
 * Em um ambiente real, esta classe conteria a lógica de comunicação com a AWS
 * SDK.
 */
@Service
public class S3Service {

    private static final Logger log = LoggerFactory.getLogger(S3Service.class);
    private static final String MOCK_S3_BASE_URL = "https://mock-s3-bucket.s3.amazonaws.com/";

    /**
     * Simula o upload de um arquivo para o S3.
     *
     * @param fileBytes Os bytes do arquivo.
     * @param key       A chave/caminho do arquivo no bucket S3.
     * @param mimeType  O tipo MIME do arquivo.
     * @return A URL pública do arquivo no S3.
     * @throws BusinessException se ocorrer um erro durante o "upload" simulado.
     */
    public String uploadFile(byte[] fileBytes, String key, String mimeType) {
        if (fileBytes == null || fileBytes.length == 0) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "O conteúdo do arquivo não pode ser vazio.");
        }
        if (key == null || key.isEmpty()) {
            throw new BusinessException(ErrorCode.DOCUMENT_UPLOAD_FAILED, HttpStatus.BAD_REQUEST,
                    "A chave do S3 não pode ser vazia.");
        }

        // Simulação de upload: Loga a operação e retorna uma URL mock
        log.info("Simulando upload para S3. Chave: {}, Tamanho: {} bytes, Tipo: {}", key, fileBytes.length, mimeType);
        String fileUrl = MOCK_S3_BASE_URL + key;
        log.info("Upload simulado concluído. URL: {}", fileUrl);
        return fileUrl;
    }

    /**
     * Simula a deleção de um arquivo do S3.
     *
     * @param fileUrl A URL pública do arquivo a ser deletado.
     * @throws BusinessException se ocorrer um erro durante a "deleção" simulada.
     */
    public void deleteFile(String fileUrl) {
        if (fileUrl == null || fileUrl.isEmpty()) {
            throw new BusinessException(ErrorCode.DADOS_INVALIDOS, HttpStatus.BAD_REQUEST,
                    "URL do arquivo não pode ser vazia para deleção.");
        }

        // Simulação de deleção: Loga a operação
        log.info("Simulando deleção de S3. URL: {}", fileUrl);
        // Em um ambiente real, aqui estaria a chamada para o AWS S3 SDK para deletar o
        // objeto.
        // Por exemplo: s3Client.deleteObject(bucketName, key);
        log.info("Deleção simulada concluída para URL: {}", fileUrl);
    }
}
```
```java
package br.com.legalconnect.commom.service;

import java.util.UUID;

/**
 * Utilitário para gerenciar o ID do Tenant no contexto da thread atual.
 * Usado em arquiteturas multitenant para garantir que as operações de banco de dados
 * sejam filtradas pelo tenant correto.
 */
public class TenantContext {

    private static final ThreadLocal<UUID> currentTenant = new ThreadLocal<>();

    /**
     * Define o ID do Tenant para a thread atual.
     *
     * @param tenantId O ID do Tenant.
     */
    public static void setCurrentTenantId(UUID tenantId) {
        currentTenant.set(tenantId);
    }

    /**
     * Retorna o ID do Tenant da thread atual.
     *
     * @return O ID do Tenant.
     * @throws IllegalStateException se o Tenant ID não estiver definido no contexto.
     */
    public static UUID getCurrentTenantId() {
        UUID tenantId = currentTenant.get();
        if (tenantId == null) {
            // Em um ambiente real, você pode lançar uma exceção ou retornar um tenant padrão
            // dependendo da lógica de segurança e acesso.
            // Por simplicidade para este exercício, lançaremos uma exceção.
            throw new IllegalStateException("Tenant ID não está definido no contexto da requisição. Verifique o filtro de segurança.");
        }
        return tenantId;
    }

    /**
     * Limpa o ID do Tenant da thread atual.
     * Deve ser chamado ao final da requisição para evitar vazamentos de contexto.
     */
    public static void clear() {
        currentTenant.remove();
    }
}
```
```java
package br.com.legalconnect.commom.tmp.dto;
// common/BaseEntity.java

import java.io.Serializable;
import java.time.LocalDateTime;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.persistence.Column;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.MappedSuperclass;
import jakarta.persistence.PrePersist;
import jakarta.persistence.PreUpdate;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.experimental.SuperBuilder;

/**
 * @class BaseEntity
 * @brief Classe base abstrata para todas as entidades persistentes.
 *        Fornece campos comuns como ID, data de criação e data de atualização.
 */
@Getter
@Setter
@NoArgsConstructor
@SuperBuilder
@MappedSuperclass // Indica que esta classe é uma superclasse mapeada para outras entidades
public abstract class BaseEntity implements Serializable {

    private static final Logger log = LoggerFactory.getLogger(BaseEntity.class);

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    protected UUID id; // Identificador único da entidade

    @Column(name = "created_at", nullable = false)
    protected LocalDateTime createdAt; // Data e hora de criação do registro

    @Column(name = "updated_at", nullable = false)
    protected LocalDateTime updatedAt; // Data e hora da última atualização do registro

    /**
     * Define a data de criação antes de persistir a entidade.
     */
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
        log.debug("Criando entidade: {}. Data de criação: {}", this.getClass().getSimpleName(), createdAt);
    }

    /**
     * Atualiza a data de atualização antes de atualizar a entidade.
     */
    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
        log.debug("Atualizando entidade: {}. ID: {}. Data de atualização: {}", this.getClass().getSimpleName(), id,
                updatedAt);
    }
}

```
```java
package br.com.legalconnect.commom.tmp.dto;
// common/BaseEntity.java

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.annotation.JsonInclude;

import br.com.legalconnect.enums.StatusResponse;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * @class BaseResponse
 * @brief DTO base para padronizar as respostas da API.
 *
 *        Inclui campos comuns para todas as respostas, como status, mensagem,
 *        timestamp e, opcionalmente, uma lista de erros.
 *        Utiliza Lombok para reduzir boilerplate (getters, setters,
 *        construtores, builder).
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL) // Inclui apenas campos não nulos na serialização JSON
public class BaseResponse<T> {

    private StatusResponse status; // Status da resposta (ex: StatusResponse.SUCESSO, StatusResponse.ERRO,
                                   // "WARNING")
    private String message; // Mensagem descritiva da resposta
    private LocalDateTime timestamp; // Data e hora da resposta
    private T data; // Payload da resposta (dados de sucesso)
    private List<String> errors; // Lista de mensagens de erro, se houver
}
```
```java
package br.com.legalconnect.commom.tmp.dto;
// common/BaseEntity.java

import java.time.LocalDateTime;

import br.com.legalconnect.enums.StatusResponse;
import lombok.Data;
import lombok.EqualsAndHashCode;

/**
 * @class SuccessResponseDTO
 * @brief DTO para respostas de sucesso simples da API.
 *
 *        Estende {@link BaseResponse} e é usado para indicar operações
 *        bem-sucedidas
 *        que podem ou não retornar dados específicos.
 */
@Data
@EqualsAndHashCode(callSuper = true) // Inclui campos da superclasse no equals e hashCode
public class SuccessResponseDTO extends BaseResponse {

    /**
     * Construtor padrão para uma resposta de sucesso.
     * Define o status como StatusResponse.SUCESSO e o timestamp atual.
     */
    public SuccessResponseDTO() {
        this.setStatus(StatusResponse.SUCESSO);
        this.setTimestamp(LocalDateTime.now());
    }

    /**
     * Construtor para uma resposta de sucesso com uma mensagem específica.
     *
     * @param message A mensagem descritiva do sucesso.
     */
    public SuccessResponseDTO(String message) {
        this(); // Chama o construtor padrão para definir status e timestamp
        this.setMessage(message);
    }
}
```
```java
package br.com.legalconnect.commom.tmp.exception;

import org.springframework.http.HttpStatus;

import lombok.Getter;

/**
 * @class BusinessException
 * @brief Exceção personalizada para representar erros de negócio na aplicação.
 *
 *        Esta exceção é lançada quando uma regra de negócio não é satisfeita.
 *        Ela encapsula um {@link ErrorCode} e, opcionalmente, argumentos para
 *        formatar
 *        a mensagem de erro, além de um status HTTP para a resposta da API.
 */
@Getter
public class BusinessException extends RuntimeException {

    private final ErrorCode errorCode; // O código de erro padronizado
    private final String[] args; // Argumentos para formatar a mensagem do erro
    private final HttpStatus httpStatus; // Status HTTP associado a esta exceção

    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String args) {
        super(args);
        this.errorCode = errorCode;
        this.args = new String[] { args, errorCode.getMessage() };
        this.httpStatus = httpStatus;
    }

    /**
     * Construtor para BusinessException com um ErrorCode e status HTTP padrão
     * (BAD_REQUEST).
     *
     * @param errorCode O código de erro que define o tipo de exceção de negócio.
     * @param args      Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, String... args) {
        this(errorCode, HttpStatus.BAD_REQUEST, args); // Por padrão, erros de negócio são BAD_REQUEST
    }

    /**
     * Construtor para BusinessException com um ErrorCode e um status HTTP
     * específico.
     *
     * @param errorCode  O código de erro que define o tipo de exceção de negócio.
     * @param httpStatus O status HTTP a ser retornado na resposta da API.
     * @param args       Argumentos opcionais para formatar a mensagem do erro.
     */
    public BusinessException(ErrorCode errorCode, HttpStatus httpStatus, String... args) {
        super(errorCode.getFormattedMessage(args)); // Define a mensagem da exceção usando a mensagem formatada do
                                                    // ErrorCode
        this.errorCode = errorCode;
        this.args = args;
        this.httpStatus = httpStatus;

    }

    /**
     * @brief Retorna a mensagem de erro formatada.
     * @return A mensagem de erro formatada.
     */
    @Override
    public String getMessage() {
        return errorCode.getFormattedMessage(args);
    }

    /**
     * @brief Retorna o código de erro.
     * @return O código de erro.
     */
    public String getCode() {
        return errorCode.getCode();
    }
}
```
```java
package br.com.legalconnect.commom.tmp.exception;

import lombok.Getter;

/**
 * @enum ErrorCode
 * @brief Enumeração que define códigos de erro padronizados para a aplicação.
 *
 *        Cada código de erro possui uma mensagem associada, facilitando a
 *        padronização
 *        de respostas de erro na API e a internacionalização ou localização
 *        futura.
 */
@Getter
public enum ErrorCode {
    // Erros gerais de validação
    DADOS_INVALIDOS("001", "Dados fornecidos são inválidos."),
    REQUISICAO_MAL_FORMADA("002", "A requisição está mal formada."),
    PARAMETRO_AUSENTE("003", "Parâmetro obrigatório ausente."),

    // Erros de entidade / negócio
    ENTIDADE_NAO_ENCONTRADA("100", "Entidade não encontrada."),
    EMPRESA_NAO_ENCONTRADA("101", "Empresa não encontrada."),
    PROFISSIONAL_NAO_ENCONTRADO("102", "Profissional não encontrado."),
    CLIENTE_NAO_ENCONTRADO("103", "Cliente não encontrado."),
    ADMINISTRADOR_NAO_ENCONTRADO("104", "Administrador não encontrado."),
    PLANO_NAO_ENCONTRADO("105", "Plano não encontrado."),
    USER_NAO_ENCONTRADO("106", "Usuário associado não encontrado."),

    // Erros de duplicidade
    CNPJ_DUPLICADO("200", "CNPJ já cadastrado."),
    CPF_DUPLICADO("201", "CPF já cadastrado."),
    OAB_DUPLICADA("202", "Número da OAB já cadastrado."),
    EMAIL_DUPLICADO("203", "Email já cadastrado."),
    NOME_PLANO_DUPLICADO("204", "Nome do plano já cadastrado."),

    // Erros de integridade
    INTEGRIDADE_VIOLADA("300", "Violação de integridade de dados."),
    RECURSO_EM_USO("301", "Recurso não pode ser excluído pois está em uso."),

    // Erros de sistema / internos
    ERRO_INTERNO_SERVIDOR("500", "Ocorreu um erro interno no servidor."),
    SERVICO_INDISPONIVEL("503", "Serviço temporariamente indisponível."),

    // Erros Gerais/Comuns (1000-1999)
    GENERIC_ERROR("1000", "Ocorreu um erro inesperado. Por favor, tente novamente mais tarde."),
    INVALID_INPUT("1001", "Dados de entrada inválidos."),
    RESOURCE_NOT_FOUND("1002", "Recurso não encontrado."),
    UNAUTHORIZED_ACCESS("1003", "Acesso não autorizado. Credenciais inválidas ou ausentes."),
    FORBIDDEN_ACCESS("1004", "Acesso negado. Você não tem permissão para realizar esta ação."),
    SERVICE_UNAVAILABLE("1005", "O serviço está temporariamente indisponível. Tente novamente mais tarde."),
    TOO_MANY_REQUESTS("1006", "Muitas requisições. Por favor, aguarde e tente novamente."),
    VALIDATION_ERROR("1007", "Erro de validação nos dados fornecidos."),
    DATABASE_ERROR("1008", "Erro ao acessar o banco de dados."),
    INTEGRATION_ERROR("1009", "Erro de integração com serviço externo."),

    // Erros de Autenticação e Autorização (2000-2999)
    INVALID_CREDENTIALS("2000", "Credenciais de autenticação inválidas."),
    ACCOUNT_LOCKED("2001", "Sua conta está bloqueada."),
    ACCOUNT_DISABLED("2002", "Sua conta está desativada."),
    TOKEN_EXPIRED("2003", "O token de acesso expirou."),
    INVALID_TOKEN("2004", "O token de acesso é inválido."),
    REFRESH_TOKEN_EXPIRED("2005", "O refresh token expirou. Faça login novamente."),
    INVALID_REFRESH_TOKEN("2006", "O refresh token é inválido."),
    USER_NOT_FOUND("2007", "Usuário não encontrado."),
    EMAIL_ALREADY_REGISTERED("2008", "Este e-mail já está cadastrado."),
    PASSWORD_RESET_FAILED("2009", "Falha ao redefinir a senha."),
    INVALID_CURRENT_PASSWORD("2010", "A senha atual fornecida está incorreta."), // Novo erro
    PASSWORD_RESET_TOKEN_INVALID("2011", "Token de redefinição de senha inválido."), // Novo erro
    PASSWORD_RESET_TOKEN_EXPIRED("2012", "Token de redefinição de senha expirado."), // Novo erro
    PASSWORD_RESET_TOKEN_USED("2013", "Token de redefinição de senha já utilizado."), // Novo erro
    PASSWORD_RESET_TOKEN_EXCEEDED("2014", "Limite de redefinições de senha excedido."), // Novo erro

    // Erros de Negócio Específicos (3000-3999) - Exemplo
    TENANT_NOT_FOUND("3000", "Tenant não encontrado."),
    TENANT_DISABLED("3001", "O tenant está desativado."),
    SUBSCRIPTION_EXPIRED("3002", "Sua assinatura expirou."),
    PLAN_NOT_ACTIVE("3003", "O plano selecionado não está ativo."),
    SERVICE_LIMIT_EXCEEDED("3004", "Limite de serviços agendáveis excedido para o seu plano."),
    ADVOCATE_NOT_AVAILABLE("3005", "Advogado não disponível no horário selecionado."),
    APPOINTMENT_CONFLICT("3006", "Conflito de agendamento. O horário já está ocupado."),
    PAYMENT_FAILED("3007", "Falha no processamento do pagamento."),
    INVALID_PROMO_CODE("3008", "Código promocional inválido ou expirado."),
    DOCUMENT_UPLOAD_FAILED("3009", "Falha ao fazer upload do documento."),
    INVALID_DOCUMENT_FORMAT("3010", "Formato de documento inválido."),

    // Erros de Validação de Campo (4000-4999) - Mais específicos, geralmente
    // tratados por @Valid
    FIELD_REQUIRED("4000", "O campo '%s' é obrigatório."),
    INVALID_FORMAT("4001", "O campo '%s' possui formato inválido."),
    MIN_LENGTH("4002", "O campo '%s' deve ter no mínimo %d caracteres."),
    MAX_LENGTH("4003", "O campo '%s' deve ter no máximo %d caracteres."),
    INVALID_EMAIL("4004", "O e-mail fornecido é inválido."),
    INVALID_CPF("4005", "O CPF fornecido é inválido."),
    INVALID_CNPJ("4006", "O CNPJ fornecido é inválido."),
    PASSWORD_TOO_WEAK("4007", "A senha é muito fraca."),
    DATE_IN_PAST("4008", "A data não pode ser no passado."),
    INVALID_ENUM_VALUE("4009", "Valor inválido para o campo '%s'.");

    private final String code;
    private final String message;

    /**
     * Construtor para ErrorCode.
     *
     * @param code    O código único do erro.
     * @param message A mensagem descritiva do erro.
     */
    ErrorCode(String code, String message) {
        this.code = code;
        this.message = message;
    }

    /**
     * @brief Retorna a mensagem de erro formatada com argumentos.
     * @param args Argumentos para formatar a mensagem.
     * @return A mensagem de erro formatada.
     */
    public String getFormattedMessage(Object... args) {
        return String.format(this.message, args);
    }
}

```
```java
package br.com.legalconnect.commom.tmp.exception;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import br.com.legalconnect.commom.tmp.dto.BaseResponse;
import lombok.extern.slf4j.Slf4j;

/**
 * @class GlobalExceptionHandler
 * @brief Manipulador global de exceções para a aplicação Spring Boot.
 *
 *        Esta classe intercepta exceções lançadas em qualquer parte da
 *        aplicação
 *        e as transforma em respostas de erro padronizadas da API, utilizando
 *        {@link BaseResponse}.
 *        Lida com {@link BusinessException} e exceções de validação do Spring,
 *        além de capturar exceções genéricas.
 */
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

        /**
         * @brief Manipula exceções de negócio personalizadas
         *        ({@link BusinessException}).
         *
         *        Retorna uma resposta de erro com o status HTTP e a mensagem definidos
         *        na BusinessException.
         *
         * @param ex      A exceção de negócio lançada.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro.
         */
        @ExceptionHandler(BusinessException.class)
        public ResponseEntity<BaseResponse> handleBusinessException(BusinessException ex, WebRequest request) {
                log.warn("Business Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ex.getMessage())
                                .errors(List.of(ex.getCode())) // Adiciona o código de erro como parte dos erros
                                .timestamp(LocalDateTime.now())
                                .errors(Arrays.asList(ex.getArgs())) // Adiciona os argumentos da exceção como parte dos
                                .build();

                return new ResponseEntity<>(errorResponse, ex.getHttpStatus());
        }

        /**
         * @brief Manipula exceções de validação de argumentos de método
         *        ({@link MethodArgumentNotValidException}).
         *
         *        Ocorre quando a validação de um DTO de entrada falha (ex:
         *        campos @NotNull, @Size).
         *        Coleta todos os erros de campo e os retorna em uma lista na resposta.
         *
         * @param ex      A exceção de validação.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} com os
         *         erros de validação.
         */
        @ExceptionHandler(MethodArgumentNotValidException.class)
        public ResponseEntity<BaseResponse> handleValidationExceptions(MethodArgumentNotValidException ex,
                        WebRequest request) {
                List<String> errors = ex.getBindingResult().getAllErrors().stream()
                                .map(error -> {
                                        String fieldName = (error instanceof FieldError)
                                                        ? ((FieldError) error).getField()
                                                        : error.getObjectName();
                                        String errorMessage = error.getDefaultMessage();
                                        return String.format("Campo '%s': %s", fieldName, errorMessage);
                                })
                                .collect(Collectors.toList());

                log.warn("Validation Exception: {} - Errors: {} - Path: {}", ex.getMessage(), errors,
                                request.getDescription(false));

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.VALIDATION_ERROR.getMessage())
                                .errors(errors)
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
        }

        /**
         * @brief Manipula todas as outras exceções não tratadas especificamente.
         *
         *        Captura qualquer {@link Exception} genérica, registra o erro e retorna
         *        uma resposta de erro genérica com status HTTP 500 (Internal Server
         *        Error).
         *
         * @param ex      A exceção genérica.
         * @param request A requisição web atual.
         * @return Uma {@link ResponseEntity} contendo a {@link BaseResponse} de erro
         *         genérico.
         */
        @ExceptionHandler(Exception.class)
        public ResponseEntity<BaseResponse> handleGlobalException(Exception ex, WebRequest request) {
                log.error("Unhandled Exception: {} - Path: {}", ex.getMessage(), request.getDescription(false), ex);

                BaseResponse errorResponse = BaseResponse.builder()
                                .status(StatusResponse.ERRO)
                                .message(ErrorCode.GENERIC_ERROR.getMessage())
                                .errors(List.of(ErrorCode.GENERIC_ERROR.getCode())) // Adiciona o código de erro
                                                                                    // genérico
                                .timestamp(LocalDateTime.now())
                                .build();

                return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
        }
}
```
```java
package br.com.legalconnect.commom.tmp.exception;

public enum StatusResponse {
    SUCESSO,
    ERRO,
    AVISO;
}

```
```java
# src/main/resources/application.properties
# ===================================================================
# Configurações Gerais da Aplicação Spring Boot
# ===================================================================

# Nome da aplicação (usado em logs e monitoramento)
spring.application.name=legalconnect-usuario-service
# Porta em que a aplicação será executada

# Desabilita o management server caso esteja ativo e conflitando (opcional)
# management.endpoints.web.exposure.include=*

 
server.port=${PORT:0}
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
eureka.instance.preferIpAddress=true
eureka.instance.lease-renewal-interval-in-seconds=30
# Configurações do SpringDoc OpenAPI
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/v3/api-docs
springdoc.packagesToScan=br.com.legalconnect
springdoc.pathsToMatch=/api/v1/**
springdoc.swagger-ui.url=/v3/api-docs
# Additional Swagger configuration
springdoc.swagger-ui.disable-swagger-default-url=true
springdoc.swagger-ui.display-request-duration=true
# Swagger config
 

# ===================================================================
# Configurações do Banco de Dados PostgreSQL
# ===================================================================

# URL de conexão com o banco de dados PostgreSQL
# O microsserviço de autenticação se conecta ao banco de dados global (public)
spring.datasource.url=jdbc:postgresql://localhost:5432/jusplatform_db
spring.datasource.username=jususer
spring.datasource.password=juspassword
spring.datasource.driver-class-name=org.postgresql.Driver

spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ===================================================================
# Configurações do JPA e Hibernate
# ===================================================================

spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

spring.jpa.hibernate.ddl-auto=create
spring.jpa.show-sql=true
# Removido: spring.jpa.properties.hibernate.default_schema=public
# Esta configuração forçava o Hibernate a usar o schema 'public' para DDL, o que não é desejado para entidades multi-tenant.


# ===================================================================
# Configurações de Segurança (JWT)
# ===================================================================

# Chave secreta para assinar e verificar os JWTs.
# **IMPORTANTE**: Esta chave deve ser longa, complexa e armazenada de forma segura (ex: HashiCorp Vault, variáveis de ambiente).
# Nunca exponha esta chave em um repositório público!
application.security.jwt.secret-key=404E635266556A586E3272357538782F413F4428472B4B6250645367566B5970

# Tempo de expiração do JWT em milissegundos (ex: 3600000ms = 1 hora)
application.security.jwt.expiration=3600000

# Tempo de expiração do Refresh Token em milissegundos (ex: 7 dias = 604800000ms)
application.security.jwt.refresh-expiration=604800000

# Força do encoder de senha (cost factor para BCrypt, padrão é 10)
# Um valor maior aumenta a segurança, mas também o tempo de hash.
application.security.password-encoder.strength=12

# ===================================================================
# Configurações de Logging (Logback)
# ===================================================================

# Nível de log padrão para a aplicação
logging.level.br.com.legalconnect=INFO
# Nível de log para o Spring Framework
logging.level.org.springframework=WARN

# Nível de log para Hibernate (queries SQL) - Desabilite em produção
logging.level.org.hibernate.SQL=WARN
logging.level.org.hibernate.type.descriptor.sql.BasicExtractor=WARN

# Nível de log para o processo de DDL do Hibernate (agora menos relevante com Flyway)
logging.level.org.hibernate.hbm2ddl=WARN

# Nível de log para as conexões JDBC do Hibernate
logging.level.org.hibernate.engine.jdbc.connections=WARN

# Nível de log para o Flyway (muito importante para depurar migrações)
logging.level.org.flywaydb=INFO

# Adicione logs específicos para a configuração do JPA e Multi-Tenancy
logging.level.org.hibernate.jpa=INFO
logging.level.org.springframework.orm.jpa=INFO
logging.level.org.springframework.data.jpa=INFO
logging.level.org.hibernate.engine.jdbc.connections.spi=INFO

# ===================================================================
# Configurações de Multitenancy Específicas do Aplicativo
# ===================================================================

# ID do tenant padrão para usuários que não estão associados a um tenant específico (ex: clientes gerais)
# Este UUID deve corresponder a um registro na tabela tb_tenant no schema global (public).
application.tenant.default-id=public

# ===================================================================
# Configurações do Spring Boot Actuator
# ===================================================================

# Habilita todos os endpoints do Actuator (para monitoramento)
management.endpoints.web.exposure.include=*
# Define o caminho base para os endpoints do Actuator
management.endpoints.web.base-path=/actuator

# ===================================================================
# Configurações de CORS (Cross-Origin Resource Sharing)
# ===================================================================

# Configuração de CORS global (pode ser mais específica nos controladores)
# Esta configuração é um exemplo e pode ser ajustada conforme a necessidade.
# Em produção, 'allowed-origins' deve ser restrito aos domínios do seu frontend.
# spring.web.cors.allowed-origins=*
# spring.web.cors.allowed-methods=GET,POST,PUT,DELETE,OPTIONS,PATCH
# spring.web.cors.allowed-headers=*
# spring.web.cors.allow-credentials=false
# spring.web.cors.max-age=3600
# ===================================================================
# Configurações do Flyway
# ===================================================================
spring.flyway.enabled=false
spring.flyway.url=${spring.datasource.url}
spring.flyway.user=${spring.datasource.username}
spring.flyway.password=${spring.datasource.password}
spring.flyway.locations=classpath:db/migration
spring.flyway.baseline-on-migrate=true
spring.flyway.baseline-version=1
# ===================================================================
# Configurações de Cache (Exemplo com Caffeine, adicione a dependência se usar)
# ===================================================================

# spring.cache.type=caffeine
# spring.cache.cache-names=users,refreshTokens
# spring.cache.caffeine.spec=expireAfterWrite=60m,maximumSize=500

# ===================================================================
# Propriedades de Aplicação Customizadas
# ===================================================================

# Exemplo de uma propriedade customizada
# app.feature.new-registration-enabled=true

# ===================================================================
# Configurações para Proxy Reverso (Nginx)
# ===================================================================

# Habilita o processamento dos cabeçalhos X-Forwarded-* enviados por proxies.
# Isso garante que a aplicação veja o IP real do cliente, o protocolo original (HTTP/HTTPS)
# e o host original, em vez dos detalhes do proxy (Nginx).
server.forward-headers-strategy=FRAMEWORK
spring.main.allow-bean-definition-overriding=true
# Configuração do Outlook SMTP
spring.mail.username=marcelo.llm@outlook.com
spring.mail.password=qlbzudmmytioxztj
spring.mail.from=marcelo.llm@outlook.com
spring.mail.protocol=smtp

# Propriedades avançadas

spring.mail.host=smtp.office365.com
spring.mail.port=587 
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.mail.properties.mail.smtp.starttls.required=true
spring.mail.properties.mail.smtp.connectiontimeout=15000
spring.mail.properties.mail.smtp.timeout=15000
spring.mail.properties.mail.smtp.writetimeout=15000

# Propriedade para o Thymeleaf (se estiver usando)
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
spring.thymeleaf.mode=HTML
spring.thymeleaf.cache=false
# (Opcional, mas útil para debug)
spring.mail.properties.mail.debug=true
app.frontend.url=http://localhost:4200

```
```java
package br.com.legalconnect.legal_usuario;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class LegalUsuarioApplicationTests {

	@Test
	void contextLoads() {
	}

}

```